{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Utils/Compiler_Utils.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma distinct_sorted_list_of_fset[simp, intro]: \"distinct (sorted_list_of_fset S)\"", "lemma sum_nat_le_single:\n  fixes x :: nat\n  assumes y: \"y \\<in> S\" and x: \"x \\<le> f y\" and finite: \"finite S\"\n  shows \"x \\<le> sum f S\"", "lemma sum_nat_less_single:\n  fixes x :: nat\n  assumes y: \"y \\<in> S\" and x: \"x < f y\" and finite: \"finite S\"\n  shows \"x < sum f S\"", "lemma prod_BallI: \"(\\<And>a b. (a, b) \\<in> M \\<Longrightarrow> P a b) \\<Longrightarrow> Ball M (\\<lambda>(a, b). P a b)\"", "lemma fset_map_snd_id:\n  assumes \"\\<And>a b e. (a, b) \\<in> fset cs \\<Longrightarrow> f a b = b\"\n  shows \"(\\<lambda>(a, b). (a, f a b)) |`| cs = cs\"", "lemmas disj_cases = disjE[case_names 1 2, consumes 1]", "lemma case_prod_twice: \"case_prod f (case_prod (\\<lambda>a b. (g a b, h a b)) x) = case_prod (\\<lambda>a b. f (g a b) (h a b)) x\"", "lemma map_of_map_keyed:\n  \"map_of (map (\\<lambda>(k, v). (k, f k v)) xs) = (\\<lambda>k. map_option (f k) (map_of xs k))\"", "lemma map_of_rekey:\n  \"map_of (map (\\<lambda>(k, v). (f k, g k v)) xs) k = map_option (g (inv f k)) (map_of xs (inv f k))\"", "lemma map_of_rekey': \"map_of (map (map_prod f g) xs) k = map_option g (map_of xs (inv f k))\"", "lemma fst_distinct: \"distinct (map fst xs) \\<Longrightarrow> distinct (map (\\<lambda>(k, _). f k) xs)\"", "lemma inv: \"rekey (inv f)\"", "lemma fset_eq_empty_iff: \"M = {||} \\<longleftrightarrow> (\\<forall>x. x |\\<notin>| M)\"", "lemma fbind_subset_eqI: \"fBall S (\\<lambda>s. f s |\\<subseteq>| T) \\<Longrightarrow> fbind S f |\\<subseteq>| T\"", "lemma prod_fBallI: \"(\\<And>a b. (a, b) |\\<in>| M \\<Longrightarrow> P a b) \\<Longrightarrow> fBall M (\\<lambda>(a, b). P a b)\"", "lemma ffUnion_subset_elem: \"x |\\<in>| X \\<Longrightarrow> x |\\<subseteq>| ffUnion X\"", "lemma fbindE:\n  assumes \"x |\\<in>| fbind S f\"\n  obtains s where \"x |\\<in>| f s\" \"s |\\<in>| S\"", "lemma ffUnion_least_rev: \"ffUnion A |\\<subseteq>| C \\<Longrightarrow> fBall A (\\<lambda>X. X |\\<subseteq>| C)\"", "lemma inj_on_fimage_set_diff:\n  assumes \"inj_on f (fset C)\" \"A |\\<subseteq>| C\" \"B |\\<subseteq>| C\"\n  shows \"f |`| (A - B) = f |`| A - f |`| B\"", "lemma list_all_iff_fset: \"list_all P xs \\<longleftrightarrow> fBall (fset_of_list xs) P\"", "lemma fbind_fun_funion: \"fbind M (\\<lambda>x. f x |\\<union>| g x) = fbind M f |\\<union>| fbind M g\"", "lemma funion_strictE:\n  assumes \"c |\\<in>| A |\\<union>| B\"\n  obtains (A) \"c |\\<in>| A\" | (B) \"c |\\<notin>| A\" \"c |\\<in>| B\"", "lemma max_decr:\n  fixes X :: \"nat set\"\n  assumes \"\\<exists>x \\<in> X. x \\<ge> k\" \"finite X\"\n  shows \"Max ((\\<lambda>x. x - k) ` X) = Max X - k\"", "lemma max_ex_gr: \"\\<exists>x \\<in> X. k < x \\<Longrightarrow> finite X \\<Longrightarrow> X \\<noteq> {} \\<Longrightarrow> k < Max X\"", "lemma fmax_decr:\n  fixes X :: \"nat fset\"\n  assumes \"fBex X (\\<lambda>x. x \\<ge> k)\"\n  shows \"fMax ((\\<lambda>x. x - k) |`| X) = fMax X - k\"", "lemma fmax_ex_gr: \"fBex X (\\<lambda>x. k < x) \\<Longrightarrow> X \\<noteq> {||} \\<Longrightarrow> k < fMax X\"", "lemma fMax_le: \"fBall M (\\<lambda>x. x \\<le> k) \\<Longrightarrow> M \\<noteq> {||} \\<Longrightarrow> fMax M \\<le> k\"", "lemma [code]: \"compress (set xs) = set (remdups xs)\"", "lemma the_elem_id: \"finite S \\<Longrightarrow> the_elem' S = the_elem S\"", "lemma fcompress_eq[simp]: \"fcompress M = M\"", "lemma fthe_elem'_eq: \"fthe_elem' = fthe_elem\"", "lemma is_mapI[intro]:\n  assumes \"\\<And>a b\\<^sub>1 b\\<^sub>2. (a, b\\<^sub>1) \\<in> M \\<Longrightarrow> (a, b\\<^sub>2) \\<in> M \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2\"\n  shows \"is_map M\"", "lemma distinct_is_map:\n  assumes \"distinct (map fst m)\"\n  shows \"is_map (set m)\"", "lemma is_map_image:\n  assumes \"is_map M\"\n  shows \"is_map ((\\<lambda>(a, b). (a, f a b)) ` M)\"", "lemma is_mapD:\n  assumes \"is_map M\" \"(a, b\\<^sub>1) \\<in> M\" \"(a, b\\<^sub>2) \\<in> M\"\n  shows \"b\\<^sub>1 = b\\<^sub>2\"", "lemma is_map_subset: \"is_map N \\<Longrightarrow> M \\<subseteq> N \\<Longrightarrow> is_map M\"", "lemma map_of_is_map: \"(k, v) \\<in> set m \\<Longrightarrow> is_map (set m) \\<Longrightarrow> map_of m k = Some v\"", "lemma get_map_elem:\n  assumes \"is_map M\"\n  assumes \"(k, v) \\<in> M\"\n  shows \"get_map M k = (k, v)\"", "lemma get_map_map:\n  assumes \"is_map S\" \"k \\<in> fst ` S\"\n  shows \"get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k = (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))\"", "lemma is_map_fst_inj: \"is_map S \\<Longrightarrow> inj_on fst S\"", "lemma is_map_transfer:\n  fixes A :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\"\n  assumes [transfer_rule]: \"bi_unique A\"\n  shows \"rel_fun (rel_set (rel_prod (=) A)) (=) is_map is_map\"", "lemma is_fmapI[intro]:\n  assumes \"\\<And>a b\\<^sub>1 b\\<^sub>2. (a, b\\<^sub>1) |\\<in>| M \\<Longrightarrow> (a, b\\<^sub>2) |\\<in>| M \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2\"\n  shows \"is_fmap M\"", "lemma is_fmap_image: \"is_fmap M \\<Longrightarrow> is_fmap ((\\<lambda>(a, b). (a, f a b)) |`| M)\"", "lemma is_fmapD:\n  assumes \"is_fmap M\" \"(a, b\\<^sub>1) |\\<in>| M\" \"(a, b\\<^sub>2) |\\<in>| M\"\n  shows \"b\\<^sub>1 = b\\<^sub>2\"", "lemma is_fmap_subset: \"is_fmap N \\<Longrightarrow> M |\\<subseteq>| N \\<Longrightarrow> is_fmap M\"", "lemma ordered_map_set_eq:\n  assumes \"finite S\" \"is_map S\"\n  shows \"set (ordered_map S) = S\"", "lemma ordered_map_image:\n  assumes \"finite S\" \"is_map S\"\n  shows \"map (\\<lambda>(a, b). (a, f a b)) (ordered_map S) = ordered_map ((\\<lambda>(a, b). (a, f a b)) ` S)\"", "lemma ordered_map_distinct:\n  assumes \"finite S\" \"is_map S\"\n  shows \"distinct (map fst (ordered_map S))\"", "lemma ordered_map_keys:\n  assumes \"finite S\" \"is_map S\"\n  shows \"map fst (ordered_map S) = sorted_list_of_set (fst ` S)\"", "lemma ordered_map_nonempty:\n  assumes \"is_map S\" \"ordered_map S \\<noteq> []\" \"finite S\"\n  shows \"S \\<noteq> {}\"", "lemma ordered_map_remove:\n  assumes \"is_map S\" \"finite S\" \"x \\<in> S\"\n  shows \"ordered_map (S - {x}) = remove1 x (ordered_map S)\"", "lemma ordered_map_list_all:\n  assumes \"finite S\" \"is_map S\"\n  shows \"list_all P (ordered_map S) = Ball S P\"", "lemma ordered_map_singleton[simp]: \"ordered_map {(x, y)} = [(x, y)]\"", "lemma ordered_fmap_set_eq: \"is_fmap S \\<Longrightarrow> fset_of_list (ordered_fmap S) = S\"", "lemma ordered_fmap_image:\n  assumes \"is_fmap S\"\n  shows \"map (\\<lambda>(a, b). (a, f a b)) (ordered_fmap S) = ordered_fmap ((\\<lambda>(a, b). (a, f a b)) |`| S)\"", "lemma ordered_fmap_distinct:\n  assumes \"is_fmap S\"\n  shows \"distinct (map fst (ordered_fmap S))\"", "lemma ordered_fmap_keys:\n  assumes \"is_fmap S\"\n  shows \"map fst (ordered_fmap S) = sorted_list_of_fset (fst |`| S)\"", "lemma ordered_fmap_sound:\n  assumes \"is_fmap S\" \"(a, b) \\<in> set (ordered_fmap S)\"\n  shows \"(a, b) |\\<in>| S\"", "lemma ordered_fmap_nonempty:\n  assumes \"is_fmap S\" \"ordered_fmap S \\<noteq> []\"\n  shows \"S \\<noteq> {||}\"", "lemma ordered_fmap_remove:\n  assumes \"is_fmap S\" \"x |\\<in>| S\"\n  shows \"ordered_fmap (S - {| x |}) = remove1 x (ordered_fmap S)\"", "lemma ordered_fmap_list_all:\n  assumes \"is_fmap S\"\n  shows \"list_all P (ordered_fmap S) = fBall S P\"", "lemma ordered_fmap_singleton[simp]: \"ordered_fmap {| (x, y) |} = [(x, y)]\"", "lemma group_by_nonempty: \"M \\<noteq> {} \\<Longrightarrow> group_by f M \\<noteq> {}\"", "lemma group_by_nonempty_inner:\n  assumes \"(b, cs) \\<in> group_by f as\"\n  obtains c where \"c \\<in> cs\"", "lemma group_by_sound: \"c \\<in> cs \\<Longrightarrow> (b, cs) \\<in> group_by f as \\<Longrightarrow> \\<exists>a \\<in> as. f a = (b, c)\"", "lemma group_byD: \"(b, cs) \\<in> group_by f as \\<Longrightarrow> f a = (b, c) \\<Longrightarrow> a \\<in> as \\<Longrightarrow> c \\<in> cs\"", "lemma group_byE[elim]:\n  assumes \"c \\<in> cs\" \"(b, cs) \\<in> group_by f as\"\n  obtains a where \"a \\<in> as\" \"f a = (b, c)\"", "lemma group_byE2:\n  assumes \"(b, cs) \\<in> group_by f as\"\n  obtains a where \"a \\<in> as\" \"fst (f a) = b\"", "lemma group_by_complete:\n  assumes \"a \\<in> as\"\n  obtains cs where \"(fst (f a), cs) \\<in> group_by f as\" \"snd (f a) \\<in> cs\"", "lemma group_by_single: \"(a, x) \\<in> group_by f s \\<Longrightarrow> (a, y) \\<in> group_by f s \\<Longrightarrow> x = y\"", "lemma group_by'_eq[code, code_unfold]: \"group_by = group_by'\"", "lemma is_map_group_by[intro]: \"is_map (group_by f M)\"", "lemma group_by_keys[simp]: \"fst ` group_by f M = fst ` f ` M\"", "lemma fgroup_by_nonempty: \"M \\<noteq> {||} \\<Longrightarrow> fgroup_by f M \\<noteq> {||}\"", "lemma fgroup_by_nonempty_inner:\n  assumes \"(b, cs) |\\<in>| fgroup_by f as\"\n  obtains c where \"c |\\<in>| cs\"", "lemma fgroup_by_sound: \"c |\\<in>| cs \\<Longrightarrow> (b, cs) |\\<in>| fgroup_by f as \\<Longrightarrow> fBex as (\\<lambda>a. f a = (b, c))\"", "lemma fgroup_byD: \"(b, cs) |\\<in>| fgroup_by f as \\<Longrightarrow> f a = (b, c) \\<Longrightarrow> a |\\<in>| as \\<Longrightarrow> c |\\<in>| cs\"", "lemma fgroup_byE[elim]:\n  assumes \"c |\\<in>| cs\" \"(b, cs) |\\<in>| fgroup_by f as\"\n  obtains a where \"a |\\<in>| as\" \"f a = (b, c)\"", "lemma fgroup_byE2:\n  assumes \"(b, cs) |\\<in>| fgroup_by f as\"\n  obtains a where \"a |\\<in>| as\" \"fst (f a) = b\"", "lemma fgroup_by_complete:\n  assumes \"a |\\<in>| as\"\n  obtains cs where \"(fst (f a), cs) |\\<in>| fgroup_by f as\" \"snd (f a) |\\<in>| cs\"", "lemma fgroup_by_single: \"(a, x) |\\<in>| fgroup_by f s \\<Longrightarrow> (a, y) |\\<in>| fgroup_by f s \\<Longrightarrow> x = y\"", "lemma fgroup_by'_eq[code, code_unfold]: \"fgroup_by = fgroup_by'\"", "lemma is_fmap_group_by[intro]: \"is_fmap (fgroup_by f M)\"", "lemma fgroup_by_keys[simp]: \"fst |`| fgroup_by f M = fst |`| f |`| M\"", "lemma singleton_set_holds:\n  assumes \"\\<forall>x \\<in> M. \\<forall>y \\<in> M. f x = f y\" \"m \\<in> M\"\n  shows \"f m = the_elem (f ` M)\"", "lemma singleton_set_is:\n  assumes \"\\<forall>x \\<in> M. x = y\" \"M \\<noteq> {}\"\n  shows \"M = {y}\"", "lemma singleton_fset_holds:\n  assumes \"fBall M (\\<lambda>x. fBall M (\\<lambda>y. f x = f y))\" \"m |\\<in>| M\"\n  shows \"f m = fthe_elem (f |`| M)\"", "lemma singleton_fset_is:\n  assumes \"fBall M (\\<lambda>x. x = y)\" \"M \\<noteq> {||}\"\n  shows \"M = {| y |}\"", "lemma pairwiseI[intro!]:\n  assumes \"\\<And>m n. m \\<in> M \\<Longrightarrow> n \\<in> M \\<Longrightarrow> P m n\"\n  shows \"pairwise P M\"", "lemma pairwiseD[dest]:\n  assumes \"pairwise P M\" \"m \\<in> M\" \"n \\<in> M\"\n  shows \"P m n\"", "lemma pairwise_subset: \"pairwise P M \\<Longrightarrow> N \\<subseteq> M \\<Longrightarrow> pairwise P N\"", "lemma pairwise_weaken: \"pairwise P M \\<Longrightarrow> (\\<And>x y. x \\<in> M \\<Longrightarrow> y \\<in> M \\<Longrightarrow> P x y \\<Longrightarrow> Q x y) \\<Longrightarrow> pairwise Q M\"", "lemma pairwise_image[simp]: \"pairwise P (f ` M) = pairwise (\\<lambda>x y. P (f x) (f y)) M\"", "lemma fpairwise_alt_def[code]: \"fpairwise P M \\<longleftrightarrow> fBall M (\\<lambda>m. fBall M (\\<lambda>n. P m n))\"", "lemma fpairwiseI[intro!]:\n  assumes \"\\<And>m n. m |\\<in>| M \\<Longrightarrow> n |\\<in>| M \\<Longrightarrow> P m n\"\n  shows \"fpairwise P M\"", "lemma fpairwiseD:\n  assumes \"fpairwise P M\" \"m |\\<in>| M\" \"n |\\<in>| M\"\n  shows \"P m n\"", "lemma fpairwise_image[simp]: \"fpairwise P (f |`| M) = fpairwise (\\<lambda>x y. P (f x) (f y)) M\"", "lemma fpairwise_subset: \"fpairwise P M \\<Longrightarrow> N |\\<subseteq>| M \\<Longrightarrow> fpairwise P N\"", "lemma fpairwise_weaken: \"fpairwise P M \\<Longrightarrow> (\\<And>x y. x |\\<in>| M \\<Longrightarrow> y |\\<in>| M \\<Longrightarrow> P x y \\<Longrightarrow> Q x y) \\<Longrightarrow> fpairwise Q M\"", "lemma rel_set_eq_eq: \"rel_set (=) A B \\<Longrightarrow> A = B\"", "lemma rel_set_image:\n  assumes \"rel_set P A B\"\n  assumes \"\\<And>a b. a \\<in> A \\<Longrightarrow> b \\<in> B \\<Longrightarrow> P a b \\<Longrightarrow> Q (f a) (g b)\"\n  shows \"rel_set Q (f ` A) (g ` B)\"", "lemma rel_set_refl_strong[intro]:\n  assumes \"\\<And>x. x \\<in> S \\<Longrightarrow> P x x\"\n  shows \"rel_set P S S\"", "lemma rel_fsetE1:\n  assumes \"rel_fset P M N\" \"x |\\<in>| M\"\n  obtains y where \"y |\\<in>| N\" \"P x y\"", "lemma rel_fsetE2:\n  assumes \"rel_fset P M N\" \"y |\\<in>| N\"\n  obtains x where \"x |\\<in>| M\" \"P x y\"", "lemma rel_fsetI:\n  assumes \"\\<And>x. x |\\<in>| A \\<Longrightarrow> fBex B (R x)\" \"\\<And>y. y |\\<in>| B \\<Longrightarrow> fBex A (\\<lambda>x. R x y)\"\n  shows \"rel_fset R A B\"", "lemma rel_fset_image:\n  assumes \"rel_fset P A B\"\n  assumes \"\\<And>a b. a |\\<in>| A \\<Longrightarrow> b |\\<in>| B \\<Longrightarrow> P a b \\<Longrightarrow> Q (f a) (g b)\"\n  shows \"rel_fset Q (f |`| A) (g |`| B)\"", "lemma rel_fset_refl_strong:\n  assumes \"\\<And>x. x |\\<in>| S \\<Longrightarrow> P x x\"\n  shows \"rel_fset P S S\"", "lemma select_finite:\n  assumes \"finite S\"\n  shows \"finite (select f S)\"", "lemma select_memberI: \"x \\<in> S \\<Longrightarrow> f x = Some y \\<Longrightarrow> y \\<in> select f S\"", "lemma select_memberE:\n  assumes \"y \\<in> select f S\"\n  obtains x where \"x \\<in> S\" \"f x = Some y\"", "lemma fselect_memberI[intro]: \"x |\\<in>| S \\<Longrightarrow> f x = Some y \\<Longrightarrow> y |\\<in>| fselect f S\"", "lemma fselect_memberE[elim]:\n  assumes \"y |\\<in>| fselect f S\"\n  obtains x where \"x |\\<in>| S\" \"f x = Some y\"", "lemma set_of_list_singletonE:\n  assumes \"set xs = {x}\" \"distinct xs\"\n  shows \"xs = [x]\"", "lemma fset_of_list_singletonE:\n  assumes \"fset_of_list xs = {|x|}\" \"distinct xs\"\n  shows \"xs = [x]\"", "lemma fmpred_foldl[intro]:\n  assumes \"fmpred P init\" \"\\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x\"\n  shows \"fmpred P (foldl (++\\<^sub>f) init xs)\"", "lemma fmdom_foldl_add: \"fmdom (foldl (++\\<^sub>f) m ns) = fmdom m |\\<union>| ffUnion (fmdom |`| fset_of_list ns)\"", "lemma fmimage_fmmap[simp]: \"fmimage (fmmap f m) S = f |`| fmimage m S\"", "lemma fmmap_total:\n  assumes \"\\<And>k v. fmlookup m k = Some v \\<Longrightarrow> (\\<exists>v'. f v' = v)\"\n  obtains m' where \"m = fmmap f m'\"", "lemma set_of_map_upd: \"set_of_map (map_upd k v m) = set_of_map (map_drop k m) \\<union> {(k, v)}\"", "lemma map_drop_delete: \"map_drop k (map_of ps) = map_of (AList.delete k ps)\"", "lemma set_of_map_map_of: \"set_of_map (map_of xs) = set (AList.clearjunk xs)\"", "lemma fset_of_fmap_code[code]: \"fset_of_fmap (fmap_of_list x) = fset_of_list (AList.clearjunk x)\"", "lemma distinct_sorted_list_of_fmap[simp, intro]: \"distinct (sorted_list_of_fmap m)\"", "lemma rev_induct2[consumes 1, case_names nil snoc]:\n  assumes \"length xs = length ys\"\n  assumes \"P [] []\"\n  assumes \"\\<And>x xs y ys. length xs = length ys \\<Longrightarrow> P xs ys \\<Longrightarrow> P (xs @ [x]) (ys @ [y])\"\n  shows \"P xs ys\"", "lemma list_allI[intro]:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> P x\"\n  shows \"list_all P xs\"", "lemma list_map_snd_id:\n  assumes \"\\<And>a b e. (a, b) \\<in> set cs \\<Longrightarrow> f a b = b\"\n  shows \"map (\\<lambda>(a, b). (a, f a b)) cs = cs\"", "lemma list_all2_leftE:\n  assumes \"list_all2 P xs ys\" \"x \\<in> set xs\"\n  obtains y where \"y \\<in> set ys\" \"P x y\"", "lemma list_all2_rightE:\n  assumes \"list_all2 P xs ys\" \"y \\<in> set ys\"\n  obtains x where \"x \\<in> set xs\" \"P x y\"", "lemma list_all3_empty[intro]: \"list_all3 P [] [] []\"", "lemma list_all3_cons[intro]: \"list_all3 P xs ys zs \\<Longrightarrow> P x y z \\<Longrightarrow> list_all3 P (x # xs) (y # ys) (z # zs)\"", "lemma list_all3_induct[consumes 1, case_names Nil Cons, induct set: list_all3]:\n  assumes P: \"list_all3 P xs ys zs\"\n  assumes Nil: \"Q [] [] []\"\n  assumes Cons: \"\\<And>x xs y ys z zs.\n    P x y z \\<Longrightarrow> Q xs ys zs \\<Longrightarrow> list_all3 P xs ys zs \\<Longrightarrow> Q (x # xs) (y # ys) (z # zs)\"\n  shows \"Q xs ys zs\"", "lemma list_all3_from_list_all2s:\n  assumes \"list_all2 P xs ys\" \"list_all2 Q xs zs\"\n  assumes \"\\<And>x y z. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> z \\<in> set zs \\<Longrightarrow> P x y \\<Longrightarrow> Q x z \\<Longrightarrow> R x y z\"\n  shows \"list_all3 R xs ys zs\"", "lemma those_someD:\n  assumes \"those xs = Some ys\"\n  shows \"xs = map Some ys\""], "translations": [["", "lemma distinct_sorted_list_of_fset[simp, intro]: \"distinct (sorted_list_of_fset S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_list_of_fset S)", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_list_of_fset S)", "by transfer (rule distinct_sorted_list_of_set)"], ["", "lemma sum_nat_le_single:\n  fixes x :: nat\n  assumes y: \"y \\<in> S\" and x: \"x \\<le> f y\" and finite: \"finite S\"\n  shows \"x \\<le> sum f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> sum f S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> sum f S", "have \"sum f S = sum f (insert y S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f S = sum f (insert y S)", "using y"], ["proof (prove)\nusing this:\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. sum f S = sum f (insert y S)", "by (metis insert_absorb)"], ["proof (state)\nthis:\n  sum f S = sum f (insert y S)\n\ngoal (1 subgoal):\n 1. x \\<le> sum f S", "with finite"], ["proof (chain)\npicking this:\n  finite S\n  sum f S = sum f (insert y S)", "have \"sum f S = f y + sum f (S - {y})\""], ["proof (prove)\nusing this:\n  finite S\n  sum f S = sum f (insert y S)\n\ngoal (1 subgoal):\n 1. sum f S = f y + sum f (S - {y})", "by (metis sum.insert_remove)"], ["proof (state)\nthis:\n  sum f S = f y + sum f (S - {y})\n\ngoal (1 subgoal):\n 1. x \\<le> sum f S", "with x"], ["proof (chain)\npicking this:\n  x \\<le> f y\n  sum f S = f y + sum f (S - {y})", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> f y\n  sum f S = f y + sum f (S - {y})\n\ngoal (1 subgoal):\n 1. x \\<le> sum f S", "by linarith"], ["proof (state)\nthis:\n  x \\<le> sum f S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_nat_less_single:\n  fixes x :: nat\n  assumes y: \"y \\<in> S\" and x: \"x < f y\" and finite: \"finite S\"\n  shows \"x < sum f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < sum f S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < sum f S", "have \"sum f S = sum f (insert y S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f S = sum f (insert y S)", "using y"], ["proof (prove)\nusing this:\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. sum f S = sum f (insert y S)", "by (metis insert_absorb)"], ["proof (state)\nthis:\n  sum f S = sum f (insert y S)\n\ngoal (1 subgoal):\n 1. x < sum f S", "with finite"], ["proof (chain)\npicking this:\n  finite S\n  sum f S = sum f (insert y S)", "have \"sum f S = f y + sum f (S - {y})\""], ["proof (prove)\nusing this:\n  finite S\n  sum f S = sum f (insert y S)\n\ngoal (1 subgoal):\n 1. sum f S = f y + sum f (S - {y})", "by (metis sum.insert_remove)"], ["proof (state)\nthis:\n  sum f S = f y + sum f (S - {y})\n\ngoal (1 subgoal):\n 1. x < sum f S", "with x"], ["proof (chain)\npicking this:\n  x < f y\n  sum f S = f y + sum f (S - {y})", "show ?thesis"], ["proof (prove)\nusing this:\n  x < f y\n  sum f S = f y + sum f (S - {y})\n\ngoal (1 subgoal):\n 1. x < sum f S", "by linarith"], ["proof (state)\nthis:\n  x < sum f S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_BallI: \"(\\<And>a b. (a, b) \\<in> M \\<Longrightarrow> P a b) \\<Longrightarrow> Ball M (\\<lambda>(a, b). P a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. (a, b) \\<in> M \\<Longrightarrow> P a b) \\<Longrightarrow>\n    \\<forall>(a, b)\\<in>M. P a b", "by auto"], ["", "lemma fset_map_snd_id:\n  assumes \"\\<And>a b e. (a, b) \\<in> fset cs \\<Longrightarrow> f a b = b\"\n  shows \"(\\<lambda>(a, b). (a, f a b)) |`| cs = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). (a, f a b)) |`| cs = cs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). (a, f a b)) |`| cs = cs", "have \"(\\<lambda>(a, b). (a, f a b)) |`| cs = id |`| cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). (a, f a b)) |`| cs = id |`| cs", "proof (rule fset.map_cong0, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> fset cs \\<Longrightarrow> (a, f a b) = id (a, b)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> fset cs \\<Longrightarrow> (a, f a b) = id (a, b)", "assume \"(a, b) \\<in> fset cs\""], ["proof (state)\nthis:\n  (a, b) \\<in> fset cs\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> fset cs \\<Longrightarrow> (a, f a b) = id (a, b)", "hence \"f a b = b\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> fset cs\n\ngoal (1 subgoal):\n 1. f a b = b", "using assms"], ["proof (prove)\nusing this:\n  (a, b) \\<in> fset cs\n  (?a, ?b) \\<in> fset cs \\<Longrightarrow> f ?a ?b = ?b\n\ngoal (1 subgoal):\n 1. f a b = b", "by auto"], ["proof (state)\nthis:\n  f a b = b\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> fset cs \\<Longrightarrow> (a, f a b) = id (a, b)", "thus \"(a, f a b) = id (a, b)\""], ["proof (prove)\nusing this:\n  f a b = b\n\ngoal (1 subgoal):\n 1. (a, f a b) = id (a, b)", "by simp"], ["proof (state)\nthis:\n  (a, f a b) = id (a, b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>(a, b). (a, f a b)) |`| cs = id |`| cs\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). (a, f a b)) |`| cs = cs", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>(a, b). (a, f a b)) |`| cs = id |`| cs\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). (a, f a b)) |`| cs = cs", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>(a, b). (a, f a b)) |`| cs = cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas disj_cases = disjE[case_names 1 2, consumes 1]"], ["", "lemma case_prod_twice: \"case_prod f (case_prod (\\<lambda>a b. (g a b, h a b)) x) = case_prod (\\<lambda>a b. f (g a b) (h a b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case x of (a, b) \\<Rightarrow> (g a b, h a b) of\n     (x, xa) \\<Rightarrow> f x xa) =\n    (case x of (a, b) \\<Rightarrow> f (g a b) (h a b))", "by (simp add: split_beta)"], ["", "lemma map_of_map_keyed:\n  \"map_of (map (\\<lambda>(k, v). (k, f k v)) xs) = (\\<lambda>k. map_option (f k) (map_of xs k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, v). (k, f k v)) xs) =\n    (\\<lambda>k. map_option (f k) (map_of xs k))", "by (induction xs) (auto simp: fun_eq_iff)"], ["", "locale rekey =\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes bij: \"bij f\"\nbegin"], ["", "lemma map_of_rekey:\n  \"map_of (map (\\<lambda>(k, v). (f k, g k v)) xs) k = map_option (g (inv f k)) (map_of xs (inv f k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, v). (f k, g k v)) xs) k =\n    map_option (g (inv f k)) (map_of xs (inv f k))", "using bij"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, v). (f k, g k v)) xs) k =\n    map_option (g (inv f k)) (map_of xs (inv f k))", "by (induction xs) (auto simp: bij_def surj_f_inv_f)"], ["", "lemma map_of_rekey': \"map_of (map (map_prod f g) xs) k = map_option g (map_of xs (inv f k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (map_prod f g) xs) k = map_option g (map_of xs (inv f k))", "unfolding map_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(x, y). (f x, g y)) xs) k =\n    map_option g (map_of xs (inv f k))", "by (rule map_of_rekey)"], ["", "lemma fst_distinct: \"distinct (map fst xs) \\<Longrightarrow> distinct (map (\\<lambda>(k, _). f k) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    distinct (map (\\<lambda>(k, uu_). f k) xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map (\\<lambda>(k, uu_). f k) [])\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map (\\<lambda>(k, uu_). f k) xs);\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map (\\<lambda>(k, uu_). f k) (a # xs))", "case Cons"], ["proof (state)\nthis:\n  distinct (map fst xs_) \\<Longrightarrow>\n  distinct (map (\\<lambda>a. case a of (k, uu_) \\<Rightarrow> f k) xs_)\n  distinct (map fst (a_ # xs_))\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map (\\<lambda>(k, uu_). f k) [])\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map (\\<lambda>(k, uu_). f k) xs);\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map (\\<lambda>(k, uu_). f k) (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst xs_) \\<Longrightarrow>\n  distinct (map (\\<lambda>a. case a of (k, uu_) \\<Rightarrow> f k) xs_)\n  distinct (map fst (a_ # xs_))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>a. case a of (k, uu_) \\<Rightarrow> f k) (a_ # xs_))", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 aa b.\n       \\<lbrakk>distinct (map (\\<lambda>(k, uu_). f k) xs_);\n        x1 \\<notin> fst ` set xs_; distinct (map fst xs_); a_ = (x1, x2);\n        f x1 = f aa; (aa, b) \\<in> set xs_\\<rbrakk>\n       \\<Longrightarrow> False", "using bij"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 aa b.\n       \\<lbrakk>distinct (map (\\<lambda>(k, uu_). f k) xs_);\n        x1 \\<notin> fst ` set xs_; distinct (map fst xs_); a_ = (x1, x2);\n        f x1 = f aa; (aa, b) \\<in> set xs_\\<rbrakk>\n       \\<Longrightarrow> False", "unfolding bij_def"], ["proof (prove)\nusing this:\n  inj f \\<and> surj f\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 aa b.\n       \\<lbrakk>distinct (map (\\<lambda>(k, uu_). f k) xs_);\n        x1 \\<notin> fst ` set xs_; distinct (map fst xs_); a_ = (x1, x2);\n        f x1 = f aa; (aa, b) \\<in> set xs_\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis fst_conv injD rev_image_eqI)"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>a. case a of (k, uu_) \\<Rightarrow> f k) (a_ # xs_))\n\ngoal (1 subgoal):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map (\\<lambda>(k, uu_). f k) [])", "qed auto"], ["", "lemma inv: \"rekey (inv f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rekey (inv f)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (inv f)", "using bij"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. bij (inv f)", "by (simp add: bij_imp_bij_inv)"], ["", "end"], ["", "section \\<open>Finite sets\\<close>"], ["", "lemma fset_eq_empty_iff: \"M = {||} \\<longleftrightarrow> (\\<forall>x. x |\\<notin>| M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M = {||}) = (\\<forall>x. x |\\<notin>| M)", "by auto"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lemma fbind_subset_eqI: \"fBall S (\\<lambda>s. f s |\\<subseteq>| T) \\<Longrightarrow> fbind S f |\\<subseteq>| T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall S (\\<lambda>s. f s |\\<subseteq>| T) \\<Longrightarrow>\n    fbind S f |\\<subseteq>| T", "by transfer' fastforce"], ["", "lemma prod_fBallI: \"(\\<And>a b. (a, b) |\\<in>| M \\<Longrightarrow> P a b) \\<Longrightarrow> fBall M (\\<lambda>(a, b). P a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. (a, b) |\\<in>| M \\<Longrightarrow> P a b) \\<Longrightarrow>\n    fBall M (\\<lambda>(a, b). P a b)", "by transfer (rule prod_BallI)"], ["", "lemma ffUnion_subset_elem: \"x |\\<in>| X \\<Longrightarrow> x |\\<subseteq>| ffUnion X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| X \\<Longrightarrow> x |\\<subseteq>| ffUnion X", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| X \\<Longrightarrow> x |\\<subseteq>| ffUnion X", "by transfer auto"], ["", "lemma fbindE:\n  assumes \"x |\\<in>| fbind S f\"\n  obtains s where \"x |\\<in>| f s\" \"s |\\<in>| S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>x |\\<in>| f s; s |\\<in>| S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x |\\<in>| fbind S f\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>x |\\<in>| f s; s |\\<in>| S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer' auto"], ["", "lemma ffUnion_least_rev: \"ffUnion A |\\<subseteq>| C \\<Longrightarrow> fBall A (\\<lambda>X. X |\\<subseteq>| C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion A |\\<subseteq>| C \\<Longrightarrow>\n    fBall A (\\<lambda>X. X |\\<subseteq>| C)", "by transfer blast"], ["", "lemma inj_on_fimage_set_diff:\n  assumes \"inj_on f (fset C)\" \"A |\\<subseteq>| C\" \"B |\\<subseteq>| C\"\n  shows \"f |`| (A - B) = f |`| A - f |`| B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f |`| (A |-| B) = f |`| A |-| f |`| B", "using assms"], ["proof (prove)\nusing this:\n  inj_on f (fset C)\n  A |\\<subseteq>| C\n  B |\\<subseteq>| C\n\ngoal (1 subgoal):\n 1. f |`| (A |-| B) = f |`| A |-| f |`| B", "by transfer (meson Diff_subset inj_on_image_set_diff order_trans)"], ["", "lemma list_all_iff_fset: \"list_all P xs \\<longleftrightarrow> fBall (fset_of_list xs) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P xs = fBall (fset_of_list xs) P", "by transfer (rule list_all_iff)"], ["", "lemma fbind_fun_funion: \"fbind M (\\<lambda>x. f x |\\<union>| g x) = fbind M f |\\<union>| fbind M g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind M (\\<lambda>x. f x |\\<union>| g x) =\n    fbind M f |\\<union>| fbind M g", "by transfer' auto"], ["", "end"], ["", "lemma funion_strictE:\n  assumes \"c |\\<in>| A |\\<union>| B\"\n  obtains (A) \"c |\\<in>| A\" | (B) \"c |\\<notin>| A\" \"c |\\<in>| B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c |\\<in>| A \\<Longrightarrow> thesis;\n     \\<lbrakk>c |\\<notin>| A; c |\\<in>| B\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  c |\\<in>| A |\\<union>| B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c |\\<in>| A \\<Longrightarrow> thesis;\n     \\<lbrakk>c |\\<notin>| A; c |\\<in>| B\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "lemma max_decr:\n  fixes X :: \"nat set\"\n  assumes \"\\<exists>x \\<in> X. x \\<ge> k\" \"finite X\"\n  shows \"Max ((\\<lambda>x. x - k) ` X) = Max X - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX x\\<in>X. x - k) = Max X - k", "proof (rule mono_Max_commute[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. mono (\\<lambda>x. x - k)\n 2. finite X\n 3. X \\<noteq> {}", "show \"mono (\\<lambda>x. x - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>x. x - k)", "by (rule monoI) linarith"], ["proof (state)\nthis:\n  mono (\\<lambda>x. x - k)\n\ngoal (2 subgoals):\n 1. finite X\n 2. X \\<noteq> {}", "show \"finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X", "by fact"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {}", "show \"X \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>X. k \\<le> x\n  finite X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  X \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_ex_gr: \"\\<exists>x \\<in> X. k < x \\<Longrightarrow> finite X \\<Longrightarrow> X \\<noteq> {} \\<Longrightarrow> k < Max X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x\\<in>X. k < x; finite X; X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k < Max X", "by (simp add: Max_gr_iff)"], ["", "context includes fset.lifting begin"], ["", "lemma fmax_decr:\n  fixes X :: \"nat fset\"\n  assumes \"fBex X (\\<lambda>x. x \\<ge> k)\"\n  shows \"fMax ((\\<lambda>x. x - k) |`| X) = fMax X - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMax ((\\<lambda>x. x - k) |`| X) = fMax X - k", "using assms"], ["proof (prove)\nusing this:\n  fBex X ((\\<le>) k)\n\ngoal (1 subgoal):\n 1. fMax ((\\<lambda>x. x - k) |`| X) = fMax X - k", "by transfer (rule max_decr)"], ["", "lemma fmax_ex_gr: \"fBex X (\\<lambda>x. k < x) \\<Longrightarrow> X \\<noteq> {||} \\<Longrightarrow> k < fMax X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fBex X ((<) k); X \\<noteq> {||}\\<rbrakk>\n    \\<Longrightarrow> k < fMax X", "by transfer (rule max_ex_gr)"], ["", "lemma fMax_le: \"fBall M (\\<lambda>x. x \\<le> k) \\<Longrightarrow> M \\<noteq> {||} \\<Longrightarrow> fMax M \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fBall M (\\<lambda>x. x \\<le> k); M \\<noteq> {||}\\<rbrakk>\n    \\<Longrightarrow> fMax M \\<le> k", "by transfer auto"], ["", "end"], ["", "section \\<open>Sets\\<close>"], ["", "subsection \\<open>Code setup trickery\\<close>"], ["", "definition compress :: \"'a set \\<Rightarrow> 'a set\" where\n\"compress = id\""], ["", "lemma [code]: \"compress (set xs) = set (remdups xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress (set xs) = set (remdups xs)", "unfolding compress_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set (remdups xs)", "by simp"], ["", "definition the_elem' :: \"'a::linorder set \\<Rightarrow> 'a\" where\n\"the_elem' S = the_elem (set (sorted_list_of_set S))\""], ["", "lemma the_elem_id: \"finite S \\<Longrightarrow> the_elem' S = the_elem S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow> the_elem' S = the_elem S", "unfolding the_elem'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    the_elem (set (sorted_list_of_set S)) = the_elem S", "by auto"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lift_definition fcompress :: \"'a fset \\<Rightarrow> 'a fset\" is compress"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set. finite set \\<Longrightarrow> finite (compress set)", "unfolding compress_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set. finite set \\<Longrightarrow> finite (id set)", "by simp"], ["", "lemma fcompress_eq[simp]: \"fcompress M = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompress M = M", "by transfer' (auto simp: compress_def)"], ["", "lift_definition fthe_elem' :: \"'a::linorder fset \\<Rightarrow> 'a\" is the_elem'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma fthe_elem'_eq: \"fthe_elem' = fthe_elem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fthe_elem' = fthe_elem", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fthe_elem' x = fthe_elem x", "fix S :: \"'a fset\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fthe_elem' x = fthe_elem x", "show \"fthe_elem' S = fthe_elem S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fthe_elem' S = fthe_elem S", "by transfer (fastforce intro: the_elem_id)"], ["proof (state)\nthis:\n  fthe_elem' S = fthe_elem S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>@{type set}s as maps\\<close>"], ["", "definition is_map :: \"('a \\<times> 'b) set \\<Rightarrow> bool\" where\n\"is_map M = Ball M (\\<lambda>(a\\<^sub>1, b\\<^sub>1). Ball M (\\<lambda>(a\\<^sub>2, b\\<^sub>2). a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow> b\\<^sub>1 = b\\<^sub>2))\""], ["", "lemma is_mapI[intro]:\n  assumes \"\\<And>a b\\<^sub>1 b\\<^sub>2. (a, b\\<^sub>1) \\<in> M \\<Longrightarrow> (a, b\\<^sub>2) \\<in> M \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2\"\n  shows \"is_map M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map M", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b\\<^sub>1) \\<in> M; (?a, ?b\\<^sub>2) \\<in> M\\<rbrakk>\n  \\<Longrightarrow> ?b\\<^sub>1 = ?b\\<^sub>2\n\ngoal (1 subgoal):\n 1. is_map M", "unfolding is_map_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b\\<^sub>1) \\<in> M; (?a, ?b\\<^sub>2) \\<in> M\\<rbrakk>\n  \\<Longrightarrow> ?b\\<^sub>1 = ?b\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>M.\n       \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>M.\n          a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow> b\\<^sub>1 = b\\<^sub>2", "by auto"], ["", "lemma distinct_is_map:\n  assumes \"distinct (map fst m)\"\n  shows \"is_map (set m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map (set m)", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst m)\n\ngoal (1 subgoal):\n 1. is_map (set m)", "by (metis Some_eq_map_of_iff is_mapI option.inject)"], ["", "lemma is_map_image:\n  assumes \"is_map M\"\n  shows \"is_map ((\\<lambda>(a, b). (a, f a b)) ` M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map ((\\<lambda>(a, b). (a, f a b)) ` M)", "using assms"], ["proof (prove)\nusing this:\n  is_map M\n\ngoal (1 subgoal):\n 1. is_map ((\\<lambda>(a, b). (a, f a b)) ` M)", "unfolding is_map_def"], ["proof (prove)\nusing this:\n  \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>M.\n     \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>M.\n        a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow> b\\<^sub>1 = b\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>(\\<lambda>(a, b). (a, f a b)) ` M.\n       \\<forall>(a\\<^sub>2, b\\<^sub>2)\n                \\<in>(\\<lambda>(a, b). (a, f a b)) ` M.\n          a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow> b\\<^sub>1 = b\\<^sub>2", "by auto"], ["", "lemma is_mapD:\n  assumes \"is_map M\" \"(a, b\\<^sub>1) \\<in> M\" \"(a, b\\<^sub>2) \\<in> M\"\n  shows \"b\\<^sub>1 = b\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b\\<^sub>1 = b\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  is_map M\n  (a, b\\<^sub>1) \\<in> M\n  (a, b\\<^sub>2) \\<in> M\n\ngoal (1 subgoal):\n 1. b\\<^sub>1 = b\\<^sub>2", "unfolding is_map_def"], ["proof (prove)\nusing this:\n  \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>M.\n     \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>M.\n        a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow> b\\<^sub>1 = b\\<^sub>2\n  (a, b\\<^sub>1) \\<in> M\n  (a, b\\<^sub>2) \\<in> M\n\ngoal (1 subgoal):\n 1. b\\<^sub>1 = b\\<^sub>2", "by auto"], ["", "lemma is_map_subset: \"is_map N \\<Longrightarrow> M \\<subseteq> N \\<Longrightarrow> is_map M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_map N; M \\<subseteq> N\\<rbrakk> \\<Longrightarrow> is_map M", "unfolding is_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>N.\n                \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>N.\n                   a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow>\n                   b\\<^sub>1 = b\\<^sub>2;\n     M \\<subseteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>M.\n                         \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>M.\n                            a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow>\n                            b\\<^sub>1 = b\\<^sub>2", "by blast"], ["", "lemma map_of_is_map: \"(k, v) \\<in> set m \\<Longrightarrow> is_map (set m) \\<Longrightarrow> map_of m k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(k, v) \\<in> set m; is_map (set m)\\<rbrakk>\n    \\<Longrightarrow> map_of m k = Some v", "by (metis is_mapD map_of_SomeD weak_map_of_SomeI)"], ["", "definition get_map :: \"('a \\<times> 'b) set \\<Rightarrow> 'a \\<Rightarrow> ('a \\<times> 'b)\" where\n\"get_map M k = the_elem (Set.filter (\\<lambda>(k', _). k = k') M)\""], ["", "lemma get_map_elem:\n  assumes \"is_map M\"\n  assumes \"(k, v) \\<in> M\"\n  shows \"get_map M k = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_map M k = (k, v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. get_map M k = (k, v)", "from assms"], ["proof (chain)\npicking this:\n  is_map M\n  (k, v) \\<in> M", "have \"Set.filter (\\<lambda>(k', _). k = k') M = {(k, v)}\""], ["proof (prove)\nusing this:\n  is_map M\n  (k, v) \\<in> M\n\ngoal (1 subgoal):\n 1. Set.filter (\\<lambda>(k', uu_). k = k') M = {(k, v)}", "unfolding is_map_def"], ["proof (prove)\nusing this:\n  \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>M.\n     \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>M.\n        a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow> b\\<^sub>1 = b\\<^sub>2\n  (k, v) \\<in> M\n\ngoal (1 subgoal):\n 1. Set.filter (\\<lambda>(k', uu_). k = k') M = {(k, v)}", "by fastforce"], ["proof (state)\nthis:\n  Set.filter (\\<lambda>(k', uu_). k = k') M = {(k, v)}\n\ngoal (1 subgoal):\n 1. get_map M k = (k, v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Set.filter (\\<lambda>(k', uu_). k = k') M = {(k, v)}\n\ngoal (1 subgoal):\n 1. get_map M k = (k, v)", "unfolding get_map_def"], ["proof (prove)\nusing this:\n  Set.filter (\\<lambda>(k', uu_). k = k') M = {(k, v)}\n\ngoal (1 subgoal):\n 1. the_elem (Set.filter (\\<lambda>(k', uu_). k = k') M) = (k, v)", "by simp"], ["proof (state)\nthis:\n  get_map M k = (k, v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma get_map_map:\n  assumes \"is_map S\" \"k \\<in> fst ` S\"\n  shows \"get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k = (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n    (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n    (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))", "from assms"], ["proof (chain)\npicking this:\n  is_map S\n  k \\<in> fst ` S", "obtain v where \"(k, v) \\<in> S\""], ["proof (prove)\nusing this:\n  is_map S\n  k \\<in> fst ` S\n\ngoal (1 subgoal):\n 1. (\\<And>v. (k, v) \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (k, v) \\<in> S\n\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n    (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))", "hence \"get_map S k = (k, v)\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> S\n\ngoal (1 subgoal):\n 1. get_map S k = (k, v)", "using assms"], ["proof (prove)\nusing this:\n  (k, v) \\<in> S\n  is_map S\n  k \\<in> fst ` S\n\ngoal (1 subgoal):\n 1. get_map S k = (k, v)", "by (simp add: get_map_elem)"], ["proof (state)\nthis:\n  get_map S k = (k, v)\n\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n    (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))", "have \"(k, f k v) \\<in> (\\<lambda>(a, b). (a, f a b)) ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, f k v) \\<in> (\\<lambda>(a, b). (a, f a b)) ` S", "using \\<open>(k, v) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  (k, v) \\<in> S\n\ngoal (1 subgoal):\n 1. (k, f k v) \\<in> (\\<lambda>(a, b). (a, f a b)) ` S", "by auto"], ["proof (state)\nthis:\n  (k, f k v) \\<in> (\\<lambda>(a, b). (a, f a b)) ` S\n\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n    (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))", "hence \"get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k = (k, f k v)\""], ["proof (prove)\nusing this:\n  (k, f k v) \\<in> (\\<lambda>(a, b). (a, f a b)) ` S\n\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k = (k, f k v)", "using assms"], ["proof (prove)\nusing this:\n  (k, f k v) \\<in> (\\<lambda>(a, b). (a, f a b)) ` S\n  is_map S\n  k \\<in> fst ` S\n\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k = (k, f k v)", "by (metis get_map_elem is_map_image)"], ["proof (state)\nthis:\n  get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k = (k, f k v)\n\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n    (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))", "(* takes long *)"], ["proof (state)\nthis:\n  get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k = (k, f k v)\n\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n    (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n    (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))", "unfolding \\<open>get_map S k = _\\<close> \\<open>get_map (_ ` S) k = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, f k v) = (case (k, v) of (a, b) \\<Rightarrow> (a, f a b))", "by simp"], ["proof (state)\nthis:\n  get_map ((\\<lambda>(a, b). (a, f a b)) ` S) k =\n  (case get_map S k of (a, b) \\<Rightarrow> (a, f a b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_map_fst_inj: \"is_map S \\<Longrightarrow> inj_on fst S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map S \\<Longrightarrow> inj_on fst S", "by (fastforce intro: inj_onI dest: is_mapD)"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lemma is_map_transfer:\n  fixes A :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\"\n  assumes [transfer_rule]: \"bi_unique A\"\n  shows \"rel_fun (rel_set (rel_prod (=) A)) (=) is_map is_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_set (rel_prod (=) A)) (=) is_map is_map", "unfolding is_map_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_set (rel_prod (=) A)) (=)\n     (\\<lambda>M.\n         \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>M.\n            \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>M.\n               a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow>\n               b\\<^sub>1 = b\\<^sub>2)\n     (\\<lambda>M.\n         \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>M.\n            \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>M.\n               a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow>\n               b\\<^sub>1 = b\\<^sub>2)", "by transfer_prover"], ["", "lift_definition is_fmap :: \"('a \\<times> 'b) fset \\<Rightarrow> bool\" is is_map parametric is_map_transfer"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma is_fmapI[intro]:\n  assumes \"\\<And>a b\\<^sub>1 b\\<^sub>2. (a, b\\<^sub>1) |\\<in>| M \\<Longrightarrow> (a, b\\<^sub>2) |\\<in>| M \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2\"\n  shows \"is_fmap M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap M", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b\\<^sub>1) |\\<in>| M; (?a, ?b\\<^sub>2) |\\<in>| M\\<rbrakk>\n  \\<Longrightarrow> ?b\\<^sub>1 = ?b\\<^sub>2\n\ngoal (1 subgoal):\n 1. is_fmap M", "by transfer' auto"], ["", "lemma is_fmap_image: \"is_fmap M \\<Longrightarrow> is_fmap ((\\<lambda>(a, b). (a, f a b)) |`| M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap M \\<Longrightarrow>\n    is_fmap ((\\<lambda>(a, b). (a, f a b)) |`| M)", "by transfer' (rule is_map_image)"], ["", "lemma is_fmapD:\n  assumes \"is_fmap M\" \"(a, b\\<^sub>1) |\\<in>| M\" \"(a, b\\<^sub>2) |\\<in>| M\"\n  shows \"b\\<^sub>1 = b\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b\\<^sub>1 = b\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  is_fmap M\n  (a, b\\<^sub>1) |\\<in>| M\n  (a, b\\<^sub>2) |\\<in>| M\n\ngoal (1 subgoal):\n 1. b\\<^sub>1 = b\\<^sub>2", "by transfer' (rule is_mapD)"], ["", "lemma is_fmap_subset: \"is_fmap N \\<Longrightarrow> M |\\<subseteq>| N \\<Longrightarrow> is_fmap M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_fmap N; M |\\<subseteq>| N\\<rbrakk>\n    \\<Longrightarrow> is_fmap M", "by transfer' (rule is_map_subset)"], ["", "end"], ["", "subsection \\<open>Conversion into sorted lists\\<close>"], ["", "definition ordered_map :: \"('a::linorder \\<times> 'b) set \\<Rightarrow> ('a \\<times> 'b) list\" where\n\"ordered_map S = map (get_map S) (sorted_list_of_set (fst ` S))\""], ["", "lemma ordered_map_set_eq:\n  assumes \"finite S\" \"is_map S\"\n  shows \"set (ordered_map S) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "have \"set (ordered_map S) = get_map S ` set (sorted_list_of_set (fst ` S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ordered_map S) = get_map S ` set (sorted_list_of_set (fst ` S))", "unfolding ordered_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    get_map S ` set (sorted_list_of_set (fst ` S))", "by simp"], ["proof (state)\nthis:\n  set (ordered_map S) = get_map S ` set (sorted_list_of_set (fst ` S))\n\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "also"], ["proof (state)\nthis:\n  set (ordered_map S) = get_map S ` set (sorted_list_of_set (fst ` S))\n\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "have \"\\<dots> = get_map S ` (fst ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_map S ` set (sorted_list_of_set (fst ` S)) = get_map S ` fst ` S", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  is_map S\n\ngoal (1 subgoal):\n 1. get_map S ` set (sorted_list_of_set (fst ` S)) = get_map S ` fst ` S", "by (auto simp: sorted_list_of_set)"], ["proof (state)\nthis:\n  get_map S ` set (sorted_list_of_set (fst ` S)) = get_map S ` fst ` S\n\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "also"], ["proof (state)\nthis:\n  get_map S ` set (sorted_list_of_set (fst ` S)) = get_map S ` fst ` S\n\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "have \"\\<dots> = (get_map S \\<circ> fst) ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_map S ` fst ` S = (get_map S \\<circ> fst) ` S", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_map S ` fst ` S = (\\<lambda>x. get_map S (fst x)) ` S", "by auto"], ["proof (state)\nthis:\n  get_map S ` fst ` S = (get_map S \\<circ> fst) ` S\n\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "also"], ["proof (state)\nthis:\n  get_map S ` fst ` S = (get_map S \\<circ> fst) ` S\n\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "have \"\\<dots> = id ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (get_map S \\<circ> fst) ` S = id ` S", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  is_map S\n\ngoal (1 subgoal):\n 1. (get_map S \\<circ> fst) ` S = id ` S", "by (force simp: get_map_elem)"], ["proof (state)\nthis:\n  (get_map S \\<circ> fst) ` S = id ` S\n\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "finally"], ["proof (chain)\npicking this:\n  set (ordered_map S) = id ` S", "show ?thesis"], ["proof (prove)\nusing this:\n  set (ordered_map S) = id ` S\n\ngoal (1 subgoal):\n 1. set (ordered_map S) = S", "by simp"], ["proof (state)\nthis:\n  set (ordered_map S) = S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordered_map_image:\n  assumes \"finite S\" \"is_map S\"\n  shows \"map (\\<lambda>(a, b). (a, f a b)) (ordered_map S) = ordered_map ((\\<lambda>(a, b). (a, f a b)) ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) (ordered_map S) =\n    ordered_map ((\\<lambda>(a, b). (a, f a b)) ` S)", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  is_map S\n\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) (ordered_map S) =\n    ordered_map ((\\<lambda>(a, b). (a, f a b)) ` S)", "unfolding ordered_map_def list.map_comp image_comp"], ["proof (prove)\nusing this:\n  finite S\n  is_map S\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>(a, b). (a, f a b)) \\<circ> get_map S)\n     (sorted_list_of_set (fst ` S)) =\n    map (get_map ((\\<lambda>(a, b). (a, f a b)) ` S))\n     (sorted_list_of_set ((fst \\<circ> (\\<lambda>(a, b). (a, f a b))) ` S))", "by (auto simp: fst_def[abs_def] comp_def case_prod_twice get_map_map)"], ["", "lemma ordered_map_distinct:\n  assumes \"finite S\" \"is_map S\"\n  shows \"distinct (map fst (ordered_map S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (ordered_map S))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (ordered_map S))", "have \"inj_on (fst \\<circ> get_map S) (set (sorted_list_of_set (fst ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (fst \\<circ> get_map S) (set (sorted_list_of_set (fst ` S)))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (sorted_list_of_set (fst ` S));\n        y \\<in> set (sorted_list_of_set (fst ` S));\n        (fst \\<circ> get_map S) x = (fst \\<circ> get_map S) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "using sorted_list_of_set assms(1)"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  sorted (sorted_list_of_set ?A)\n  distinct (sorted_list_of_set ?A)\n  finite S\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (sorted_list_of_set (fst ` S));\n        y \\<in> set (sorted_list_of_set (fst ` S));\n        (fst \\<circ> get_map S) x = (fst \\<circ> get_map S) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> fst ` S; y \\<in> fst ` S;\n        fst (get_map S x) = fst (get_map S y);\n        \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n        finite S\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (erule imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>y \\<in> fst ` S; fst (get_map S x) = fst (get_map S y);\n        \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n        finite S; x = fst xa; xa \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (erule imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa xb.\n       \\<lbrakk>fst (get_map S x) = fst (get_map S y);\n        \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n        finite S; x = fst xa; xa \\<in> S; y = fst xb; xb \\<in> S\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y x' y'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (get_map S x) = fst (get_map S y);\n     \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n     finite S; x = fst x'; x' \\<in> S; y = fst y'; y' \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply (cases x', cases y')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>fst (get_map S x) = fst (get_map S y);\n        \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n        finite S; x = fst x'; x' \\<in> S; y = fst y'; y' \\<in> S;\n        x' = (a, b); y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>fst (get_map S a) = fst (get_map S aa); finite S; x = a;\n        (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S; x' = (a, b);\n        y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (subst (asm) get_map_elem)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>finite S; x = a; (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S;\n        x' = (a, b); y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> is_map S\n 2. \\<And>a b aa ba.\n       \\<lbrakk>finite S; x = a; (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S;\n        x' = (a, b); y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, ?v2 a b aa ba) \\<in> S\n 3. \\<And>a b aa ba.\n       \\<lbrakk>fst (a, ?v2 a b aa ba) = fst (get_map S aa); finite S;\n        x = a; (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S; x' = (a, b);\n        y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (rule assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>finite S; x = a; (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S;\n        x' = (a, b); y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, ?v2 a b aa ba) \\<in> S\n 2. \\<And>a b aa ba.\n       \\<lbrakk>fst (a, ?v2 a b aa ba) = fst (get_map S aa); finite S;\n        x = a; (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S; x' = (a, b);\n        y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>fst (a, b) = fst (get_map S aa); finite S; x = a;\n        (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S; x' = (a, b);\n        y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (subst (asm) get_map_elem)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>finite S; x = a; (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S;\n        x' = (a, b); y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> is_map S\n 2. \\<And>a b aa ba.\n       \\<lbrakk>finite S; x = a; (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S;\n        x' = (a, b); y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (aa, ?v3 a b aa ba) \\<in> S\n 3. \\<And>a b aa ba.\n       \\<lbrakk>fst (a, b) = fst (aa, ?v3 a b aa ba); finite S; x = a;\n        (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S; x' = (a, b);\n        y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (rule assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>finite S; x = a; (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S;\n        x' = (a, b); y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (aa, ?v3 a b aa ba) \\<in> S\n 2. \\<And>a b aa ba.\n       \\<lbrakk>fst (a, b) = fst (aa, ?v3 a b aa ba); finite S; x = a;\n        (a, b) \\<in> S; y = aa; (aa, ba) \\<in> S; x' = (a, b);\n        y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>fst (a, b) = fst (aa, ba); finite S; x = a; (a, b) \\<in> S;\n        y = aa; (aa, ba) \\<in> S; x' = (a, b); y' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inj_on (fst \\<circ> get_map S) (set (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. distinct (map fst (ordered_map S))", "then"], ["proof (chain)\npicking this:\n  inj_on (fst \\<circ> get_map S) (set (sorted_list_of_set (fst ` S)))", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on (fst \\<circ> get_map S) (set (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. distinct (map fst (ordered_map S))", "unfolding ordered_map_def"], ["proof (prove)\nusing this:\n  inj_on (fst \\<circ> get_map S) (set (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. distinct (map fst (map (get_map S) (sorted_list_of_set (fst ` S))))", "by (auto intro: distinct_sorted_list_of_set simp: distinct_map)"], ["proof (state)\nthis:\n  distinct (map fst (ordered_map S))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordered_map_keys:\n  assumes \"finite S\" \"is_map S\"\n  shows \"map fst (ordered_map S) = sorted_list_of_set (fst ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (ordered_map S) = sorted_list_of_set (fst ` S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst (ordered_map S) = sorted_list_of_set (fst ` S)", "have \"fst (get_map S z) = z\" if \"z \\<in> fst ` S\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (get_map S z) = z", "using assms that"], ["proof (prove)\nusing this:\n  finite S\n  is_map S\n  z \\<in> fst ` S\n\ngoal (1 subgoal):\n 1. fst (get_map S z) = z", "by (fastforce simp: get_map_elem)"], ["proof (state)\nthis:\n  ?z \\<in> fst ` S \\<Longrightarrow> fst (get_map S ?z) = ?z\n\ngoal (1 subgoal):\n 1. map fst (ordered_map S) = sorted_list_of_set (fst ` S)", "moreover"], ["proof (state)\nthis:\n  ?z \\<in> fst ` S \\<Longrightarrow> fst (get_map S ?z) = ?z\n\ngoal (1 subgoal):\n 1. map fst (ordered_map S) = sorted_list_of_set (fst ` S)", "have \"set (sorted_list_of_set (fst ` S)) = fst ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_list_of_set (fst ` S)) = fst ` S", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  is_map S\n\ngoal (1 subgoal):\n 1. set (sorted_list_of_set (fst ` S)) = fst ` S", "by (force simp: sorted_list_of_set)"], ["proof (state)\nthis:\n  set (sorted_list_of_set (fst ` S)) = fst ` S\n\ngoal (1 subgoal):\n 1. map fst (ordered_map S) = sorted_list_of_set (fst ` S)", "ultimately"], ["proof (chain)\npicking this:\n  ?z \\<in> fst ` S \\<Longrightarrow> fst (get_map S ?z) = ?z\n  set (sorted_list_of_set (fst ` S)) = fst ` S", "show ?thesis"], ["proof (prove)\nusing this:\n  ?z \\<in> fst ` S \\<Longrightarrow> fst (get_map S ?z) = ?z\n  set (sorted_list_of_set (fst ` S)) = fst ` S\n\ngoal (1 subgoal):\n 1. map fst (ordered_map S) = sorted_list_of_set (fst ` S)", "unfolding ordered_map_def"], ["proof (prove)\nusing this:\n  ?z \\<in> fst ` S \\<Longrightarrow> fst (get_map S ?z) = ?z\n  set (sorted_list_of_set (fst ` S)) = fst ` S\n\ngoal (1 subgoal):\n 1. map fst (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    sorted_list_of_set (fst ` S)", "by (metis (no_types, lifting) map_idI map_map o_apply)"], ["proof (state)\nthis:\n  map fst (ordered_map S) = sorted_list_of_set (fst ` S)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary ordered_map_sound:\n  assumes \"is_map S\" \"finite S\" \"(a, b) \\<in> set (ordered_map S)\"\n  shows \"(a, b) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> S", "using assms"], ["proof (prove)\nusing this:\n  is_map S\n  finite S\n  (a, b) \\<in> set (ordered_map S)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> S", "by (metis ordered_map_set_eq)"], ["", "lemma ordered_map_nonempty:\n  assumes \"is_map S\" \"ordered_map S \\<noteq> []\" \"finite S\"\n  shows \"S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  is_map S\n  ordered_map S \\<noteq> []\n  finite S\n\ngoal (1 subgoal):\n 1. S \\<noteq> {}", "unfolding ordered_map_def"], ["proof (prove)\nusing this:\n  is_map S\n  map (get_map S) (sorted_list_of_set (fst ` S)) \\<noteq> []\n  finite S\n\ngoal (1 subgoal):\n 1. S \\<noteq> {}", "by auto"], ["", "lemma ordered_map_remove:\n  assumes \"is_map S\" \"finite S\" \"x \\<in> S\"\n  shows \"ordered_map (S - {x}) = remove1 x (ordered_map S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have distinct: \"distinct (sorted_list_of_set (fst ` S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_list_of_set (fst ` S))", "using assms"], ["proof (prove)\nusing this:\n  is_map S\n  finite S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. distinct (sorted_list_of_set (fst ` S))", "by (fastforce simp: sorted_list_of_set)"], ["proof (state)\nthis:\n  distinct (sorted_list_of_set (fst ` S))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"inj_on (get_map S) (fst ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (get_map S) (fst ` S)", "using assms"], ["proof (prove)\nusing this:\n  is_map S\n  finite S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. inj_on (get_map S) (fst ` S)", "by (fastforce simp: get_map_elem intro: inj_onI)"], ["proof (state)\nthis:\n  inj_on (get_map S) (fst ` S)\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "hence inj: \"inj_on (get_map S) (set (sorted_list_of_set (fst ` S)))\""], ["proof (prove)\nusing this:\n  inj_on (get_map S) (fst ` S)\n\ngoal (1 subgoal):\n 1. inj_on (get_map S) (set (sorted_list_of_set (fst ` S)))", "using assms"], ["proof (prove)\nusing this:\n  inj_on (get_map S) (fst ` S)\n  is_map S\n  finite S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. inj_on (get_map S) (set (sorted_list_of_set (fst ` S)))", "by (simp add: sorted_list_of_set)"], ["proof (state)\nthis:\n  inj_on (get_map S) (set (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"ordered_map (S - {x}) = map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) =\n    map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x})))", "unfolding ordered_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x}))) =\n    map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x})))", "by simp"], ["proof (state)\nthis:\n  ordered_map (S - {x}) =\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x})))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "also"], ["proof (state)\nthis:\n  ordered_map (S - {x}) =\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x})))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"\\<dots> = map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x}))) =\n    map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x}))", "proof (subst inj_on_image_set_diff)"], ["proof (state)\ngoal (4 subgoals):\n 1. inj_on fst ?C\n 2. S - {x} \\<subseteq> ?C\n 3. {x} \\<subseteq> ?C\n 4. map (get_map (S - {x})) (sorted_list_of_set (fst ` S - fst ` {x})) =\n    map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x}))", "show \"inj_on fst S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst S", "by (rule is_map_fst_inj) fact"], ["proof (state)\nthis:\n  inj_on fst S\n\ngoal (3 subgoals):\n 1. S - {x} \\<subseteq> S\n 2. {x} \\<subseteq> S\n 3. map (get_map (S - {x})) (sorted_list_of_set (fst ` S - fst ` {x})) =\n    map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x}))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. S - {x} \\<subseteq> S\n 2. {x} \\<subseteq> S\n 3. map (get_map (S - {x})) (sorted_list_of_set (fst ` S - fst ` {x})) =\n    map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x}))", "show \"{x} \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<subseteq> S", "using assms"], ["proof (prove)\nusing this:\n  is_map S\n  finite S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. {x} \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  {x} \\<subseteq> S\n\ngoal (2 subgoals):\n 1. S - {x} \\<subseteq> S\n 2. map (get_map (S - {x})) (sorted_list_of_set (fst ` S - fst ` {x})) =\n    map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x}))", "qed auto"], ["proof (state)\nthis:\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x}))) =\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x}))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "also"], ["proof (state)\nthis:\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x}))) =\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x}))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"\\<dots> = map (get_map (S - {x})) (remove1 (fst x) (sorted_list_of_set (fst ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x})) =\n    map (get_map (S - {x})) (remove1 (fst x) (sorted_list_of_set (fst ` S)))", "proof (subst sorted_list_of_set_remove)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (fst ` S)\n 2. map (get_map (S - {x}))\n     (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n    map (get_map (S - {x})) (remove1 (fst x) (sorted_list_of_set (fst ` S)))", "show \"finite (fst ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fst ` S)", "using assms"], ["proof (prove)\nusing this:\n  is_map S\n  finite S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. finite (fst ` S)", "by simp"], ["proof (state)\nthis:\n  finite (fst ` S)\n\ngoal (1 subgoal):\n 1. map (get_map (S - {x}))\n     (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n    map (get_map (S - {x})) (remove1 (fst x) (sorted_list_of_set (fst ` S)))", "qed simp"], ["proof (state)\nthis:\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x})) =\n  map (get_map (S - {x})) (remove1 (fst x) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "also"], ["proof (state)\nthis:\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` S - {fst x})) =\n  map (get_map (S - {x})) (remove1 (fst x) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"\\<dots> = map (get_map S) (remove1 (fst x) (sorted_list_of_set (fst ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (get_map (S - {x}))\n     (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n    map (get_map S) (remove1 (fst x) (sorted_list_of_set (fst ` S)))", "proof (rule list.map_cong0)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set (remove1 (fst x)\n                     (sorted_list_of_set (fst ` S))) \\<Longrightarrow>\n       get_map (S - {x}) z = get_map S z", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set (remove1 (fst x)\n                     (sorted_list_of_set (fst ` S))) \\<Longrightarrow>\n       get_map (S - {x}) z = get_map S z", "assume \"z \\<in> set (remove1 (fst x) (sorted_list_of_set (fst ` S)))\""], ["proof (state)\nthis:\n  z \\<in> set (remove1 (fst x) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set (remove1 (fst x)\n                     (sorted_list_of_set (fst ` S))) \\<Longrightarrow>\n       get_map (S - {x}) z = get_map S z", "with distinct"], ["proof (chain)\npicking this:\n  distinct (sorted_list_of_set (fst ` S))\n  z \\<in> set (remove1 (fst x) (sorted_list_of_set (fst ` S)))", "have \"z \\<noteq> fst x\""], ["proof (prove)\nusing this:\n  distinct (sorted_list_of_set (fst ` S))\n  z \\<in> set (remove1 (fst x) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. z \\<noteq> fst x", "by simp"], ["proof (state)\nthis:\n  z \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set (remove1 (fst x)\n                     (sorted_list_of_set (fst ` S))) \\<Longrightarrow>\n       get_map (S - {x}) z = get_map S z", "thus \"get_map (S - {x}) z = get_map S z\""], ["proof (prove)\nusing this:\n  z \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. get_map (S - {x}) z = get_map S z", "unfolding get_map_def Set.filter_def"], ["proof (prove)\nusing this:\n  z \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. the_elem {a \\<in> S - {x}. case a of (k', uu_) \\<Rightarrow> z = k'} =\n    the_elem {a \\<in> S. case a of (k', uu_) \\<Rightarrow> z = k'}", "by (metis (full_types, lifting) case_prodE fst_conv member_remove remove_def)"], ["proof (state)\nthis:\n  get_map (S - {x}) z = get_map S z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (get_map (S - {x})) (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n  map (get_map S) (remove1 (fst x) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "also"], ["proof (state)\nthis:\n  map (get_map (S - {x})) (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n  map (get_map S) (remove1 (fst x) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"\\<dots> = map (get_map S) (removeAll (fst x) (sorted_list_of_set (fst ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (get_map S) (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n    map (get_map S) (removeAll (fst x) (sorted_list_of_set (fst ` S)))", "using distinct"], ["proof (prove)\nusing this:\n  distinct (sorted_list_of_set (fst ` S))\n\ngoal (1 subgoal):\n 1. map (get_map S) (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n    map (get_map S) (removeAll (fst x) (sorted_list_of_set (fst ` S)))", "by (auto simp: distinct_remove1_removeAll)"], ["proof (state)\nthis:\n  map (get_map S) (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n  map (get_map S) (removeAll (fst x) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "also"], ["proof (state)\nthis:\n  map (get_map S) (remove1 (fst x) (sorted_list_of_set (fst ` S))) =\n  map (get_map S) (removeAll (fst x) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"\\<dots> = removeAll (get_map S (fst x)) (map (get_map S) (sorted_list_of_set (fst ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (get_map S) (removeAll (fst x) (sorted_list_of_set (fst ` S))) =\n    removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S)))", "proof (subst map_removeAll_inj_on)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (get_map S) (insert (fst x) (set (sorted_list_of_set (fst ` S))))\n 2. removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S)))", "have \"fst x \\<in> set (sorted_list_of_set (fst ` S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x \\<in> set (sorted_list_of_set (fst ` S))", "using assms"], ["proof (prove)\nusing this:\n  is_map S\n  finite S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. fst x \\<in> set (sorted_list_of_set (fst ` S))", "by (fastforce simp: sorted_list_of_set)"], ["proof (state)\nthis:\n  fst x \\<in> set (sorted_list_of_set (fst ` S))\n\ngoal (2 subgoals):\n 1. inj_on (get_map S) (insert (fst x) (set (sorted_list_of_set (fst ` S))))\n 2. removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S)))", "hence \"insert (fst x) (set (sorted_list_of_set (fst ` S))) = set (sorted_list_of_set (fst ` S))\""], ["proof (prove)\nusing this:\n  fst x \\<in> set (sorted_list_of_set (fst ` S))\n\ngoal (1 subgoal):\n 1. insert (fst x) (set (sorted_list_of_set (fst ` S))) =\n    set (sorted_list_of_set (fst ` S))", "by auto"], ["proof (state)\nthis:\n  insert (fst x) (set (sorted_list_of_set (fst ` S))) =\n  set (sorted_list_of_set (fst ` S))\n\ngoal (2 subgoals):\n 1. inj_on (get_map S) (insert (fst x) (set (sorted_list_of_set (fst ` S))))\n 2. removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S)))", "with inj"], ["proof (chain)\npicking this:\n  inj_on (get_map S) (set (sorted_list_of_set (fst ` S)))\n  insert (fst x) (set (sorted_list_of_set (fst ` S))) =\n  set (sorted_list_of_set (fst ` S))", "show \"inj_on (get_map S) (insert (fst x) (set (sorted_list_of_set (fst ` S))))\""], ["proof (prove)\nusing this:\n  inj_on (get_map S) (set (sorted_list_of_set (fst ` S)))\n  insert (fst x) (set (sorted_list_of_set (fst ` S))) =\n  set (sorted_list_of_set (fst ` S))\n\ngoal (1 subgoal):\n 1. inj_on (get_map S) (insert (fst x) (set (sorted_list_of_set (fst ` S))))", "by auto"], ["proof (state)\nthis:\n  inj_on (get_map S) (insert (fst x) (set (sorted_list_of_set (fst ` S))))\n\ngoal (1 subgoal):\n 1. removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S)))", "qed simp"], ["proof (state)\nthis:\n  map (get_map S) (removeAll (fst x) (sorted_list_of_set (fst ` S))) =\n  removeAll (get_map S (fst x))\n   (map (get_map S) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "also"], ["proof (state)\nthis:\n  map (get_map S) (removeAll (fst x) (sorted_list_of_set (fst ` S))) =\n  removeAll (get_map S (fst x))\n   (map (get_map S) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"\\<dots> = removeAll x (map (get_map S) (sorted_list_of_set (fst ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    removeAll x (map (get_map S) (sorted_list_of_set (fst ` S)))", "using assms"], ["proof (prove)\nusing this:\n  is_map S\n  finite S\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. removeAll (get_map S (fst x))\n     (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    removeAll x (map (get_map S) (sorted_list_of_set (fst ` S)))", "by (auto simp: get_map_elem[where v = \"snd x\"])"], ["proof (state)\nthis:\n  removeAll (get_map S (fst x))\n   (map (get_map S) (sorted_list_of_set (fst ` S))) =\n  removeAll x (map (get_map S) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "also"], ["proof (state)\nthis:\n  removeAll (get_map S (fst x))\n   (map (get_map S) (sorted_list_of_set (fst ` S))) =\n  removeAll x (map (get_map S) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "have \"\\<dots> = remove1 x (map (get_map S) (sorted_list_of_set (fst ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll x (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    remove1 x (map (get_map S) (sorted_list_of_set (fst ` S)))", "using distinct inj"], ["proof (prove)\nusing this:\n  distinct (sorted_list_of_set (fst ` S))\n  inj_on (get_map S) (set (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. removeAll x (map (get_map S) (sorted_list_of_set (fst ` S))) =\n    remove1 x (map (get_map S) (sorted_list_of_set (fst ` S)))", "by (simp add: distinct_remove1_removeAll distinct_map)"], ["proof (state)\nthis:\n  removeAll x (map (get_map S) (sorted_list_of_set (fst ` S))) =\n  remove1 x (map (get_map S) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "finally"], ["proof (chain)\npicking this:\n  ordered_map (S - {x}) =\n  remove1 x (map (get_map S) (sorted_list_of_set (fst ` S)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ordered_map (S - {x}) =\n  remove1 x (map (get_map S) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. ordered_map (S - {x}) = remove1 x (ordered_map S)", "unfolding ordered_map_def"], ["proof (prove)\nusing this:\n  map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x}))) =\n  remove1 x (map (get_map S) (sorted_list_of_set (fst ` S)))\n\ngoal (1 subgoal):\n 1. map (get_map (S - {x})) (sorted_list_of_set (fst ` (S - {x}))) =\n    remove1 x (map (get_map S) (sorted_list_of_set (fst ` S)))", "."], ["proof (state)\nthis:\n  ordered_map (S - {x}) = remove1 x (ordered_map S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordered_map_list_all:\n  assumes \"finite S\" \"is_map S\"\n  shows \"list_all P (ordered_map S) = Ball S P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P (ordered_map S) = Ball S P", "unfolding list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (ordered_map S)) P = Ball S P", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  is_map S\n\ngoal (1 subgoal):\n 1. Ball (set (ordered_map S)) P = Ball S P", "by (simp add: ordered_map_set_eq)"], ["", "lemma ordered_map_singleton[simp]: \"ordered_map {(x, y)} = [(x, y)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_map {(x, y)} = [(x, y)]", "unfolding ordered_map_def get_map_def Set.filter_def the_elem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            THE xa.\n               {a \\<in> {(x, y)}.\n                case a of (k', uu_) \\<Rightarrow> k = k'} =\n               {xa})\n     (sorted_list_of_set (fst ` {(x, y)})) =\n    [(x, y)]", "by auto"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lift_definition ordered_fmap :: \"('a::linorder \\<times> 'b) fset \\<Rightarrow> ('a \\<times> 'b) list\" is ordered_map"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ordered_fmap_set_eq: \"is_fmap S \\<Longrightarrow> fset_of_list (ordered_fmap S) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap S \\<Longrightarrow> fset_of_list (ordered_fmap S) = S", "by transfer (rule ordered_map_set_eq)"], ["", "lemma ordered_fmap_image:\n  assumes \"is_fmap S\"\n  shows \"map (\\<lambda>(a, b). (a, f a b)) (ordered_fmap S) = ordered_fmap ((\\<lambda>(a, b). (a, f a b)) |`| S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) (ordered_fmap S) =\n    ordered_fmap ((\\<lambda>(a, b). (a, f a b)) |`| S)", "using assms"], ["proof (prove)\nusing this:\n  is_fmap S\n\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) (ordered_fmap S) =\n    ordered_fmap ((\\<lambda>(a, b). (a, f a b)) |`| S)", "by transfer (rule ordered_map_image)"], ["", "lemma ordered_fmap_distinct:\n  assumes \"is_fmap S\"\n  shows \"distinct (map fst (ordered_fmap S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (ordered_fmap S))", "using assms"], ["proof (prove)\nusing this:\n  is_fmap S\n\ngoal (1 subgoal):\n 1. distinct (map fst (ordered_fmap S))", "by transfer (rule ordered_map_distinct)"], ["", "lemma ordered_fmap_keys:\n  assumes \"is_fmap S\"\n  shows \"map fst (ordered_fmap S) = sorted_list_of_fset (fst |`| S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (ordered_fmap S) = sorted_list_of_fset (fst |`| S)", "using assms"], ["proof (prove)\nusing this:\n  is_fmap S\n\ngoal (1 subgoal):\n 1. map fst (ordered_fmap S) = sorted_list_of_fset (fst |`| S)", "by transfer (rule ordered_map_keys)"], ["", "lemma ordered_fmap_sound:\n  assumes \"is_fmap S\" \"(a, b) \\<in> set (ordered_fmap S)\"\n  shows \"(a, b) |\\<in>| S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) |\\<in>| S", "using assms"], ["proof (prove)\nusing this:\n  is_fmap S\n  (a, b) \\<in> set (ordered_fmap S)\n\ngoal (1 subgoal):\n 1. (a, b) |\\<in>| S", "by transfer (rule ordered_map_sound)"], ["", "lemma ordered_fmap_nonempty:\n  assumes \"is_fmap S\" \"ordered_fmap S \\<noteq> []\"\n  shows \"S \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {||}", "using assms"], ["proof (prove)\nusing this:\n  is_fmap S\n  ordered_fmap S \\<noteq> []\n\ngoal (1 subgoal):\n 1. S \\<noteq> {||}", "by transfer (rule ordered_map_nonempty)"], ["", "lemma ordered_fmap_remove:\n  assumes \"is_fmap S\" \"x |\\<in>| S\"\n  shows \"ordered_fmap (S - {| x |}) = remove1 x (ordered_fmap S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_fmap (S |-| {|x|}) = remove1 x (ordered_fmap S)", "using assms"], ["proof (prove)\nusing this:\n  is_fmap S\n  x |\\<in>| S\n\ngoal (1 subgoal):\n 1. ordered_fmap (S |-| {|x|}) = remove1 x (ordered_fmap S)", "by transfer (rule ordered_map_remove)"], ["", "lemma ordered_fmap_list_all:\n  assumes \"is_fmap S\"\n  shows \"list_all P (ordered_fmap S) = fBall S P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P (ordered_fmap S) = fBall S P", "unfolding list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (ordered_fmap S)) P = fBall S P", "using assms"], ["proof (prove)\nusing this:\n  is_fmap S\n\ngoal (1 subgoal):\n 1. Ball (set (ordered_fmap S)) P = fBall S P", "by transfer (simp add: ordered_map_set_eq)"], ["", "lemma ordered_fmap_singleton[simp]: \"ordered_fmap {| (x, y) |} = [(x, y)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_fmap {|(x, y)|} = [(x, y)]", "by transfer' simp"], ["", "end"], ["", "subsection \\<open>Grouping into sets\\<close>"], ["", "definition group_by :: \"('a \\<Rightarrow> ('b \\<times> 'c)) \\<Rightarrow> 'a set \\<Rightarrow> ('b \\<times> 'c set) set\" where\n\"group_by f s = {(fst (f a), {snd (f a')| a'. a' \\<in> s \\<and> fst (f a) = fst (f a') }) |a. a \\<in> s}\""], ["", "lemma group_by_nonempty: \"M \\<noteq> {} \\<Longrightarrow> group_by f M \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<noteq> {} \\<Longrightarrow> group_by f M \\<noteq> {}", "unfolding group_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<noteq> {} \\<Longrightarrow>\n    {(fst (f a),\n      {snd (f a') |a'. a' \\<in> M \\<and> fst (f a) = fst (f a')}) |\n     a. a \\<in> M} \\<noteq>\n    {}", "by blast"], ["", "lemma group_by_nonempty_inner:\n  assumes \"(b, cs) \\<in> group_by f as\"\n  obtains c where \"c \\<in> cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. c \\<in> cs \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (b, cs) \\<in> group_by f as\n\ngoal (1 subgoal):\n 1. (\\<And>c. c \\<in> cs \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding group_by_def"], ["proof (prove)\nusing this:\n  (b, cs)\n  \\<in> {(fst (f a),\n          {snd (f a') |a'. a' \\<in> as \\<and> fst (f a) = fst (f a')}) |\n         a. a \\<in> as}\n\ngoal (1 subgoal):\n 1. (\\<And>c. c \\<in> cs \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["", "lemma group_by_sound: \"c \\<in> cs \\<Longrightarrow> (b, cs) \\<in> group_by f as \\<Longrightarrow> \\<exists>a \\<in> as. f a = (b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> cs; (b, cs) \\<in> group_by f as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>as. f a = (b, c)", "unfolding group_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> cs;\n     (b, cs)\n     \\<in> {(fst (f a),\n             {snd (f a') |a'. a' \\<in> as \\<and> fst (f a) = fst (f a')}) |\n            a. a \\<in> as}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>as. f a = (b, c)", "by force"], ["", "lemma group_byD: \"(b, cs) \\<in> group_by f as \\<Longrightarrow> f a = (b, c) \\<Longrightarrow> a \\<in> as \\<Longrightarrow> c \\<in> cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(b, cs) \\<in> group_by f as; f a = (b, c); a \\<in> as\\<rbrakk>\n    \\<Longrightarrow> c \\<in> cs", "unfolding group_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(b, cs)\n             \\<in> {(fst (f a),\n                     {snd (f a') |a'.\n                      a' \\<in> as \\<and> fst (f a) = fst (f a')}) |\n                    a. a \\<in> as};\n     f a = (b, c); a \\<in> as\\<rbrakk>\n    \\<Longrightarrow> c \\<in> cs", "by force"], ["", "lemma group_byE[elim]:\n  assumes \"c \\<in> cs\" \"(b, cs) \\<in> group_by f as\"\n  obtains a where \"a \\<in> as\" \"f a = (b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> as; f a = (b, c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  c \\<in> cs\n  (b, cs) \\<in> group_by f as\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> as; f a = (b, c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis group_by_sound)"], ["", "lemma group_byE2:\n  assumes \"(b, cs) \\<in> group_by f as\"\n  obtains a where \"a \\<in> as\" \"fst (f a) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> as; fst (f a) = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (b, cs) \\<in> group_by f as\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> as; fst (f a) = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis group_byE group_by_nonempty_inner prod.sel(1))"], ["", "lemma group_by_complete:\n  assumes \"a \\<in> as\"\n  obtains cs where \"(fst (f a), cs) \\<in> group_by f as\" \"snd (f a) \\<in> cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(fst (f a), cs) \\<in> group_by f as;\n         snd (f a) \\<in> cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> as\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(fst (f a), cs) \\<in> group_by f as;\n         snd (f a) \\<in> cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding group_by_def"], ["proof (prove)\nusing this:\n  a \\<in> as\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(fst (f a), cs)\n                 \\<in> {(fst (f a),\n                         {snd (f a') |a'.\n                          a' \\<in> as \\<and> fst (f a) = fst (f a')}) |\n                        a. a \\<in> as};\n         snd (f a) \\<in> cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma group_by_single: \"(a, x) \\<in> group_by f s \\<Longrightarrow> (a, y) \\<in> group_by f s \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, x) \\<in> group_by f s; (a, y) \\<in> group_by f s\\<rbrakk>\n    \\<Longrightarrow> x = y", "unfolding group_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, x)\n             \\<in> {(fst (f a),\n                     {snd (f a') |a'.\n                      a' \\<in> s \\<and> fst (f a) = fst (f a')}) |\n                    a. a \\<in> s};\n     (a, y)\n     \\<in> {(fst (f a),\n             {snd (f a') |a'. a' \\<in> s \\<and> fst (f a) = fst (f a')}) |\n            a. a \\<in> s}\\<rbrakk>\n    \\<Longrightarrow> x = y", "by force"], ["", "definition group_by' :: \"('a \\<Rightarrow> ('b \\<times> 'c)) \\<Rightarrow> 'a set \\<Rightarrow> ('b \\<times> 'c set) set\" where\n\"group_by' f s = (\\<lambda>a. let (fa, _) = f a in (fa, (snd \\<circ> f) ` Set.filter (\\<lambda>a'. fa = fst (f a')) s)) ` s\""], ["", "lemma group_by'_eq[code, code_unfold]: \"group_by = group_by'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_by = group_by'", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. group_by x xa = group_by' x xa", "unfolding group_by_def group_by'_def Set.filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       {(fst (x a),\n         {snd (x a') |a'. a' \\<in> xa \\<and> fst (x a) = fst (x a')}) |\n        a. a \\<in> xa} =\n       (\\<lambda>a.\n           let (fa, uu_) = x a\n           in (fa, (snd \\<circ> x) ` {a \\<in> xa. fa = fst (x a)})) `\n       xa", "by (auto simp: Let_def split_beta)"], ["", "lemma is_map_group_by[intro]: \"is_map (group_by f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map (group_by f M)", "unfolding group_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map\n     {(fst (f a),\n       {snd (f a') |a'. a' \\<in> M \\<and> fst (f a) = fst (f a')}) |\n      a. a \\<in> M}", "by force"], ["", "lemma group_by_keys[simp]: \"fst ` group_by f M = fst ` f ` M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` group_by f M = fst ` f ` M", "unfolding group_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    {(fst (f a),\n      {snd (f a') |a'. a' \\<in> M \\<and> fst (f a) = fst (f a')}) |\n     a. a \\<in> M} =\n    fst ` f ` M", "by force"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lift_definition fgroup_by :: \"('a \\<Rightarrow> ('b \\<times> 'c)) \\<Rightarrow> 'a fset \\<Rightarrow> ('b \\<times> 'c fset) fset\" is group_by"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       finite set \\<Longrightarrow>\n       inf (\\<lambda>A. Ball A (pred_prod top finite)) finite\n        (group_by fun set)", "unfolding inf_apply inf_bool_def group_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       finite set \\<Longrightarrow>\n       Ball\n        {(fst (fun a),\n          {snd (fun a') |a'.\n           a' \\<in> set \\<and> fst (fun a) = fst (fun a')}) |\n         a. a \\<in> set}\n        (pred_prod top finite) \\<and>\n       finite\n        {(fst (fun a),\n          {snd (fun a') |a'.\n           a' \\<in> set \\<and> fst (fun a) = fst (fun a')}) |\n         a. a \\<in> set}", "by auto"], ["", "lemma fgroup_by_nonempty: \"M \\<noteq> {||} \\<Longrightarrow> fgroup_by f M \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<noteq> {||} \\<Longrightarrow> fgroup_by f M \\<noteq> {||}", "by transfer' (rule group_by_nonempty)"], ["", "lemma fgroup_by_nonempty_inner:\n  assumes \"(b, cs) |\\<in>| fgroup_by f as\"\n  obtains c where \"c |\\<in>| cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. c |\\<in>| cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (b, cs) |\\<in>| fgroup_by f as\n\ngoal (1 subgoal):\n 1. (\\<And>c. c |\\<in>| cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer' (rule group_by_nonempty_inner)"], ["", "lemma fgroup_by_sound: \"c |\\<in>| cs \\<Longrightarrow> (b, cs) |\\<in>| fgroup_by f as \\<Longrightarrow> fBex as (\\<lambda>a. f a = (b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c |\\<in>| cs; (b, cs) |\\<in>| fgroup_by f as\\<rbrakk>\n    \\<Longrightarrow> fBex as (\\<lambda>a. f a = (b, c))", "by transfer (metis group_by_sound)"], ["", "lemma fgroup_byD: \"(b, cs) |\\<in>| fgroup_by f as \\<Longrightarrow> f a = (b, c) \\<Longrightarrow> a |\\<in>| as \\<Longrightarrow> c |\\<in>| cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(b, cs) |\\<in>| fgroup_by f as; f a = (b, c);\n     a |\\<in>| as\\<rbrakk>\n    \\<Longrightarrow> c |\\<in>| cs", "by transfer' (metis group_byD)"], ["", "lemma fgroup_byE[elim]:\n  assumes \"c |\\<in>| cs\" \"(b, cs) |\\<in>| fgroup_by f as\"\n  obtains a where \"a |\\<in>| as\" \"f a = (b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a |\\<in>| as; f a = (b, c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  (b, cs) |\\<in>| fgroup_by f as\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a |\\<in>| as; f a = (b, c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer' auto"], ["", "lemma fgroup_byE2:\n  assumes \"(b, cs) |\\<in>| fgroup_by f as\"\n  obtains a where \"a |\\<in>| as\" \"fst (f a) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a |\\<in>| as; fst (f a) = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (b, cs) |\\<in>| fgroup_by f as\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a |\\<in>| as; fst (f a) = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer' (rule group_byE2)"], ["", "lemma fgroup_by_complete:\n  assumes \"a |\\<in>| as\"\n  obtains cs where \"(fst (f a), cs) |\\<in>| fgroup_by f as\" \"snd (f a) |\\<in>| cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(fst (f a), cs) |\\<in>| fgroup_by f as;\n         snd (f a) |\\<in>| cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a |\\<in>| as\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(fst (f a), cs) |\\<in>| fgroup_by f as;\n         snd (f a) |\\<in>| cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix a :: 'a and as :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix f :: \"'a \\<Rightarrow> ('c \\<times> 'b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix thesis"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume as: \"finite as\""], ["proof (state)\nthis:\n  finite as\n\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"a \\<in> as\""], ["proof (state)\nthis:\n  a \\<in> as\n\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  a \\<in> as", "obtain cs where cs: \"(fst (f a), cs) \\<in> group_by f as\" \"snd (f a) \\<in> cs\""], ["proof (prove)\nusing this:\n  a \\<in> as\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(fst (f a), cs) \\<in> group_by f as;\n         snd (f a) \\<in> cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis group_by_complete)"], ["proof (state)\nthis:\n  (fst (f a), cs) \\<in> group_by f as\n  snd (f a) \\<in> cs\n\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"finite cs\""], ["proof (prove)\nusing this:\n  (fst (f a), cs) \\<in> group_by f as\n  snd (f a) \\<in> cs\n\ngoal (1 subgoal):\n 1. finite cs", "unfolding group_by_def"], ["proof (prove)\nusing this:\n  (fst (f a), cs)\n  \\<in> {(fst (f a),\n          {snd (f a') |a'. a' \\<in> as \\<and> fst (f a) = fst (f a')}) |\n         a. a \\<in> as}\n  snd (f a) \\<in> cs\n\ngoal (1 subgoal):\n 1. finite cs", "using as"], ["proof (prove)\nusing this:\n  (fst (f a), cs)\n  \\<in> {(fst (f a),\n          {snd (f a') |a'. a' \\<in> as \\<and> fst (f a) = fst (f a')}) |\n         a. a \\<in> as}\n  snd (f a) \\<in> cs\n  finite as\n\ngoal (1 subgoal):\n 1. finite cs", "by force"], ["proof (state)\nthis:\n  finite cs\n\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume thesis: \"\\<And>cs. finite cs \\<Longrightarrow> (fst (f a), cs) \\<in> group_by f as \\<Longrightarrow> snd (f a) \\<in> cs \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>finite ?cs; (fst (f a), ?cs) \\<in> group_by f as;\n   snd (f a) \\<in> ?cs\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>f a as thesis.\n       \\<lbrakk>finite as;\n        \\<And>cs.\n           \\<lbrakk>finite cs; (fst (f a), cs) \\<in> group_by f as;\n            snd (f a) \\<in> cs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        a \\<in> as\\<rbrakk>\n       \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule thesis) fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgroup_by_single: \"(a, x) |\\<in>| fgroup_by f s \\<Longrightarrow> (a, y) |\\<in>| fgroup_by f s \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, x) |\\<in>| fgroup_by f s;\n     (a, y) |\\<in>| fgroup_by f s\\<rbrakk>\n    \\<Longrightarrow> x = y", "by transfer (metis group_by_single)"], ["", "definition fgroup_by' :: \"('a \\<Rightarrow> ('b \\<times> 'c)) \\<Rightarrow> 'a fset \\<Rightarrow> ('b \\<times> 'c fset) fset\" where\n\"fgroup_by' f s = fcompress ((\\<lambda>a. let (fa, _) = f a in (fa, (snd \\<circ> f) |`| ffilter (\\<lambda>a'. fa = fst (f a')) s)) |`| s)\""], ["", "lemma fgroup_by'_eq[code, code_unfold]: \"fgroup_by = fgroup_by'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgroup_by = fgroup_by'", "unfolding fgroup_by'_def[abs_def] fcompress_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgroup_by =\n    (\\<lambda>f s.\n        (\\<lambda>a.\n            let (fa, uu_) = f a\n            in (fa,\n                (snd \\<circ> f) |`|\n                ffilter (\\<lambda>a'. fa = fst (f a')) s)) |`|\n        s)", "by transfer' (metis group_by'_def group_by'_eq)"], ["", "lemma is_fmap_group_by[intro]: \"is_fmap (fgroup_by f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap (fgroup_by f M)", "by transfer' (rule is_map_group_by)"], ["", "lemma fgroup_by_keys[simp]: \"fst |`| fgroup_by f M = fst |`| f |`| M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| fgroup_by f M = fst |`| f |`| M", "by transfer' (rule group_by_keys)"], ["", "end"], ["", "subsection \\<open>Singletons\\<close>"], ["", "lemma singleton_set_holds:\n  assumes \"\\<forall>x \\<in> M. \\<forall>y \\<in> M. f x = f y\" \"m \\<in> M\"\n  shows \"f m = the_elem (f ` M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m = the_elem (f ` M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f m = the_elem (f ` M)", "let ?n = \"the_elem (f ` M)\""], ["proof (state)\ngoal (1 subgoal):\n 1. f m = the_elem (f ` M)", "have \"f ` M = {f m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` M = {f m}", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>M. \\<forall>y\\<in>M. f x = f y\n  m \\<in> M\n\ngoal (1 subgoal):\n 1. f ` M = {f m}", "by blast"], ["proof (state)\nthis:\n  f ` M = {f m}\n\ngoal (1 subgoal):\n 1. f m = the_elem (f ` M)", "hence \"?n = (THE n. {f m} = {n})\""], ["proof (prove)\nusing this:\n  f ` M = {f m}\n\ngoal (1 subgoal):\n 1. the_elem (f ` M) = (THE n. {f m} = {n})", "unfolding the_elem_def"], ["proof (prove)\nusing this:\n  f ` M = {f m}\n\ngoal (1 subgoal):\n 1. (THE x. f ` M = {x}) = (THE n. {f m} = {n})", "by simp"], ["proof (state)\nthis:\n  the_elem (f ` M) = (THE n. {f m} = {n})\n\ngoal (1 subgoal):\n 1. f m = the_elem (f ` M)", "thus ?thesis"], ["proof (prove)\nusing this:\n  the_elem (f ` M) = (THE n. {f m} = {n})\n\ngoal (1 subgoal):\n 1. f m = the_elem (f ` M)", "by auto"], ["proof (state)\nthis:\n  f m = the_elem (f ` M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_set_is:\n  assumes \"\\<forall>x \\<in> M. x = y\" \"M \\<noteq> {}\"\n  shows \"M = {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = {y}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>M. x = y\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. M = {y}", "by auto"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lemma singleton_fset_holds:\n  assumes \"fBall M (\\<lambda>x. fBall M (\\<lambda>y. f x = f y))\" \"m |\\<in>| M\"\n  shows \"f m = fthe_elem (f |`| M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m = fthe_elem (f |`| M)", "using assms"], ["proof (prove)\nusing this:\n  fBall M (\\<lambda>x. fBall M (\\<lambda>y. f x = f y))\n  m |\\<in>| M\n\ngoal (1 subgoal):\n 1. f m = fthe_elem (f |`| M)", "by transfer (rule singleton_set_holds)"], ["", "lemma singleton_fset_is:\n  assumes \"fBall M (\\<lambda>x. x = y)\" \"M \\<noteq> {||}\"\n  shows \"M = {| y |}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = {|y|}", "using assms"], ["proof (prove)\nusing this:\n  fBall M (\\<lambda>x. x = y)\n  M \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. M = {|y|}", "by transfer' (rule singleton_set_is)"], ["", "end"], ["", "subsection \\<open>Pairwise relations\\<close>"], ["", "definition pairwise :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n\"pairwise P M \\<longleftrightarrow> (\\<forall>m \\<in> M. \\<forall>n \\<in> M. P m n)\""], ["", "lemma pairwiseI[intro!]:\n  assumes \"\\<And>m n. m \\<in> M \\<Longrightarrow> n \\<in> M \\<Longrightarrow> P m n\"\n  shows \"pairwise P M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Compiler_Utils.pairwise P M", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m \\<in> M; ?n \\<in> M\\<rbrakk> \\<Longrightarrow> P ?m ?n\n\ngoal (1 subgoal):\n 1. Compiler_Utils.pairwise P M", "unfolding pairwise_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m \\<in> M; ?n \\<in> M\\<rbrakk> \\<Longrightarrow> P ?m ?n\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>M. Ball M (P m)", "by simp"], ["", "lemma pairwiseD[dest]:\n  assumes \"pairwise P M\" \"m \\<in> M\" \"n \\<in> M\"\n  shows \"P m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P m n", "using assms"], ["proof (prove)\nusing this:\n  Compiler_Utils.pairwise P M\n  m \\<in> M\n  n \\<in> M\n\ngoal (1 subgoal):\n 1. P m n", "unfolding pairwise_def"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>M. Ball M (P m)\n  m \\<in> M\n  n \\<in> M\n\ngoal (1 subgoal):\n 1. P m n", "by simp"], ["", "lemma pairwise_subset: \"pairwise P M \\<Longrightarrow> N \\<subseteq> M \\<Longrightarrow> pairwise P N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Compiler_Utils.pairwise P M; N \\<subseteq> M\\<rbrakk>\n    \\<Longrightarrow> Compiler_Utils.pairwise P N", "unfolding pairwise_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m\\<in>M. Ball M (P m); N \\<subseteq> M\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m\\<in>N. Ball N (P m)", "by blast"], ["", "lemma pairwise_weaken: \"pairwise P M \\<Longrightarrow> (\\<And>x y. x \\<in> M \\<Longrightarrow> y \\<in> M \\<Longrightarrow> P x y \\<Longrightarrow> Q x y) \\<Longrightarrow> pairwise Q M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Compiler_Utils.pairwise P M;\n     \\<And>x y.\n        \\<lbrakk>x \\<in> M; y \\<in> M; P x y\\<rbrakk>\n        \\<Longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> Compiler_Utils.pairwise Q M", "by auto"], ["", "lemma pairwise_image[simp]: \"pairwise P (f ` M) = pairwise (\\<lambda>x y. P (f x) (f y)) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Compiler_Utils.pairwise P (f ` M) =\n    Compiler_Utils.pairwise (\\<lambda>x y. P (f x) (f y)) M", "by auto"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lift_definition fpairwise :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a fset \\<Rightarrow> bool\" is pairwise"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma fpairwise_alt_def[code]: \"fpairwise P M \\<longleftrightarrow> fBall M (\\<lambda>m. fBall M (\\<lambda>n. P m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fpairwise P M = fBall M (\\<lambda>m. fBall M (P m))", "by transfer' auto"], ["", "lemma fpairwiseI[intro!]:\n  assumes \"\\<And>m n. m |\\<in>| M \\<Longrightarrow> n |\\<in>| M \\<Longrightarrow> P m n\"\n  shows \"fpairwise P M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fpairwise P M", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m |\\<in>| M; ?n |\\<in>| M\\<rbrakk> \\<Longrightarrow> P ?m ?n\n\ngoal (1 subgoal):\n 1. fpairwise P M", "unfolding fpairwise_alt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m |\\<in>| M; ?n |\\<in>| M\\<rbrakk> \\<Longrightarrow> P ?m ?n\n\ngoal (1 subgoal):\n 1. fBall M (\\<lambda>m. fBall M (P m))", "by blast"], ["", "lemma fpairwiseD:\n  assumes \"fpairwise P M\" \"m |\\<in>| M\" \"n |\\<in>| M\"\n  shows \"P m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P m n", "using assms"], ["proof (prove)\nusing this:\n  fpairwise P M\n  m |\\<in>| M\n  n |\\<in>| M\n\ngoal (1 subgoal):\n 1. P m n", "unfolding fpairwise_alt_def"], ["proof (prove)\nusing this:\n  fBall M (\\<lambda>m. fBall M (P m))\n  m |\\<in>| M\n  n |\\<in>| M\n\ngoal (1 subgoal):\n 1. P m n", "by auto"], ["", "lemma fpairwise_image[simp]: \"fpairwise P (f |`| M) = fpairwise (\\<lambda>x y. P (f x) (f y)) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fpairwise P (f |`| M) = fpairwise (\\<lambda>x y. P (f x) (f y)) M", "by (auto dest: fpairwiseD)"], ["", "end"], ["", "lemma fpairwise_subset: \"fpairwise P M \\<Longrightarrow> N |\\<subseteq>| M \\<Longrightarrow> fpairwise P N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fpairwise P M; N |\\<subseteq>| M\\<rbrakk>\n    \\<Longrightarrow> fpairwise P N", "unfolding fpairwise_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fBall M (\\<lambda>m. fBall M (P m)); N |\\<subseteq>| M\\<rbrakk>\n    \\<Longrightarrow> fBall N (\\<lambda>m. fBall N (P m))", "by auto"], ["", "lemma fpairwise_weaken: \"fpairwise P M \\<Longrightarrow> (\\<And>x y. x |\\<in>| M \\<Longrightarrow> y |\\<in>| M \\<Longrightarrow> P x y \\<Longrightarrow> Q x y) \\<Longrightarrow> fpairwise Q M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fpairwise P M;\n     \\<And>x y.\n        \\<lbrakk>x |\\<in>| M; y |\\<in>| M; P x y\\<rbrakk>\n        \\<Longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> fpairwise Q M", "unfolding fpairwise_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fBall M (\\<lambda>m. fBall M (P m));\n     \\<And>x y.\n        \\<lbrakk>x |\\<in>| M; y |\\<in>| M; P x y\\<rbrakk>\n        \\<Longrightarrow> Q x y\\<rbrakk>\n    \\<Longrightarrow> fBall M (\\<lambda>m. fBall M (Q m))", "by auto"], ["", "subsection \\<open>Relators\\<close>"], ["", "lemma rel_set_eq_eq: \"rel_set (=) A B \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set (=) A B \\<Longrightarrow> A = B", "unfolding rel_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>A. Bex B ((=) x)) \\<and>\n    (\\<forall>y\\<in>B. \\<exists>x\\<in>A. x = y) \\<Longrightarrow>\n    A = B", "by fast"], ["", "lemma rel_set_image:\n  assumes \"rel_set P A B\"\n  assumes \"\\<And>a b. a \\<in> A \\<Longrightarrow> b \\<in> B \\<Longrightarrow> P a b \\<Longrightarrow> Q (f a) (g b)\"\n  shows \"rel_set Q (f ` A) (g ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set Q (f ` A) (g ` B)", "using assms"], ["proof (prove)\nusing this:\n  rel_set P A B\n  \\<lbrakk>?a \\<in> A; ?b \\<in> B; P ?a ?b\\<rbrakk>\n  \\<Longrightarrow> Q (f ?a) (g ?b)\n\ngoal (1 subgoal):\n 1. rel_set Q (f ` A) (g ` B)", "by (force intro!: rel_setI dest: rel_setD1 rel_setD2)"], ["", "corollary rel_set_image_eq:\n  assumes \"rel_set P A B\"\n  assumes \"\\<And>a b. a \\<in> A \\<Longrightarrow> b \\<in> B \\<Longrightarrow> P a b \\<Longrightarrow> f a = g b\"\n  shows \"f ` A = g ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` A = g ` B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` A = g ` B", "have \"rel_set (=) (f ` A) (g ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set (=) (f ` A) (g ` B)", "by (rule rel_set_image) fact+"], ["proof (state)\nthis:\n  rel_set (=) (f ` A) (g ` B)\n\ngoal (1 subgoal):\n 1. f ` A = g ` B", "thus ?thesis"], ["proof (prove)\nusing this:\n  rel_set (=) (f ` A) (g ` B)\n\ngoal (1 subgoal):\n 1. f ` A = g ` B", "by (rule rel_set_eq_eq)"], ["proof (state)\nthis:\n  f ` A = g ` B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_set_refl_strong[intro]:\n  assumes \"\\<And>x. x \\<in> S \\<Longrightarrow> P x x\"\n  shows \"rel_set P S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set P S S", "proof (rule rel_setI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> \\<exists>y\\<in>S. P x y\n 2. \\<And>y. y \\<in> S \\<Longrightarrow> \\<exists>x\\<in>S. P x y", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> \\<exists>y\\<in>S. P x y\n 2. \\<And>y. y \\<in> S \\<Longrightarrow> \\<exists>x\\<in>S. P x y", "assume \"x \\<in> S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> \\<exists>y\\<in>S. P x y\n 2. \\<And>y. y \\<in> S \\<Longrightarrow> \\<exists>x\\<in>S. P x y", "thus \"\\<exists>y \\<in> S. P x y\""], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. P x y", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> S\n  ?x \\<in> S \\<Longrightarrow> P ?x ?x\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. P x y", "by blast"], ["proof (state)\nthis:\n  \\<exists>y\\<in>S. P x y\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> S \\<Longrightarrow> \\<exists>x\\<in>S. P x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> S \\<Longrightarrow> \\<exists>x\\<in>S. P x y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> S \\<Longrightarrow> \\<exists>x\\<in>S. P x y", "assume \"y \\<in> S\""], ["proof (state)\nthis:\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> S \\<Longrightarrow> \\<exists>x\\<in>S. P x y", "thus \"\\<exists>x \\<in> S. P x y\""], ["proof (prove)\nusing this:\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. P x y", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> S\n  ?x \\<in> S \\<Longrightarrow> P ?x ?x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. P x y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>S. P x y\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lemma rel_fsetE1:\n  assumes \"rel_fset P M N\" \"x |\\<in>| M\"\n  obtains y where \"y |\\<in>| N\" \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y |\\<in>| N; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  rel_fset P M N\n  x |\\<in>| M\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y |\\<in>| N; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer' (auto dest: rel_setD1)"], ["", "lemma rel_fsetE2:\n  assumes \"rel_fset P M N\" \"y |\\<in>| N\"\n  obtains x where \"x |\\<in>| M\" \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x |\\<in>| M; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  rel_fset P M N\n  y |\\<in>| N\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x |\\<in>| M; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer' (auto dest: rel_setD2)"], ["", "lemma rel_fsetI:\n  assumes \"\\<And>x. x |\\<in>| A \\<Longrightarrow> fBex B (R x)\" \"\\<And>y. y |\\<in>| B \\<Longrightarrow> fBex A (\\<lambda>x. R x y)\"\n  shows \"rel_fset R A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fset R A B", "using assms"], ["proof (prove)\nusing this:\n  ?x |\\<in>| A \\<Longrightarrow> fBex B (R ?x)\n  ?y |\\<in>| B \\<Longrightarrow> fBex A (\\<lambda>x. R x ?y)\n\ngoal (1 subgoal):\n 1. rel_fset R A B", "by transfer' (rule rel_setI)"], ["", "lemma rel_fset_image:\n  assumes \"rel_fset P A B\"\n  assumes \"\\<And>a b. a |\\<in>| A \\<Longrightarrow> b |\\<in>| B \\<Longrightarrow> P a b \\<Longrightarrow> Q (f a) (g b)\"\n  shows \"rel_fset Q (f |`| A) (g |`| B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fset Q (f |`| A) (g |`| B)", "using assms"], ["proof (prove)\nusing this:\n  rel_fset P A B\n  \\<lbrakk>?a |\\<in>| A; ?b |\\<in>| B; P ?a ?b\\<rbrakk>\n  \\<Longrightarrow> Q (f ?a) (g ?b)\n\ngoal (1 subgoal):\n 1. rel_fset Q (f |`| A) (g |`| B)", "by transfer' (rule rel_set_image)"], ["", "corollary rel_fset_image_eq:\n  assumes \"rel_fset P A B\"\n  assumes \"\\<And>a b. a |\\<in>| A \\<Longrightarrow> b |\\<in>| B \\<Longrightarrow> P a b \\<Longrightarrow> f a = g b\"\n  shows \"f |`| A = g |`| B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f |`| A = g |`| B", "using assms"], ["proof (prove)\nusing this:\n  rel_fset P A B\n  \\<lbrakk>?a |\\<in>| A; ?b |\\<in>| B; P ?a ?b\\<rbrakk>\n  \\<Longrightarrow> f ?a = g ?b\n\ngoal (1 subgoal):\n 1. f |`| A = g |`| B", "by transfer' (rule rel_set_image_eq)"], ["", "lemma rel_fset_refl_strong:\n  assumes \"\\<And>x. x |\\<in>| S \\<Longrightarrow> P x x\"\n  shows \"rel_fset P S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fset P S S", "using assms"], ["proof (prove)\nusing this:\n  ?x |\\<in>| S \\<Longrightarrow> P ?x ?x\n\ngoal (1 subgoal):\n 1. rel_fset P S S", "by transfer' (rule rel_set_refl_strong)"], ["", "end"], ["", "subsection \\<open>Selecting values from keys\\<close>"], ["", "definition select :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 'a set \\<Rightarrow> 'b set\" where\n\"select f S = {z|z. \\<exists>x \\<in> S. f x = Some z}\""], ["", "lemma select_finite:\n  assumes \"finite S\"\n  shows \"finite (select f S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (select f S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (select f S)", "have \"finite (f ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f ` S)", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite (f ` S)", "by simp"], ["proof (state)\nthis:\n  finite (f ` S)\n\ngoal (1 subgoal):\n 1. finite (select f S)", "moreover"], ["proof (state)\nthis:\n  finite (f ` S)\n\ngoal (1 subgoal):\n 1. finite (select f S)", "have \"Some ` (select f S) \\<subseteq> f ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some ` select f S \\<subseteq> f ` S", "unfolding select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some ` {z |z. \\<exists>x\\<in>S. f x = Some z} \\<subseteq> f ` S", "by force"], ["proof (state)\nthis:\n  Some ` select f S \\<subseteq> f ` S\n\ngoal (1 subgoal):\n 1. finite (select f S)", "ultimately"], ["proof (chain)\npicking this:\n  finite (f ` S)\n  Some ` select f S \\<subseteq> f ` S", "have \"finite (Some ` select f S)\""], ["proof (prove)\nusing this:\n  finite (f ` S)\n  Some ` select f S \\<subseteq> f ` S\n\ngoal (1 subgoal):\n 1. finite (Some ` select f S)", "by (rule rev_finite_subset)"], ["proof (state)\nthis:\n  finite (Some ` select f S)\n\ngoal (1 subgoal):\n 1. finite (select f S)", "moreover"], ["proof (state)\nthis:\n  finite (Some ` select f S)\n\ngoal (1 subgoal):\n 1. finite (select f S)", "have \"\\<And>S. inj_on Some S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S. inj_on Some S", "by simp"], ["proof (state)\nthis:\n  inj_on Some ?S\n\ngoal (1 subgoal):\n 1. finite (select f S)", "ultimately"], ["proof (chain)\npicking this:\n  finite (Some ` select f S)\n  inj_on Some ?S", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (Some ` select f S)\n  inj_on Some ?S\n\ngoal (1 subgoal):\n 1. finite (select f S)", "by (rule finite_imageD)"], ["proof (state)\nthis:\n  finite (select f S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma select_memberI: \"x \\<in> S \\<Longrightarrow> f x = Some y \\<Longrightarrow> y \\<in> select f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; f x = Some y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> select f S", "unfolding select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> S; f x = Some y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> {z |z. \\<exists>x\\<in>S. f x = Some z}", "by blast"], ["", "lemma select_memberE:\n  assumes \"y \\<in> select f S\"\n  obtains x where \"x \\<in> S\" \"f x = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; f x = Some y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> select f S\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; f x = Some y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding select_def"], ["proof (prove)\nusing this:\n  y \\<in> {z |z. \\<exists>x\\<in>S. f x = Some z}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; f x = Some y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lift_definition fselect :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 'a fset \\<Rightarrow> 'b fset\" is select"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun set. finite set \\<Longrightarrow> finite (select fun set)", "by (rule select_finite)"], ["", "lemma fselect_memberI[intro]: \"x |\\<in>| S \\<Longrightarrow> f x = Some y \\<Longrightarrow> y |\\<in>| fselect f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| S; f x = Some y\\<rbrakk>\n    \\<Longrightarrow> y |\\<in>| fselect f S", "by transfer' (rule select_memberI)"], ["", "lemma fselect_memberE[elim]:\n  assumes \"y |\\<in>| fselect f S\"\n  obtains x where \"x |\\<in>| S\" \"f x = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x |\\<in>| S; f x = Some y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  y |\\<in>| fselect f S\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x |\\<in>| S; f x = Some y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer' (rule select_memberE)"], ["", "end"], ["", "subsection \\<open>Miscellaneous\\<close>"], ["", "lemma set_of_list_singletonE:\n  assumes \"set xs = {x}\" \"distinct xs\"\n  shows \"xs = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [x]", "using assms"], ["proof (prove)\nusing this:\n  set xs = {x}\n  distinct xs\n\ngoal (1 subgoal):\n 1. xs = [x]", "by (metis distinct.simps(2) empty_iff insertI1 insert_ident list.simps(15) neq_Nil_conv set_empty2 singletonD)"], ["", "lemma fset_of_list_singletonE:\n  assumes \"fset_of_list xs = {|x|}\" \"distinct xs\"\n  shows \"xs = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [x]", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [x]", "using assms"], ["proof (prove)\nusing this:\n  fset_of_list xs = {|x|}\n  distinct xs\n\ngoal (1 subgoal):\n 1. xs = [x]", "by transfer (rule set_of_list_singletonE)"], ["", "section \\<open>Finite maps\\<close>"], ["", "definition fmlookup_default :: \"('a, 'b) fmap \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\" where\n\"fmlookup_default m f x = (case fmlookup m x of None \\<Rightarrow> f x | Some b \\<Rightarrow> b)\""], ["", "lemma fmpred_foldl[intro]:\n  assumes \"fmpred P init\" \"\\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x\"\n  shows \"fmpred P (foldl (++\\<^sub>f) init xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred P (foldl (++\\<^sub>f) init xs)", "using assms"], ["proof (prove)\nusing this:\n  fmpred P init\n  ?x \\<in> set xs \\<Longrightarrow> fmpred P ?x\n\ngoal (1 subgoal):\n 1. fmpred P (foldl (++\\<^sub>f) init xs)", "proof (induction xs arbitrary: init)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>fmpred P init;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> fmpred P x\\<rbrakk>\n       \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init [])\n 2. \\<And>a xs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>fmpred P init;\n                    \\<And>x.\n                       x \\<in> set xs \\<Longrightarrow> fmpred P x\\<rbrakk>\n                   \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init xs);\n        fmpred P init;\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> fmpred P x\\<rbrakk>\n       \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>fmpred P ?init;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x\\<rbrakk>\n  \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) ?init xs)\n  fmpred P init\n  ?x \\<in> set (x # xs) \\<Longrightarrow> fmpred P ?x\n\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>fmpred P init;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> fmpred P x\\<rbrakk>\n       \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init [])\n 2. \\<And>a xs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>fmpred P init;\n                    \\<And>x.\n                       x \\<in> set xs \\<Longrightarrow> fmpred P x\\<rbrakk>\n                   \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init xs);\n        fmpred P init;\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> fmpred P x\\<rbrakk>\n       \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init (a # xs))", "have \"fmpred P (foldl (++\\<^sub>f) (init ++\\<^sub>f x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred P (foldl (++\\<^sub>f) (init ++\\<^sub>f x) xs)", "proof (rule Cons)"], ["proof (state)\ngoal (2 subgoals):\n 1. fmpred P (init ++\\<^sub>f x)\n 2. \\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x", "show \"fmpred P (init ++\\<^sub>f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred P (init ++\\<^sub>f x)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmpred P ?init;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x\\<rbrakk>\n  \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) ?init xs)\n  fmpred P init\n  ?x \\<in> set (x # xs) \\<Longrightarrow> fmpred P ?x\n\ngoal (1 subgoal):\n 1. fmpred P (init ++\\<^sub>f x)", "by auto"], ["proof (state)\nthis:\n  fmpred P (init ++\\<^sub>f x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x", "thus \"fmpred P x\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. fmpred P x", "using Cons"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  \\<lbrakk>fmpred P ?init;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> fmpred P x\\<rbrakk>\n  \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) ?init xs)\n  fmpred P init\n  ?x \\<in> set (x__ # xs) \\<Longrightarrow> fmpred P ?x\n\ngoal (1 subgoal):\n 1. fmpred P x", "by auto"], ["proof (state)\nthis:\n  fmpred P x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmpred P (foldl (++\\<^sub>f) (init ++\\<^sub>f x) xs)\n\ngoal (2 subgoals):\n 1. \\<And>init.\n       \\<lbrakk>fmpred P init;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> fmpred P x\\<rbrakk>\n       \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init [])\n 2. \\<And>a xs init.\n       \\<lbrakk>\\<And>init.\n                   \\<lbrakk>fmpred P init;\n                    \\<And>x.\n                       x \\<in> set xs \\<Longrightarrow> fmpred P x\\<rbrakk>\n                   \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init xs);\n        fmpred P init;\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> fmpred P x\\<rbrakk>\n       \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  fmpred P (foldl (++\\<^sub>f) (init ++\\<^sub>f x) xs)\n\ngoal (1 subgoal):\n 1. fmpred P (foldl (++\\<^sub>f) init (x # xs))", "by simp"], ["proof (state)\nthis:\n  fmpred P (foldl (++\\<^sub>f) init (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>init.\n       \\<lbrakk>fmpred P init;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> fmpred P x\\<rbrakk>\n       \\<Longrightarrow> fmpred P (foldl (++\\<^sub>f) init [])", "qed auto"], ["", "lemma fmdom_foldl_add: \"fmdom (foldl (++\\<^sub>f) m ns) = fmdom m |\\<union>| ffUnion (fmdom |`| fset_of_list ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom (foldl (++\\<^sub>f) m ns) =\n    fmdom m |\\<union>| ffUnion (fmdom |`| fset_of_list ns)", "by (induction ns arbitrary: m) auto"], ["", "lemma fmimage_fmmap[simp]: \"fmimage (fmmap f m) S = f |`| fmimage m S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmimage (fmmap f m) S = f |`| fmimage m S", "including fmap.lifting fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmimage (fmmap f m) S = f |`| fmimage m S", "by transfer' auto"], ["", "lemma fmmap_total:\n  assumes \"\\<And>k v. fmlookup m k = Some v \\<Longrightarrow> (\\<exists>v'. f v' = v)\"\n  obtains m' where \"m = fmmap f m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m'. m = fmmap f m' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule that[of \"fmmap (inv f) m\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m'. m = fmmap f m' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    m = fmmap f (fmmap (inv f) m)", "unfolding fmap.map_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m'. m = fmmap f m' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    m = fmmap (f \\<circ> inv f) m", "apply (subst fmap.map_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m'. m = fmmap f m' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmmap id m = fmmap (f \\<circ> inv f) m", "apply (rule fmap.map_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>m'. m = fmmap f m' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    m = m\n 2. \\<And>z.\n       \\<lbrakk>\\<And>m'. m = fmmap f m' \\<Longrightarrow> thesis;\n        z \\<in> fmran' m\\<rbrakk>\n       \\<Longrightarrow> id z = (f \\<circ> inv f) z", "apply (auto simp: fmran'_def f_inv_into_f dest!: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_of_map_upd: \"set_of_map (map_upd k v m) = set_of_map (map_drop k m) \\<union> {(k, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_map (map_upd k v m) = set_of_map (map_drop k m) \\<union> {(k, v)}", "unfolding set_of_map_def map_upd_def map_drop_def map_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(ka, va) |ka va. (m(k \\<mapsto> v)) ka = Some va} =\n    {(ka, v) |ka v.\n     (if ka \\<noteq> k then m ka else None) = Some v} \\<union>\n    {(k, v)}", "by (auto split: if_splits)"], ["", "lemma map_drop_delete: \"map_drop k (map_of ps) = map_of (AList.delete k ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_drop k (map_of ps) = map_of (AList.delete k ps)", "unfolding AList.delete_eq map_drop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_filter (\\<lambda>a'. a' \\<noteq> k) (map_of ps) =\n    map_of (filter (\\<lambda>(k', uu_). k \\<noteq> k') ps)", "apply (subst map_filter_map_of)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (filter (\\<lambda>(ka, uu_). ka \\<noteq> k) ps) =\n    map_of (filter (\\<lambda>(k', uu_). k \\<noteq> k') ps)", "apply (rule arg_cong[where f = \"map_of\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(ka, uu_). ka \\<noteq> k) ps =\n    filter (\\<lambda>(k', uu_). k \\<noteq> k') ps", "apply (rule filter_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps \\<Longrightarrow>\n       (case x of (ka, uu_) \\<Rightarrow> ka \\<noteq> k) =\n       (case x of (k', uu_) \\<Rightarrow> k \\<noteq> k')", "by auto"], ["", "lemma set_of_map_map_of: \"set_of_map (map_of xs) = set (AList.clearjunk xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_map (map_of xs) = set (AList.clearjunk xs)", "proof (induction xs rule: clearjunk.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "case (2 p ps)"], ["proof (state)\nthis:\n  set_of_map (map_of (AList.delete (fst p) ps)) =\n  set (AList.clearjunk (AList.delete (fst p) ps))\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "(* honourable mention: int-e on IRC, but it's way to short to understand what's going on *)"], ["proof (state)\nthis:\n  set_of_map (map_of (AList.delete (fst p) ps)) =\n  set (AList.clearjunk (AList.delete (fst p) ps))\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "by (simp add: 2[symmetric] delete_conv) (auto simp: set_of_map_def)"], ["proof (state)\nthis:\n  set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "obtain k v where \"p = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. p = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) auto"], ["proof (state)\nthis:\n  p = (k, v)\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "have \"set_of_map (map_of (p # ps)) = set_of_map (map_upd k v (map_of ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_map (map_of (p # ps)) = set_of_map (map_upd k v (map_of ps))", "unfolding \\<open>p = _\\<close> map_upd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_map (map_of ((k, v) # ps)) =\n    set_of_map (map_of ps(k \\<mapsto> v))", "by simp"], ["proof (state)\nthis:\n  set_of_map (map_of (p # ps)) = set_of_map (map_upd k v (map_of ps))\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "also"], ["proof (state)\nthis:\n  set_of_map (map_of (p # ps)) = set_of_map (map_upd k v (map_of ps))\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "have \"\\<dots> = set_of_map (map_drop k (map_of ps)) \\<union> {(k, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_map (map_upd k v (map_of ps)) =\n    set_of_map (map_drop k (map_of ps)) \\<union> {(k, v)}", "by (rule set_of_map_upd)"], ["proof (state)\nthis:\n  set_of_map (map_upd k v (map_of ps)) =\n  set_of_map (map_drop k (map_of ps)) \\<union> {(k, v)}\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "also"], ["proof (state)\nthis:\n  set_of_map (map_upd k v (map_of ps)) =\n  set_of_map (map_drop k (map_of ps)) \\<union> {(k, v)}\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "have \"\\<dots> = set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_map (map_drop k (map_of ps)) \\<union> {(k, v)} =\n    set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)}", "by (simp only: map_drop_delete)"], ["proof (state)\nthis:\n  set_of_map (map_drop k (map_of ps)) \\<union> {(k, v)} =\n  set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)}\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "also"], ["proof (state)\nthis:\n  set_of_map (map_drop k (map_of ps)) \\<union> {(k, v)} =\n  set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)}\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "have \"\\<dots> =  set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)} =\n    set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)}", "using 2"], ["proof (prove)\nusing this:\n  set_of_map (map_of (AList.delete (fst p) ps)) =\n  set (AList.clearjunk (AList.delete (fst p) ps))\n\ngoal (1 subgoal):\n 1. set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)} =\n    set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)}", "unfolding \\<open>p = _\\<close>"], ["proof (prove)\nusing this:\n  set_of_map (map_of (AList.delete (fst (k, v)) ps)) =\n  set (AList.clearjunk (AList.delete (fst (k, v)) ps))\n\ngoal (1 subgoal):\n 1. set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)} =\n    set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)}", "by simp"], ["proof (state)\nthis:\n  set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)} =\n  set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)}\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "also"], ["proof (state)\nthis:\n  set_of_map (map_of (AList.delete k ps)) \\<union> {(k, v)} =\n  set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)}\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "have \"\\<dots> = set (AList.clearjunk (p # ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)} =\n    set (AList.clearjunk (p # ps))", "unfolding \\<open>p = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)} =\n    set (AList.clearjunk ((k, v) # ps))", "by simp"], ["proof (state)\nthis:\n  set (AList.clearjunk (AList.delete k ps)) \\<union> {(k, v)} =\n  set (AList.clearjunk (p # ps))\n\ngoal (2 subgoals):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])\n 2. \\<And>p ps.\n       set_of_map (map_of (AList.delete (fst p) ps)) =\n       set (AList.clearjunk (AList.delete (fst p) ps)) \\<Longrightarrow>\n       set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "finally"], ["proof (chain)\npicking this:\n  set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "show ?case"], ["proof (prove)\nusing this:\n  set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))\n\ngoal (1 subgoal):\n 1. set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))", "."], ["proof (state)\nthis:\n  set_of_map (map_of (p # ps)) = set (AList.clearjunk (p # ps))\n\ngoal (1 subgoal):\n 1. set_of_map (map_of []) = set (AList.clearjunk [])", "qed (simp add: set_of_map_def)"], ["", "lemma fset_of_fmap_code[code]: \"fset_of_fmap (fmap_of_list x) = fset_of_list (AList.clearjunk x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_fmap (fmap_of_list x) = fset_of_list (AList.clearjunk x)", "including fmap.lifting fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_fmap (fmap_of_list x) = fset_of_list (AList.clearjunk x)", "by transfer (rule set_of_map_map_of)"], ["", "lemma distinct_sorted_list_of_fmap[simp, intro]: \"distinct (sorted_list_of_fmap m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_list_of_fmap m)", "unfolding sorted_list_of_fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>k. (k, the (fmlookup m k)))\n       (sorted_list_of_fset (fmdom m)))", "apply (subst distinct_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_list_of_fset (fmdom m)) \\<and>\n    inj_on (\\<lambda>k. (k, the (fmlookup m k)))\n     (set (sorted_list_of_fset (fmdom m)))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (sorted_list_of_fset (fmdom m))\n 2. inj_on (\\<lambda>k. (k, the (fmlookup m k)))\n     (set (sorted_list_of_fset (fmdom m)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_list_of_fset (fmdom m))", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>k. (k, the (fmlookup m k)))\n     (set (sorted_list_of_fset (fmdom m)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>k. (k, the (fmlookup m k)))\n     (set (sorted_list_of_fset (fmdom m)))", "by (rule inj_on_convol_ident)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Lists\\<close>"], ["", "lemma rev_induct2[consumes 1, case_names nil snoc]:\n  assumes \"length xs = length ys\"\n  assumes \"P [] []\"\n  assumes \"\\<And>x xs y ys. length xs = length ys \\<Longrightarrow> P xs ys \\<Longrightarrow> P (xs @ [x]) (ys @ [y])\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs ys", "have \"length (rev xs) = length (rev ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rev xs) = length (rev ys)", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n  P [] []\n  \\<lbrakk>length ?xs = length ?ys; P ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])\n\ngoal (1 subgoal):\n 1. length (rev xs) = length (rev ys)", "by simp"], ["proof (state)\nthis:\n  length (rev xs) = length (rev ys)\n\ngoal (1 subgoal):\n 1. P xs ys", "hence \"P (rev (rev xs)) (rev (rev ys))\""], ["proof (prove)\nusing this:\n  length (rev xs) = length (rev ys)\n\ngoal (1 subgoal):\n 1. P (rev (rev xs)) (rev (rev ys))", "using assms"], ["proof (prove)\nusing this:\n  length (rev xs) = length (rev ys)\n  length xs = length ys\n  P [] []\n  \\<lbrakk>length ?xs = length ?ys; P ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])\n\ngoal (1 subgoal):\n 1. P (rev (rev xs)) (rev (rev ys))", "by (induct rule: list_induct2) auto"], ["proof (state)\nthis:\n  P (rev (rev xs)) (rev (rev ys))\n\ngoal (1 subgoal):\n 1. P xs ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  P (rev (rev xs)) (rev (rev ys))\n\ngoal (1 subgoal):\n 1. P xs ys", "by simp"], ["proof (state)\nthis:\n  P xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_allI[intro]:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> P x\"\n  shows \"list_all P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P xs", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. list_all P xs", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. Ball (set xs) P", "by auto"], ["", "lemma list_map_snd_id:\n  assumes \"\\<And>a b e. (a, b) \\<in> set cs \\<Longrightarrow> f a b = b\"\n  shows \"map (\\<lambda>(a, b). (a, f a b)) cs = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) cs = cs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) cs = cs", "have \"map (\\<lambda>(a, b). (a, f a b)) cs = map id cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) cs = map id cs", "proof (rule list.map_cong0, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> set cs \\<Longrightarrow> (a, f a b) = id (a, b)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> set cs \\<Longrightarrow> (a, f a b) = id (a, b)", "assume \"(a, b) \\<in> set cs\""], ["proof (state)\nthis:\n  (a, b) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> set cs \\<Longrightarrow> (a, f a b) = id (a, b)", "hence \"f a b = b\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set cs\n\ngoal (1 subgoal):\n 1. f a b = b", "using assms"], ["proof (prove)\nusing this:\n  (a, b) \\<in> set cs\n  (?a, ?b) \\<in> set cs \\<Longrightarrow> f ?a ?b = ?b\n\ngoal (1 subgoal):\n 1. f a b = b", "by auto"], ["proof (state)\nthis:\n  f a b = b\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> set cs \\<Longrightarrow> (a, f a b) = id (a, b)", "thus \"(a, f a b) = id (a, b)\""], ["proof (prove)\nusing this:\n  f a b = b\n\ngoal (1 subgoal):\n 1. (a, f a b) = id (a, b)", "by simp"], ["proof (state)\nthis:\n  (a, f a b) = id (a, b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>(a, b). (a, f a b)) cs = map id cs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) cs = cs", "thus ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>(a, b). (a, f a b)) cs = map id cs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, f a b)) cs = cs", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>(a, b). (a, f a b)) cs = cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_all2_leftE:\n  assumes \"list_all2 P xs ys\" \"x \\<in> set xs\"\n  obtains y where \"y \\<in> set ys\" \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set ys; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  list_all2 P xs ys\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set ys; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induct auto"], ["", "lemma list_all2_rightE:\n  assumes \"list_all2 P xs ys\" \"y \\<in> set ys\"\n  obtains x where \"x \\<in> set xs\" \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  list_all2 P xs ys\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; P x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induct auto"], ["", "fun list_all3 where\n\"list_all3 P (x # xs) (y # ys) (z # zs) \\<longleftrightarrow> P x y z \\<and> list_all3 P xs ys zs\" |\n\"list_all3 P [] [] [] \\<longleftrightarrow> True\" |\n\"list_all3 _ _ _ _ \\<longleftrightarrow> False\""], ["", "lemma list_all3_empty[intro]: \"list_all3 P [] [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all3 P [] [] []", "by simp"], ["", "lemma list_all3_cons[intro]: \"list_all3 P xs ys zs \\<Longrightarrow> P x y z \\<Longrightarrow> list_all3 P (x # xs) (y # ys) (z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all3 P xs ys zs; P x y z\\<rbrakk>\n    \\<Longrightarrow> list_all3 P (x # xs) (y # ys) (z # zs)", "by simp"], ["", "lemma list_all3_induct[consumes 1, case_names Nil Cons, induct set: list_all3]:\n  assumes P: \"list_all3 P xs ys zs\"\n  assumes Nil: \"Q [] [] []\"\n  assumes Cons: \"\\<And>x xs y ys z zs.\n    P x y z \\<Longrightarrow> Q xs ys zs \\<Longrightarrow> list_all3 P xs ys zs \\<Longrightarrow> Q (x # xs) (y # ys) (z # zs)\"\n  shows \"Q xs ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q xs ys zs", "using P"], ["proof (prove)\nusing this:\n  list_all3 P xs ys zs\n\ngoal (1 subgoal):\n 1. Q xs ys zs", "proof (induction P\\<equiv>P xs ys zs rule: list_all3.induct, goal_cases cons)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x xs y ys z zs.\n       \\<lbrakk>list_all3 P xs ys zs \\<Longrightarrow> Q xs ys zs;\n        list_all3 P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> Q (x # xs) (y # ys) (z # zs)\n 2. list_all3 P [] [] [] \\<Longrightarrow> Q [] [] []\n 3. \\<And>v va ux_.\n       list_all3 P [] (v # va) ux_ \\<Longrightarrow> Q [] (v # va) ux_\n 4. \\<And>uw_ v va.\n       list_all3 P [] uw_ (v # va) \\<Longrightarrow> Q [] uw_ (v # va)\n 5. \\<And>v va ux_.\n       list_all3 P (v # va) [] ux_ \\<Longrightarrow> Q (v # va) [] ux_\n 6. \\<And>uv_ v va.\n       list_all3 P uv_ [] (v # va) \\<Longrightarrow> Q uv_ [] (v # va)\n 7. \\<And>v va uw_.\n       list_all3 P (v # va) uw_ [] \\<Longrightarrow> Q (v # va) uw_ []\n 8. \\<And>uv_ v va.\n       list_all3 P uv_ (v # va) [] \\<Longrightarrow> Q uv_ (v # va) []", "show \"Q [] [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q [] [] []", "by fact"], ["proof (state)\nthis:\n  Q [] [] []\n\ngoal (7 subgoals):\n 1. \\<And>x xs y ys z zs.\n       \\<lbrakk>list_all3 P xs ys zs \\<Longrightarrow> Q xs ys zs;\n        list_all3 P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> Q (x # xs) (y # ys) (z # zs)\n 2. \\<And>v va ux_.\n       list_all3 P [] (v # va) ux_ \\<Longrightarrow> Q [] (v # va) ux_\n 3. \\<And>uw_ v va.\n       list_all3 P [] uw_ (v # va) \\<Longrightarrow> Q [] uw_ (v # va)\n 4. \\<And>v va ux_.\n       list_all3 P (v # va) [] ux_ \\<Longrightarrow> Q (v # va) [] ux_\n 5. \\<And>uv_ v va.\n       list_all3 P uv_ [] (v # va) \\<Longrightarrow> Q uv_ [] (v # va)\n 6. \\<And>v va uw_.\n       list_all3 P (v # va) uw_ [] \\<Longrightarrow> Q (v # va) uw_ []\n 7. \\<And>uv_ v va.\n       list_all3 P uv_ (v # va) [] \\<Longrightarrow> Q uv_ (v # va) []", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xs y ys z zs.\n       \\<lbrakk>list_all3 P xs ys zs \\<Longrightarrow> Q xs ys zs;\n        list_all3 P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> Q (x # xs) (y # ys) (z # zs)\n 2. \\<And>v va ux_.\n       list_all3 P [] (v # va) ux_ \\<Longrightarrow> Q [] (v # va) ux_\n 3. \\<And>uw_ v va.\n       list_all3 P [] uw_ (v # va) \\<Longrightarrow> Q [] uw_ (v # va)\n 4. \\<And>v va ux_.\n       list_all3 P (v # va) [] ux_ \\<Longrightarrow> Q (v # va) [] ux_\n 5. \\<And>uv_ v va.\n       list_all3 P uv_ [] (v # va) \\<Longrightarrow> Q uv_ [] (v # va)\n 6. \\<And>v va uw_.\n       list_all3 P (v # va) uw_ [] \\<Longrightarrow> Q (v # va) uw_ []\n 7. \\<And>uv_ v va.\n       list_all3 P uv_ (v # va) [] \\<Longrightarrow> Q uv_ (v # va) []", "case (cons x xs y ys z zs)"], ["proof (state)\nthis:\n  list_all3 P xs ys zs \\<Longrightarrow> Q xs ys zs\n  list_all3 P (x # xs) (y # ys) (z # zs)\n\ngoal (7 subgoals):\n 1. \\<And>x xs y ys z zs.\n       \\<lbrakk>list_all3 P xs ys zs \\<Longrightarrow> Q xs ys zs;\n        list_all3 P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> Q (x # xs) (y # ys) (z # zs)\n 2. \\<And>v va ux_.\n       list_all3 P [] (v # va) ux_ \\<Longrightarrow> Q [] (v # va) ux_\n 3. \\<And>uw_ v va.\n       list_all3 P [] uw_ (v # va) \\<Longrightarrow> Q [] uw_ (v # va)\n 4. \\<And>v va ux_.\n       list_all3 P (v # va) [] ux_ \\<Longrightarrow> Q (v # va) [] ux_\n 5. \\<And>uv_ v va.\n       list_all3 P uv_ [] (v # va) \\<Longrightarrow> Q uv_ [] (v # va)\n 6. \\<And>v va uw_.\n       list_all3 P (v # va) uw_ [] \\<Longrightarrow> Q (v # va) uw_ []\n 7. \\<And>uv_ v va.\n       list_all3 P uv_ (v # va) [] \\<Longrightarrow> Q uv_ (v # va) []", "thus ?case"], ["proof (prove)\nusing this:\n  list_all3 P xs ys zs \\<Longrightarrow> Q xs ys zs\n  list_all3 P (x # xs) (y # ys) (z # zs)\n\ngoal (1 subgoal):\n 1. Q (x # xs) (y # ys) (z # zs)", "using Cons"], ["proof (prove)\nusing this:\n  list_all3 P xs ys zs \\<Longrightarrow> Q xs ys zs\n  list_all3 P (x # xs) (y # ys) (z # zs)\n  \\<lbrakk>P ?x ?y ?z; Q ?xs ?ys ?zs; list_all3 P ?xs ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> Q (?x # ?xs) (?y # ?ys) (?z # ?zs)\n\ngoal (1 subgoal):\n 1. Q (x # xs) (y # ys) (z # zs)", "by auto"], ["proof (state)\nthis:\n  Q (x # xs) (y # ys) (z # zs)\n\ngoal (6 subgoals):\n 1. \\<And>v va ux_.\n       list_all3 P [] (v # va) ux_ \\<Longrightarrow> Q [] (v # va) ux_\n 2. \\<And>uw_ v va.\n       list_all3 P [] uw_ (v # va) \\<Longrightarrow> Q [] uw_ (v # va)\n 3. \\<And>v va ux_.\n       list_all3 P (v # va) [] ux_ \\<Longrightarrow> Q (v # va) [] ux_\n 4. \\<And>uv_ v va.\n       list_all3 P uv_ [] (v # va) \\<Longrightarrow> Q uv_ [] (v # va)\n 5. \\<And>v va uw_.\n       list_all3 P (v # va) uw_ [] \\<Longrightarrow> Q (v # va) uw_ []\n 6. \\<And>uv_ v va.\n       list_all3 P uv_ (v # va) [] \\<Longrightarrow> Q uv_ (v # va) []", "qed auto"], ["", "lemma list_all3_from_list_all2s:\n  assumes \"list_all2 P xs ys\" \"list_all2 Q xs zs\"\n  assumes \"\\<And>x y z. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> z \\<in> set zs \\<Longrightarrow> P x y \\<Longrightarrow> Q x z \\<Longrightarrow> R x y z\"\n  shows \"list_all3 R xs ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all3 R xs ys zs", "using assms"], ["proof (prove)\nusing this:\n  list_all2 P xs ys\n  list_all2 Q xs zs\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set ys; ?z \\<in> set zs; P ?x ?y;\n   Q ?x ?z\\<rbrakk>\n  \\<Longrightarrow> R ?x ?y ?z\n\ngoal (1 subgoal):\n 1. list_all3 R xs ys zs", "proof (induction arbitrary: zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       \\<lbrakk>list_all2 Q [] zs;\n        \\<And>x y z.\n           \\<lbrakk>x \\<in> set []; y \\<in> set []; z \\<in> set zs; P x y;\n            Q x z\\<rbrakk>\n           \\<Longrightarrow> R x y z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R [] [] zs\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>P x y; list_all2 P xs ys;\n        \\<And>zs.\n           \\<lbrakk>list_all2 Q xs zs;\n            \\<And>x y z.\n               \\<lbrakk>x \\<in> set xs; y \\<in> set ys; z \\<in> set zs;\n                P x y; Q x z\\<rbrakk>\n               \\<Longrightarrow> R x y z\\<rbrakk>\n           \\<Longrightarrow> list_all3 R xs ys zs;\n        list_all2 Q (x # xs) zs;\n        \\<And>xa ya z.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys);\n            z \\<in> set zs; P xa ya; Q xa z\\<rbrakk>\n           \\<Longrightarrow> R xa ya z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R (x # xs) (y # ys) zs", "case Nil"], ["proof (state)\nthis:\n  list_all2 Q [] zs\n  \\<lbrakk>?x \\<in> set []; ?y \\<in> set []; ?z \\<in> set zs; P ?x ?y;\n   Q ?x ?z\\<rbrakk>\n  \\<Longrightarrow> R ?x ?y ?z\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       \\<lbrakk>list_all2 Q [] zs;\n        \\<And>x y z.\n           \\<lbrakk>x \\<in> set []; y \\<in> set []; z \\<in> set zs; P x y;\n            Q x z\\<rbrakk>\n           \\<Longrightarrow> R x y z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R [] [] zs\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>P x y; list_all2 P xs ys;\n        \\<And>zs.\n           \\<lbrakk>list_all2 Q xs zs;\n            \\<And>x y z.\n               \\<lbrakk>x \\<in> set xs; y \\<in> set ys; z \\<in> set zs;\n                P x y; Q x z\\<rbrakk>\n               \\<Longrightarrow> R x y z\\<rbrakk>\n           \\<Longrightarrow> list_all3 R xs ys zs;\n        list_all2 Q (x # xs) zs;\n        \\<And>xa ya z.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys);\n            z \\<in> set zs; P xa ya; Q xa z\\<rbrakk>\n           \\<Longrightarrow> R xa ya z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R (x # xs) (y # ys) zs", "hence \"zs = []\""], ["proof (prove)\nusing this:\n  list_all2 Q [] zs\n  \\<lbrakk>?x \\<in> set []; ?y \\<in> set []; ?z \\<in> set zs; P ?x ?y;\n   Q ?x ?z\\<rbrakk>\n  \\<Longrightarrow> R ?x ?y ?z\n\ngoal (1 subgoal):\n 1. zs = []", "by blast"], ["proof (state)\nthis:\n  zs = []\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       \\<lbrakk>list_all2 Q [] zs;\n        \\<And>x y z.\n           \\<lbrakk>x \\<in> set []; y \\<in> set []; z \\<in> set zs; P x y;\n            Q x z\\<rbrakk>\n           \\<Longrightarrow> R x y z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R [] [] zs\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>P x y; list_all2 P xs ys;\n        \\<And>zs.\n           \\<lbrakk>list_all2 Q xs zs;\n            \\<And>x y z.\n               \\<lbrakk>x \\<in> set xs; y \\<in> set ys; z \\<in> set zs;\n                P x y; Q x z\\<rbrakk>\n               \\<Longrightarrow> R x y z\\<rbrakk>\n           \\<Longrightarrow> list_all3 R xs ys zs;\n        list_all2 Q (x # xs) zs;\n        \\<And>xa ya z.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys);\n            z \\<in> set zs; P xa ya; Q xa z\\<rbrakk>\n           \\<Longrightarrow> R xa ya z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R (x # xs) (y # ys) zs", "thus ?case"], ["proof (prove)\nusing this:\n  zs = []\n\ngoal (1 subgoal):\n 1. list_all3 R [] [] zs", "by simp"], ["proof (state)\nthis:\n  list_all3 R [] [] zs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>P x y; list_all2 P xs ys;\n        \\<And>zs.\n           \\<lbrakk>list_all2 Q xs zs;\n            \\<And>x y z.\n               \\<lbrakk>x \\<in> set xs; y \\<in> set ys; z \\<in> set zs;\n                P x y; Q x z\\<rbrakk>\n               \\<Longrightarrow> R x y z\\<rbrakk>\n           \\<Longrightarrow> list_all3 R xs ys zs;\n        list_all2 Q (x # xs) zs;\n        \\<And>xa ya z.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys);\n            z \\<in> set zs; P xa ya; Q xa z\\<rbrakk>\n           \\<Longrightarrow> R xa ya z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R (x # xs) (y # ys) zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>P x y; list_all2 P xs ys;\n        \\<And>zs.\n           \\<lbrakk>list_all2 Q xs zs;\n            \\<And>x y z.\n               \\<lbrakk>x \\<in> set xs; y \\<in> set ys; z \\<in> set zs;\n                P x y; Q x z\\<rbrakk>\n               \\<Longrightarrow> R x y z\\<rbrakk>\n           \\<Longrightarrow> list_all3 R xs ys zs;\n        list_all2 Q (x # xs) zs;\n        \\<And>xa ya z.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys);\n            z \\<in> set zs; P xa ya; Q xa z\\<rbrakk>\n           \\<Longrightarrow> R xa ya z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R (x # xs) (y # ys) zs", "case (Cons x y xs ys zs0)"], ["proof (state)\nthis:\n  P x xs\n  list_all2 P y ys\n  \\<lbrakk>list_all2 Q y ?zs;\n   \\<And>x ya z.\n      \\<lbrakk>x \\<in> set y; ya \\<in> set ys; z \\<in> set ?zs; P x ya;\n       Q x z\\<rbrakk>\n      \\<Longrightarrow> R x ya z\\<rbrakk>\n  \\<Longrightarrow> list_all3 R y ys ?zs\n  list_all2 Q (x # y) zs0\n  \\<lbrakk>?x \\<in> set (x # y); ?y \\<in> set (xs # ys); ?z \\<in> set zs0;\n   P ?x ?y; Q ?x ?z\\<rbrakk>\n  \\<Longrightarrow> R ?x ?y ?z\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>P x y; list_all2 P xs ys;\n        \\<And>zs.\n           \\<lbrakk>list_all2 Q xs zs;\n            \\<And>x y z.\n               \\<lbrakk>x \\<in> set xs; y \\<in> set ys; z \\<in> set zs;\n                P x y; Q x z\\<rbrakk>\n               \\<Longrightarrow> R x y z\\<rbrakk>\n           \\<Longrightarrow> list_all3 R xs ys zs;\n        list_all2 Q (x # xs) zs;\n        \\<And>xa ya z.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys);\n            z \\<in> set zs; P xa ya; Q xa z\\<rbrakk>\n           \\<Longrightarrow> R xa ya z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R (x # xs) (y # ys) zs", "then"], ["proof (chain)\npicking this:\n  P x xs\n  list_all2 P y ys\n  \\<lbrakk>list_all2 Q y ?zs;\n   \\<And>x ya z.\n      \\<lbrakk>x \\<in> set y; ya \\<in> set ys; z \\<in> set ?zs; P x ya;\n       Q x z\\<rbrakk>\n      \\<Longrightarrow> R x ya z\\<rbrakk>\n  \\<Longrightarrow> list_all3 R y ys ?zs\n  list_all2 Q (x # y) zs0\n  \\<lbrakk>?x \\<in> set (x # y); ?y \\<in> set (xs # ys); ?z \\<in> set zs0;\n   P ?x ?y; Q ?x ?z\\<rbrakk>\n  \\<Longrightarrow> R ?x ?y ?z", "obtain z zs where \"zs0 = z # zs\""], ["proof (prove)\nusing this:\n  P x xs\n  list_all2 P y ys\n  \\<lbrakk>list_all2 Q y ?zs;\n   \\<And>x ya z.\n      \\<lbrakk>x \\<in> set y; ya \\<in> set ys; z \\<in> set ?zs; P x ya;\n       Q x z\\<rbrakk>\n      \\<Longrightarrow> R x ya z\\<rbrakk>\n  \\<Longrightarrow> list_all3 R y ys ?zs\n  list_all2 Q (x # y) zs0\n  \\<lbrakk>?x \\<in> set (x # y); ?y \\<in> set (xs # ys); ?z \\<in> set zs0;\n   P ?x ?y; Q ?x ?z\\<rbrakk>\n  \\<Longrightarrow> R ?x ?y ?z\n\ngoal (1 subgoal):\n 1. (\\<And>z zs. zs0 = z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases zs0) auto"], ["proof (state)\nthis:\n  zs0 = z # zs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>P x y; list_all2 P xs ys;\n        \\<And>zs.\n           \\<lbrakk>list_all2 Q xs zs;\n            \\<And>x y z.\n               \\<lbrakk>x \\<in> set xs; y \\<in> set ys; z \\<in> set zs;\n                P x y; Q x z\\<rbrakk>\n               \\<Longrightarrow> R x y z\\<rbrakk>\n           \\<Longrightarrow> list_all3 R xs ys zs;\n        list_all2 Q (x # xs) zs;\n        \\<And>xa ya z.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys);\n            z \\<in> set zs; P xa ya; Q xa z\\<rbrakk>\n           \\<Longrightarrow> R xa ya z\\<rbrakk>\n       \\<Longrightarrow> list_all3 R (x # xs) (y # ys) zs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all3 R (x # y) (xs # ys) zs0", "using Cons"], ["proof (prove)\nusing this:\n  P x xs\n  list_all2 P y ys\n  \\<lbrakk>list_all2 Q y ?zs;\n   \\<And>x ya z.\n      \\<lbrakk>x \\<in> set y; ya \\<in> set ys; z \\<in> set ?zs; P x ya;\n       Q x z\\<rbrakk>\n      \\<Longrightarrow> R x ya z\\<rbrakk>\n  \\<Longrightarrow> list_all3 R y ys ?zs\n  list_all2 Q (x # y) zs0\n  \\<lbrakk>?x \\<in> set (x # y); ?y \\<in> set (xs # ys); ?z \\<in> set zs0;\n   P ?x ?y; Q ?x ?z\\<rbrakk>\n  \\<Longrightarrow> R ?x ?y ?z\n\ngoal (1 subgoal):\n 1. list_all3 R (x # y) (xs # ys) zs0", "unfolding \\<open>zs0 = _\\<close>"], ["proof (prove)\nusing this:\n  P x xs\n  list_all2 P y ys\n  \\<lbrakk>list_all2 Q y ?zs;\n   \\<And>x ya z.\n      \\<lbrakk>x \\<in> set y; ya \\<in> set ys; z \\<in> set ?zs; P x ya;\n       Q x z\\<rbrakk>\n      \\<Longrightarrow> R x ya z\\<rbrakk>\n  \\<Longrightarrow> list_all3 R y ys ?zs\n  list_all2 Q (x # y) (z # zs)\n  \\<lbrakk>?x \\<in> set (x # y); ?y \\<in> set (xs # ys);\n   ?z \\<in> set (z # zs); P ?x ?y; Q ?x ?z\\<rbrakk>\n  \\<Longrightarrow> R ?x ?y ?z\n\ngoal (1 subgoal):\n 1. list_all3 R (x # y) (xs # ys) (z # zs)", "by auto"], ["proof (state)\nthis:\n  list_all3 R (x # y) (xs # ys) zs0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma those_someD:\n  assumes \"those xs = Some ys\"\n  shows \"xs = map Some ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map Some ys", "using assms"], ["proof (prove)\nusing this:\n  those xs = Some ys\n\ngoal (1 subgoal):\n 1. xs = map Some ys", "by (induction xs arbitrary: ys) (auto split: if_splits option.splits)"], ["", "end"]]}