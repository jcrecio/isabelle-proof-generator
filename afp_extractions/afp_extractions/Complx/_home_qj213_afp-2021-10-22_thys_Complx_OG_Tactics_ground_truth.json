{"file_name": "/home/qj213/afp-2021-10-22/thys/Complx/OG_Tactics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complx", "problem_names": ["lemmas SeqSkipRule = SeqSkip", "lemmas SeqThrowRule = SeqThrow", "lemmas SeqBasicRule = SeqBasic", "lemmas SeqSpecRule = SeqSpec", "lemmas SeqSeqRule = SeqSeq", "lemma SeqCondRule: \n \"\\<lbrakk>  \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> C1 P\\<^sub>1 c\\<^sub>1 Q,A;\n    \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> C2 P\\<^sub>2 c\\<^sub>2 Q,A \\<rbrakk>\n   \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> {s. (s\\<in>b \\<longrightarrow> s\\<in>C1) \\<and> (s\\<notin>b \\<longrightarrow> s\\<in>C2)} (AnnBin r P\\<^sub>1 P\\<^sub>2)\n                   (Cond b c\\<^sub>1 c\\<^sub>2) Q,A\"", "lemma SeqWhileRule:\n  \"\\<lbrakk> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i,A; i \\<inter> - b \\<subseteq> Q \\<rbrakk>\n   \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> i (AnnWhile r i a) (While b c) Q,A\"", "lemma DynComRule:\n \"\\<lbrakk> r \\<subseteq> pre a;  \\<And>s. s\\<in>r \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> a (c s) Q,A \\<rbrakk> \\<Longrightarrow> \n      \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnRec r a) (DynCom c) Q,A\"", "lemma SeqDynComRule:\n \"\\<lbrakk>r \\<subseteq> pre a;\n   \\<And>s. s\\<in>r \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub>P a (c s) Q,A;\n      P\\<subseteq>r \\<rbrakk> \\<Longrightarrow> \n  \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P (AnnRec r a) (DynCom c) Q,A\"", "lemma SeqCallRule:\n  \"\\<lbrakk> P' \\<subseteq> P; \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P P'' f Q,A; \n     n < length as; \\<Gamma> p = Some f;\n     as ! n = P''; \\<Theta> p = Some as\\<rbrakk>\n   \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P' (AnnCall r n) (Call p) Q,A\"", "lemma SeqGuardRule:\n  \"\\<lbrakk> P \\<inter> g \\<subseteq> P'; P \\<inter> -g \\<noteq> {} \\<Longrightarrow> f \\<in> F;\n     \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P' a c Q,A \\<rbrakk> \\<Longrightarrow>\n   \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P (AnnRec r a) (Guard f g c) Q,A\"", "lemma GuardRule:\n  \"\\<lbrakk> r \\<inter> g \\<subseteq> pre P; r \\<inter> -g \\<noteq> {} \\<longrightarrow> f \\<in> F;\n     \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q,A \\<rbrakk> \\<Longrightarrow>\n   \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnRec r P) (Guard f g c) Q,A\"", "lemma CallRule:\n  \"\\<lbrakk> r \\<subseteq> pre P; \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P f Q,A;\n     n < length as; \\<Gamma> p = Some f;\n     as ! n = P; \\<Theta> p = Some as\\<rbrakk>\n   \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnCall r n) (Call p) Q,A\"", "lemma MapAnnEmpty: \"\\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> [] []\"", "lemma MapAnnList: \"\\<lbrakk> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q, A;\n                     \\<Gamma>, \\<Theta>  [\\<tturnstile>]\\<^bsub>/F\\<^esub> Ps Ts \\<rbrakk> \n                \\<Longrightarrow> \\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> ((P, Q, A)#Ps) (c#Ts)\"", "lemma MapAnnMap: \n   \"\\<forall>k. i\\<le>k \\<and> k<j \\<longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (P k) (c k) (Q k), (A k) \n\\<Longrightarrow> \\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> (map (\\<lambda>k. (P k, Q k, A k)) [i..<j]) (map c [i..<j])\"", "lemma ParallelRule:\n  \"\\<lbrakk>\\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> Ps Cs;\n    interfree \\<Gamma> \\<Theta> F Ps Cs;\n    length Cs = length Ps\n \\<rbrakk> \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) \n                    (Parallel Cs) \n                    (\\<Inter>i\\<in>{i. i<length Ps}. postcond (Ps!i)), (\\<Union>i\\<in>{i. i<length Ps}. abrcond (Ps!i))\"", "lemma ParallelConseqRule:\n  \"\\<lbrakk> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) \n                    (Parallel Ts) \n                    (\\<Inter>i\\<in>{i. i<length Ps}. postcond (Ps!i)), (\\<Union>i\\<in>{i. i<length Ps}. abrcond (Ps!i));\n     (\\<Inter>i\\<in>{i. i<length Ps}. postcond (Ps!i)) \\<subseteq> Q;\n     (\\<Union>i\\<in>{i. i<length Ps}. abrcond (Ps!i)) \\<subseteq> A\n \\<rbrakk> \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) (Parallel Ts) Q, A\"", "lemma pre_strengthen: \"\\<not>pre_par a \\<Longrightarrow> pre (strengthen_pre a a') = pre a \\<inter> a'\"", "lemma Basic_inter_right: \n  \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) (Basic f) q, q \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Basic f, AnnExpr r)\"", "lemma Skip_inter_right:\n  \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) Skip q, q \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Skip, AnnExpr r)\"", "lemma Throw_inter_right:\n  \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) Throw q, q \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Throw, AnnExpr r)\"", "lemma Spec_inter_right: \n  \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) (Spec rel) q, q \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Spec rel, AnnExpr r)\"", "lemma valid_Await:\n \"atom_com c \\<Longrightarrow> \\<Gamma>\\<Turnstile>\\<^bsub>/F\\<^esub> (P \\<inter> b) c Q,A \\<Longrightarrow> \\<Gamma>\\<Turnstile>\\<^bsub>/F\\<^esub> P Await b c Q,A\"", "lemma atomcom_imp_not_prepare:\n \"ann_matches \\<Gamma> \\<Theta> a c \\<Longrightarrow> atom_com c \\<Longrightarrow> \n   \\<not> pre_par a\"", "lemma Await_inter_right: \n  \"atom_com c \\<Longrightarrow>\n  \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a c q,q \\<Longrightarrow>\n  q \\<inter> r \\<inter> b \\<subseteq> P \\<Longrightarrow>\n  interfree_aux_right \\<Gamma> \\<Theta> F (q, Await b c, AnnRec r a)\"", "lemma Call_inter_right:\n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, f, P);\n     n < length as; \\<Gamma> p = Some f;\n     as ! n = P; \\<Theta> p = Some as\\<rbrakk> \\<Longrightarrow>\n  interfree_aux_right \\<Gamma> \\<Theta> F (q, Call p, AnnCall r n)\"", "lemma DynCom_inter_right:\n  \"\\<lbrakk>\\<And>s. s \\<in> r \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, f s, P) \\<rbrakk> \\<Longrightarrow>\n  interfree_aux_right \\<Gamma> \\<Theta> F (q, DynCom f, AnnRec r P)\"", "lemma Guard_inter_right:\n  \"interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a)\n     \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Guard f g c, AnnRec r a)\"", "lemma Parallel_inter_right_empty:\n  \"interfree_aux_right \\<Gamma> \\<Theta> F (q, Parallel [], AnnPar [])\"", "lemma Parallel_inter_right_List:\n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a);\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, Parallel cs, AnnPar as)\\<rbrakk>\n     \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Parallel (c#cs), AnnPar ((a, Q, A) #as))\"", "lemma Parallel_inter_right_Map:\n  \"\\<forall>k. i\\<le>k \\<and> k<j \\<longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, c k, a k)\n     \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F\n                (q, Parallel (map c [i..<j]), AnnPar (map (\\<lambda>i. (a i, Q, A)) [i..<j]))\"", "lemma Seq_inter_right: \n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1); interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow> \n  interfree_aux_right \\<Gamma> \\<Theta> F (q, Seq c\\<^sub>1 c\\<^sub>2, AnnComp a1 a2)\"", "lemma Catch_inter_right:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1); interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow>\n  interfree_aux_right \\<Gamma> \\<Theta> F (q, Catch c\\<^sub>1 c\\<^sub>2, AnnComp a1 a2)\"", "lemma While_inter_aux_any: \"interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, abr), c, P) \\<Longrightarrow>\n  interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, abr), While b c, AnnWhile R I P)\"", "lemma While_inter_right:\n  \"interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a)\n     \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, While b c, AnnWhile r i a)\"", "lemma Cond_inter_aux_any:\n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), c\\<^sub>1, a1); interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow> \n   interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), Cond b c\\<^sub>1 c\\<^sub>2, AnnBin r a1 a2)\"", "lemma Cond_inter_right:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1); interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow> \n   interfree_aux_right \\<Gamma> \\<Theta> F (q, Cond b c\\<^sub>1 c\\<^sub>2, AnnBin r a1 a2)\"", "lemma Basic_inter_aux: \n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann); \n    interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann) \\<rbrakk> \\<Longrightarrow> \n    interfree_aux \\<Gamma> \\<Theta> F (Basic f, (AnnExpr r, q, a), com, ann)\"", "lemma Skip_inter_aux:\n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann) \\<rbrakk> \\<Longrightarrow>\n    interfree_aux \\<Gamma> \\<Theta> F (Skip, (AnnExpr r, q, a), com, ann)\"", "lemma Throw_inter_aux:\n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann) \\<rbrakk> \\<Longrightarrow>\n    interfree_aux \\<Gamma> \\<Theta> F (Throw, (AnnExpr r, q, a), com, ann)\"", "lemma Spec_inter_aux: \n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann); \n    interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann) \\<rbrakk> \\<Longrightarrow> \n    interfree_aux \\<Gamma> \\<Theta> F (Spec rel, (AnnExpr r, q, a), com, ann)\"", "lemma Seq_inter_aux:\n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>1, (r\\<^sub>1, pre r\\<^sub>2, A), com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann) \\<rbrakk>\n   \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (Seq c\\<^sub>1 c\\<^sub>2, (AnnComp r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)\"", "lemma Catch_inter_aux:\n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>1, (r\\<^sub>1, Q, pre r\\<^sub>2), com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann) \\<rbrakk>\n   \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (Catch c\\<^sub>1 c\\<^sub>2, (AnnComp r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)\"", "lemma Cond_inter_aux: \n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n    interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>1, (r\\<^sub>1, Q, A), com, ann); \n    interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann) \\<rbrakk>\n \\<Longrightarrow>  interfree_aux \\<Gamma> \\<Theta> F (Cond b c\\<^sub>1 c\\<^sub>2, (AnnBin r r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)\"", "lemma While_inter_aux: \n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann); \n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c, (P, i, A), com, ann) \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (While b c, (AnnWhile r i P, Q, A), com, ann)\"", "lemma Await_inter_aux: \n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann); \n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann); \n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann) \\<rbrakk>\n  \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (Await b e, (AnnRec r ae, Q, A), com, ann)\"", "lemma Call_inter_aux:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (f, (P, Q, A), com, ann);\n     n < length as; \\<Gamma> p = Some f;\n     as ! n = P; \\<Theta> p = Some as \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (Call p, (AnnCall r n, Q, A), com, ann)\"", "lemma DynCom_inter_aux:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann); \n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann);\n     \\<And>s. s\\<in>r \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (f s, (P, Q, A), com, ann) \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (DynCom f, (AnnRec r P, Q, A), com, ann)\"", "lemma Guard_inter_aux:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c, (P, Q, A), com, ann) \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (Guard f g c, (AnnRec r P, Q, A), com, ann)\"", "lemma inter_aux_Par_Empty: \"inter_aux_Par \\<Gamma> \\<Theta> F ([], [], c, a)\"", "lemma inter_aux_Par_List:\n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (x, a, y, a');\n  inter_aux_Par \\<Gamma> \\<Theta> F (xs, as, y, a')\\<rbrakk> \n  \\<Longrightarrow> inter_aux_Par \\<Gamma> \\<Theta> F (x#xs, a#as, y, a')\"", "lemma inter_aux_Par_Map: \"\\<forall>k. i\\<le>k \\<and> k<j \\<longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (c k, Q k, x, a)\n \\<Longrightarrow> inter_aux_Par \\<Gamma> \\<Theta> F (map c [i..<j], map Q [i..<j], x, a)\"", "lemma Parallel_inter_aux:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (\\<Inter> (set (map postcond as)), com, ann);\n     inter_aux_Par \\<Gamma> \\<Theta> F (cs, as, com, ann) \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (Parallel cs, (AnnPar as, Q, A), com, ann)\"", "lemma interfree_swap_Empty: \"interfree_swap  \\<Gamma> \\<Theta> F (x, a, [], [])\"", "lemma interfree_swap_List:  \n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (x, a, y, fst (a')); \n  interfree_aux \\<Gamma> \\<Theta> F (y, a', x, fst a);\n  interfree_swap \\<Gamma> \\<Theta> F (x, a, xs, as)\\<rbrakk> \n  \\<Longrightarrow> interfree_swap \\<Gamma> \\<Theta> F (x, a, y#xs, a'#as)\"", "lemma interfree_swap_Map: \"\\<forall>k. i\\<le>k \\<and> k<j \\<longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (x, a, c k, fst (Q k)) \n \\<and> interfree_aux \\<Gamma> \\<Theta> F (c k, (Q k), x, fst a)\n \\<Longrightarrow> interfree_swap \\<Gamma> \\<Theta> F (x, a, map c [i..<j], map Q [i..<j])\"", "lemma interfree_Empty: \"interfree \\<Gamma> \\<Theta> F [] []\"", "lemma interfree_List: \n  \"\\<lbrakk> interfree_swap \\<Gamma> \\<Theta> F (x, a, xs, as); interfree \\<Gamma> \\<Theta> F as xs \\<rbrakk> \\<Longrightarrow> interfree \\<Gamma> \\<Theta> F (a#as) (x#xs)\"", "lemma interfree_Map: \n  \"(\\<forall>i j. a\\<le>i \\<and> i<b \\<and> a\\<le>j \\<and> j<b  \\<and> i\\<noteq>j \\<longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (c i, A i, c j, pres (A j)))  \n  \\<Longrightarrow> interfree \\<Gamma> \\<Theta> F (map (\\<lambda>k. A k) [a..<b]) (map (\\<lambda>k. c k) [a..<b])\"", "lemma list_lemmas: \"length []=0\" \"length (x#xs) = Suc(length xs)\"\n    \"(x#xs) ! 0 = x\" \"(x#xs) ! Suc n = xs ! n\"", "lemma le_Suc_eq_insert: \"{i. i <Suc n} = insert n {i. i< n}\"", "lemmas primrecdef_list = \"pre.simps\" strengthen_pre.simps", "lemmas ParallelConseq_list = INTER_eq Collect_conj_eq length_map length_upt length_append", "lemmas my_simp_list = list_lemmas fst_conv snd_conv\nnot_less0 refl le_Suc_eq_insert Suc_not_Zero Zero_not_Suc nat.inject\nCollect_mem_eq ball_simps option.simps primrecdef_list", "lemmas guards.simps[oghoare_simps add]\n       ann_guards.simps[oghoare_simps add]"], "translations": [["", "lemmas SeqSkipRule = SeqSkip"], ["", "lemmas SeqThrowRule = SeqThrow"], ["", "lemmas SeqBasicRule = SeqBasic"], ["", "lemmas SeqSpecRule = SeqSpec"], ["", "lemmas SeqSeqRule = SeqSeq"], ["", "lemma SeqCondRule: \n \"\\<lbrakk>  \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> C1 P\\<^sub>1 c\\<^sub>1 Q,A;\n    \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> C2 P\\<^sub>2 c\\<^sub>2 Q,A \\<rbrakk>\n   \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> {s. (s\\<in>b \\<longrightarrow> s\\<in>C1) \\<and> (s\\<notin>b \\<longrightarrow> s\\<in>C2)} (AnnBin r P\\<^sub>1 P\\<^sub>2)\n                   (Cond b c\\<^sub>1 c\\<^sub>2) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> C1 P\\<^sub>1 c\\<^sub>1\n           Q, A;\n     \\<Gamma>, \\<Theta>\n         \\<tturnstile>\\<^bsub>/F\\<^esub> C2 P\\<^sub>2 c\\<^sub>2\n   Q, A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> {s.\n                     (s \\<in> b \\<longrightarrow> s \\<in> C1) \\<and>\n                     (s \\<notin> b \\<longrightarrow> s \\<in> C2)}\n                    (AnnBin r P\\<^sub>1 P\\<^sub>2)\n                    (Cond b c\\<^sub>1 c\\<^sub>2) Q, A", "apply (rule SeqCond)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> C1 P\\<^sub>1 c\\<^sub>1\n           Q, A;\n     \\<Gamma>, \\<Theta>\n         \\<tturnstile>\\<^bsub>/F\\<^esub> C2 P\\<^sub>2 c\\<^sub>2\n   Q, A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> ({s.\n                      (s \\<in> b \\<longrightarrow> s \\<in> C1) \\<and>\n                      (s \\<notin> b \\<longrightarrow> s \\<in> C2)} \\<inter>\n                     b)\n                    P\\<^sub>1 c\\<^sub>1 Q, A\n 2. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> C1 P\\<^sub>1 c\\<^sub>1\n           Q, A;\n     \\<Gamma>, \\<Theta>\n         \\<tturnstile>\\<^bsub>/F\\<^esub> C2 P\\<^sub>2 c\\<^sub>2\n   Q, A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> ({s.\n                      (s \\<in> b \\<longrightarrow> s \\<in> C1) \\<and>\n                      (s \\<notin> b \\<longrightarrow> s \\<in> C2)} \\<inter>\n                     - b)\n                    P\\<^sub>2 c\\<^sub>2 Q, A", "apply (erule SeqConseq[rotated]; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> C1 P\\<^sub>1 c\\<^sub>1\n           Q, A;\n     \\<Gamma>, \\<Theta>\n         \\<tturnstile>\\<^bsub>/F\\<^esub> C2 P\\<^sub>2 c\\<^sub>2\n   Q, A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> ({s.\n                      (s \\<in> b \\<longrightarrow> s \\<in> C1) \\<and>\n                      (s \\<notin> b \\<longrightarrow> s \\<in> C2)} \\<inter>\n                     - b)\n                    P\\<^sub>2 c\\<^sub>2 Q, A", "apply (erule SeqConseq[rotated]; clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SeqWhileRule:\n  \"\\<lbrakk> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i,A; i \\<inter> - b \\<subseteq> Q \\<rbrakk>\n   \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> i (AnnWhile r i a) (While b c) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> i (AnnWhile r i a)\n                    (While b c) Q, A", "apply (rule SeqConseq[OF _ SeqWhile])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> i \\<subseteq> ?P'\n 2. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> (?P' \\<inter> b) a\n                    c ?P', ?A'\n 3. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> ?P' \\<inter> - b \\<subseteq> Q\n 4. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> ?A' \\<subseteq> A", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> (?P' \\<inter> b) a\n                    c ?P', ?A'\n 2. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> i \\<subseteq> ?P'\n 3. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> ?P' \\<inter> - b \\<subseteq> Q\n 4. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> ?A' \\<subseteq> A", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> i \\<subseteq> i\n 2. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> i \\<inter> - b \\<subseteq> Q\n 3. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<tturnstile>\\<^bsub>/F\\<^esub> (i \\<inter> b) a c i, A;\n     i \\<inter> - b \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> A", "by simp+"], ["", "lemma DynComRule:\n \"\\<lbrakk> r \\<subseteq> pre a;  \\<And>s. s\\<in>r \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> a (c s) Q,A \\<rbrakk> \\<Longrightarrow> \n      \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnRec r a) (DynCom c) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> pre a;\n     \\<And>s.\n        s \\<in> r \\<Longrightarrow>\n        \\<Gamma>, \\<Theta>\n            \\<turnstile>\\<^bsub>/F\\<^esub> a (c s) Q, A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<turnstile>\\<^bsub>/F\\<^esub> (AnnRec r a)\n                   (DynCom c) Q, A", "by (erule DynCom) clarsimp"], ["", "lemma SeqDynComRule:\n \"\\<lbrakk>r \\<subseteq> pre a;\n   \\<And>s. s\\<in>r \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub>P a (c s) Q,A;\n      P\\<subseteq>r \\<rbrakk> \\<Longrightarrow> \n  \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P (AnnRec r a) (DynCom c) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> pre a;\n     \\<And>s.\n        s \\<in> r \\<Longrightarrow>\n        \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a (c s) Q, A;\n     P \\<subseteq> r\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> P (AnnRec r a)\n                    (DynCom c) Q, A", "by (erule SeqDynCom) clarsimp"], ["", "lemma SeqCallRule:\n  \"\\<lbrakk> P' \\<subseteq> P; \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P P'' f Q,A; \n     n < length as; \\<Gamma> p = Some f;\n     as ! n = P''; \\<Theta> p = Some as\\<rbrakk>\n   \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P' (AnnCall r n) (Call p) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P' \\<subseteq> P;\n     \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P P'' f Q, A;\n     n < length as; \\<Gamma> p = Some f; as ! n = P'';\n     \\<Theta> p = Some as\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> P' (AnnCall r n)\n                    (Call p) Q, A", "by (simp add: SeqCall SeqConseq)"], ["", "lemma SeqGuardRule:\n  \"\\<lbrakk> P \\<inter> g \\<subseteq> P'; P \\<inter> -g \\<noteq> {} \\<Longrightarrow> f \\<in> F;\n     \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P' a c Q,A \\<rbrakk> \\<Longrightarrow>\n   \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P (AnnRec r a) (Guard f g c) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<inter> g \\<subseteq> P';\n     P \\<inter> - g \\<noteq> {} \\<Longrightarrow> f \\<in> F;\n     \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P' a c Q, A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<tturnstile>\\<^bsub>/F\\<^esub> P (AnnRec r a)\n                    (Guard f g c) Q, A", "by (simp add: SeqGuard SeqConseq)"], ["", "subsection \\<open>Parallel-mode rules\\<close>"], ["", "lemma GuardRule:\n  \"\\<lbrakk> r \\<inter> g \\<subseteq> pre P; r \\<inter> -g \\<noteq> {} \\<longrightarrow> f \\<in> F;\n     \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q,A \\<rbrakk> \\<Longrightarrow>\n   \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnRec r P) (Guard f g c) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<inter> g \\<subseteq> pre P;\n     r \\<inter> - g \\<noteq> {} \\<longrightarrow> f \\<in> F;\n     \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q, A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<turnstile>\\<^bsub>/F\\<^esub> (AnnRec r P)\n                   (Guard f g c) Q, A", "by (simp add: Guard)"], ["", "lemma CallRule:\n  \"\\<lbrakk> r \\<subseteq> pre P; \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P f Q,A;\n     n < length as; \\<Gamma> p = Some f;\n     as ! n = P; \\<Theta> p = Some as\\<rbrakk>\n   \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnCall r n) (Call p) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<subseteq> pre P;\n     \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P f Q, A;\n     n < length as; \\<Gamma> p = Some f; as ! n = P;\n     \\<Theta> p = Some as\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<turnstile>\\<^bsub>/F\\<^esub> (AnnCall r n)\n                   (Call p) Q, A", "by (simp add: Call)"], ["", "definition map_ann_hoare :: \"('s,'p,'f) body \\<Rightarrow> ('s,'p,'f) proc_assns \\<Rightarrow> 'f set\n              \\<Rightarrow> ('s, 'p, 'f) ann_triple list \\<Rightarrow> ('s,'p,'f) com list \\<Rightarrow> bool\"\n    (\"(4_,_/[\\<tturnstile>]\\<^bsub>'/_ \\<^esub>(_/ (_)))\" [60,60,60,1000,20]60) where\n  \"\\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> Ps Ts \\<equiv> \\<forall>i < length Ts. \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (pres (Ps!i)) (Ts!i) (postcond (Ps!i)), (abrcond (Ps!i))\""], ["", "lemma MapAnnEmpty: \"\\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>[\\<tturnstile>]\\<^bsub>/F \\<^esub>[] []", "by(simp add:map_ann_hoare_def)"], ["", "lemma MapAnnList: \"\\<lbrakk> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q, A;\n                     \\<Gamma>, \\<Theta>  [\\<tturnstile>]\\<^bsub>/F\\<^esub> Ps Ts \\<rbrakk> \n                \\<Longrightarrow> \\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> ((P, Q, A)#Ps) (c#Ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q, A;\n     \\<Gamma>,\\<Theta>[\\<tturnstile>]\\<^bsub>/F \\<^esub>Ps Ts\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>,\\<Theta>\n                          [\\<tturnstile>]\\<^bsub>/F \\<^esub>((P, Q, A) # Ps)\n                      c # Ts", "apply(simp add:map_ann_hoare_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q, A;\n     \\<forall>i<length Ts.\n        \\<Gamma>, \\<Theta>\n            \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Ts ! i)\n     (fst (snd (Ps ! i))), (snd (snd (Ps ! i)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc (length Ts).\n                         \\<Gamma>, \\<Theta>\n                             \\<turnstile>\\<^bsub>/F\\<^esub> (fst\n                        (((P, Q, A) # Ps) ! i))\n                      ((c # Ts) ! i)\n                      (fst (snd (((P, Q, A) # Ps) !\n                                 i))), (snd (snd (((P, Q, A) # Ps) ! i)))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q, A;\n        \\<forall>i<length Ts.\n           \\<Gamma>, \\<Theta>\n               \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Ts ! i)\n        (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n        i < Suc (length Ts)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                             \\<turnstile>\\<^bsub>/F\\<^esub> (fst\n                        (((P, Q, A) # Ps) ! i))\n                      ((c # Ts) ! i)\n                      (fst (snd (((P, Q, A) # Ps) !\n                                 i))), (snd (snd (((P, Q, A) # Ps) ! i)))", "apply (rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> P c Q, A;\n        \\<forall>i<length Ts.\n           \\<Gamma>, \\<Theta>\n               \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Ts ! i)\n        (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n        i < Suc (length Ts)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                             \\<turnstile>\\<^bsub>/F\\<^esub> (fst\n                        (((P, Q, A) # Ps) ! i))\n                      ((c # Ts) ! i)\n                      (fst (snd (((P, Q, A) # Ps) !\n                                 i))), (snd (snd (((P, Q, A) # Ps) ! i)))", "apply(case_tac i,simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma MapAnnMap: \n   \"\\<forall>k. i\\<le>k \\<and> k<j \\<longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (P k) (c k) (Q k), (A k) \n\\<Longrightarrow> \\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> (map (\\<lambda>k. (P k, Q k, A k)) [i..<j]) (map c [i..<j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       i \\<le> k \\<and> k < j \\<longrightarrow>\n       \\<Gamma>, \\<Theta>\n           \\<turnstile>\\<^bsub>/F\\<^esub> (P k) (c k)\n    (Q k), (A k) \\<Longrightarrow>\n    \\<Gamma>,\\<Theta>\n        [\\<tturnstile>]\\<^bsub>/F \\<^esub>(map (\\<lambda>k. (P k, Q k, A k))\n      [i..<j])\n    map c [i..<j]", "by (simp add: add.commute le_add1 map_ann_hoare_def)"], ["", "lemma ParallelRule:\n  \"\\<lbrakk>\\<Gamma>, \\<Theta> [\\<tturnstile>]\\<^bsub>/F\\<^esub> Ps Cs;\n    interfree \\<Gamma> \\<Theta> F Ps Cs;\n    length Cs = length Ps\n \\<rbrakk> \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) \n                    (Parallel Cs) \n                    (\\<Inter>i\\<in>{i. i<length Ps}. postcond (Ps!i)), (\\<Union>i\\<in>{i. i<length Ps}. abrcond (Ps!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>,\\<Theta>[\\<tturnstile>]\\<^bsub>/F \\<^esub>Ps Cs;\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps)\n                   (Parallel Cs)\n                   (\\<Inter>i\\<in>{i. i < length Ps}.\n                       fst (snd (Ps !\n                                 i))), (\\<Union>i\\<in>{i. i < length Ps}.\n     snd (snd (Ps ! i)))", "apply (clarsimp simp add:neq_Nil_conv Parallel map_ann_hoare_def )+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps)\n                   (Parallel Cs)\n                   (\\<Inter>i\\<in>{i. i < length Ps}.\n                       fst (snd (Ps !\n                                 i))), (\\<Union>i\\<in>{i. i < length Ps}.\n     snd (snd (Ps ! i)))", "apply (rule Parallel)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> length Ps = length Cs\n 2. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length Cs.\n                         \\<Gamma>, \\<Theta>\n                             \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i))\n                      (Cs ! i) (fst (snd (Ps ! i))), (snd (snd (Ps ! i)))\n 3. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> interfree \\<Gamma> \\<Theta> F Ps Cs\n 4. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Inter> (set (map (\\<lambda>a. fst (snd a)) Ps))\n                      \\<subseteq> (\\<Inter>i\\<in>{i. i < length Ps}.\nfst (snd (Ps ! i)))\n 5. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (set (map (\\<lambda>a. snd (snd a)) Ps))\n                      \\<subseteq> (\\<Union>i\\<in>{i. i < length Ps}.\nsnd (snd (Ps ! i)))", "apply fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length Cs.\n                         \\<Gamma>, \\<Theta>\n                             \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i))\n                      (Cs ! i) (fst (snd (Ps ! i))), (snd (snd (Ps ! i)))\n 2. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> interfree \\<Gamma> \\<Theta> F Ps Cs\n 3. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Inter> (set (map (\\<lambda>a. fst (snd a)) Ps))\n                      \\<subseteq> (\\<Inter>i\\<in>{i. i < length Ps}.\nfst (snd (Ps ! i)))\n 4. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (set (map (\\<lambda>a. snd (snd a)) Ps))\n                      \\<subseteq> (\\<Union>i\\<in>{i. i < length Ps}.\nsnd (snd (Ps ! i)))", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> interfree \\<Gamma> \\<Theta> F Ps Cs\n 2. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Inter> (set (map (\\<lambda>a. fst (snd a)) Ps))\n                      \\<subseteq> (\\<Inter>i\\<in>{i. i < length Ps}.\nfst (snd (Ps ! i)))\n 3. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (set (map (\\<lambda>a. snd (snd a)) Ps))\n                      \\<subseteq> (\\<Union>i\\<in>{i. i < length Ps}.\nsnd (snd (Ps ! i)))", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Inter> (set (map (\\<lambda>a. fst (snd a)) Ps))\n                      \\<subseteq> (\\<Inter>i\\<in>{i. i < length Ps}.\nfst (snd (Ps ! i)))\n 2. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (set (map (\\<lambda>a. snd (snd a)) Ps))\n                      \\<subseteq> (\\<Union>i\\<in>{i. i < length Ps}.\nsnd (snd (Ps ! i)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<length Ps.\n                \\<Gamma>, \\<Theta>\n                    \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i)) (Cs ! i)\n             (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n     interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (set (map (\\<lambda>a. snd (snd a)) Ps))\n                      \\<subseteq> (\\<Union>i\\<in>{i. i < length Ps}.\nsnd (snd (Ps ! i)))", "apply (clarsimp simp: in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa b i.\n       \\<lbrakk>\\<forall>i<length Ps.\n                   \\<Gamma>, \\<Theta>\n                       \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i))\n                (Cs ! i) (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n        interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps;\n        x \\<in> b; i < length Ps; Ps ! i = (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa<length Ps. x \\<in> snd (snd (Ps ! xa))", "apply (rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa b i.\n       \\<lbrakk>\\<forall>i<length Ps.\n                   \\<Gamma>, \\<Theta>\n                       \\<turnstile>\\<^bsub>/F\\<^esub> (fst (Ps ! i))\n                (Cs ! i) (fst (snd (Ps ! i))), (snd (snd (Ps ! i)));\n        interfree \\<Gamma> \\<Theta> F Ps Cs; length Cs = length Ps;\n        x \\<in> b; i < length Ps; Ps ! i = (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa<length Ps. x \\<in> snd (snd (Ps ! xa))", "apply (rule_tac x=i in exI, fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ParallelConseqRule:\n  \"\\<lbrakk> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) \n                    (Parallel Ts) \n                    (\\<Inter>i\\<in>{i. i<length Ps}. postcond (Ps!i)), (\\<Union>i\\<in>{i. i<length Ps}. abrcond (Ps!i));\n     (\\<Inter>i\\<in>{i. i<length Ps}. postcond (Ps!i)) \\<subseteq> Q;\n     (\\<Union>i\\<in>{i. i<length Ps}. abrcond (Ps!i)) \\<subseteq> A\n \\<rbrakk> \\<Longrightarrow> \\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) (Parallel Ts) Q, A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) (Parallel Ts)\n          (\\<Inter>i\\<in>{i. i < length Ps}.\n              fst (snd (Ps !\n                        i))), (\\<Union>i\\<in>{i. i < length Ps}.\n                                  snd (snd (Ps ! i)));\n     (\\<Inter>i\\<in>{i. i < length Ps}. fst (snd (Ps ! i))) \\<subseteq> Q;\n     (\\<Union>i\\<in>{i. i < length Ps}. snd (snd (Ps ! i)))\n     \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps)\n                   (Parallel Ts) Q, A", "apply (rule Conseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) (Parallel Ts)\n          (\\<Inter>i\\<in>{i. i < length Ps}.\n              fst (snd (Ps !\n                        i))), (\\<Union>i\\<in>{i. i < length Ps}.\n                                  snd (snd (Ps ! i)));\n     (\\<Inter>i\\<in>{i. i < length Ps}. fst (snd (Ps ! i))) \\<subseteq> Q;\n     (\\<Union>i\\<in>{i. i < length Ps}. snd (snd (Ps ! i)))\n     \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>P' Q' A'.\n                         \\<Gamma>, \\<Theta>\n                             \\<turnstile>\\<^bsub>/F\\<^esub> (weaken_pre\n                        (AnnPar Ps) P')\n                      (Parallel Ts) Q', A' \\<and>\n                         Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (rule exI[where x=\"(\\<Inter>i\\<in>{i. i<length Ps}. precond (Ps!i))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) (Parallel Ts)\n          (\\<Inter>i\\<in>{i. i < length Ps}.\n              fst (snd (Ps !\n                        i))), (\\<Union>i\\<in>{i. i < length Ps}.\n                                  snd (snd (Ps ! i)));\n     (\\<Inter>i\\<in>{i. i < length Ps}. fst (snd (Ps ! i))) \\<subseteq> Q;\n     (\\<Union>i\\<in>{i. i < length Ps}. snd (snd (Ps ! i)))\n     \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q' A'.\n                         \\<Gamma>, \\<Theta>\n                             \\<turnstile>\\<^bsub>/F\\<^esub> (weaken_pre\n                        (AnnPar Ps)\n                        (\\<Inter>i\\<in>{i. i < length Ps}.\n                            precond (Ps ! i)))\n                      (Parallel Ts) Q', A' \\<and>\n                         Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (rule exI[where x=\"(\\<Inter>i\\<in>{i. i<length Ps}. postcond (Ps!i))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) (Parallel Ts)\n          (\\<Inter>i\\<in>{i. i < length Ps}.\n              fst (snd (Ps !\n                        i))), (\\<Union>i\\<in>{i. i < length Ps}.\n                                  snd (snd (Ps ! i)));\n     (\\<Inter>i\\<in>{i. i < length Ps}. fst (snd (Ps ! i))) \\<subseteq> Q;\n     (\\<Union>i\\<in>{i. i < length Ps}. snd (snd (Ps ! i)))\n     \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A'.\n                         \\<Gamma>, \\<Theta>\n                             \\<turnstile>\\<^bsub>/F\\<^esub> (weaken_pre\n                        (AnnPar Ps)\n                        (\\<Inter>i\\<in>{i. i < length Ps}.\n                            precond (Ps ! i)))\n                      (Parallel Ts)\n                      (\\<Inter>i\\<in>{i. i < length Ps}.\n                          fst (snd (Ps ! i))), A' \\<and>\n                         (\\<Inter>i\\<in>{i. i < length Ps}.\n                             fst (snd (Ps ! i)))\n                         \\<subseteq> Q \\<and>\n                         A' \\<subseteq> A", "apply (rule exI[where x=\"(\\<Union>i\\<in>{i. i<length Ps}. abrcond (Ps!i))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma>, \\<Theta>\n                 \\<turnstile>\\<^bsub>/F\\<^esub> (AnnPar Ps) (Parallel Ts)\n          (\\<Inter>i\\<in>{i. i < length Ps}.\n              fst (snd (Ps !\n                        i))), (\\<Union>i\\<in>{i. i < length Ps}.\n                                  snd (snd (Ps ! i)));\n     (\\<Inter>i\\<in>{i. i < length Ps}. fst (snd (Ps ! i))) \\<subseteq> Q;\n     (\\<Union>i\\<in>{i. i < length Ps}. snd (snd (Ps ! i)))\n     \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>, \\<Theta>\n                          \\<turnstile>\\<^bsub>/F\\<^esub> (weaken_pre\n                     (AnnPar Ps)\n                     (\\<Inter>i\\<in>{i. i < length Ps}. precond (Ps ! i)))\n                   (Parallel Ts)\n                   (\\<Inter>i\\<in>{i. i < length Ps}.\n                       fst (snd (Ps !\n                                 i))), (\\<Union>i\\<in>{i. i < length Ps}.\n     snd (snd (Ps ! i))) \\<and>\n                      (\\<Inter>i\\<in>{i. i < length Ps}. fst (snd (Ps ! i)))\n                      \\<subseteq> Q \\<and>\n                      (\\<Union>i\\<in>{i. i < length Ps}. snd (snd (Ps ! i)))\n                      \\<subseteq> A", "apply (clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>See Soundness.thy for the rest of Parallel-mode rules\\<close>"], ["", "subsection \\<open>VCG tactic helper definitions and lemmas\\<close>"], ["", "definition interfree_aux_right :: \"('s,'p,'f) body \\<Rightarrow> ('s,'p,'f) proc_assns \\<Rightarrow> 'f set \\<Rightarrow> ('s assn \\<times> ('s,'p,'f) com \\<times> ('s, 'p, 'f) ann) \\<Rightarrow> bool\" where\n  \"interfree_aux_right \\<Gamma> \\<Theta> F \\<equiv> \\<lambda>(q, cmd, ann). (\\<forall>aa ac.  atomicsR \\<Gamma> \\<Theta> ann cmd (aa,ac) \\<longrightarrow> (\\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub> (q \\<inter> aa) ac q, q))\""], ["", "lemma pre_strengthen: \"\\<not>pre_par a \\<Longrightarrow> pre (strengthen_pre a a') = pre a \\<inter> a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> pre_par a \\<Longrightarrow>\n    pre (strengthen_pre a a') = pre a \\<inter> a'", "by (induct a arbitrary: a', simp_all)"], ["", "lemma Basic_inter_right: \n  \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) (Basic f) q, q \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Basic f, AnnExpr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>, \\<Theta>\n        \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) (Basic f)\n q, q \\<Longrightarrow>\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, Basic f, AnnExpr r)", "by (auto simp: interfree_aux_right_def\n           elim!: atomicsR.cases\n           dest: oghoare_sound)"], ["", "lemma Skip_inter_right:\n  \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) Skip q, q \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Skip, AnnExpr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>, \\<Theta>\n        \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) Skip\n q, q \\<Longrightarrow>\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, Skip, AnnExpr r)", "by (auto simp: interfree_aux_right_def\n           elim!: atomicsR.cases\n           dest: oghoare_sound)"], ["", "lemma Throw_inter_right:\n  \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) Throw q, q \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Throw, AnnExpr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>, \\<Theta>\n        \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) Throw\n q, q \\<Longrightarrow>\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, Throw, AnnExpr r)", "by (auto simp: interfree_aux_right_def\n           elim!: atomicsR.cases\n           dest: oghoare_sound)"], ["", "lemma Spec_inter_right: \n  \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) (Spec rel) q, q \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Spec rel, AnnExpr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>, \\<Theta>\n        \\<turnstile>\\<^bsub>/F\\<^esub> (AnnExpr (q \\<inter> r)) (Spec rel)\n q, q \\<Longrightarrow>\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, Spec rel, AnnExpr r)", "by (auto simp: interfree_aux_right_def  \n           elim!: atomicsR.cases\n           dest: oghoare_sound)"], ["", "lemma valid_Await:\n \"atom_com c \\<Longrightarrow> \\<Gamma>\\<Turnstile>\\<^bsub>/F\\<^esub> (P \\<inter> b) c Q,A \\<Longrightarrow> \\<Gamma>\\<Turnstile>\\<^bsub>/F\\<^esub> P Await b c Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom_com c;\n     \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub> (P \\<inter> b) c Q, A\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                      P Await b c Q, A", "apply (clarsimp simp: valid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t c' x.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        \\<Gamma> \\<turnstile> (Await b c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c', t);\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (erule converse_rtranclpE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t c' x.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        (Await b c, Normal x) = (c', t)\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x y.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma>\\<turnstile> (Await b c, Normal x) \\<rightarrow> y;\n        \\<Gamma> \\<turnstile> y \\<rightarrow>\\<^sup>* (c', t)\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (clarsimp simp: final_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t c' x y.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma>\\<turnstile> (Await b c, Normal x) \\<rightarrow> y;\n        \\<Gamma> \\<turnstile> y \\<rightarrow>\\<^sup>* (c', t)\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma>\\<turnstile> (Await b c, Normal x) \\<rightarrow> (a, ba);\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t)\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (erule step_Normal_elim_cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t c' x a ba c'a s'.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (c'a, Normal s'); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Normal s');\n        atom_com c; c'a = Skip \\<or> c'a = Throw\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 4. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t c' x a s'.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, Normal s') \\<rightarrow>\\<^sup>* (c', t);\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (a, Normal s');\n        atom_com c; a = Skip \\<or> a = Throw\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 4. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (erule disjE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>t c' x a s'.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, Normal s') \\<rightarrow>\\<^sup>* (c', t);\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (a, Normal s');\n        atom_com c; a = Skip\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a s'.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, Normal s') \\<rightarrow>\\<^sup>* (c', t);\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (a, Normal s');\n        atom_com c; a = Throw\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba c'a.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 4. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 5. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (fastforce dest: no_steps_final simp: final_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t c' x a s'.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, Normal s') \\<rightarrow>\\<^sup>* (c', t);\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (a, Normal s');\n        atom_com c; a = Throw\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 4. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (fastforce dest: no_steps_final simp: final_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t c' x a ba c'a.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t c' x c'a.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (Skip, Stuck) \\<rightarrow>\\<^sup>* (c', t);\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (drule no_steps_final, simp add: final_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t c' x c'a.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Stuck);\n        atom_com c; (c', t) = (Skip, Stuck)\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c'a.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> Stuck \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (rename_tac x c'')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c''.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> Stuck \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (drule_tac x=\"Normal x\" in spec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c''.\n       \\<lbrakk>final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c;\n        \\<forall>t c'.\n           \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Stuck \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (drule spec[where x=Stuck])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c''.\n       \\<lbrakk>final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c;\n        \\<forall>c'.\n           \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                                 (c', Stuck) \\<longrightarrow>\n           final (c', Stuck) \\<longrightarrow>\n           Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           Stuck \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> Stuck \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> Stuck \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Stuck \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (drule spec[where x=Skip])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c''.\n       \\<lbrakk>final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (Skip, Stuck) \\<longrightarrow>\n        final (Skip, Stuck) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Stuck \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Stuck \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Stuck \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Stuck \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (erule impE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x c''.\n       \\<lbrakk>final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile> (c,\n          Normal x) \\<rightarrow>\\<^sup>*\n         (Skip, Stuck)\n 2. \\<And>x c''.\n       \\<lbrakk>final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c;\n        final (Skip, Stuck) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Stuck \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Stuck \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Stuck \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Stuck \\<in> Normal ` Q\n 3. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 4. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (cut_tac c=c'' in steps_Stuck[where \\<Gamma>=\\<Gamma>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x c''.\n       \\<lbrakk>final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c;\n        \\<Gamma> \\<turnstile> (c'', Stuck) \\<rightarrow>\\<^sup>*\n                              (Skip, Stuck)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile> (c,\n          Normal x) \\<rightarrow>\\<^sup>*\n         (Skip, Stuck)\n 2. \\<And>x c''.\n       \\<lbrakk>final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c;\n        final (Skip, Stuck) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Stuck \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Stuck \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Stuck \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Stuck \\<in> Normal ` Q\n 3. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 4. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c''.\n       \\<lbrakk>final (Skip, Stuck); x \\<in> P; Stuck \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Stuck);\n        atom_com c;\n        final (Skip, Stuck) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Stuck \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Stuck \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Stuck \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Stuck \\<in> Normal ` Q\n 2. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (drule no_steps_final, simp add: final_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t c' x a ba c'a f.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        (a, ba) = (Skip, Fault f); x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c; (c', t) = (a, ba)\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q\n 2. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x c'a f.\n       \\<lbrakk>\\<forall>s t c'.\n                   \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n   (c', t) \\<longrightarrow>\n                   final (c', t) \\<longrightarrow>\n                   s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n                   t \\<notin> Fault ` F \\<longrightarrow>\n                   c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n                   c' = Throw \\<and> t \\<in> Normal ` A;\n        final (Skip, Fault f); x \\<in> P; Fault f \\<notin> Fault ` F;\n        x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> Fault f \\<in> Normal ` Q\n 2. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (drule_tac x=\"Normal x\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x c'a f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c;\n        \\<forall>t c'.\n           \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Fault f \\<in> Normal ` Q\n 2. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (drule_tac x=\"Fault f\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x c'a f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c;\n        \\<forall>c'.\n           \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                                 (c', Fault f) \\<longrightarrow>\n           final (c', Fault f) \\<longrightarrow>\n           Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           Fault f \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> Fault f \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> Fault f \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Fault f \\<in> Normal ` Q\n 2. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (drule spec[where x=Skip])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x c'a f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (Skip, Fault f) \\<longrightarrow>\n        final (Skip, Fault f) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Fault f \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Fault f \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Fault f \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Fault f \\<in> Normal ` Q\n 2. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c'a f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile> (c,\n          Normal x) \\<rightarrow>\\<^sup>*\n         (Skip, Fault f)\n 2. \\<And>x c'a f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c;\n        final (Skip, Fault f) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Fault f \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Fault f \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Fault f \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Fault f \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (rename_tac c'' f)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c'' f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Fault f);\n        atom_com c\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile> (c,\n          Normal x) \\<rightarrow>\\<^sup>*\n         (Skip, Fault f)\n 2. \\<And>x c'a f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c;\n        final (Skip, Fault f) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Fault f \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Fault f \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Fault f \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Fault f \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply (cut_tac c=c'' and f=f in steps_Fault[where \\<Gamma>=\\<Gamma>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x c'' f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'', Fault f);\n        atom_com c;\n        \\<Gamma> \\<turnstile> (c'', Fault f) \\<rightarrow>\\<^sup>*\n                              (Skip, Fault f)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile> (c,\n          Normal x) \\<rightarrow>\\<^sup>*\n         (Skip, Fault f)\n 2. \\<And>x c'a f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c;\n        final (Skip, Fault f) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Fault f \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Fault f \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Fault f \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Fault f \\<in> Normal ` Q\n 3. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x c'a f.\n       \\<lbrakk>final (Skip, Fault f); x \\<in> P;\n        Fault f \\<notin> Fault ` F; x \\<in> b;\n        \\<Gamma> \\<turnstile> (c, Normal x) \\<rightarrow>\\<^sup>*\n                              (c'a, Fault f);\n        atom_com c;\n        final (Skip, Fault f) \\<longrightarrow>\n        Normal x \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n        Fault f \\<notin> Fault ` F \\<longrightarrow>\n        Skip = Skip \\<and> Fault f \\<in> Normal ` Q \\<or>\n        Skip = Throw \\<and> Fault f \\<in> Normal ` A\\<rbrakk>\n       \\<Longrightarrow> Fault f \\<in> Normal ` Q\n 2. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t c' x a ba.\n       \\<lbrakk>atom_com c;\n        \\<forall>s t c'.\n           \\<Gamma> \\<turnstile> (c, s) \\<rightarrow>\\<^sup>*\n                                 (c', t) \\<longrightarrow>\n           final (c', t) \\<longrightarrow>\n           s \\<in> Normal ` (P \\<inter> b) \\<longrightarrow>\n           t \\<notin> Fault ` F \\<longrightarrow>\n           c' = Skip \\<and> t \\<in> Normal ` Q \\<or>\n           c' = Throw \\<and> t \\<in> Normal ` A;\n        final (c', t); x \\<in> P; t \\<notin> Fault ` F;\n        c' = Throw \\<longrightarrow> t \\<notin> Normal ` A;\n        \\<Gamma> \\<turnstile> (a, ba) \\<rightarrow>\\<^sup>* (c', t);\n        (a, ba) = (Skip, Stuck); \\<not> atom_com c\\<rbrakk>\n       \\<Longrightarrow> c' = Skip \\<and> t \\<in> Normal ` Q", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atomcom_imp_not_prepare:\n \"ann_matches \\<Gamma> \\<Theta> a c \\<Longrightarrow> atom_com c \\<Longrightarrow> \n   \\<not> pre_par a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ann_matches \\<Gamma> \\<Theta> a c; atom_com c\\<rbrakk>\n    \\<Longrightarrow> \\<not> pre_par a", "by (induct rule:ann_matches.induct, simp_all)"], ["", "lemma Await_inter_right: \n  \"atom_com c \\<Longrightarrow>\n  \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a c q,q \\<Longrightarrow>\n  q \\<inter> r \\<inter> b \\<subseteq> P \\<Longrightarrow>\n  interfree_aux_right \\<Gamma> \\<Theta> F (q, Await b c, AnnRec r a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom_com c;\n     \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a c q, q;\n     q \\<inter> r \\<inter> b \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F\n                       (q, Await b c, AnnRec r a)", "apply (simp add: interfree_aux_right_def  )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom_com c;\n     \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a c q, q;\n     q \\<inter> r \\<inter> b \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa ac.\n                         atomicsR \\<Gamma> \\<Theta> (AnnRec r a) (Await b c)\n                          (aa, ac) \\<longrightarrow>\n                         \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) ac q, q", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ac.\n       \\<lbrakk>atom_com c;\n        \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a c q, q;\n        q \\<inter> r \\<inter> b \\<subseteq> P;\n        atomicsR \\<Gamma> \\<Theta> (AnnRec r a) (Await b c)\n         (aa, ac)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) ac q, q", "apply (erule atomicsR.cases, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ra ba.\n       \\<lbrakk>atom_com c;\n        \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a c q, q;\n        q \\<inter> ra \\<inter> ba \\<subseteq> P; r = ra; b = ba;\n        aa = ra \\<inter> ba\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> (ra \\<inter> ba)) Await ba c q, q", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom_com c;\n     \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a c q, q;\n     q \\<inter> r \\<inter> b \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                      (q \\<inter> (r \\<inter> b)) Await b c q, q", "apply (rule valid_Await, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom_com c;\n     \\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P a c q, q;\n     q \\<inter> r \\<inter> b \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                      (q \\<inter> (r \\<inter> b) \\<inter> b) c q, q", "apply (drule oghoare_seq_sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom_com c; q \\<inter> r \\<inter> b \\<subseteq> P;\n     \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub> P c q, q\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                      (q \\<inter> (r \\<inter> b) \\<inter> b) c q, q", "apply (erule valid_weaken_pre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom_com c; q \\<inter> r \\<inter> b \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> q \\<inter> (r \\<inter> b) \\<inter> b \\<subseteq> P", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Call_inter_right:\n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, f, P);\n     n < length as; \\<Gamma> p = Some f;\n     as ! n = P; \\<Theta> p = Some as\\<rbrakk> \\<Longrightarrow>\n  interfree_aux_right \\<Gamma> \\<Theta> F (q, Call p, AnnCall r n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, f, P);\n     n < length as; \\<Gamma> p = Some f; as ! n = P;\n     \\<Theta> p = Some as\\<rbrakk>\n    \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F\n                       (q, Call p, AnnCall r n)", "by(auto simp: interfree_aux_right_def elim: atomicsR.cases)"], ["", "lemma DynCom_inter_right:\n  \"\\<lbrakk>\\<And>s. s \\<in> r \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, f s, P) \\<rbrakk> \\<Longrightarrow>\n  interfree_aux_right \\<Gamma> \\<Theta> F (q, DynCom f, AnnRec r P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> r \\<Longrightarrow>\n        interfree_aux_right \\<Gamma> \\<Theta> F\n         (q, f s, P)) \\<Longrightarrow>\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, DynCom f, AnnRec r P)", "by(auto simp: interfree_aux_right_def elim: atomicsR.cases)"], ["", "lemma Guard_inter_right:\n  \"interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a)\n     \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Guard f g c, AnnRec r a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a) \\<Longrightarrow>\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, Guard f g c, AnnRec r a)", "by(auto simp: interfree_aux_right_def elim: atomicsR.cases)"], ["", "lemma Parallel_inter_right_empty:\n  \"interfree_aux_right \\<Gamma> \\<Theta> F (q, Parallel [], AnnPar [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interfree_aux_right \\<Gamma> \\<Theta> F (q, Parallel [], AnnPar [])", "by(auto simp: interfree_aux_right_def elim: atomicsR.cases)"], ["", "lemma Parallel_inter_right_List:\n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a);\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, Parallel cs, AnnPar as)\\<rbrakk>\n     \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, Parallel (c#cs), AnnPar ((a, Q, A) #as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a);\n     interfree_aux_right \\<Gamma> \\<Theta> F\n      (q, Parallel cs, AnnPar as)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F\n                       (q, Parallel (c # cs), AnnPar ((a, Q, A) # as))", "apply (clarsimp simp: interfree_aux_right_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ac.\n       \\<lbrakk>\\<forall>aa ac.\n                   atomicsR \\<Gamma> \\<Theta> a c (aa, ac) \\<longrightarrow>\n                   \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                   (q \\<inter> aa) ac q, q;\n        \\<forall>aa ac.\n           atomicsR \\<Gamma> \\<Theta> (AnnPar as) (Parallel cs)\n            (aa, ac) \\<longrightarrow>\n           \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub> (q \\<inter> aa) ac q, q;\n        atomicsR \\<Gamma> \\<Theta> (AnnPar ((a, Q, A) # as))\n         (Parallel (c # cs)) (aa, ac)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) ac q, q", "apply (erule atomicsR.cases; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i aa b.\n       \\<lbrakk>\\<forall>aa ac.\n                   atomicsR \\<Gamma> \\<Theta> a c (aa, ac) \\<longrightarrow>\n                   \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                   (q \\<inter> aa) ac q, q;\n        \\<forall>aa ac.\n           atomicsR \\<Gamma> \\<Theta> (AnnPar as) (Parallel cs)\n            (aa, ac) \\<longrightarrow>\n           \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub> (q \\<inter> aa) ac q, q;\n        i < Suc (length cs);\n        atomicsR \\<Gamma> \\<Theta> (fst (((a, Q, A) # as) ! i))\n         ((c # cs) ! i) (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) b q, q", "apply (rename_tac i aa b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i aa b.\n       \\<lbrakk>\\<forall>aa ac.\n                   atomicsR \\<Gamma> \\<Theta> a c (aa, ac) \\<longrightarrow>\n                   \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                   (q \\<inter> aa) ac q, q;\n        \\<forall>aa ac.\n           atomicsR \\<Gamma> \\<Theta> (AnnPar as) (Parallel cs)\n            (aa, ac) \\<longrightarrow>\n           \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub> (q \\<inter> aa) ac q, q;\n        i < Suc (length cs);\n        atomicsR \\<Gamma> \\<Theta> (fst (((a, Q, A) # as) ! i))\n         ((c # cs) ! i) (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) b q, q", "apply (case_tac i, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i aa b nat.\n       \\<lbrakk>\\<forall>aa ac.\n                   atomicsR \\<Gamma> \\<Theta> a c (aa, ac) \\<longrightarrow>\n                   \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                   (q \\<inter> aa) ac q, q;\n        \\<forall>aa ac.\n           atomicsR \\<Gamma> \\<Theta> (AnnPar as) (Parallel cs)\n            (aa, ac) \\<longrightarrow>\n           \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub> (q \\<inter> aa) ac q, q;\n        i < Suc (length cs);\n        atomicsR \\<Gamma> \\<Theta> (fst (((a, Q, A) # as) ! i))\n         ((c # cs) ! i) (aa, b);\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) b q, q", "apply (fastforce intro: AtParallelExprs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Parallel_inter_right_Map:\n  \"\\<forall>k. i\\<le>k \\<and> k<j \\<longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, c k, a k)\n     \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F\n                (q, Parallel (map c [i..<j]), AnnPar (map (\\<lambda>i. (a i, Q, A)) [i..<j]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       i \\<le> k \\<and> k < j \\<longrightarrow>\n       interfree_aux_right \\<Gamma> \\<Theta> F\n        (q, c k, a k) \\<Longrightarrow>\n    interfree_aux_right \\<Gamma> \\<Theta> F\n     (q, Parallel (map c [i..<j]),\n      AnnPar (map (\\<lambda>i. (a i, Q, A)) [i..<j]))", "apply (clarsimp simp: interfree_aux_right_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ac.\n       \\<lbrakk>\\<forall>k.\n                   i \\<le> k \\<and> k < j \\<longrightarrow>\n                   (\\<forall>aa ac.\n                       atomicsR \\<Gamma> \\<Theta> (a k) (c k)\n                        (aa, ac) \\<longrightarrow>\n                       \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                       (q \\<inter> aa) ac q, q);\n        atomicsR \\<Gamma> \\<Theta>\n         (AnnPar (map (\\<lambda>i. (a i, Q, A)) [i..<j]))\n         (Parallel (map c [i..<j])) (aa, ac)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) ac q, q", "apply (erule atomicsR.cases; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia aa b.\n       \\<lbrakk>\\<forall>k.\n                   i \\<le> k \\<and> k < j \\<longrightarrow>\n                   (\\<forall>aa ac.\n                       atomicsR \\<Gamma> \\<Theta> (a k) (c k)\n                        (aa, ac) \\<longrightarrow>\n                       \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                       (q \\<inter> aa) ac q, q);\n        ia < j - i;\n        atomicsR \\<Gamma> \\<Theta> (a (i + ia)) (c (i + ia))\n         (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) b q, q", "apply (rename_tac ia aa b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia aa b.\n       \\<lbrakk>\\<forall>k.\n                   i \\<le> k \\<and> k < j \\<longrightarrow>\n                   (\\<forall>aa ac.\n                       atomicsR \\<Gamma> \\<Theta> (a k) (c k)\n                        (aa, ac) \\<longrightarrow>\n                       \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                       (q \\<inter> aa) ac q, q);\n        ia < j - i;\n        atomicsR \\<Gamma> \\<Theta> (a (i + ia)) (c (i + ia))\n         (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) b q, q", "apply (drule_tac x=\"i+ia\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia aa b.\n       \\<lbrakk>ia < j - i;\n        atomicsR \\<Gamma> \\<Theta> (a (i + ia)) (c (i + ia)) (aa, b);\n        i \\<le> i + ia \\<and> i + ia < j \\<longrightarrow>\n        (\\<forall>aa ac.\n            atomicsR \\<Gamma> \\<Theta> (a (i + ia)) (c (i + ia))\n             (aa, ac) \\<longrightarrow>\n            \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n            (q \\<inter> aa) ac q, q)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (q \\<inter> aa) b q, q", "by fastforce"], ["", "lemma Seq_inter_right: \n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1); interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow> \n  interfree_aux_right \\<Gamma> \\<Theta> F (q, Seq c\\<^sub>1 c\\<^sub>2, AnnComp a1 a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1);\n     interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F\n                       (q, Seq c\\<^sub>1 c\\<^sub>2, AnnComp a1 a2)", "by (auto simp add: interfree_aux_right_def elim: atomicsR.cases)"], ["", "lemma Catch_inter_right:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1); interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow>\n  interfree_aux_right \\<Gamma> \\<Theta> F (q, Catch c\\<^sub>1 c\\<^sub>2, AnnComp a1 a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1);\n     interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F\n                       (q, Catch c\\<^sub>1 c\\<^sub>2, AnnComp a1 a2)", "by (auto simp add: interfree_aux_right_def elim: atomicsR.cases)"], ["", "lemma While_inter_aux_any: \"interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, abr), c, P) \\<Longrightarrow>\n  interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, abr), While b c, AnnWhile R I P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interfree_aux \\<Gamma> \\<Theta> F\n     (Any, (AnyAnn, q, abr), c, P) \\<Longrightarrow>\n    interfree_aux \\<Gamma> \\<Theta> F\n     (Any, (AnyAnn, q, abr), While b c, AnnWhile R I P)", "by (auto simp add:  interfree_aux_def\n          elim: atomicsR.cases[where ?a1.0=\"AnnWhile _ _ _\"] )"], ["", "lemma While_inter_right:\n  \"interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a)\n     \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F (q, While b c, AnnWhile r i a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interfree_aux_right \\<Gamma> \\<Theta> F (q, c, a) \\<Longrightarrow>\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, While b c, AnnWhile r i a)", "by(auto simp: interfree_aux_right_def elim: atomicsR.cases)"], ["", "lemma Cond_inter_aux_any:\n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), c\\<^sub>1, a1); interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow> \n   interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), Cond b c\\<^sub>1 c\\<^sub>2, AnnBin r a1 a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F\n              (Any, (AnyAnn, q, a), c\\<^sub>1, a1);\n     interfree_aux \\<Gamma> \\<Theta> F\n      (Any, (AnyAnn, q, a), c\\<^sub>2, a2)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Any, (AnyAnn, q, a), Cond b c\\<^sub>1 c\\<^sub>2,\n                        AnnBin r a1 a2)", "by (fastforce simp add:  interfree_aux_def \n               elim: atomicsR.cases[where ?a1.0=\"AnnBin _ _ _\"])"], ["", "lemma Cond_inter_right:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1); interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow> \n   interfree_aux_right \\<Gamma> \\<Theta> F (q, Cond b c\\<^sub>1 c\\<^sub>2, AnnBin r a1 a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>1, a1);\n     interfree_aux_right \\<Gamma> \\<Theta> F (q, c\\<^sub>2, a2)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux_right \\<Gamma> \\<Theta> F\n                       (q, Cond b c\\<^sub>1 c\\<^sub>2, AnnBin r a1 a2)", "by(auto simp: interfree_aux_right_def elim: atomicsR.cases)"], ["", "lemma Basic_inter_aux: \n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann); \n    interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann) \\<rbrakk> \\<Longrightarrow> \n    interfree_aux \\<Gamma> \\<Theta> F (Basic f, (AnnExpr r, q, a), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Basic f, (AnnExpr r, q, a), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma Skip_inter_aux:\n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann) \\<rbrakk> \\<Longrightarrow>\n    interfree_aux \\<Gamma> \\<Theta> F (Skip, (AnnExpr r, q, a), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Skip, (AnnExpr r, q, a), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma Throw_inter_aux:\n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann) \\<rbrakk> \\<Longrightarrow>\n    interfree_aux \\<Gamma> \\<Theta> F (Throw, (AnnExpr r, q, a), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Throw, (AnnExpr r, q, a), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma Spec_inter_aux: \n  \"\\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann); \n    interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n    interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann) \\<rbrakk> \\<Longrightarrow> \n    interfree_aux \\<Gamma> \\<Theta> F (Spec rel, (AnnExpr r, q, a), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (a, com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Spec rel, (AnnExpr r, q, a), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "(*lemma Seq_inter_aux_any: \n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), c\\<^sub>1, a1);\n    interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), c\\<^sub>2, a2) \\<rbrakk>\\<Longrightarrow> \n  interfree_aux \\<Gamma> \\<Theta> F (Any, (AnyAnn, q, a), Seq c\\<^sub>1 c\\<^sub>2, AnnComp a1 a2)\"\n by (fastforce simp add:  interfree_aux_def interfree_aux_right_def\n               elim: atomicsR.cases[where ?a1.0=\"AnnComp _ _\"])*)"], ["", "lemma Seq_inter_aux:\n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>1, (r\\<^sub>1, pre r\\<^sub>2, A), com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann) \\<rbrakk>\n   \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (Seq c\\<^sub>1 c\\<^sub>2, (AnnComp r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F\n              (c\\<^sub>1, (r\\<^sub>1, pre r\\<^sub>2, A), com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F\n      (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Seq c\\<^sub>1 c\\<^sub>2,\n                        (AnnComp r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma Catch_inter_aux:\n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>1, (r\\<^sub>1, Q, pre r\\<^sub>2), com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann) \\<rbrakk>\n   \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (Catch c\\<^sub>1 c\\<^sub>2, (AnnComp r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F\n              (c\\<^sub>1, (r\\<^sub>1, Q, pre r\\<^sub>2), com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F\n      (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Catch c\\<^sub>1 c\\<^sub>2,\n                        (AnnComp r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma Cond_inter_aux: \n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n    interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>1, (r\\<^sub>1, Q, A), com, ann); \n    interfree_aux \\<Gamma> \\<Theta> F (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann) \\<rbrakk>\n \\<Longrightarrow>  interfree_aux \\<Gamma> \\<Theta> F (Cond b c\\<^sub>1 c\\<^sub>2, (AnnBin r r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F\n      (c\\<^sub>1, (r\\<^sub>1, Q, A), com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F\n      (c\\<^sub>2, (r\\<^sub>2, Q, A), com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Cond b c\\<^sub>1 c\\<^sub>2,\n                        (AnnBin r r\\<^sub>1 r\\<^sub>2, Q, A), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma While_inter_aux: \n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann); \n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c, (P, i, A), com, ann) \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (While b c, (AnnWhile r i P, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c, (P, i, A), com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (While b c, (AnnWhile r i P, Q, A), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma Await_inter_aux: \n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann); \n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann); \n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann) \\<rbrakk>\n  \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (Await b e, (AnnRec r ae, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Await b e, (AnnRec r ae, Q, A), com, ann)", "by (auto simp: interfree_aux_def interfree_aux_right_def elim: assertionsR.cases)"], ["", "lemma Call_inter_aux:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (f, (P, Q, A), com, ann);\n     n < length as; \\<Gamma> p = Some f;\n     as ! n = P; \\<Theta> p = Some as \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (Call p, (AnnCall r n, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (f, (P, Q, A), com, ann);\n     n < length as; \\<Gamma> p = Some f; as ! n = P;\n     \\<Theta> p = Some as\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Call p, (AnnCall r n, Q, A), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma DynCom_inter_aux:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann); \n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann);\n     \\<And>s. s\\<in>r \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (f s, (P, Q, A), com, ann) \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (DynCom f, (AnnRec r P, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann);\n     \\<And>s.\n        s \\<in> r \\<Longrightarrow>\n        interfree_aux \\<Gamma> \\<Theta> F\n         (f s, (P, Q, A), com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (DynCom f, (AnnRec r P, Q, A), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "lemma Guard_inter_aux:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c, (P, Q, A), com, ann) \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (Guard f g c, (AnnRec r P, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (r, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux \\<Gamma> \\<Theta> F (c, (P, Q, A), com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Guard f g c, (AnnRec r P, Q, A), com, ann)", "by (auto elim: assertionsR.cases simp: interfree_aux_def interfree_aux_right_def)"], ["", "definition\n  inter_aux_Par :: \"('s,'p,'f) body \\<Rightarrow> ('s,'p,'f) proc_assns \\<Rightarrow> 'f set \\<Rightarrow>\n                    (('s, 'p, 'f) com list \\<times> (('s, 'p, 'f) ann_triple) list \\<times> ('s, 'p, 'f) com \\<times> ('s, 'p, 'f) ann) \\<Rightarrow> bool\" where\n  \"inter_aux_Par \\<Gamma> \\<Theta> F \\<equiv>\n     \\<lambda>(cs, as, c, a). \\<forall>i < length cs. interfree_aux \\<Gamma> \\<Theta> F (cs ! i, as ! i, c, a)\""], ["", "lemma inter_aux_Par_Empty: \"inter_aux_Par \\<Gamma> \\<Theta> F ([], [], c, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inter_aux_Par \\<Gamma> \\<Theta> F ([], [], c, a)", "by(simp add:inter_aux_Par_def)"], ["", "lemma inter_aux_Par_List:\n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (x, a, y, a');\n  inter_aux_Par \\<Gamma> \\<Theta> F (xs, as, y, a')\\<rbrakk> \n  \\<Longrightarrow> inter_aux_Par \\<Gamma> \\<Theta> F (x#xs, a#as, y, a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, a');\n     inter_aux_Par \\<Gamma> \\<Theta> F (xs, as, y, a')\\<rbrakk>\n    \\<Longrightarrow> inter_aux_Par \\<Gamma> \\<Theta> F\n                       (x # xs, a # as, y, a')", "apply (simp add: inter_aux_Par_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, a');\n     \\<forall>i<length xs.\n        interfree_aux \\<Gamma> \\<Theta> F (xs ! i, as ! i, y, a')\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc (length xs).\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, y, a')", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, a');\n        \\<forall>i<length xs.\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, y, a')\\<rbrakk>\n       \\<Longrightarrow> i < Suc (length xs) \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, y, a')", "apply (rename_tac v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, a');\n        \\<forall>i<length xs.\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, y, a')\\<rbrakk>\n       \\<Longrightarrow> v < Suc (length xs) \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! v, (a # as) ! v, y, a')", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, a');\n        \\<forall>i<length xs.\n           interfree_aux \\<Gamma> \\<Theta> F (xs ! i, as ! i, y, a');\n        v = 0\\<rbrakk>\n       \\<Longrightarrow> v < Suc (length xs) \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! v, (a # as) ! v, y, a')\n 2. \\<And>v nat.\n       \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, a');\n        \\<forall>i<length xs.\n           interfree_aux \\<Gamma> \\<Theta> F (xs ! i, as ! i, y, a');\n        v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc (length xs) \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! v, (a # as) ! v, y, a')", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inter_aux_Par_Map: \"\\<forall>k. i\\<le>k \\<and> k<j \\<longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (c k, Q k, x, a)\n \\<Longrightarrow> inter_aux_Par \\<Gamma> \\<Theta> F (map c [i..<j], map Q [i..<j], x, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       i \\<le> k \\<and> k < j \\<longrightarrow>\n       interfree_aux \\<Gamma> \\<Theta> F (c k, Q k, x, a) \\<Longrightarrow>\n    inter_aux_Par \\<Gamma> \\<Theta> F (map c [i..<j], map Q [i..<j], x, a)", "by(force simp add: inter_aux_Par_def less_diff_conv)"], ["", "lemma Parallel_inter_aux:\n  \"\\<lbrakk> interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (\\<Inter> (set (map postcond as)), com, ann);\n     inter_aux_Par \\<Gamma> \\<Theta> F (cs, as, com, ann) \\<rbrakk> \\<Longrightarrow>\n     interfree_aux \\<Gamma> \\<Theta> F (Parallel cs, (AnnPar as, Q, A), com, ann)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux_right \\<Gamma> \\<Theta> F (Q, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F (A, com, ann);\n     interfree_aux_right \\<Gamma> \\<Theta> F\n      (\\<Inter> (set (map (\\<lambda>a. fst (snd a)) as)), com, ann);\n     inter_aux_Par \\<Gamma> \\<Theta> F (cs, as, com, ann)\\<rbrakk>\n    \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                       (Parallel cs, (AnnPar as, Q, A), com, ann)", "apply (clarsimp simp: interfree_aux_def interfree_aux_right_def inter_aux_Par_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c a.\n       \\<lbrakk>\\<forall>aa ac.\n                   atomicsR \\<Gamma> \\<Theta> ann com\n                    (aa, ac) \\<longrightarrow>\n                   \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                   (Q \\<inter> aa) ac Q, Q;\n        \\<forall>aa ac.\n           atomicsR \\<Gamma> \\<Theta> ann com (aa, ac) \\<longrightarrow>\n           \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub> (A \\<inter> aa) ac A, A;\n        \\<forall>aa ac.\n           atomicsR \\<Gamma> \\<Theta> ann com (aa, ac) \\<longrightarrow>\n           \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n           ((\\<Inter>a\\<in>set as. fst (snd a)) \\<inter>\n            aa) ac (\\<Inter>a\\<in>set as.\n                       fst (snd a)), (\\<Inter>a\\<in>set as. fst (snd a));\n        \\<forall>i<length cs.\n           (case as ! i of\n            (P\\<^sub>1, Q\\<^sub>1, A\\<^sub>1) \\<Rightarrow>\n              \\<lambda>(c\\<^sub>2, P\\<^sub>2).\n                 \\<forall>p c.\n                    atomicsR \\<Gamma> \\<Theta> P\\<^sub>2 c\\<^sub>2\n                     (p, c) \\<longrightarrow>\n                    \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                    (Q\\<^sub>1 \\<inter> p) c Q\\<^sub>1, Q\\<^sub>1 \\<and>\n                    \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                    (A\\<^sub>1 \\<inter> p) c A\\<^sub>1, A\\<^sub>1 \\<and>\n                    (\\<forall>a.\n                        assertionsR \\<Gamma> \\<Theta> Q\\<^sub>1 A\\<^sub>1\n                         P\\<^sub>1 (cs ! i) a \\<longrightarrow>\n                        \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                        (a \\<inter> p) c a, a))\n            (com, ann);\n        atomicsR \\<Gamma> \\<Theta> ann com (p, c);\n        assertionsR \\<Gamma> \\<Theta> Q A (AnnPar as) (Parallel cs)\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Turnstile>\\<^bsub>/F\\<^esub>\n                         (a \\<inter> p) c a, a", "by (erule assertionsR.cases; fastforce)"], ["", "definition interfree_swap :: \"('s,'p,'f) body \\<Rightarrow> ('s,'p,'f) proc_assns \\<Rightarrow> 'f set \\<Rightarrow> (('s, 'p, 'f) com \\<times> (('s, 'p, 'f) ann \\<times> 's assn \\<times> 's assn) \\<times> ('s, 'p, 'f) com list \\<times> (('s, 'p, 'f) ann \\<times> 's assn \\<times> 's assn) list) \\<Rightarrow> bool\" where\n  \"interfree_swap \\<Gamma> \\<Theta> F \\<equiv> \\<lambda>(x, a, xs, as). \\<forall>y < length xs. interfree_aux \\<Gamma> \\<Theta> F (x, a, xs ! y, pres (as ! y))\n  \\<and> interfree_aux \\<Gamma> \\<Theta> F (xs ! y, as ! y, x, fst a)\""], ["", "lemma interfree_swap_Empty: \"interfree_swap  \\<Gamma> \\<Theta> F (x, a, [], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interfree_swap \\<Gamma> \\<Theta> F (x, a, [], [])", "by(simp add:interfree_swap_def)"], ["", "lemma interfree_swap_List:  \n  \"\\<lbrakk> interfree_aux \\<Gamma> \\<Theta> F (x, a, y, fst (a')); \n  interfree_aux \\<Gamma> \\<Theta> F (y, a', x, fst a);\n  interfree_swap \\<Gamma> \\<Theta> F (x, a, xs, as)\\<rbrakk> \n  \\<Longrightarrow> interfree_swap \\<Gamma> \\<Theta> F (x, a, y#xs, a'#as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, fst a');\n     interfree_aux \\<Gamma> \\<Theta> F (y, a', x, fst a);\n     interfree_swap \\<Gamma> \\<Theta> F (x, a, xs, as)\\<rbrakk>\n    \\<Longrightarrow> interfree_swap \\<Gamma> \\<Theta> F\n                       (x, a, y # xs, a' # as)", "apply (simp add: interfree_swap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, fst a');\n     interfree_aux \\<Gamma> \\<Theta> F (y, a', x, fst a);\n     \\<forall>y<length xs.\n        interfree_aux \\<Gamma> \\<Theta> F\n         (x, a, xs ! y, fst (as ! y)) \\<and>\n        interfree_aux \\<Gamma> \\<Theta> F\n         (xs ! y, as ! y, x, fst a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ya<Suc (length xs).\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          (x, a, (y # xs) ! ya, fst ((a' # as) ! ya)) \\<and>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((y # xs) ! ya, (a' # as) ! ya, x, fst a)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, fst a');\n        interfree_aux \\<Gamma> \\<Theta> F (y, a', x, fst a);\n        \\<forall>y<length xs.\n           interfree_aux \\<Gamma> \\<Theta> F\n            (x, a, xs ! y, fst (as ! y)) \\<and>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! y, as ! y, x, fst a)\\<rbrakk>\n       \\<Longrightarrow> ya < Suc (length xs) \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          (x, a, (y # xs) ! ya, fst ((a' # as) ! ya)) \\<and>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((y # xs) ! ya, (a' # as) ! ya, x, fst a)", "apply (rename_tac v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, fst a');\n        interfree_aux \\<Gamma> \\<Theta> F (y, a', x, fst a);\n        \\<forall>y<length xs.\n           interfree_aux \\<Gamma> \\<Theta> F\n            (x, a, xs ! y, fst (as ! y)) \\<and>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! y, as ! y, x, fst a)\\<rbrakk>\n       \\<Longrightarrow> v < Suc (length xs) \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          (x, a, (y # xs) ! v, fst ((a' # as) ! v)) \\<and>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((y # xs) ! v, (a' # as) ! v, x, fst a)", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, fst a');\n        interfree_aux \\<Gamma> \\<Theta> F (y, a', x, fst a);\n        \\<forall>y<length xs.\n           interfree_aux \\<Gamma> \\<Theta> F\n            (x, a, xs ! y, fst (as ! y)) \\<and>\n           interfree_aux \\<Gamma> \\<Theta> F (xs ! y, as ! y, x, fst a);\n        v = 0\\<rbrakk>\n       \\<Longrightarrow> v < Suc (length xs) \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          (x, a, (y # xs) ! v, fst ((a' # as) ! v)) \\<and>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((y # xs) ! v, (a' # as) ! v, x, fst a)\n 2. \\<And>v nat.\n       \\<lbrakk>interfree_aux \\<Gamma> \\<Theta> F (x, a, y, fst a');\n        interfree_aux \\<Gamma> \\<Theta> F (y, a', x, fst a);\n        \\<forall>y<length xs.\n           interfree_aux \\<Gamma> \\<Theta> F\n            (x, a, xs ! y, fst (as ! y)) \\<and>\n           interfree_aux \\<Gamma> \\<Theta> F (xs ! y, as ! y, x, fst a);\n        v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc (length xs) \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          (x, a, (y # xs) ! v, fst ((a' # as) ! v)) \\<and>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((y # xs) ! v, (a' # as) ! v, x, fst a)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma interfree_swap_Map: \"\\<forall>k. i\\<le>k \\<and> k<j \\<longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (x, a, c k, fst (Q k)) \n \\<and> interfree_aux \\<Gamma> \\<Theta> F (c k, (Q k), x, fst a)\n \\<Longrightarrow> interfree_swap \\<Gamma> \\<Theta> F (x, a, map c [i..<j], map Q [i..<j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       i \\<le> k \\<and> k < j \\<longrightarrow>\n       interfree_aux \\<Gamma> \\<Theta> F (x, a, c k, fst (Q k)) \\<and>\n       interfree_aux \\<Gamma> \\<Theta> F\n        (c k, Q k, x, fst a) \\<Longrightarrow>\n    interfree_swap \\<Gamma> \\<Theta> F (x, a, map c [i..<j], map Q [i..<j])", "by(force simp add: interfree_swap_def less_diff_conv)"], ["", "lemma interfree_Empty: \"interfree \\<Gamma> \\<Theta> F [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interfree \\<Gamma> \\<Theta> F [] []", "by(simp add:interfree_def)"], ["", "lemma interfree_List: \n  \"\\<lbrakk> interfree_swap \\<Gamma> \\<Theta> F (x, a, xs, as); interfree \\<Gamma> \\<Theta> F as xs \\<rbrakk> \\<Longrightarrow> interfree \\<Gamma> \\<Theta> F (a#as) (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interfree_swap \\<Gamma> \\<Theta> F (x, a, xs, as);\n     interfree \\<Gamma> \\<Theta> F as xs\\<rbrakk>\n    \\<Longrightarrow> interfree \\<Gamma> \\<Theta> F (a # as) (x # xs)", "apply (simp add: interfree_swap_def interfree_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y<length xs.\n                interfree_aux \\<Gamma> \\<Theta> F\n                 (x, a, xs ! y, fst (as ! y)) \\<and>\n                interfree_aux \\<Gamma> \\<Theta> F\n                 (xs ! y, as ! y, x, fst a);\n     \\<forall>i j.\n        i < length xs \\<and>\n        j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n        interfree_aux \\<Gamma> \\<Theta> F\n         (xs ! i, as ! i, xs ! j, fst (as ! j))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i j.\n                         i < Suc (length xs) \\<and>\n                         j < Suc (length xs) \\<and>\n                         i \\<noteq> j \\<longrightarrow>\n                         interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, (x # xs) ! j,\n                           fst ((a # as) ! j))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        i < Suc (length xs); j < Suc (length xs); i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, (x # xs) ! j,\n                           fst ((a # as) ! j))", "apply (rename_tac i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        i < Suc (length xs); j < Suc (length xs); i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, (x # xs) ! j,\n                           fst ((a # as) ! j))", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        i < Suc (length xs); j < Suc (length xs); i \\<noteq> j;\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, (x # xs) ! j,\n                           fst ((a # as) ! j))\n 2. \\<And>i j nat.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        i < Suc (length xs); j < Suc (length xs); i \\<noteq> j;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, (x # xs) ! j,\n                           fst ((a # as) ! j))", "apply (case_tac j)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        i < Suc (length xs); j < Suc (length xs); i \\<noteq> j; i = 0;\n        j = 0\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, (x # xs) ! j,\n                           fst ((a # as) ! j))\n 2. \\<And>i j nat.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        i < Suc (length xs); j < Suc (length xs); i \\<noteq> j; i = 0;\n        j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, (x # xs) ! j,\n                           fst ((a # as) ! j))\n 3. \\<And>i j nat.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        i < Suc (length xs); j < Suc (length xs); i \\<noteq> j;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          ((x # xs) ! i, (a # as) ! i, (x # xs) ! j,\n                           fst ((a # as) ! j))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j nat.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        nat < length xs; j < Suc (length xs); Suc nat \\<noteq> j;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          (xs ! nat, as ! nat, (x # xs) ! j,\n                           fst ((a # as) ! j))", "apply (case_tac j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j nat.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        nat < length xs; j < Suc (length xs); Suc nat \\<noteq> j;\n        i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          (xs ! nat, as ! nat, (x # xs) ! j,\n                           fst ((a # as) ! j))\n 2. \\<And>i j nat nata.\n       \\<lbrakk>\\<forall>y<length xs.\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (x, a, xs ! y, fst (as ! y)) \\<and>\n                   interfree_aux \\<Gamma> \\<Theta> F\n                    (xs ! y, as ! y, x, fst a);\n        \\<forall>i j.\n           i < length xs \\<and>\n           j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n           interfree_aux \\<Gamma> \\<Theta> F\n            (xs ! i, as ! i, xs ! j, fst (as ! j));\n        nat < length xs; j < Suc (length xs); Suc nat \\<noteq> j;\n        i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> interfree_aux \\<Gamma> \\<Theta> F\n                          (xs ! nat, as ! nat, (x # xs) ! j,\n                           fst ((a # as) ! j))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma interfree_Map: \n  \"(\\<forall>i j. a\\<le>i \\<and> i<b \\<and> a\\<le>j \\<and> j<b  \\<and> i\\<noteq>j \\<longrightarrow> interfree_aux \\<Gamma> \\<Theta> F (c i, A i, c j, pres (A j)))  \n  \\<Longrightarrow> interfree \\<Gamma> \\<Theta> F (map (\\<lambda>k. A k) [a..<b]) (map (\\<lambda>k. c k) [a..<b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       a \\<le> i \\<and>\n       i < b \\<and>\n       a \\<le> j \\<and> j < b \\<and> i \\<noteq> j \\<longrightarrow>\n       interfree_aux \\<Gamma> \\<Theta> F\n        (c i, A i, c j, fst (A j)) \\<Longrightarrow>\n    interfree \\<Gamma> \\<Theta> F (map A [a..<b]) (map c [a..<b])", "by (force simp add: interfree_def less_diff_conv)"], ["", "lemma list_lemmas: \"length []=0\" \"length (x#xs) = Suc(length xs)\"\n    \"(x#xs) ! 0 = x\" \"(x#xs) ! Suc n = xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length [] = 0 &&& length (x # xs) = Suc (length xs)) &&&\n    (x # xs) ! 0 = x &&& (x # xs) ! Suc n = xs ! n", "by simp_all"], ["", "lemma le_Suc_eq_insert: \"{i. i <Suc n} = insert n {i. i< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < Suc n} = insert n {i. i < n}", "by auto"], ["", "lemmas primrecdef_list = \"pre.simps\" strengthen_pre.simps"], ["", "lemmas ParallelConseq_list = INTER_eq Collect_conj_eq length_map length_upt length_append"], ["", "lemmas my_simp_list = list_lemmas fst_conv snd_conv\nnot_less0 refl le_Suc_eq_insert Suc_not_Zero Zero_not_Suc nat.inject\nCollect_mem_eq ball_simps option.simps primrecdef_list"], ["", "(* Push remaining subgoals into hyps to remove duplicates quickly *)"], ["", "ML \\<open>val hyp_tac = CSUBGOAL (fn (prem,i) => PRIMITIVE (fn thm =>\n    let\n      val thm' = Thm.permute_prems 0 (i-1) thm |> Goal.protect 1\n      val asm = Thm.assume prem\n    in\n      case (try (fn thm' => (Thm.implies_elim thm' asm)) thm') of\n      SOME thm => thm |> Goal.conclude |> Thm.permute_prems 0 (~(i-1))\n     | NONE => error (\"hyp_tac failed:\" ^ (@{make_string} (thm',asm)))\n    end\n  ))\n\\<close>"], ["", "ML \\<open>\n\n(*Remove a premise of the form 's \\<in> _' if s is not referred to anywhere*)\nfun remove_single_Bound_mem ctxt = SUBGOAL (fn (t, i) => let\n    val prems = Logic.strip_assums_hyp t\n    val concl = Logic.strip_assums_concl t\n    fun bd_member t = (case HOLogic.dest_Trueprop t\n        of Const (@{const_name \"Set.member\"}, _) $ Bound j $ _ => SOME j\n        | _ => NONE) handle TERM _ => NONE\n  in filter_prems_tac ctxt\n    (fn prem => case bd_member prem of NONE => true\n      | SOME j => let val xs = (filter (fn t => loose_bvar1 (t, j)) (concl :: prems))\n        in length xs <> 1 end)\n    i\n  end handle Subscript => no_tac)\n\\<close>"], ["", "named_theorems proc_simp"], ["", "named_theorems oghoare_simps"], ["", "lemmas guards.simps[oghoare_simps add]\n       ann_guards.simps[oghoare_simps add]"], ["", "ML \\<open>\n\nfun rt ctxt t i =\n  resolve_tac ctxt [t] i\n\nfun rts ctxt xs i =\n  resolve_tac ctxt xs i\n\nfun conjI_Tac ctxt tac i st = st |>\n       ( (EVERY [rt ctxt conjI i,\n          conjI_Tac ctxt tac (i+1),\n          tac i]) ORELSE (tac i) )\n\nfun get_oghoare_simps ctxt =\n Proof_Context.get_thms ctxt \"oghoare_simps\"\n\nfun simp ctxt extra =\n  simp_tac (put_simpset HOL_basic_ss ctxt addsimps extra)\n\nfun simp_only ctxt simps =\n  simp_tac ((clear_simpset ctxt) addsimps simps)\n\nfun prod_sel_simp ctxt =\n  simp_only ctxt @{thms prod.sel}\n\nfun oghoare_simp ctxt =\n   simp_only ctxt (get_oghoare_simps ctxt)\n\nfun ParallelConseq ctxt =\n  clarsimp_tac (put_simpset HOL_basic_ss ctxt addsimps (@{thms ParallelConseq_list} @ @{thms my_simp_list}))\n\nval enable_trace = false;\nfun trace str = if enable_trace then tracing str else ();\n\nfun HoareRuleTac (ctxt' as (ctxt,args)) i st =\n  (Cache_Tactics.SUBGOAL_CACHE (nth args 0)\n  (fn (_,i) => (SUBGOAL (fn (_,i) =>\n    (EVERY[rts ctxt @{thms Seq Catch SeqSeq SeqCatch} i,\n        HoareRuleTac ctxt' (i+1),\n        HoareRuleTac ctxt' i]\n    ORELSE\n    (FIRST[rts ctxt (@{thms SkipRule SeqSkipRule}) i,\n         rts ctxt (@{thms BasicRule SeqBasicRule}) i,\n         rts ctxt (@{thms ThrowRule SeqThrowRule}) i,\n         rts ctxt (@{thms SpecRule SeqSpecRule}) i,\n         EVERY[rt ctxt (@{thm SeqParallel}) i,\n               HoareRuleTac ctxt' (i+1)],\n         EVERY[rt ctxt  (@{thm ParallelConseqRule}) i,\n               ParallelConseq ctxt (i+2),\n               ParallelConseq ctxt (i+1),\n               ParallelTac ctxt' i],\n         EVERY[rt ctxt (@{thm CondRule}) i,\n               HoareRuleTac ctxt' (i+2),\n               HoareRuleTac ctxt' (i+1)],\n         EVERY[rt ctxt @{thm SeqCondRule} i,\n               HoareRuleTac ctxt' (i+1),\n               HoareRuleTac ctxt' i],\n         EVERY[rt ctxt  (@{thm WhileRule}) i,\n               HoareRuleTac ctxt' (i+3)],\n         EVERY[rt ctxt  (@{thm SeqWhileRule}) i,\n               HoareRuleTac ctxt' i],\n         EVERY[rt ctxt (@{thm AwaitRule}) i,\n               HoareRuleTac ctxt' (i+1),\n               simp ctxt (@{thms atom_com.simps}) i],\n         EVERY[rts ctxt (@{thms CallRule SeqCallRule}) i,\n               Call_asm_inst ctxt (i+2),\n               HoareRuleTac ctxt' (i+1)],\n         EVERY[rts ctxt (@{thms DynComRule SeqDynComRule}) i,\n               HoareRuleTac ctxt' (i+1)],\n         EVERY[rts ctxt (@{thms GuardRule}) i,\n               HoareRuleTac ctxt' (i+2)],\n         K all_tac i ])))\n         THEN_ALL_NEW hyp_tac) i)) i st\n\nand Call_asm_inst ctxt i = \n  let val proc_simps = Proof_Context.get_thms ctxt \"proc_simp\" @ @{thms list_lemmas} in\n    EVERY[rts ctxt proc_simps (i+3),\n         rts ctxt proc_simps (i+2),\n         rts ctxt proc_simps (i+1),\n        ParallelConseq ctxt i]\n    end\n\nand ParallelTac (ctxt' as (ctxt,args)) i =\n          EVERY[rt ctxt (@{thm ParallelRule}) i,\n                               ParallelConseq ctxt (i+2),\n                               interfree_Tac ctxt' (i+1),\n                               ParallelConseq ctxt i,\n                               MapAnn_Tac ctxt' i]\n\nand MapAnn_Tac (ctxt' as (ctxt,args)) i st = st |>\n    (FIRST[rt ctxt (@{thm MapAnnEmpty}) i,\n           EVERY[rt ctxt (@{thm MapAnnList}) i,\n                 MapAnn_Tac ctxt' (i+1),\n                 HoareRuleTac ctxt' i],\n            EVERY[rt ctxt (@{thm MapAnnMap}) i,\n                 rt ctxt (@{thm allI}) i, rt ctxt (@{thm impI}) i,\n                 HoareRuleTac ctxt' i]])\n\nand interfree_Tac (ctxt' as (ctxt,args)) i st = st |>\n   (FIRST[rt ctxt (@{thm interfree_Empty}) i,\n          EVERY[rt ctxt (@{thm interfree_List}) i,\n                interfree_Tac ctxt' (i+1),\n                interfree_swap_Tac ctxt' i],\n          EVERY[rt ctxt (@{thm interfree_Map}) i,\n                rt ctxt (@{thm allI}) i, rt ctxt (@{thm allI}) i, rt ctxt (@{thm impI}) i,\n                interfree_aux_Tac ctxt' i ]])\n\nand interfree_swap_Tac (ctxt' as (ctxt,args)) i st = st |>\n    (FIRST[rt ctxt (@{thm interfree_swap_Empty}) i,\n           EVERY[rt ctxt (@{thm interfree_swap_List}) i,\n                 interfree_swap_Tac ctxt' (i+2),\n                 interfree_aux_Tac ctxt' (i+1),\n                 interfree_aux_Tac ctxt' i ],\n           EVERY[rt ctxt (@{thm interfree_swap_Map}) i,\n                 rt ctxt (@{thm allI}) i, rt ctxt (@{thm impI}) i,\n                 conjI_Tac ctxt (interfree_aux_Tac ctxt') i]])\n\nand inter_aux_Par_Tac (ctxt' as (ctxt,args)) i st = st |>\n    (FIRST[rt ctxt (@{thm inter_aux_Par_Empty}) i,\n           EVERY[rt ctxt (@{thm inter_aux_Par_List}) i,\n                 inter_aux_Par_Tac ctxt' (i+1),\n                 interfree_aux_Tac ctxt' i ],\n           EVERY[rt ctxt (@{thm inter_aux_Par_Map}) i,\n                 rt ctxt (@{thm allI}) i, rt ctxt (@{thm impI}) i,\n                 interfree_aux_Tac ctxt' i]])\n\nand interfree_aux_Tac ctxt' i = dest_inter_aux_Tac ctxt' i\n\nand dest_inter_aux_Tac (ctxt' as (ctxt,args)) i st =\n  (Cache_Tactics.SUBGOAL_CACHE (nth args 1)\n  (fn (_,i) => (SUBGOAL (fn (_,i) =>\n     (TRY (REPEAT (EqSubst.eqsubst_tac ctxt [0] @{thms prod.sel} i)) THEN\n     FIRST[EVERY[rts ctxt (@{thms Skip_inter_aux Throw_inter_aux Basic_inter_aux Spec_inter_aux}) i,\n                 dest_inter_right_Tac ctxt' (i+2),\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rts ctxt (@{thms Seq_inter_aux Catch_inter_aux}) i,\n                 dest_inter_aux_Tac ctxt' (i+1),\n                 dest_inter_aux_Tac ctxt' (i+0)],\n           EVERY[rt ctxt (@{thm Cond_inter_aux}) i,\n                 dest_inter_aux_Tac ctxt' (i+2),\n                 dest_inter_aux_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm While_inter_aux}) i,\n                 dest_inter_aux_Tac ctxt' (i+2),\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm Await_inter_aux}) i,\n                 dest_inter_right_Tac ctxt' (i+2),\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' (i+0)],\n           EVERY[rt ctxt (@{thm Call_inter_aux}) i,\n                 Call_asm_inst ctxt (i+2),\n                 dest_inter_aux_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm DynCom_inter_aux}) i,\n                 dest_inter_aux_Tac ctxt' (i+3),\n                 dest_inter_right_Tac ctxt' (i+2),\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm Guard_inter_aux}) i,\n                 dest_inter_aux_Tac ctxt' (i+2),\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm Parallel_inter_aux}) i,\n                 inter_aux_Par_Tac ctxt' (i+3),\n                 dest_inter_right_Tac ctxt' (i+2),\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           dest_inter_right_Tac ctxt' i]))\n         THEN_ALL_NEW hyp_tac) i)) i st\n\nand dest_inter_right_Tac (ctxt' as (ctxt,args)) i st =\n  (Cache_Tactics.SUBGOAL_CACHE (nth args 2)\n  (fn (_,i) =>\n     FIRST[EVERY[rts ctxt (@{thms Skip_inter_right Throw_inter_right\n                                  Basic_inter_right Spec_inter_right}) i,\n                 HoareRuleTac ctxt' i],\n           EVERY[rts ctxt (@{thms Seq_inter_right Catch_inter_right}) i,\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm Cond_inter_right}) i,\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm While_inter_right}) i,\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm Await_inter_right}) i,\n                 HoareRuleTac ctxt' (i+1),\n                 simp ctxt (@{thms atom_com.simps}) i],\n           EVERY[rt ctxt (@{thm Call_inter_right}) i,\n                   Call_asm_inst ctxt (i+1),\n                   dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm DynCom_inter_right}) i,\n                   dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm Guard_inter_right}) i,\n                   dest_inter_right_Tac ctxt' i],\n           rt ctxt (@{thm Parallel_inter_right_empty}) i,\n           EVERY[rt ctxt (@{thm Parallel_inter_right_List}) i,\n                 dest_inter_right_Tac ctxt' (i+1),\n                 dest_inter_right_Tac ctxt' i],\n           EVERY[rt ctxt (@{thm Parallel_inter_right_Map}) i,\n                 rt ctxt (@{thm allI}) i, rt ctxt (@{thm impI}) i,\n                 dest_inter_right_Tac ctxt' i],\n           K all_tac i])) i st\n\\<close>"], ["", "ML \\<open>\n\nfun oghoare_tac ctxt =\n   SUBGOAL (fn (_, i) =>\n   TRY (prod_sel_simp ctxt i)\n   THEN TRY (oghoare_simp ctxt i)\n   THEN Cache_Tactics.cacheify_tactic 3 HoareRuleTac ctxt i)\n\n(* oghoare_tac' fails if oghoare_tac does not do anything *)\nfun oghoare_tac' ctxt i goal =\n  let\n    val results = oghoare_tac ctxt i goal;\n  in\n    if (Thm.eq_thm (results |> Seq.hd, goal) handle Option => false)\n    then no_tac goal\n    else results\n  end;\n\nfun oghoare_parallel_tac ctxt i = \n  TRY (oghoare_simp ctxt i) THEN\n  Cache_Tactics.cacheify_tactic 3 ParallelTac ctxt i\nfun oghoare_interfree_tac ctxt i =\n  TRY (oghoare_simp ctxt i) THEN\n  Cache_Tactics.cacheify_tactic 3 interfree_Tac ctxt i\nfun oghoare_interfree_aux_tac ctxt i =\n  TRY (oghoare_simp ctxt i) THEN\n  Cache_Tactics.cacheify_tactic 3 interfree_aux_Tac ctxt i\n\\<close>"], ["", "method_setup oghoare = \\<open>\n  Scan.succeed (SIMPLE_METHOD' o oghoare_tac')\\<close>\n  \"verification condition generator for the oghoare logic\""], ["", "method_setup oghoare_parallel = \\<open>\n  Scan.succeed (SIMPLE_METHOD' o oghoare_parallel_tac)\\<close>\n  \"verification condition generator for the oghoare logic\""], ["", "method_setup oghoare_interfree = \\<open>\n  Scan.succeed (SIMPLE_METHOD' o oghoare_interfree_tac)\\<close>\n  \"verification condition generator for the oghoare logic\""], ["", "method_setup oghoare_interfree_aux = \\<open>\n  Scan.succeed (SIMPLE_METHOD' o oghoare_interfree_aux_tac)\\<close>\n  \"verification condition generator for the oghoare logic\""], ["", "end"]]}