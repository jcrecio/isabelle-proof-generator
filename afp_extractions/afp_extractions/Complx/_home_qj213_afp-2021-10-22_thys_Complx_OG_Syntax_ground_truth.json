{"file_name": "/home/qj213/afp-2021-10-22/thys/Complx/OG_Syntax.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complx", "problem_names": ["lemmas ann.simps[oghoare_simps] com.simps[oghoare_simps]"], "translations": [["", "lemmas ann.simps[oghoare_simps] com.simps[oghoare_simps]"], ["", "syntax\n  \"_quote\"     :: \"'b \\<Rightarrow> ('a \\<Rightarrow> 'b)\"                (\"(\\<guillemotleft>_\\<guillemotright>)\" [0] 1000)\n  \"_antiquote\" :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'b\"                (\"\\<acute>_\" [1000] 1000)\n  \"_Assert\"    :: \"'a \\<Rightarrow> 'a set\"                    (\"(\\<lbrace>_\\<rbrace>)\" [0] 1000)"], ["", "translations\n  \"\\<lbrace>b\\<rbrace>\" \\<rightharpoonup> \"CONST Collect \\<guillemotleft>b\\<guillemotright>\""], ["", "parse_translation \\<open>\n  let\n    fun quote_tr [t] = Syntax_Trans.quote_tr @{syntax_const \"_antiquote\"} t\n      | quote_tr ts = raise TERM (\"quote_tr\", ts);\n  in [(@{syntax_const \"_quote\"}, K quote_tr)] end\n\\<close>"], ["", "syntax\n  \"_fst\" :: \"'a \\<times> 'b \\<Rightarrow> 'a\"  (\"_\\<^sub>,\" [60] 61)\n  \"_snd\" :: \"'a \\<times> 'b \\<Rightarrow> 'b\"  (\"_\\<^sub>.\" [60] 61)"], ["", "parse_translation \\<open>\n  let\n    fun fst_tr ((Const (@{const_syntax Pair}, _) $ p $ c)\n          :: ts) = p;\n\n    fun snd_tr ((Const (@{const_syntax Pair}, _) $ p $ c)\n          :: ts) = c;\n  in\n   [(@{syntax_const \"_fst\"}, K fst_tr),\n    (@{syntax_const \"_snd\"}, K snd_tr)]\n  end\n\\<close>"], ["", "text\\<open>Syntax for commands and for assertions and boolean expressions in \n commands \\<open>com\\<close> and annotated commands \\<open>ann_com\\<close>.\\<close>"], ["", "syntax\n  \"_Annotation\" :: \"('s,'p,'f) ann_com \\<Rightarrow> ('s, 'p, 'f) ann\"  (\"_\\<^sub>?\" [60] 61)\n  \"_Command\" :: \"('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) com\"  (\"_\\<^sub>!\" [60] 61)"], ["", "parse_translation \\<open>\n  let\n    fun ann_tr ((Const (@{const_syntax AnnCom}, _) $ p $ c)\n          :: ts) = p\n      | ann_tr (p :: ts) =\n          Const (@{const_syntax ann}, dummyT) $ p\n      | ann_tr x = raise TERM (\"ann_tr\", x);\n\n    fun com_tr ((Const (@{const_syntax AnnCom}, _) $ p $ c)\n          :: ts) = c\n      | com_tr (c :: ts) =\n          Const (@{const_syntax com}, dummyT) $ c\n      | com_tr x = raise TERM (\"com_tr\", x);\n  in\n   [(@{syntax_const \"_Annotation\"}, K ann_tr),\n    (@{syntax_const \"_Command\"}, K com_tr)]\n  end\n\\<close>"], ["", "syntax\n  \"_Seq\"  :: \"('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                   (\"(_,,/ _)\" [55, 56] 55)\n  \"_AnnSeq\"  :: \"('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                   (\"(_;;//_)\" [55, 56] 55)"], ["", "translations\n  \"_Seq c1 c2\" \\<rightharpoonup> \"CONST AnnCom (CONST AnnComp (c1\\<^sub>?) (c2\\<^sub>?)) (CONST Seq (c1\\<^sub>!) (c2\\<^sub>!))\"\n  \"_AnnSeq c1 c2\" \\<rightharpoonup> \"CONST AnnCom (CONST AnnComp (c1\\<^sub>?) (c2\\<^sub>?)) (CONST Seq (c1\\<^sub>!) (c2\\<^sub>!))\""], ["", "syntax\n  \"_Assign\"    :: \"idt \\<Rightarrow> 'b \\<Rightarrow> ('s,'p,'f) ann_com\"\n                   (\"(\\<acute>_ :=/ _)\" [70, 65] 61)\n  \"_AnnAssign\" :: \"'s assn \\<Rightarrow> idt \\<Rightarrow> 'b \\<Rightarrow> ('s,'p,'f) ann_com\"\n                   (\"(_//\\<acute>_ :=/ _)\" [90,70,65] 61)"], ["", "definition \"FAKE_ANN \\<equiv> UNIV\""], ["", "translations\n  \"r \\<acute>x := a\" \\<rightharpoonup> \"CONST AnnCom (CONST AnnExpr r)\n                               (CONST Basic \\<guillemotleft>\\<acute>(_update_name x (\\<lambda>_. a))\\<guillemotright>)\"\n  \"\\<acute>x := a\" \\<rightleftharpoons> \"CONST FAKE_ANN \\<acute>x := a\""], ["", "abbreviation\n  \"update_var f S s \\<equiv> (\\<lambda>v. f (\\<lambda>_. v) s) ` S\""], ["", "abbreviation\n  \"fun_to_rel f \\<equiv>  \\<Union> ((\\<lambda>s. (\\<lambda>v. (s, v)) ` f s) ` UNIV)\""], ["", "syntax\n  \"_Spec\"      :: \"idt \\<Rightarrow> 'b \\<Rightarrow> ('s,'p,'f) ann_com\"\n                   (\"(\\<acute>_ :\\<in>/ _)\" [70, 65] 61)\n  \"_AnnSpec\"   :: \"'a assn \\<Rightarrow> idt \\<Rightarrow> 'b \\<Rightarrow> ('s,'p,'f) ann_com\"\n                   (\"(_//\\<acute>_ :\\<in>/ _)\" [90,70,65] 61)"], ["", "translations\n  \"r \\<acute>x :\\<in> S\" \\<rightharpoonup> \"CONST AnnCom (CONST AnnExpr r)\n                               (CONST Spec (CONST fun_to_rel \\<guillemotleft>\\<acute>(CONST update_var (_update_name x) S)\\<guillemotright>))\"\n  \"\\<acute>x :\\<in> S\" \\<rightleftharpoons> \"CONST FAKE_ANN \\<acute>x :\\<in> S\""], ["", "nonterminal grds and grd"], ["", "syntax\n  \"_AnnCond1\"    :: \"'s assn \\<Rightarrow> 's bexp  \\<Rightarrow> ('s,'p,'f) ann_com  \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_//IF _//(2THEN/ (_))//(2ELSE/ (_))//FI)\"  [90,0,0,0] 61)\n  \"_AnnCond2\"    :: \"'s assn \\<Rightarrow> 's bexp  \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_//IF _//(2THEN/ (_))//FI)\"  [90,0,0] 61)\n  \"_AnnWhile\"    :: \"'s assn \\<Rightarrow> 's bexp  \\<Rightarrow> 's assn \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\" \n                    (\"(_//WHILE _/ INV _//(2DO/ (_))//OD)\"  [90,0,0,0] 61)\n  \"_AnnAwait\"    :: \"'s assn \\<Rightarrow> 's bexp  \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_//AWAIT _/ (2THEN/ (_))/ END)\"  [90,0,0] 61)\n  \"_AnnAtom\"     :: \"'s assn  \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_//\\<langle>_\\<rangle>)\" [90,0] 61)\n  \"_AnnWait\"     :: \"'s assn \\<Rightarrow> 's bexp \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_//WAIT _/ END)\" [90,0] 61)\n\n  \"_Cond\"        :: \"'s bexp \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\" \n                    (\"(IF _//(2THEN/ (_))//(2ELSE/ (_))//FI)\" [0, 0, 0] 61)\n  \"_Cond2\"       :: \"'s bexp \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(IF _//(2THEN/ (_))//FI)\" [0,0] 56)\n  \"_While_inv\"   :: \"'s bexp \\<Rightarrow> 's assn \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(WHILE _/ INV _//(2DO/ (_))//OD)\"  [0, 0, 0] 61)\n  \"_While\"       :: \"'s bexp \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(WHILE _//(2DO/ (_))//OD)\"  [0, 0] 61)\n  \"_Await\"       :: \"'s bexp  \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(AWAIT _/ (2THEN/ (_))/ END)\"  [0,0] 61)\n  \"_Atom\"        :: \"('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(\\<langle>_\\<rangle>)\" [0] 61)\n  \"_Wait\"        :: \"'s bexp \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(WAIT _/ END)\" [0] 61)\n  \"_grd\"         :: \"'f \\<Rightarrow> 's bexp \\<Rightarrow> grd\"\n                    (\"'(_, _')\" [1000] 1000)\n  \"_last_grd\"    :: \"grd \\<Rightarrow> grds\"   (\"_\" 1000)\n  \"_grds\"        :: \"[grd, grds] \\<Rightarrow> grds\"\n                    (\"(_,/ _)\" [999,1000] 1000)\n  \"_guards\"      :: \"'s assn \\<Rightarrow> grds  \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_//(2_ \\<longmapsto>/ (_)))\" [90, 0, 56] 61)\n  \"_Throw\"       :: \"('s,'p,'f) ann_com\"\n                    (\"THROW\" 61)\n  \"_AnnThrow\"    :: \"'s assn \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_/ THROW)\" [90] 61)\n  \"_Try_Catch\"   :: \"('s,'p,'f) ann_com \\<Rightarrow>('s,'p,'f) ann_com \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"((2TRY/ (_))//(2CATCH/ (_))/ END)\"  [0,0] 71)\n  \"_AnnCallX\"    :: \"'s assn \\<Rightarrow> ('s \\<Rightarrow> 's) \\<Rightarrow> 's assn  \\<Rightarrow> 'p \\<Rightarrow> nat \\<Rightarrow> ('s \\<Rightarrow> 's \\<Rightarrow> 's) \\<Rightarrow> ('s\\<Rightarrow>'s\\<Rightarrow>('s,'p,'f) com) \\<Rightarrow> 's assn \\<Rightarrow> 's assn \\<Rightarrow> 's assn \\<Rightarrow> 's assn \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_//(2CALLX/ (_)//_/ _/ _//_/ _//_/ _//_/ _))\"\n                      [90,1000,0,1000,0,1000,1000,0,0,0,0] 61)\n  \"_AnnSCall\"    :: \"'s assn \\<Rightarrow> 'p \\<Rightarrow> nat \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_//SCALL _/ _)\" [90,0,0] 61)\n  \"_Skip\"        :: \"('s,'p,'f) ann_com\"\n                    (\"SKIP\" 61)\n  \"_AnnSkip\"     :: \"'s assn \\<Rightarrow> ('s,'p,'f) ann_com\"\n                    (\"(_/ SKIP)\" [90] 61)"], ["", "translations\n  \"r IF b THEN c1 ELSE c2 FI\" \\<rightharpoonup>\n    \"CONST AnnCom (CONST AnnBin r (c1\\<^sub>?) (c2\\<^sub>?)) (CONST Cond \\<lbrace>b\\<rbrace> (c1\\<^sub>!) (c2\\<^sub>!))\"\n  \"r IF b THEN c FI\" \\<rightharpoonup> \"r IF b THEN c ELSE SKIP FI\"\n  \"r WHILE b INV i DO c OD\" \\<rightharpoonup>\n    \"CONST AnnCom (CONST AnnWhile r i (c\\<^sub>?)) (CONST While \\<lbrace>b\\<rbrace> (c\\<^sub>!))\"\n  \"r AWAIT b THEN c END\" \\<rightharpoonup>\n    \"CONST AnnCom (CONST AnnRec r (c\\<^sub>?)) (CONST Await \\<lbrace>b\\<rbrace> (c\\<^sub>!))\"\n  \"r \\<langle>c\\<rangle>\" \\<rightleftharpoons> \"r AWAIT CONST True THEN c END\"\n  \"r WAIT b END\" \\<rightleftharpoons> \"r AWAIT b THEN SKIP END\"\n\n  \"IF b THEN c1 ELSE c2 FI\" \\<rightleftharpoons> \"CONST FAKE_ANN IF b THEN c1 ELSE c2 FI\"\n  \"IF b THEN c FI\" \\<rightleftharpoons> \"CONST FAKE_ANN IF b THEN c ELSE SKIP FI\"\n  \"WHILE b DO c OD\" \\<rightleftharpoons> \"CONST FAKE_ANN WHILE b INV CONST FAKE_ANN DO c OD\"\n  \"WHILE b INV i DO c OD\" \\<rightleftharpoons> \"CONST FAKE_ANN WHILE b INV i DO c OD\"\n  \"AWAIT b THEN c END\" \\<rightleftharpoons> \"CONST FAKE_ANN AWAIT b THEN c END\"\n  \"\\<langle>c\\<rangle>\" \\<rightleftharpoons> \"CONST FAKE_ANN AWAIT CONST True THEN c END\"\n  \"WAIT b END\" \\<rightleftharpoons> \"AWAIT b THEN SKIP END\"\n\n  \"_grd f g\" \\<rightharpoonup> \"(f, g)\"\n  \"_grds g gs\" \\<rightharpoonup> \"g#gs\"\n  \"_last_grd g\" \\<rightharpoonup> \"[g]\"\n  \"_guards r gs c\" \\<rightharpoonup>\n    \"CONST AnnCom (CONST ann_guards r gs (c\\<^sub>?)) (CONST guards gs (c\\<^sub>!))\"\n\n  \"ai CALLX init r p n restore return arestoreq areturn arestorea A\" \\<rightharpoonup>\n    \"CONST AnnCom (CONST ann_call ai r n arestoreq areturn arestorea A)\n                  (CONST call init p restore return)\"\n  \"r SCALL p n\" \\<rightharpoonup> \"CONST AnnCom (CONST AnnCall r n) (CONST Call p)\"\n\n  \"r THROW\" \\<rightleftharpoons> \"CONST AnnCom (CONST AnnExpr r) (CONST Throw)\"\n  \"THROW\" \\<rightleftharpoons> \"CONST FAKE_ANN THROW\"\n  \"TRY c1 CATCH c2 END\" \\<rightharpoonup> \"CONST AnnCom (CONST AnnComp (c1\\<^sub>?) (c2\\<^sub>?))\n                                         (CONST Catch (c1\\<^sub>!) (c2\\<^sub>!))\"\n\n  \"r SKIP\" \\<rightleftharpoons> \"CONST AnnCom (CONST AnnExpr r) (CONST Skip)\"\n  \"SKIP\" \\<rightleftharpoons> \"CONST FAKE_ANN SKIP\""], ["", "nonterminal prgs"], ["", "syntax\n  \"_PAR\" :: \"prgs \\<Rightarrow> 'a\"              (\"(COBEGIN//_//COEND)\" [57] 56)\n  \"_prg\" :: \"['a, 'a, 'a] \\<Rightarrow> prgs\"        (\"(2  _//_,/ _)\" [60, 90, 90] 57)\n  \"_prgs\" :: \"['a, 'a, 'a, prgs] \\<Rightarrow> prgs\"  (\"(2  _//_,/ _)//\\<parallel>//_\" [60,90,90,57] 57)\n\n  \"_prg_scheme\" :: \"['a, 'a, 'a, 'a, 'a, 'a] \\<Rightarrow> prgs\"  \n                  (\"  (2SCHEME [_ \\<le> _ < _]//_//_,/ _)\" [0,0,0,60, 90,90] 57)"], ["", "translations\n  \"_prg c q a\" \\<rightharpoonup> \"([((c\\<^sub>?), q, a)], [(c\\<^sub>!)])\"\n  \"_prgs c q a ps\" \\<rightharpoonup> \"(((c\\<^sub>?), q, a) # (ps\\<^sub>,), (c\\<^sub>!) # (ps\\<^sub>.))\"\n  \"_PAR ps\" \\<rightharpoonup> \"CONST AnnCom (CONST AnnPar (ps\\<^sub>,)) (CONST Parallel (ps\\<^sub>.))\"\n\n  \"_prg_scheme j i k c q a\" \\<rightharpoonup> \"(CONST map (\\<lambda>i. ((c\\<^sub>?), q, a)) [j..<k], CONST map (\\<lambda>i. (c\\<^sub>!)) [j..<k])\""], ["", "syntax\n  \"_oghoare\" :: \"('s,'p,'f) body \\<Rightarrow> ('s,'p,'f) proc_assns \\<Rightarrow> 'f set\n              \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> 's assn \\<Rightarrow> 's assn \\<Rightarrow> bool\"  \n    (\"(4_),/ (4_)/ (|\\<turnstile>\\<^bsub>'/_\\<^esub> (_//_, _))\" [60,60,60,20,1000,1000]60)\n\n  \"_oghoare_seq\" :: \"('s,'p,'f) body \\<Rightarrow> ('s,'p,'f) proc_assns \\<Rightarrow> 'f set\n              \\<Rightarrow>'s assn \\<Rightarrow> ('s,'p,'f) ann_com \\<Rightarrow> 's assn \\<Rightarrow> 's assn \\<Rightarrow> bool\"  \n    (\"(4_),/ (4_)/ (|\\<tturnstile>\\<^bsub>'/_\\<^esub> (_//_//_, _))\" [60,60,60,1000,20,1000,1000]60)"], ["", "translations\n  \"_oghoare \\<Gamma> \\<Theta> F c Q A\" \\<rightharpoonup> \"\\<Gamma>, \\<Theta> \\<turnstile>\\<^bsub>/F\\<^esub> (c\\<^sub>?) (c\\<^sub>!) Q, A\"\n  \"_oghoare_seq \\<Gamma> \\<Theta> F P c Q A\" \\<rightharpoonup> \"\\<Gamma>, \\<Theta> \\<tturnstile>\\<^bsub>/F\\<^esub> P (c\\<^sub>?) (c\\<^sub>!) Q, A\""], ["", "ML \\<open>val syntax_debug = false\\<close>"], ["", "print_translation \\<open> let\n  fun quote_tr' f (t :: ts) =\n        Term.list_comb (f $ Syntax_Trans.quote_tr' @{syntax_const \"_antiquote\"} t, ts)\n    | quote_tr' _ _ = raise Match;\n\n  fun annquote_tr' f (r :: t :: ts) =\n        Term.list_comb (f $ r $ Syntax_Trans.quote_tr' @{syntax_const \"_antiquote\"} t, ts)\n    | annquote_tr' _ _ = raise Match;\n\n  val assert_tr' = quote_tr' (Syntax.const @{syntax_const \"_Assert\"});\n\n  fun annbexp_tr' name (r :: (Const (@{const_syntax Collect}, _) $ t) :: ts) =\n        annquote_tr' (Syntax.const name) (r :: t :: ts)\n    | annbexp_tr' name (r :: Const (@{const_syntax UNIV}, _) :: ts) =\n        annquote_tr' (Syntax.const name)\n                     (r :: Abs (\"s\", dummyT, Const (@{const_syntax True}, dummyT)) :: ts)\n    | annbexp_tr' name (r :: Const (@{const_syntax Set.empty}, _) :: ts) =\n        annquote_tr' (Syntax.const name)\n                     (r :: Abs (\"s\", dummyT, Const (@{const_syntax False}, dummyT)) :: ts)\n    | annbexp_tr' name x =\n        let val _ = if syntax_debug then writeln (\"annbexp_tr'\\n \" ^ @{make_string} x) else () in\n        raise Match end;\n\n  fun annassign_tr' (r :: Abs (x, _, f $ k $ Bound 0) :: ts) =\n        quote_tr' (Syntax.const @{syntax_const \"_AnnAssign\"} $ r $ Syntax_Trans.update_name_tr' f)\n          (Abs (x, dummyT, Syntax_Trans.const_abs_tr' k) :: ts)\n    | annassign_tr' r = let val _ = writeln (\"annassign_tr'\\n \" ^ @{make_string} r) in\n     raise Match end;\n\n  fun dest_list (Const (@{const_syntax Nil}, _)) = []\n    | dest_list (Const (@{const_syntax Cons}, _) $ x $ xs) = x :: dest_list xs\n    | dest_list _ = raise Match;\n\n  fun guards_lst_tr' [fg] = fg\n    | guards_lst_tr' (t :: ts) =\n        Syntax.const @{syntax_const \"_grds\"} $ t $ guards_lst_tr' ts\n    | guards_lst_tr' [] = raise Match;\n\n  fun new_AnnCom r c =\n    (Const (@{const_syntax AnnCom}, dummyT) $ r $ c)\n\n  fun new_Pair a b =\n    (Const (@{const_syntax Pair}, dummyT) $ a $ b)\n\n  fun dest_prod (Const (@{const_syntax Pair}, _) $ a $ b) = (a, b)\n    | dest_prod _ = raise Match;\n\n  fun prgs_tr' f pqa c =\n        let val (p, qa) = dest_prod pqa\n            val (q, a) = dest_prod qa\n        in [new_AnnCom (f p) (f c), f q, f a] end\n\n  fun prgs_lst_tr' [p] [c] =\n        list_comb (Syntax.const @{syntax_const \"_prg\"},\n                   prgs_tr' I p c)\n    | prgs_lst_tr' (p :: ps) (c :: cs) =\n        list_comb (Syntax.const @{syntax_const \"_prgs\"},\n                   prgs_tr' I p c) $ prgs_lst_tr' ps cs\n    | prgs_lst_tr' _ _= raise Match;\n\n  fun AnnCom_tr (Const (@{const_syntax AnnPar}, _) $\n                 (Const (@{const_syntax map}, _) $\n                  Abs (i, T, p) $ (Const _ $ j $ k)) ::\n                 Const (@{const_syntax Parallel}, _) $\n                 (Const (@{const_syntax map}, _) $\n                  Abs (_, _, c) $ _) :: ts) =\n        let val _ = if syntax_debug then writeln \"prg_scheme\" else ()\n            fun dest_abs body = snd (Term.dest_abs (i, T, body)) in\n          Syntax.const @{syntax_const \"_PAR\"} $\n            list_comb (Syntax.const @{syntax_const \"_prg_scheme\"} $\n              j $ Free (i, T) $ k, prgs_tr' dest_abs p c)\n        end\n    | AnnCom_tr (Const (@{const_syntax AnnPar}, _) $ ps ::\n               Const (@{const_syntax Parallel}, _) $ cs :: ts) =\n        let val _ = if syntax_debug then writeln \"Par\" else ()\n            val (ps', cs') = (dest_list ps, dest_list cs)\n        in Syntax.const @{syntax_const \"_PAR\"} $\n             prgs_lst_tr' ps' cs' end\n    | AnnCom_tr (Const (@{const_syntax AnnExpr}, _) $ r ::\n               Const (@{const_syntax Basic}, _) $ Abs (x, _, f $ k $ Bound 0) :: ts) =\n      let val _ = if syntax_debug then writeln \"Basic'\" else () in\n        quote_tr' (Syntax.const @{syntax_const \"_AnnAssign\"} $ r $ Syntax_Trans.update_name_tr' f)\n          (Abs (x, dummyT, Syntax_Trans.const_abs_tr' k) :: ts) end\n    | AnnCom_tr (Const (@{const_syntax AnnExpr}, _) $ r ::\n               Const (@{const_syntax Basic}, _) $ (f $ k) :: ts) =\n      let val _ = if syntax_debug then writeln \"Basic\" else () in\n        quote_tr' (Syntax.const @{syntax_const \"_AnnAssign\"} $ r $ Syntax_Trans.update_name_tr' f)\n          (k :: ts) end\n    | AnnCom_tr (Const (@{const_syntax AnnExpr}, _) $ r ::\n               Const (@{const_syntax Spec}, _) $ (_ $ _ $ Abs (_,_, _ $ _ $ ((_ $ f) $ S $ _))) :: ts) =\n      let val _ = if syntax_debug then writeln (\"Spec\") else () in\n        (Syntax.const @{syntax_const \"_AnnSpec\"} $ r $\n           Syntax_Trans.update_name_tr' f $\n           Syntax_Trans.antiquote_tr' @{syntax_const \"_antiquote\"} S)\n      end\n    | AnnCom_tr (Const (@{const_syntax AnnComp}, _) $ r $ r' ::\n               Const (@{const_syntax Seq}, _) $ c $ c' :: ts) =\n      let val _ = if syntax_debug then writeln \"Seq\" else ()\n      in Syntax.const @{syntax_const \"_AnnSeq\"} $\n                new_AnnCom r c $ new_AnnCom r' c' end\n    | AnnCom_tr (Const (@{const_syntax AnnRec}, _) $ r $ p ::\n               Const (@{const_syntax Await}, _) $ b $ c :: ts) =\n       let val _ = if syntax_debug then writeln \"Await\" else ()\n          in annbexp_tr' @{syntax_const \"_AnnAwait\"}\n                  (r :: b :: new_AnnCom p c :: ts) end\n    | AnnCom_tr (Const (@{const_syntax AnnWhile}, _) $ r $ i $ p ::\n               Const (@{const_syntax While}, _) $ b $ c :: ts) =\n       let val _ = if syntax_debug then writeln \"While\" else ()\n          in annbexp_tr' @{syntax_const \"_AnnWhile\"}\n                  (r :: b :: i :: new_AnnCom p c :: ts) end\n    | AnnCom_tr (Const (@{const_syntax AnnBin}, _) $ r $ p $ p' ::\n               Const (@{const_syntax Cond}, _) $ b $ c $ c':: ts) =\n       let val _ = if syntax_debug then writeln \"Cond\" else ()\n          in annbexp_tr' @{syntax_const \"_AnnCond1\"}\n                  (r :: b :: new_AnnCom p c :: new_AnnCom p' c' :: ts) end\n    | AnnCom_tr (Const (@{const_syntax ann_guards}, _) $ r $ gs $ p ::\n               Const (@{const_syntax guards}, _) $ _ $ c :: ts) =\n       let val _ = if syntax_debug then writeln \"guards\" else ()\n          in Syntax.const @{syntax_const \"_guards\"} $ r $\n                guards_lst_tr' (dest_list gs) $ new_AnnCom p c end\n    | AnnCom_tr (Const (@{const_syntax AnnRec}, _) $ r $ p ::\n               Const (@{const_syntax Guard}, _) $ f $ g $ c :: ts) =\n       let val _ = if syntax_debug then writeln \"guards'\" else ()\n          in Syntax.const @{syntax_const \"_guards\"} $ r $\n                new_Pair f g $ new_AnnCom p c end\n    | AnnCom_tr (Const (@{const_syntax AnnCall}, _) $ r $ n ::\n               Const (@{const_syntax Call}, _) $ p :: ts) =\n       let val _ = if syntax_debug then writeln \"SCall\" else ()\n          in Syntax.const @{syntax_const \"_AnnSCall\"} $ r $ p $ n end\n    | AnnCom_tr (Const (@{const_syntax ann_call}, _) $\n                   ai $ r $ n $ arestoreq $ areturn $ arestorea $ A ::\n               Const (@{const_syntax call}, _) $\n                   init $ p $ restore $ return :: ts) =\n       let val _ = if syntax_debug then writeln \"CallX\" else ()\n          in Syntax.const @{syntax_const \"_AnnCallX\"} $ ai $ init $\n                  r $ p $ n $ restore $ return $ arestoreq $ areturn $\n                  arestorea $ A end\n    | AnnCom_tr (Const (@{const_syntax AnnComp}, _) $ r $ r' ::\n               Const (@{const_syntax Catch}, _) $ c $ c' :: ts) =\n      let val _ = if syntax_debug then writeln \"Catch\" else ()\n      in Syntax.const @{syntax_const \"_Try_Catch\"} $\n                new_AnnCom r c $ new_AnnCom r' c' end\n    | AnnCom_tr (Const (@{const_syntax ann}, _) $ p ::\n               Const (@{const_syntax com}, _) $ p' :: ts) =\n       let val _ = if syntax_debug then writeln \"ann_com\" else ()\n          in if p = p' then p else raise Match end\n    | AnnCom_tr x = let val _ = if syntax_debug then writeln (\"AnnCom_tr\\n \" ^ @{make_string} x) else ()\n          in raise Match end;\n\n    fun oghoare_tr (gamma :: sigma :: F :: r :: c :: Q :: A :: ts) =\n        let val _ = if syntax_debug then writeln \"oghoare\" else ()\n          in Syntax.const @{syntax_const \"_oghoare\"} $\n               gamma $ sigma $ F $ new_AnnCom r c $ Q $ A\n          end\n      | oghoare_tr x = let val _ = writeln (\"oghoare_tr\\n \" ^ @{make_string} x)\n            in raise Match end;\n\n    fun oghoare_seq_tr (gamma :: sigma :: F :: P :: r :: c :: Q :: A :: ts) =\n        let val _ = if syntax_debug then writeln \"oghoare_seq\" else ()\n          in Syntax.const @{syntax_const \"_oghoare_seq\"} $\n               gamma $ sigma $ F $ P $ new_AnnCom r c $ Q $ A\n          end\n      | oghoare_seq_tr x = let val _ = writeln (\"oghoare_seq_tr\\n \" ^ @{make_string} x)\n            in raise Match end;\n\n  in\n   [(@{const_syntax Collect}, K assert_tr'),\n    (@{const_syntax AnnCom}, K AnnCom_tr),\n    (@{const_syntax oghoare}, K oghoare_tr),\n    (@{const_syntax oghoare_seq}, K oghoare_seq_tr)]\n\n  end\n\\<close>"], ["", "end"]]}