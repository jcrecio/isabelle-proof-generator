{"file_name": "/home/qj213/afp-2021-10-22/thys/Noninterference_Concurrent_Composition/ConcurrentComposition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Noninterference_Concurrent_Composition", "problem_names": ["lemma sinks_aux_elem [rule_format]:\n \"u \\<in> sinks_aux I D U xs \\<longrightarrow> u \\<in> U \\<or> (\\<exists>x \\<in> set xs. u = D x)\"", "lemma ipurge_ref_aux_cons:\n \"ipurge_ref_aux I D U (x # xs) X = ipurge_ref_aux I D (sinks_aux I D U [x]) xs X\"", "lemma process_rule_1_futures:\n \"xs \\<in> traces P \\<Longrightarrow> ([], {}) \\<in> futures P xs\"", "lemma process_rule_3_futures:\n \"(ys, Y) \\<in> futures P xs \\<Longrightarrow> Y' \\<subseteq> Y \\<Longrightarrow> (ys, Y') \\<in> futures P xs\"", "lemma process_rule_4_futures:\n \"(ys, Y) \\<in> futures P xs \\<Longrightarrow>\n    (ys @ [x], {}) \\<in> futures P xs \\<or> (ys, insert x Y) \\<in> futures P xs\"", "lemma process_rule_5_general [rule_format]:\n \"xs \\<in> divergences P \\<longrightarrow> xs @ ys \\<in> divergences P\"", "lemma process_rule_5_futures:\n \"ys \\<in> future_divergences P xs \\<Longrightarrow> ys @ [x] \\<in> future_divergences P xs\"", "lemma process_rule_6_futures:\n \"ys \\<in> future_divergences P xs \\<Longrightarrow> (ys, Y) \\<in> futures P xs\"", "lemma after_rep:\n  assumes A: \"xs \\<in> traces P\"\n  shows \"Rep_process (P \\<setminus> xs) = (futures P xs, future_divergences P xs)\"\n    (is \"_ = ?X\")", "lemma after_failures:\n  assumes A: \"xs \\<in> traces P\"\n  shows \"failures (P \\<setminus> xs) = futures P xs\"", "lemma after_futures:\n  assumes A: \"xs \\<in> traces P\"\n  shows \"futures (P \\<setminus> xs) ys = futures P (xs @ ys)\"", "lemma after_secure:\n  assumes A: \"xs \\<in> traces P\"\n  shows \"secure P I D \\<Longrightarrow> secure (P \\<setminus> xs) I D\"", "lemma ipurge_tr_ref_aux_futures:\n \"\\<lbrakk>secure P I D; (ys, Y) \\<in> futures P xs\\<rbrakk> \\<Longrightarrow>\n    (ipurge_tr_aux I D U ys, ipurge_ref_aux I D U ys Y) \\<in> futures P xs\"", "lemma ipurge_tr_ref_aux_failures_general:\n \"\\<lbrakk>secure P I D; (xs @ ys, Y) \\<in> failures P\\<rbrakk> \\<Longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys, ipurge_ref_aux I D U ys Y) \\<in> failures P\"", "lemma con_comp_prop_1:\n \"([], {}) \\<in> con_comp_failures P Q p q\"", "lemma con_comp_prop_2:\n \"(xs @ [x], X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    (xs, {}) \\<in> con_comp_failures P Q p q\"", "lemma con_comp_prop_3:\n \"\\<lbrakk>(xs, Y) \\<in> con_comp_failures P Q p q; X \\<subseteq> Y\\<rbrakk> \\<Longrightarrow>\n    (xs, X) \\<in> con_comp_failures P Q p q\"", "lemma con_comp_prop_4:\n \"(xs, X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    (xs @ [x], {}) \\<in> con_comp_failures P Q p q \\<or>\n    (xs, insert x X) \\<in> con_comp_failures P Q p q\"", "lemma con_comp_prop_5:\n \"xs \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    xs @ [x] \\<in> con_comp_divergences P Q p q\"", "lemma con_comp_prop_6:\n \"xs \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    (xs, X) \\<in> con_comp_failures P Q p q\"", "lemma con_comp_rep:\n \"Rep_process (P \\<parallel> Q <p, q>) =\n    (con_comp_failures P Q p q, con_comp_divergences P Q p q)\"\n  (is \"_ = ?X\")", "lemma con_comp_failures:\n \"failures (P \\<parallel> Q <p, q>) = con_comp_failures P Q p q\"", "lemma con_comp_divergences:\n \"divergences (P \\<parallel> Q <p, q>) = con_comp_divergences P Q p q\"", "lemma con_comp_futures:\n \"futures (P \\<parallel> Q <p, q>) xs =\n    {(ys, Y). (xs @ ys, Y) \\<in> con_comp_failures P Q p q}\"", "lemma con_comp_traces:\n \"traces (P \\<parallel> Q <p, q>) = Domain (con_comp_failures P Q p q)\"", "lemma con_comp_refusals:\n \"refusals (P \\<parallel> Q <p, q>) xs \\<equiv> con_comp_failures P Q p q `` {xs}\"", "lemma con_comp_next_events:\n \"next_events (P \\<parallel> Q <p, q>) xs =\n    {x. xs @ [x] \\<in> Domain (con_comp_failures P Q p q)}\"", "lemma con_comp_ref_union_closed:\n  assumes\n    A: \"ref_union_closed P\" and\n    B: \"ref_union_closed Q\"\n  shows \"ref_union_closed (P \\<parallel> Q <p, q>)\"", "lemma con_comp_failures_traces:\n \"(xs, X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    map (inv p) [x\\<leftarrow>xs. x \\<in> range p] \\<in> traces P \\<and>\n    map (inv q) [x\\<leftarrow>xs. x \\<in> range q] \\<in> traces Q\"", "lemma con_comp_failures_divergences:\n \"(xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n  y \\<notin> range p \\<Longrightarrow>\n  y \\<notin> range q \\<Longrightarrow>\n    \\<exists>xs'.\n      (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q\"", "lemma ipurge_tr_aux_foldr_subset:\n \"U \\<subseteq> V \\<Longrightarrow>\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P V xs) =\n    ipurge_tr_aux_foldr I D P V xs\"", "lemma ipurge_tr_aux_foldr_eq:\n \"[x\\<leftarrow>ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux_foldr I D P U xs\"", "lemma ipurge_tr_aux_foldr_sinks_aux [rule_format]:\n \"U \\<subseteq> V \\<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\"", "lemma ipurge_tr_aux_foldr_ref_aux:\n  assumes A: \"U \\<subseteq> V\"\n  shows \"ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P V xs) X =\n    ipurge_ref_aux I D U [] X\"", "lemma ipurge_ref_aux_foldr_subset [rule_format]:\n \"sinks_aux I D U ys \\<subseteq> V \\<longrightarrow>\n  ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V xs X) =\n    ipurge_ref_aux_foldr I D P V xs X\"", "lemma ipurge_ref_aux_foldr_eq:\n \"ipurge_ref_aux I D U xs X = ipurge_ref_aux_foldr I D P U xs X\"", "lemma con_comp_sinks_aux_range:\n  assumes\n    A: \"U \\<subseteq> range Some\" and\n    B: \"set xs \\<subseteq> range p \\<union> range q\"\n  shows \"sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs \\<subseteq> range Some\"\n    (is \"sinks_aux _ ?D' _ _ \\<subseteq> _\")", "lemma con_comp_sinks_aux [rule_format]:\n  assumes A: \"U \\<subseteq> range Some\"\n  shows \"set xs \\<subseteq> range p \\<longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\"\n    (is \"_ \\<longrightarrow> _ = the ` sinks_aux ?I' ?D' _ _\")", "lemma con_comp_ipurge_tr_aux [rule_format]:\n  assumes A: \"U \\<subseteq> range Some\"\n  shows \"set xs \\<subseteq> range p \\<longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n    map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\"\n    (is \"_ \\<longrightarrow> _ = map (inv p) (ipurge_tr_aux ?I' ?D' _ _)\")", "lemma con_comp_ipurge_ref_aux:\n  assumes\n    A: \"U \\<subseteq> range Some\" and\n    B: \"set xs \\<subseteq> range p\" and\n    C: \"X \\<subseteq> range p\"\n  shows \"ipurge_ref_aux I D (the ` U) (map (inv p) xs) (inv p ` X) =\n    inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U xs X\"\n  (is \"_ = inv p ` ipurge_ref_aux ?I' ?D' _ _ _\")", "lemma con_comp_sinks_filter:\n \"sinks (con_comp_pol I) (con_comp_map D E p q) u\n    [x\\<leftarrow>xs. x \\<in> range p \\<union> range q] =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\"\n  (is \"sinks ?I' ?D' _ _ = _\")", "lemma con_comp_ipurge_tr_filter:\n \"ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n    [x\\<leftarrow>xs. x \\<in> range p \\<union> range q] =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\"\n  (is \"ipurge_tr ?I' ?D' _ _ = _\")", "lemma con_comp_ipurge_ref_filter:\n \"ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u\n    [x\\<leftarrow>xs. x \\<in> range p \\<union> range q] X =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u xs X\"\n  (is \"ipurge_ref ?I' ?D' _ _ _ = _\")", "lemma con_comp_secure_aux [rule_format]:\n  assumes\n    A: \"secure P I D\" and\n    B: \"Y \\<subseteq> range p\"\n  shows \"set ys \\<subseteq> range p \\<union> range q \\<longrightarrow> U \\<subseteq> range Some \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs @ ys. x \\<in> range p], inv p ` Y) \\<in> failures P \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n     map (inv p) (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) U ys),\n     inv p ` ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) U ys Y) \\<in> failures P\"", "lemma con_comp_secure_del_aux_1:\n  assumes\n    A: \"secure P I D\" and\n    B: \"y \\<in> range p \\<or> y \\<in> range q\" and\n    C: \"set ys \\<subseteq> range p \\<union> range q\" and\n    D: \"Y \\<subseteq> range p\" and\n    E: \"(map (inv p) [x\\<leftarrow>xs @ y # ys. x \\<in> range p], inv p ` Y) \\<in> failures P\"\n  shows\n   \"(map (inv p) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys. x \\<in> range p],\n     inv p ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys Y) \\<in> failures P\"\n    (is \"(map (inv p) [x\\<leftarrow>xs @ ipurge_tr ?I' ?D' _ _. _], _) \\<in> _\")", "lemma con_comp_secure_add_aux_1:\n  assumes\n    A: \"secure P I D\" and\n    B: \"y \\<in> range p \\<or> y \\<in> range q\" and\n    C: \"set zs \\<subseteq> range p \\<union> range q\" and\n    D: \"Z \\<subseteq> range p\" and\n    E: \"(map (inv p) [x\\<leftarrow>xs @ zs. x \\<in> range p], inv p ` Z) \\<in> failures P\" and\n    F: \"map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] \\<in> traces P\"\n  shows\n   \"(map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs. x \\<in> range p],\n     inv p ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs Z) \\<in> failures P\"\n    (is \"(map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr ?I' ?D' _ _. _], _) \\<in> _\")", "lemma con_comp_consistent_maps:\n \"consistent_maps D E p q \\<Longrightarrow> con_comp_map D E p q = con_comp_map E D q p\"", "lemma con_comp_secure_del_aux_2:\n  assumes A: \"consistent_maps D E p q\"\n  shows\n   \"secure Q I E \\<Longrightarrow>\n    y \\<in> range p \\<or> y \\<in> range q \\<Longrightarrow>\n    set ys \\<subseteq> range p \\<union> range q \\<Longrightarrow>\n    Y \\<subseteq> range q \\<Longrightarrow>\n    (map (inv q) [x\\<leftarrow>xs @ y # ys. x \\<in> range q], inv q ` Y) \\<in> failures Q \\<Longrightarrow>\n      (map (inv q) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys. x \\<in> range q],\n       inv q ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys Y) \\<in> failures Q\"", "lemma con_comp_secure_add_aux_2:\n  assumes A: \"consistent_maps D E p q\"\n  shows\n   \"secure Q I E \\<Longrightarrow>\n    y \\<in> range p \\<or> y \\<in> range q \\<Longrightarrow>\n    set zs \\<subseteq> range p \\<union> range q \\<Longrightarrow>\n    Z \\<subseteq> range q \\<Longrightarrow>\n    (map (inv q) [x\\<leftarrow>xs @ zs. x \\<in> range q], inv q ` Z) \\<in> failures Q \\<Longrightarrow>\n    map (inv q) [x\\<leftarrow>xs @ [y]. x \\<in> range q] \\<in> traces Q \\<Longrightarrow>\n      (map (inv q) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range q],\n       inv q ` ipurge_ref (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs Z) \\<in> failures Q\"", "lemma con_comp_secure_del_case_1:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\"\n  shows\n   \"\\<exists>R S T.\n      Y = R \\<union> S \\<union> T \\<and>\n      (y \\<in> range p \\<or> y \\<in> range q) \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set ys \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ y # ys. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ y # ys. x \\<in> range q], inv q ` S) \\<in> failures Q \\<Longrightarrow>\n    \\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>                     \n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys) \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys. x \\<in> range q], inv q ` S) \\<in> failures Q\"\n  (is \"_ \\<Longrightarrow> \\<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \\<and> _\")", "lemma con_comp_secure_del_case_2:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\"\n  shows\n   \"\\<exists>xs'.\n      (\\<exists>ys'. xs @ y # ys = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q \\<Longrightarrow>\n    (\\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys) \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys. x \\<in> range q], inv q ` S) \\<in> failures Q) \\<or>\n    (\\<exists>xs'.\n      (\\<exists>ys'. xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q)\"\n  (is \"_ \\<Longrightarrow> (\\<exists>R S T. ?F R S T ys) \\<or> ?G\")", "lemma con_comp_secure_add_case_1:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\" and\n    D: \"(xs @ y # ys, Y) \\<in> con_comp_failures P Q p q\" and\n    E: \"y \\<in> range p \\<or> y \\<in> range q\"\n  shows\n   \"\\<exists>R S T.\n      Z = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set zs \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ zs. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ zs. x \\<in> range q], inv q ` S) \\<in> failures Q \\<Longrightarrow>\n    \\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs) \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range p],\n       inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range q],\n       inv q ` S) \\<in> failures Q\"\n  (is \"_ \\<Longrightarrow> \\<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \\<and> _\")", "lemma con_comp_secure_add_case_2:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\" and\n    D: \"(xs @ y # ys, Y) \\<in> con_comp_failures P Q p q\" and\n    E: \"y \\<in> range p \\<or> y \\<in> range q\"\n  shows\n   \"\\<exists>xs'.\n      (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q \\<Longrightarrow>\n    (\\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs) \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range p],\n       inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range q],\n       inv q ` S) \\<in> failures Q) \\<or>\n    (\\<exists>xs'.\n      (\\<exists>ys'. xs @ y # ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q)\"\n  (is \"_ \\<Longrightarrow> (\\<exists>R S T. ?F R S T zs) \\<or> ?G\")", "theorem con_comp_secure:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\"\n  shows \"secure (P \\<parallel> Q <p, q>) (con_comp_pol I) (con_comp_map D E p q)\"", "lemma con_comp_sinks_range:\n \"u \\<in> range Some \\<Longrightarrow>\n  set xs \\<subseteq> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\"", "lemma con_comp_sinks_no_fake:\n  assumes\n    A: \"range p \\<union> range q = UNIV\" and\n    B: \"u \\<in> range Some\"\n  shows \"sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\"\n    (is \"_ = the ` sinks ?I' ?D' _ _\")", "lemma con_comp_ipurge_tr_no_fake:\n  assumes\n    A: \"range p \\<union> range q = UNIV\" and\n    B: \"u \\<in> range Some\"\n  shows \"ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs\"\n    (is \"ipurge_tr ?I' ?D' _ _ = _\")", "lemma con_comp_ipurge_ref_no_fake:\n  assumes\n    A: \"range p \\<union> range q = UNIV\" and\n    B: \"u \\<in> range Some\"\n  shows \"ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u xs X =\n    ipurge_ref I (the \\<circ> con_comp_map D E p q) (the u) xs X\"\n    (is \"ipurge_ref ?I' ?D' _ _ _ = _\")", "theorem con_comp_secure_no_fake:\n  assumes\n    A: \"range p \\<union> range q = UNIV\" and\n    B: \"consistent_maps D E p q\" and\n    C: \"secure P I D\" and\n    D: \"secure Q I E\"\n  shows \"secure (P \\<parallel> Q <p, q>) I (the \\<circ> con_comp_map D E p q)\""], "translations": [["", "lemma sinks_aux_elem [rule_format]:\n \"u \\<in> sinks_aux I D U xs \\<longrightarrow> u \\<in> U \\<or> (\\<exists>x \\<in> set xs. u = D x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> sinks_aux I D U xs \\<longrightarrow>\n    u \\<in> U \\<or> (\\<exists>x\\<in>set xs. u = D x)", "by (induction xs rule: rev_induct, simp_all, blast)"], ["", "lemma ipurge_ref_aux_cons:\n \"ipurge_ref_aux I D U (x # xs) X = ipurge_ref_aux I D (sinks_aux I D U [x]) xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U (x # xs) X =\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X", "by (subgoal_tac \"x # xs = [x] @ xs\", simp only: ipurge_ref_aux_append, simp)"], ["", "lemma process_rule_1_futures:\n \"xs \\<in> traces P \\<Longrightarrow> ([], {}) \\<in> futures P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> traces P \\<Longrightarrow> ([], {}) \\<in> futures P xs", "by (simp add: futures_def, rule traces_failures)"], ["", "lemma process_rule_3_futures:\n \"(ys, Y) \\<in> futures P xs \\<Longrightarrow> Y' \\<subseteq> Y \\<Longrightarrow> (ys, Y') \\<in> futures P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ys, Y) \\<in> futures P xs; Y' \\<subseteq> Y\\<rbrakk>\n    \\<Longrightarrow> (ys, Y') \\<in> futures P xs", "by (simp add: futures_def, rule process_rule_3)"], ["", "lemma process_rule_4_futures:\n \"(ys, Y) \\<in> futures P xs \\<Longrightarrow>\n    (ys @ [x], {}) \\<in> futures P xs \\<or> (ys, insert x Y) \\<in> futures P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys, Y) \\<in> futures P xs \\<Longrightarrow>\n    (ys @ [x], {}) \\<in> futures P xs \\<or>\n    (ys, insert x Y) \\<in> futures P xs", "by (simp add: futures_def, subst append_assoc [symmetric], rule process_rule_4)"], ["", "lemma process_rule_5_general [rule_format]:\n \"xs \\<in> divergences P \\<longrightarrow> xs @ ys \\<in> divergences P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> divergences P \\<longrightarrow> xs @ ys \\<in> divergences P", "proof (induction ys rule: rev_induct, simp, rule impI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>xs @ xsa \\<in> divergences P;\n        xs \\<in> divergences P\\<rbrakk>\n       \\<Longrightarrow> xs @ xsa @ [x] \\<in> divergences P", "qed (subst append_assoc [symmetric], rule process_rule_5)"], ["", "text \\<open>\n\\null\n\nHere below is the definition of operator \\emph{after}, for which a symbolic notation similar to the\none used in \\cite{R6} is introduced. Then, it is proven that for any process @{term P} and any trace\n@{term xs} of @{term P}, the failures set and the divergences set of @{term P} after @{term xs}\nindeed enjoy their respective characteristic properties as defined in \\cite{R1}.\n\n\\null\n\\<close>"], ["", "definition future_divergences :: \"'a process \\<Rightarrow> 'a list \\<Rightarrow> 'a list set\" where\n\"future_divergences P xs \\<equiv> {ys. xs @ ys \\<in> divergences P}\""], ["", "definition after :: \"'a process \\<Rightarrow> 'a list \\<Rightarrow> 'a process\" (infixl \"\\<setminus>\" 64) where\n\"P \\<setminus> xs \\<equiv> Abs_process (futures P xs, future_divergences P xs)\""], ["", "lemma process_rule_5_futures:\n \"ys \\<in> future_divergences P xs \\<Longrightarrow> ys @ [x] \\<in> future_divergences P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> future_divergences P xs \\<Longrightarrow>\n    ys @ [x] \\<in> future_divergences P xs", "by (simp add: future_divergences_def, subst append_assoc [symmetric],\n rule process_rule_5)"], ["", "lemma process_rule_6_futures:\n \"ys \\<in> future_divergences P xs \\<Longrightarrow> (ys, Y) \\<in> futures P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> future_divergences P xs \\<Longrightarrow>\n    (ys, Y) \\<in> futures P xs", "by (simp add: futures_def future_divergences_def, rule process_rule_6)"], ["", "lemma after_rep:\n  assumes A: \"xs \\<in> traces P\"\n  shows \"Rep_process (P \\<setminus> xs) = (futures P xs, future_divergences P xs)\"\n    (is \"_ = ?X\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_process (P \\<setminus> xs) = (futures P xs, future_divergences P xs)", "proof (subst after_def, rule Abs_process_inverse, simp add: process_set_def,\n (subst conj_assoc [symmetric])+, (rule conjI)+)"], ["proof (state)\ngoal (6 subgoals):\n 1. process_prop_1 (futures P xs, future_divergences P xs)\n 2. process_prop_2 (futures P xs, future_divergences P xs)\n 3. process_prop_3 (futures P xs, future_divergences P xs)\n 4. process_prop_4 (futures P xs, future_divergences P xs)\n 5. process_prop_5 (futures P xs, future_divergences P xs)\n 6. process_prop_6 (futures P xs, future_divergences P xs)", "show \"process_prop_1 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_1 (futures P xs, future_divergences P xs)", "proof (simp add: process_prop_1_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> futures P xs", "qed (rule process_rule_1_futures [OF A])"], ["proof (state)\nthis:\n  process_prop_1 (futures P xs, future_divergences P xs)\n\ngoal (5 subgoals):\n 1. process_prop_2 (futures P xs, future_divergences P xs)\n 2. process_prop_3 (futures P xs, future_divergences P xs)\n 3. process_prop_4 (futures P xs, future_divergences P xs)\n 4. process_prop_5 (futures P xs, future_divergences P xs)\n 5. process_prop_6 (futures P xs, future_divergences P xs)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. process_prop_2 (futures P xs, future_divergences P xs)\n 2. process_prop_3 (futures P xs, future_divergences P xs)\n 3. process_prop_4 (futures P xs, future_divergences P xs)\n 4. process_prop_5 (futures P xs, future_divergences P xs)\n 5. process_prop_6 (futures P xs, future_divergences P xs)", "show \"process_prop_2 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_2 (futures P xs, future_divergences P xs)", "proof (simp add: process_prop_2_def del: all_simps, (rule allI)+, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa x X.\n       (xsa @ [x], X) \\<in> futures P xs \\<Longrightarrow>\n       (xsa, {}) \\<in> futures P xs", "qed (rule process_rule_2_futures)"], ["proof (state)\nthis:\n  process_prop_2 (futures P xs, future_divergences P xs)\n\ngoal (4 subgoals):\n 1. process_prop_3 (futures P xs, future_divergences P xs)\n 2. process_prop_4 (futures P xs, future_divergences P xs)\n 3. process_prop_5 (futures P xs, future_divergences P xs)\n 4. process_prop_6 (futures P xs, future_divergences P xs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. process_prop_3 (futures P xs, future_divergences P xs)\n 2. process_prop_4 (futures P xs, future_divergences P xs)\n 3. process_prop_5 (futures P xs, future_divergences P xs)\n 4. process_prop_6 (futures P xs, future_divergences P xs)", "show \"process_prop_3 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_3 (futures P xs, future_divergences P xs)", "proof (simp add: process_prop_3_def del: all_simps, (rule allI)+, rule impI,\n   erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa X Y.\n       \\<lbrakk>(xsa, Y) \\<in> futures P xs; X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xsa, X) \\<in> futures P xs", "qed (rule process_rule_3_futures)"], ["proof (state)\nthis:\n  process_prop_3 (futures P xs, future_divergences P xs)\n\ngoal (3 subgoals):\n 1. process_prop_4 (futures P xs, future_divergences P xs)\n 2. process_prop_5 (futures P xs, future_divergences P xs)\n 3. process_prop_6 (futures P xs, future_divergences P xs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. process_prop_4 (futures P xs, future_divergences P xs)\n 2. process_prop_5 (futures P xs, future_divergences P xs)\n 3. process_prop_6 (futures P xs, future_divergences P xs)", "show \"process_prop_4 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_4 (futures P xs, future_divergences P xs)", "proof (simp add: process_prop_4_def, (rule allI)+, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa x X.\n       (xsa, X) \\<in> futures P xs \\<Longrightarrow>\n       (xsa @ [x], {}) \\<in> futures P xs \\<or>\n       (xsa, insert x X) \\<in> futures P xs", "qed (rule process_rule_4_futures)"], ["proof (state)\nthis:\n  process_prop_4 (futures P xs, future_divergences P xs)\n\ngoal (2 subgoals):\n 1. process_prop_5 (futures P xs, future_divergences P xs)\n 2. process_prop_6 (futures P xs, future_divergences P xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. process_prop_5 (futures P xs, future_divergences P xs)\n 2. process_prop_6 (futures P xs, future_divergences P xs)", "show \"process_prop_5 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_5 (futures P xs, future_divergences P xs)", "proof (simp add: process_prop_5_def, rule allI, rule impI, rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa x.\n       xsa \\<in> future_divergences P xs \\<Longrightarrow>\n       xsa @ [x] \\<in> future_divergences P xs", "qed (rule process_rule_5_futures)"], ["proof (state)\nthis:\n  process_prop_5 (futures P xs, future_divergences P xs)\n\ngoal (1 subgoal):\n 1. process_prop_6 (futures P xs, future_divergences P xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. process_prop_6 (futures P xs, future_divergences P xs)", "show \"process_prop_6 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_6 (futures P xs, future_divergences P xs)", "proof (simp add: process_prop_6_def, rule allI, rule impI, rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa X.\n       xsa \\<in> future_divergences P xs \\<Longrightarrow>\n       (xsa, X) \\<in> futures P xs", "qed (rule process_rule_6_futures)"], ["proof (state)\nthis:\n  process_prop_6 (futures P xs, future_divergences P xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma after_failures:\n  assumes A: \"xs \\<in> traces P\"\n  shows \"failures (P \\<setminus> xs) = futures P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. failures (P \\<setminus> xs) = futures P xs", "by (simp add: failures_def after_rep [OF A])"], ["", "lemma after_futures:\n  assumes A: \"xs \\<in> traces P\"\n  shows \"futures (P \\<setminus> xs) ys = futures P (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. futures (P \\<setminus> xs) ys = futures P (xs @ ys)", "by (simp add: futures_def after_failures [OF A])"], ["", "text \\<open>\n\\null\n\nFinally, the closure of the futures of a secure process under intransitive purge is proven.\n\n\\null\n\\<close>"], ["", "lemma after_secure:\n  assumes A: \"xs \\<in> traces P\"\n  shows \"secure P I D \\<Longrightarrow> secure (P \\<setminus> xs) I D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P I D \\<Longrightarrow> secure (P \\<setminus> xs) I D", "by (simp add: secure_def after_futures [OF A], blast)"], ["", "lemma ipurge_tr_ref_aux_futures:\n \"\\<lbrakk>secure P I D; (ys, Y) \\<in> futures P xs\\<rbrakk> \\<Longrightarrow>\n    (ipurge_tr_aux I D U ys, ipurge_ref_aux I D U ys Y) \\<in> futures P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (ys, Y) \\<in> futures P xs\\<rbrakk>\n    \\<Longrightarrow> (ipurge_tr_aux I D U ys, ipurge_ref_aux I D U ys Y)\n                      \\<in> futures P xs", "proof (subgoal_tac \"xs \\<in> traces P\", simp add: after_failures [symmetric],\n rule ipurge_tr_ref_aux_failures, rule after_secure, assumption+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (ys, Y) \\<in> futures P xs\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> traces P", "qed (simp add: futures_def, drule failures_traces, rule process_rule_2_traces)"], ["", "lemma ipurge_tr_ref_aux_failures_general:\n \"\\<lbrakk>secure P I D; (xs @ ys, Y) \\<in> failures P\\<rbrakk> \\<Longrightarrow>\n    (xs @ ipurge_tr_aux I D U ys, ipurge_ref_aux I D U ys Y) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (xs @ ys, Y) \\<in> failures P\\<rbrakk>\n    \\<Longrightarrow> (xs @ ipurge_tr_aux I D U ys,\n                       ipurge_ref_aux I D U ys Y)\n                      \\<in> failures P", "by (drule ipurge_tr_ref_aux_futures, simp_all add: futures_def)"], ["", "subsection \"Concurrent composition\""], ["", "text \\<open>\nIn \\cite{R6}, the concurrent composition of two processes @{term P}, @{term Q}, expressed using\nnotation \\<open>P \\<parallel> Q\\<close>, is defined as a process whose alphabet is the union of the alphabets of\n@{term P} and @{term Q}, so that the shared events requiring the synchronous participation of both\nprocesses are those in the intersection of their alphabets.\n\nIn the formalization of Communicating Sequential Processes developed in \\cite{R1}, the alphabets of\n@{term P} and @{term Q} are the data types @{typ 'a} and @{typ 'b} nested in their respective types\n@{typ \"'a process\"} and @{typ \"'b process\"}. Therefore, for any two maps @{term \"p :: 'a \\<Rightarrow> 'c\"},\n@{term \"q :: 'b \\<Rightarrow> 'c\"}, the concurrent composition of @{term P} and @{term Q} with respect to\n@{term p} and @{term q}, expressed using notation \\<open>P \\<parallel> Q <p, q>\\<close>, is defined in what follows\nas a process of type @{typ \"'c process\"}, where meaningful events are those in\n@{term \"range p \\<union> range q\"} and shared events are those in @{term \"range p \\<inter> range q\"}.\n\nThe case where @{term \"- (range p \\<union> range q) \\<noteq> {}\"} constitutes a generalization of the definition\ngiven in \\cite{R6}, and the events in @{term \"- (range p \\<union> range q)\"}, not being mapped to any event\nin the alphabets of the input processes, shall be understood as fake events lacking any meaning.\nConsistently with this interpretation, such events are allowed to occur in divergent traces only --\nnecessarily, since divergences are capable by definition of giving rise to any sort of event. As a\nresult, while in \\cite{R6} the refusals associated to non-divergent traces are the union of two\nsets, a refusal of @{term P} and a refusal of @{term Q}, in the following definition they are the\nunion of three sets instead, where the third set is any subset of @{term \"- (range p \\<union> range q)\"}.\n\nSince the definition given in \\cite{R6} preserves the identity of the events of the input processes,\na further generalization resulting from the following definition corresponds to the case where\neither map @{term p}, @{term q} is not injective. However, as shown below, these generalizations\nturn out to compromise neither the compliance of the output of concurrent composition with the\ncharacteristic properties of processes as defined in \\cite{R1}, nor even the validity of the target\nsecurity conservation theorem.\n\nSince divergences can contain fake events, whereas non-divergent traces cannot, it is necessary to\nadd divergent failures to the failures set explicitly. The following definition of the divergences\nset restricts the definition given in \\cite{R6}, as it identifies a divergence with an arbitrary\nextension of an event sequence @{term xs} being a divergence of both @{term P} and @{term Q}, rather\nthan a divergence of either process and a trace of the other one. This is a reasonable restriction,\nin that it requires the concurrent composition of @{term P} and @{term Q} to admit a shared event\n@{term x} in a divergent trace just in case both @{term P} and @{term Q} diverge and can then accept\n@{term x}, analogously to what is required for a non-divergent trace. Anyway, the definitions match\nif the input processes do not diverge, which is the case for any process of practical significance\n(cf. \\cite{R6}).\n\n\\null\n\\<close>"], ["", "definition con_comp_divergences ::\n \"'a process \\<Rightarrow> 'b process \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> ('b \\<Rightarrow> 'c) \\<Rightarrow> 'c list set\" where\n\"con_comp_divergences P Q p q \\<equiv>\n  {xs @ ys | xs ys.\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    map (inv p) [x\\<leftarrow>xs. x \\<in> range p] \\<in> divergences P \\<and>\n    map (inv q) [x\\<leftarrow>xs. x \\<in> range q] \\<in> divergences Q}\""], ["", "definition con_comp_failures ::\n \"'a process \\<Rightarrow> 'b process \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> ('b \\<Rightarrow> 'c) \\<Rightarrow> 'c failure set\" where\n\"con_comp_failures P Q p q \\<equiv>\n  {(xs, X \\<union> Y \\<union> Z) | xs X Y Z.\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    X \\<subseteq> range p \\<and> Y \\<subseteq> range q \\<and> Z \\<subseteq> - (range p \\<union> range q) \\<and>\n    (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X) \\<in> failures P \\<and>\n    (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y) \\<in> failures Q} \\<union>\n  {(xs, X). xs \\<in> con_comp_divergences P Q p q}\""], ["", "definition con_comp ::\n \"'a process \\<Rightarrow> 'b process \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> ('b \\<Rightarrow> 'c) \\<Rightarrow> 'c process\" where\n\"con_comp P Q p q \\<equiv>\n  Abs_process (con_comp_failures P Q p q, con_comp_divergences P Q p q)\""], ["", "abbreviation con_comp_syntax ::\n \"'a process \\<Rightarrow> 'b process \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> ('b \\<Rightarrow> 'c) \\<Rightarrow> 'c process\"\n (\"(_ \\<parallel> _ <_, _>)\" 55)\nwhere\n\"P \\<parallel> Q <p, q> \\<equiv> con_comp P Q p q\""], ["", "text \\<open>\n\\null\n\nHere below is the proof that, for any two processes @{term P}, @{term Q} and any two maps @{term p},\n@{term q}, sets @{term \"con_comp_failures P Q p q\"} and @{term \"con_comp_divergences P Q p q\"} enjoy\nthe characteristic properties of the failures and the divergences sets of a process as defined in\n\\cite{R1}.\n\n\\null\n\\<close>"], ["", "lemma con_comp_prop_1:\n \"([], {}) \\<in> con_comp_failures P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> con_comp_failures P Q p q", "proof (simp add: con_comp_failures_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> failures P \\<and> ([], {}) \\<in> failures Q \\<or>\n    [] \\<in> con_comp_divergences P Q p q", "qed (rule disjI1, rule conjI, (rule process_rule_1)+)"], ["", "lemma con_comp_prop_2:\n \"(xs @ [x], X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    (xs, {}) \\<in> con_comp_failures P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ [x], X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    (xs, {}) \\<in> con_comp_failures P Q p q", "proof (simp add: con_comp_failures_def del: filter_append,\n erule disjE, (erule exE)+, (erule conjE)+, rule disjI1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        x \\<in> range p \\<or> x \\<in> range q;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x])),\n         inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x])),\n         inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> set xs \\<subseteq> range p \\<union> range q \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          {})\n                         \\<in> failures Q\n 2. xs @ [x] \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "fix X Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        x \\<in> range p \\<or> x \\<in> range q;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x])),\n         inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x])),\n         inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> set xs \\<subseteq> range p \\<union> range q \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          {})\n                         \\<in> failures Q\n 2. xs @ [x] \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "assume\n    A: \"set xs \\<subseteq> range p \\<union> range q\" and\n    B: \"(map (inv p) [x\\<leftarrow>xs @ [x]. x \\<in> range p], inv p ` X) \\<in> failures P\" and\n    C: \"(map (inv q) [x\\<leftarrow>xs @ [x]. x \\<in> range q], inv q ` Y) \\<in> failures Q\""], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x])), inv p ` X)\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x])), inv q ` Y)\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        x \\<in> range p \\<or> x \\<in> range q;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x])),\n         inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x])),\n         inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> set xs \\<subseteq> range p \\<union> range q \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          {})\n                         \\<in> failures Q\n 2. xs @ [x] \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "show \"set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], {}) \\<in> failures P \\<and>\n    (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], {}) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "proof (simp add: A, rule conjI, cases \"x \\<in> range p\",\n   case_tac [3] \"x \\<in> range q\")"], ["proof (state)\ngoal (4 subgoals):\n 1. x \\<in> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 3. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 4. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "assume \"x \\<in> range p\""], ["proof (state)\nthis:\n  x \\<in> range p\n\ngoal (4 subgoals):\n 1. x \\<in> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 3. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 4. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "hence \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x], inv p ` X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  x \\<in> range p\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x],\n     inv p ` X)\n    \\<in> failures P", "using B"], ["proof (prove)\nusing this:\n  x \\<in> range p\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x])), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x],\n     inv p ` X)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x],\n   inv p ` X)\n  \\<in> failures P\n\ngoal (4 subgoals):\n 1. x \\<in> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 3. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 4. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "thus \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x],\n   inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P", "by (rule process_rule_2)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (3 subgoals):\n 1. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 3. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 3. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "assume \"x \\<notin> range p\""], ["proof (state)\nthis:\n  x \\<notin> range p\n\ngoal (3 subgoals):\n 1. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 3. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "hence \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  x \\<notin> range p\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P", "using B"], ["proof (prove)\nusing this:\n  x \\<notin> range p\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x])), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (3 subgoals):\n 1. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 3. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (3 subgoals):\n 1. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 3. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "have \"{} \\<subseteq> inv p ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> inv p ` X", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> inv p ` X\n\ngoal (3 subgoals):\n 1. x \\<notin> range p \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P\n 2. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 3. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n  {} \\<subseteq> inv p ` X", "show \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n  {} \\<subseteq> inv p ` X\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "assume \"x \\<in> range q\""], ["proof (state)\nthis:\n  x \\<in> range q\n\ngoal (2 subgoals):\n 1. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "hence \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x], inv q ` Y) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  x \\<in> range q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x],\n     inv q ` Y)\n    \\<in> failures Q", "using C"], ["proof (prove)\nusing this:\n  x \\<in> range q\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x])), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x],\n     inv q ` Y)\n    \\<in> failures Q", "by simp"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x],\n   inv q ` Y)\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. x \\<in> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "thus \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], {}) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x],\n   inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "by (rule process_rule_2)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "assume \"x \\<notin> range q\""], ["proof (state)\nthis:\n  x \\<notin> range q\n\ngoal (1 subgoal):\n 1. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "hence \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  x \\<notin> range q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "using C"], ["proof (prove)\nusing this:\n  x \\<notin> range q\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x])), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "by simp"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "have \"{} \\<subseteq> inv q ` Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> inv q ` Y", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> inv q ` Y\n\ngoal (1 subgoal):\n 1. x \\<notin> range q \\<Longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n  {} \\<subseteq> inv q ` Y", "show \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], {}) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n  {} \\<subseteq> inv q ` Y\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q \\<and>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. xs @ [x] \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs @ [x] \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "assume A: \"xs @ [x] \\<in> con_comp_divergences P Q p q\""], ["proof (state)\nthis:\n  xs @ [x] \\<in> con_comp_divergences P Q p q\n\ngoal (1 subgoal):\n 1. xs @ [x] \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "show\n   \"set xs \\<subseteq> range p \\<union> range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], {}) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], {}) \\<in> failures Q \\<or>\n    xs \\<in> con_comp_divergences P Q p q\"\n    (is \"?A \\<or> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "proof (insert A, simp add: con_comp_divergences_def,\n   ((erule exE)?, erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xs @ [x] = xsa @ ys;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q\\<rbrakk>\n       \\<Longrightarrow> set xs \\<subseteq> range p \\<union> range q \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          {})\n                         \\<in> failures Q \\<or>\n                         (\\<exists>xsa.\n                             (\\<exists>ys. xs = xsa @ ys) \\<and>\n                             set xsa\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xsa)\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xsa)\n                             \\<in> divergences Q)", "fix ws ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xs @ [x] = xsa @ ys;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q\\<rbrakk>\n       \\<Longrightarrow> set xs \\<subseteq> range p \\<union> range q \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          {})\n                         \\<in> failures Q \\<or>\n                         (\\<exists>xsa.\n                             (\\<exists>ys. xs = xsa @ ys) \\<and>\n                             set xsa\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xsa)\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xsa)\n                             \\<in> divergences Q)", "assume\n      B: \"xs @ [x] = ws @ ys\" and\n      C: \"set ws \\<subseteq> range p \\<union> range q\" and\n      D: \"map (inv p) [x\\<leftarrow>ws. x \\<in> range p] \\<in> divergences P\" and\n      E: \"map (inv q) [x\\<leftarrow>ws. x \\<in> range q] \\<in> divergences Q\""], ["proof (state)\nthis:\n  xs @ [x] = ws @ ys\n  set ws \\<subseteq> range p \\<union> range q\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws) \\<in> divergences P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xs @ [x] = xsa @ ys;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q\\<rbrakk>\n       \\<Longrightarrow> set xs \\<subseteq> range p \\<union> range q \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          {})\n                         \\<in> failures Q \\<or>\n                         (\\<exists>xsa.\n                             (\\<exists>ys. xs = xsa @ ys) \\<and>\n                             set xsa\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xsa)\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xsa)\n                             \\<in> divergences Q)", "show \"?A \\<or> (\\<exists>ws'.\n      (\\<exists>ys'. xs = ws' @ ys') \\<and>\n      set ws' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>ws'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>ws'. x \\<in> range q] \\<in> divergences Q)\"\n      (is \"_ \\<or> (\\<exists>ws'. ?B ws')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    (\\<exists>ws'.\n        (\\<exists>ys'. xs = ws' @ ys') \\<and>\n        set ws' \\<subseteq> range p \\<union> range q \\<and>\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n        \\<in> divergences P \\<and>\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n        \\<in> divergences Q)", "proof (cases ys, rule disjI1, rule_tac [2] disjI2)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "hence \"set (xs @ [x]) \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. set (xs @ [x]) \\<subseteq> range p \\<union> range q", "using B and C"], ["proof (prove)\nusing this:\n  ys = []\n  xs @ [x] = ws @ ys\n  set ws \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set (xs @ [x]) \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  set (xs @ [x]) \\<subseteq> range p \\<union> range q\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "hence \"insert x (set xs) \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. insert x (set xs) \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  insert x (set xs) \\<subseteq> range p \\<union> range q\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  insert x (set xs) \\<subseteq> range p \\<union> range q\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "have \"set xs \\<subseteq> insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> insert x (set xs)", "by (rule subset_insertI)"], ["proof (state)\nthis:\n  set xs \\<subseteq> insert x (set xs)\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  insert x (set xs) \\<subseteq> range p \\<union> range q\n  set xs \\<subseteq> insert x (set xs)", "have \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  insert x (set xs) \\<subseteq> range p \\<union> range q\n  set xs \\<subseteq> insert x (set xs)\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "have \"map (inv p) [x\\<leftarrow>xs @ [x]. x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x]))\n    \\<in> divergences P", "using Nil and B and D"], ["proof (prove)\nusing this:\n  ys = []\n  xs @ [x] = ws @ ys\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws) \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x]))\n    \\<in> divergences P", "by simp"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x]))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "hence \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x]))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P", "proof (cases \"x \\<in> range p\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n             [inv p x]\n             \\<in> divergences P;\n     x \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P\n 2. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n             \\<in> divergences P;\n     x \\<notin> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P", "assume \"map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x] \\<in> divergences P\""], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x]\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n             [inv p x]\n             \\<in> divergences P;\n     x \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P\n 2. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n             \\<in> divergences P;\n     x \\<notin> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P", "hence \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x], {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x]\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n             [inv p x]\n             \\<in> divergences P;\n     x \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P\n 2. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n             \\<in> divergences P;\n     x \\<notin> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P", "by (rule process_rule_2)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n             \\<in> divergences P;\n     x \\<notin> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n             \\<in> divergences P;\n     x \\<notin> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P", "assume \"map (inv p) [x\\<leftarrow>xs. x \\<in> range p] \\<in> divergences P\""], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> divergences P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n             \\<in> divergences P;\n     x \\<notin> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P", "thus ?thesis"], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> divergences P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "have \"map (inv q) [x\\<leftarrow>xs @ [x]. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x]))\n    \\<in> divergences Q", "using Nil and B and E"], ["proof (prove)\nusing this:\n  ys = []\n  xs @ [x] = ws @ ys\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x]))\n    \\<in> divergences Q", "by simp"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x]))\n  \\<in> divergences Q\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "hence \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], {}) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x]))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "proof (cases \"x \\<in> range q\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @\n             [inv q x]\n             \\<in> divergences Q;\n     x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q\n 2. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs)\n             \\<in> divergences Q;\n     x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q", "assume \"map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x] \\<in> divergences Q\""], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x]\n  \\<in> divergences Q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @\n             [inv q x]\n             \\<in> divergences Q;\n     x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q\n 2. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs)\n             \\<in> divergences Q;\n     x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q", "hence \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x], {}) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x]\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @\n             [inv q x]\n             \\<in> divergences Q;\n     x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q\n 2. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs)\n             \\<in> divergences Q;\n     x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "by (rule process_rule_2)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs)\n             \\<in> divergences Q;\n     x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs)\n             \\<in> divergences Q;\n     x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q", "assume \"map (inv q) [x\\<leftarrow>xs. x \\<in> range q] \\<in> divergences Q\""], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs)\n             \\<in> divergences Q;\n     x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> range p \\<union> range q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q", "show ?A"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p \\<union> range q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "by blast"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q \\<and>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "case Cons"], ["proof (state)\nthis:\n  ys = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  ys = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "have \"butlast (xs @ [x]) = butlast (ws @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (xs @ [x]) = butlast (ws @ ys)", "using B"], ["proof (prove)\nusing this:\n  xs @ [x] = ws @ ys\n\ngoal (1 subgoal):\n 1. butlast (xs @ [x]) = butlast (ws @ ys)", "by simp"], ["proof (state)\nthis:\n  butlast (xs @ [x]) = butlast (ws @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  ys = a_ # list_\n  butlast (xs @ [x]) = butlast (ws @ ys)", "have \"xs = ws @ butlast ys\""], ["proof (prove)\nusing this:\n  ys = a_ # list_\n  butlast (xs @ [x]) = butlast (ws @ ys)\n\ngoal (1 subgoal):\n 1. xs = ws @ butlast ys", "by (simp add: butlast_append)"], ["proof (state)\nthis:\n  xs = ws @ butlast ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "hence \"\\<exists>ys'. xs = ws @ ys'\""], ["proof (prove)\nusing this:\n  xs = ws @ butlast ys\n\ngoal (1 subgoal):\n 1. \\<exists>ys'. xs = ws @ ys'", ".."], ["proof (state)\nthis:\n  \\<exists>ys'. xs = ws @ ys'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "hence \"?B ws\""], ["proof (prove)\nusing this:\n  \\<exists>ys'. xs = ws @ ys'\n\ngoal (1 subgoal):\n 1. (\\<exists>ys'. xs = ws @ ys') \\<and>\n    set ws \\<subseteq> range p \\<union> range q \\<and>\n    map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws)\n    \\<in> divergences P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws)\n    \\<in> divergences Q", "using C and D and E"], ["proof (prove)\nusing this:\n  \\<exists>ys'. xs = ws @ ys'\n  set ws \\<subseteq> range p \\<union> range q\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws) \\<in> divergences P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (\\<exists>ys'. xs = ws @ ys') \\<and>\n    set ws \\<subseteq> range p \\<union> range q \\<and>\n    map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws)\n    \\<in> divergences P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws)\n    \\<in> divergences Q", "by simp"], ["proof (state)\nthis:\n  (\\<exists>ys'. xs = ws @ ys') \\<and>\n  set ws \\<subseteq> range p \\<union> range q \\<and>\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws)\n  \\<in> divergences P \\<and>\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>ws'.\n          (\\<exists>ys'. xs = ws' @ ys') \\<and>\n          set ws' \\<subseteq> range p \\<union> range q \\<and>\n          map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n          \\<in> divergences P \\<and>\n          map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n          \\<in> divergences Q", "thus \"\\<exists>ws'. ?B ws'\""], ["proof (prove)\nusing this:\n  (\\<exists>ys'. xs = ws @ ys') \\<and>\n  set ws \\<subseteq> range p \\<union> range q \\<and>\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws)\n  \\<in> divergences P \\<and>\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. \\<exists>ws'.\n       (\\<exists>ys'. xs = ws' @ ys') \\<and>\n       set ws' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n       \\<in> divergences Q", ".."], ["proof (state)\nthis:\n  \\<exists>ws'.\n     (\\<exists>ys'. xs = ws' @ ys') \\<and>\n     set ws' \\<subseteq> range p \\<union> range q \\<and>\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n     \\<in> divergences P \\<and>\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n     \\<in> divergences Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q \\<and>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q \\<or>\n  (\\<exists>ws'.\n      (\\<exists>ys'. xs = ws' @ ys') \\<and>\n      set ws' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws')\n      \\<in> divergences P \\<and>\n      map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws')\n      \\<in> divergences Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q \\<and>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_prop_3:\n \"\\<lbrakk>(xs, Y) \\<in> con_comp_failures P Q p q; X \\<subseteq> Y\\<rbrakk> \\<Longrightarrow>\n    (xs, X) \\<in> con_comp_failures P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xs, Y) \\<in> con_comp_failures P Q p q;\n     X \\<subseteq> Y\\<rbrakk>\n    \\<Longrightarrow> (xs, X) \\<in> con_comp_failures P Q p q", "proof (simp add: con_comp_failures_def, erule disjE, simp_all,\n (erule exE)+, (erule conjE)+, rule disjI1, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Xa Ya Z.\n       \\<lbrakk>X \\<subseteq> Xa \\<union> Ya \\<union> Z;\n        Y = Xa \\<union> Ya \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Ya \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Ya)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Y Z.\n                            X = Xa \\<union> Y \\<union> Z \\<and>\n                            Xa \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` Xa)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "fix X' Y' Z'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Xa Ya Z.\n       \\<lbrakk>X \\<subseteq> Xa \\<union> Ya \\<union> Z;\n        Y = Xa \\<union> Ya \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Ya \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Ya)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Y Z.\n                            X = Xa \\<union> Y \\<union> Z \\<and>\n                            Xa \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` Xa)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "assume\n    A: \"X \\<subseteq> X' \\<union> Y' \\<union> Z'\" and\n    B: \"X' \\<subseteq> range p\" and\n    C: \"Y' \\<subseteq> range q\" and\n    D: \"Z' \\<subseteq> - range p\" and\n    E: \"Z' \\<subseteq> - range q\" and\n    F: \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X') \\<in> failures P\" and\n    G: \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y') \\<in> failures Q\""], ["proof (state)\nthis:\n  X \\<subseteq> X' \\<union> Y' \\<union> Z'\n  X' \\<subseteq> range p\n  Y' \\<subseteq> range q\n  Z' \\<subseteq> - range p\n  Z' \\<subseteq> - range q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>Xa Ya Z.\n       \\<lbrakk>X \\<subseteq> Xa \\<union> Ya \\<union> Z;\n        Y = Xa \\<union> Ya \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Ya \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Ya)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Y Z.\n                            X = Xa \\<union> Y \\<union> Z \\<and>\n                            Xa \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` Xa)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "show \"\\<exists>X' Y' Z'.\n    X = X' \\<union> Y' \\<union> Z' \\<and>\n    X' \\<subseteq> range p \\<and>\n    Y' \\<subseteq> range q \\<and>\n    Z' \\<subseteq> - range p \\<and>\n    Z' \\<subseteq> - range q \\<and>\n    (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X') \\<in> failures P \\<and>\n    (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y') \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X' Y' Z'.\n       X = X' \\<union> Y' \\<union> Z' \\<and>\n       X' \\<subseteq> range p \\<and>\n       Y' \\<subseteq> range q \\<and>\n       Z' \\<subseteq> - range p \\<and>\n       Z' \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n       \\<in> failures Q", "proof (rule_tac x = \"X' \\<inter> X\" in exI, rule_tac x = \"Y' \\<inter> X\" in exI,\n   rule_tac x = \"Z' \\<inter> X\" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)"], ["proof (state)\ngoal (7 subgoals):\n 1. X = X' \\<inter> X \\<union> Y' \\<inter> X \\<union> Z' \\<inter> X\n 2. X' \\<inter> X \\<subseteq> range p\n 3. Y' \\<inter> X \\<subseteq> range q\n 4. Z' \\<inter> X \\<subseteq> - range p\n 5. Z' \\<inter> X \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "show \"X = X' \\<inter> X \\<union> Y' \\<inter> X \\<union> Z' \\<inter> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = X' \\<inter> X \\<union> Y' \\<inter> X \\<union> Z' \\<inter> X", "using A"], ["proof (prove)\nusing this:\n  X \\<subseteq> X' \\<union> Y' \\<union> Z'\n\ngoal (1 subgoal):\n 1. X = X' \\<inter> X \\<union> Y' \\<inter> X \\<union> Z' \\<inter> X", "by blast"], ["proof (state)\nthis:\n  X = X' \\<inter> X \\<union> Y' \\<inter> X \\<union> Z' \\<inter> X\n\ngoal (6 subgoals):\n 1. X' \\<inter> X \\<subseteq> range p\n 2. Y' \\<inter> X \\<subseteq> range q\n 3. Z' \\<inter> X \\<subseteq> - range p\n 4. Z' \\<inter> X \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. X' \\<inter> X \\<subseteq> range p\n 2. Y' \\<inter> X \\<subseteq> range q\n 3. Z' \\<inter> X \\<subseteq> - range p\n 4. Z' \\<inter> X \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "show \"X' \\<inter> X \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X' \\<inter> X \\<subseteq> range p", "using B"], ["proof (prove)\nusing this:\n  X' \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. X' \\<inter> X \\<subseteq> range p", "by blast"], ["proof (state)\nthis:\n  X' \\<inter> X \\<subseteq> range p\n\ngoal (5 subgoals):\n 1. Y' \\<inter> X \\<subseteq> range q\n 2. Z' \\<inter> X \\<subseteq> - range p\n 3. Z' \\<inter> X \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. Y' \\<inter> X \\<subseteq> range q\n 2. Z' \\<inter> X \\<subseteq> - range p\n 3. Z' \\<inter> X \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "show \"Y' \\<inter> X \\<subseteq> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y' \\<inter> X \\<subseteq> range q", "using C"], ["proof (prove)\nusing this:\n  Y' \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. Y' \\<inter> X \\<subseteq> range q", "by blast"], ["proof (state)\nthis:\n  Y' \\<inter> X \\<subseteq> range q\n\ngoal (4 subgoals):\n 1. Z' \\<inter> X \\<subseteq> - range p\n 2. Z' \\<inter> X \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. Z' \\<inter> X \\<subseteq> - range p\n 2. Z' \\<inter> X \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "show \"Z' \\<inter> X \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z' \\<inter> X \\<subseteq> - range p", "using D"], ["proof (prove)\nusing this:\n  Z' \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. Z' \\<inter> X \\<subseteq> - range p", "by blast"], ["proof (state)\nthis:\n  Z' \\<inter> X \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. Z' \\<inter> X \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Z' \\<inter> X \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "show \"Z' \\<inter> X \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z' \\<inter> X \\<subseteq> - range q", "using E"], ["proof (prove)\nusing this:\n  Z' \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. Z' \\<inter> X \\<subseteq> - range q", "by blast"], ["proof (state)\nthis:\n  Z' \\<inter> X \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "have \"inv p ` (X' \\<inter> X) \\<subseteq> inv p ` X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv p ` (X' \\<inter> X) \\<subseteq> inv p ` X'", "by blast"], ["proof (state)\nthis:\n  inv p ` (X' \\<inter> X) \\<subseteq> inv p ` X'\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "with F"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n  \\<in> failures P\n  inv p ` (X' \\<inter> X) \\<subseteq> inv p ` X'", "show \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` (X' \\<inter> X))\n      \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n  \\<in> failures P\n  inv p ` (X' \\<inter> X) \\<subseteq> inv p ` X'\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` (X' \\<inter> X))\n    \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   inv p ` (X' \\<inter> X))\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "have \"inv q ` (Y' \\<inter> X) \\<subseteq> inv q ` Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv q ` (Y' \\<inter> X) \\<subseteq> inv q ` Y'", "by blast"], ["proof (state)\nthis:\n  inv q ` (Y' \\<inter> X) \\<subseteq> inv q ` Y'\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "with G"], ["proof (chain)\npicking this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n  \\<in> failures Q\n  inv q ` (Y' \\<inter> X) \\<subseteq> inv q ` Y'", "show \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` (Y' \\<inter> X))\n      \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n  \\<in> failures Q\n  inv q ` (Y' \\<inter> X) \\<subseteq> inv q ` Y'\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` (Y' \\<inter> X))\n    \\<in> failures Q", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   inv q ` (Y' \\<inter> X))\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X' Y' Z'.\n     X = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_prop_4:\n \"(xs, X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    (xs @ [x], {}) \\<in> con_comp_failures P Q p q \\<or>\n    (xs, insert x X) \\<in> con_comp_failures P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    (xs @ [x], {}) \\<in> con_comp_failures P Q p q \\<or>\n    (xs, insert x X) \\<in> con_comp_failures P Q p q", "proof (simp add: con_comp_failures_def del: filter_append,\n erule disjE, (erule exE)+, (erule conjE)+, simp_all del: filter_append)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p)\n                             (xs @ [x])),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q)\n                             (xs @ [x])),\n                          {})\n                         \\<in> failures Q \\<or>\n                         xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                         (\\<exists>X Ya Za.\n                             insert x (Xa \\<union> Y \\<union> Z) =\n                             X \\<union> Ya \\<union> Za \\<and>\n                             X \\<subseteq> range p \\<and>\n                             Ya \\<subseteq> range q \\<and>\n                             Za \\<subseteq> - range p \\<and>\n                             Za \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p) xs),\n                              inv p ` X)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q) xs),\n                              inv q ` Ya)\n                             \\<in> failures Q) \\<or>\n                         xs \\<in> con_comp_divergences P Q p q", "fix X Y Z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p)\n                             (xs @ [x])),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q)\n                             (xs @ [x])),\n                          {})\n                         \\<in> failures Q \\<or>\n                         xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                         (\\<exists>X Ya Za.\n                             insert x (Xa \\<union> Y \\<union> Z) =\n                             X \\<union> Ya \\<union> Za \\<and>\n                             X \\<subseteq> range p \\<and>\n                             Ya \\<subseteq> range q \\<and>\n                             Za \\<subseteq> - range p \\<and>\n                             Za \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p) xs),\n                              inv p ` X)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q) xs),\n                              inv q ` Ya)\n                             \\<in> failures Q) \\<or>\n                         xs \\<in> con_comp_divergences P Q p q", "assume\n    A: \"X \\<subseteq> range p\" and\n    B: \"Y \\<subseteq> range q\" and\n    C: \"Z \\<subseteq> - range p\" and\n    D: \"Z \\<subseteq> - range q\" and\n    E: \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X) \\<in> failures P\" and\n    F: \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y) \\<in> failures Q\""], ["proof (state)\nthis:\n  X \\<subseteq> range p\n  Y \\<subseteq> range q\n  Z \\<subseteq> - range p\n  Z \\<subseteq> - range q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p)\n                             (xs @ [x])),\n                          {})\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q)\n                             (xs @ [x])),\n                          {})\n                         \\<in> failures Q \\<or>\n                         xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                         (\\<exists>X Ya Za.\n                             insert x (Xa \\<union> Y \\<union> Z) =\n                             X \\<union> Ya \\<union> Za \\<and>\n                             X \\<subseteq> range p \\<and>\n                             Ya \\<subseteq> range q \\<and>\n                             Za \\<subseteq> - range p \\<and>\n                             Za \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p) xs),\n                              inv p ` X)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q) xs),\n                              inv q ` Ya)\n                             \\<in> failures Q) \\<or>\n                         xs \\<in> con_comp_divergences P Q p q", "show\n   \"(x \\<in> range p \\<or> x \\<in> range q) \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ [x]. x \\<in> range p], {}) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ [x]. x \\<in> range q], {}) \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X') \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y') \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\"\n    (is \"_ \\<or> _ \\<or> ?A \\<or> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x])), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x])), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "proof (cases \"x \\<in> range p\", case_tac [!] \"x \\<in> range q\", simp_all)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       [inv p x],\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 2. \\<lbrakk>x \\<in> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       [inv p x],\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 3. \\<lbrakk>x \\<notin> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 4. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "assume\n      G: \"x \\<in> range p\" and\n      H: \"x \\<in> range q\""], ["proof (state)\nthis:\n  x \\<in> range p\n  x \\<in> range q\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       [inv p x],\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 2. \\<lbrakk>x \\<in> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       [inv p x],\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 3. \\<lbrakk>x \\<notin> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 4. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "show\n     \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x], {}) \\<in> failures P \\<and>\n        (map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x], {}) \\<in> failures Q \\<or>\n      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n      ?A \\<or>\n      xs \\<in> con_comp_divergences P Q p q\"\n      (is \"?B \\<or> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "proof (cases ?B, simp_all del: disj_not1, erule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "assume\n        I: \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x], {}) \\<notin> failures P\""], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<notin> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "have ?A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X' Y' Z'.\n       insert x (X \\<union> Y \\<union> Z) =\n       X' \\<union> Y' \\<union> Z' \\<and>\n       X' \\<subseteq> range p \\<and>\n       Y' \\<subseteq> range q \\<and>\n       Z' \\<subseteq> - range p \\<and>\n       Z' \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n       \\<in> failures Q", "proof (rule_tac x = \"insert x X\" in exI, rule_tac x = \"Y\" in exI,\n       rule_tac x = \"Z\" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)"], ["proof (state)\ngoal (7 subgoals):\n 1. insert x (X \\<union> Y \\<union> Z) = insert x X \\<union> Y \\<union> Z\n 2. insert x X \\<subseteq> range p\n 3. Y \\<subseteq> range q\n 4. Z \\<subseteq> - range p\n 5. Z \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"insert x (X \\<union> Y \\<union> Z) = insert x X \\<union> Y \\<union> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (X \\<union> Y \\<union> Z) = insert x X \\<union> Y \\<union> Z", "by simp"], ["proof (state)\nthis:\n  insert x (X \\<union> Y \\<union> Z) = insert x X \\<union> Y \\<union> Z\n\ngoal (6 subgoals):\n 1. insert x X \\<subseteq> range p\n 2. Y \\<subseteq> range q\n 3. Z \\<subseteq> - range p\n 4. Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. insert x X \\<subseteq> range p\n 2. Y \\<subseteq> range q\n 3. Z \\<subseteq> - range p\n 4. Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"insert x X \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x X \\<subseteq> range p", "using A and G"], ["proof (prove)\nusing this:\n  X \\<subseteq> range p\n  x \\<in> range p\n\ngoal (1 subgoal):\n 1. insert x X \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  insert x X \\<subseteq> range p\n\ngoal (5 subgoals):\n 1. Y \\<subseteq> range q\n 2. Z \\<subseteq> - range p\n 3. Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. Y \\<subseteq> range q\n 2. Z \\<subseteq> - range p\n 3. Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"Y \\<subseteq> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> range q", "using B"], ["proof (prove)\nusing this:\n  Y \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> range q", "."], ["proof (state)\nthis:\n  Y \\<subseteq> range q\n\ngoal (4 subgoals):\n 1. Z \\<subseteq> - range p\n 2. Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. Z \\<subseteq> - range p\n 2. Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"Z \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range p", "using C"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range p", "."], ["proof (state)\nthis:\n  Z \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"Z \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range q", "using D"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range q", "."], ["proof (state)\nthis:\n  Z \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "have\n         \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x], {})\n            \\<in> failures P \\<or>\n          (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], insert (inv p x) (inv p ` X))\n            \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<or>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     insert (inv p x) (inv p ` X))\n    \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<or>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     insert (inv p x) (inv p ` X))\n    \\<in> failures P", "by (rule process_rule_4)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<or>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   insert (inv p x) (inv p ` X))\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "thus \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` insert x X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<or>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   insert (inv p x) (inv p ` X))\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P", "using I"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<or>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   insert (inv p x) (inv p ` X))\n  \\<in> failures P\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<notin> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   inv p ` insert x X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "using F"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "."], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "assume\n        I: \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x], {}) \\<notin> failures Q\""], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<notin> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "have ?A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X' Y' Z'.\n       insert x (X \\<union> Y \\<union> Z) =\n       X' \\<union> Y' \\<union> Z' \\<and>\n       X' \\<subseteq> range p \\<and>\n       Y' \\<subseteq> range q \\<and>\n       Z' \\<subseteq> - range p \\<and>\n       Z' \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n       \\<in> failures Q", "proof (rule_tac x = \"X\" in exI, rule_tac x = \"insert x Y\" in exI,\n       rule_tac x = \"Z\" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)"], ["proof (state)\ngoal (7 subgoals):\n 1. insert x (X \\<union> Y \\<union> Z) = X \\<union> insert x Y \\<union> Z\n 2. X \\<subseteq> range p\n 3. insert x Y \\<subseteq> range q\n 4. Z \\<subseteq> - range p\n 5. Z \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"insert x (X \\<union> Y \\<union> Z) = X \\<union> insert x Y \\<union> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (X \\<union> Y \\<union> Z) = X \\<union> insert x Y \\<union> Z", "by simp"], ["proof (state)\nthis:\n  insert x (X \\<union> Y \\<union> Z) = X \\<union> insert x Y \\<union> Z\n\ngoal (6 subgoals):\n 1. X \\<subseteq> range p\n 2. insert x Y \\<subseteq> range q\n 3. Z \\<subseteq> - range p\n 4. Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. X \\<subseteq> range p\n 2. insert x Y \\<subseteq> range q\n 3. Z \\<subseteq> - range p\n 4. Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"X \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> range p", "using A"], ["proof (prove)\nusing this:\n  X \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. X \\<subseteq> range p", "."], ["proof (state)\nthis:\n  X \\<subseteq> range p\n\ngoal (5 subgoals):\n 1. insert x Y \\<subseteq> range q\n 2. Z \\<subseteq> - range p\n 3. Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. insert x Y \\<subseteq> range q\n 2. Z \\<subseteq> - range p\n 3. Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"insert x Y \\<subseteq> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x Y \\<subseteq> range q", "using B and H"], ["proof (prove)\nusing this:\n  Y \\<subseteq> range q\n  x \\<in> range q\n\ngoal (1 subgoal):\n 1. insert x Y \\<subseteq> range q", "by simp"], ["proof (state)\nthis:\n  insert x Y \\<subseteq> range q\n\ngoal (4 subgoals):\n 1. Z \\<subseteq> - range p\n 2. Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. Z \\<subseteq> - range p\n 2. Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"Z \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range p", "using C"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range p", "."], ["proof (state)\nthis:\n  Z \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"Z \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range q", "using D"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range q", "."], ["proof (state)\nthis:\n  Z \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P", "."], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "have\n         \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x], {})\n            \\<in> failures Q \\<or>\n          (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], insert (inv q x) (inv q ` Y))\n            \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     insert (inv q x) (inv q ` Y))\n    \\<in> failures Q", "using F"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     insert (inv q x) (inv q ` Y))\n    \\<in> failures Q", "by (rule process_rule_4)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   insert (inv q x) (inv q ` Y))\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "thus \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` insert x Y) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   insert (inv q x) (inv q ` Y))\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "using I"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   insert (inv q x) (inv q ` Y))\n  \\<in> failures Q\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<notin> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "by simp"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   inv q ` insert x Y)\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       [inv p x],\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 2. \\<lbrakk>x \\<notin> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 3. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       [inv p x],\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 2. \\<lbrakk>x \\<notin> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 3. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "assume G: \"x \\<in> range p\""], ["proof (state)\nthis:\n  x \\<in> range p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       [inv p x],\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 2. \\<lbrakk>x \\<notin> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 3. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "show\n     \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x], {}) \\<in> failures P \\<and>\n        (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], {}) \\<in> failures Q \\<or>\n      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n      ?A \\<or>\n      xs \\<in> con_comp_divergences P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "proof (cases \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x], {})\n     \\<in> failures P\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "case True"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "moreover"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "have \"{} \\<subseteq> inv q ` Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> inv q ` Y", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> inv q ` Y\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "with F"], ["proof (chain)\npicking this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n  {} \\<subseteq> inv q ` Y", "have \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], {}) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n  {} \\<subseteq> inv q ` Y\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q", "show ?thesis"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "case False"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<notin> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "have ?A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X' Y' Z'.\n       insert x (X \\<union> Y \\<union> Z) =\n       X' \\<union> Y' \\<union> Z' \\<and>\n       X' \\<subseteq> range p \\<and>\n       Y' \\<subseteq> range q \\<and>\n       Z' \\<subseteq> - range p \\<and>\n       Z' \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n       \\<in> failures Q", "proof (rule_tac x = \"insert x X\" in exI, rule_tac x = \"Y\" in exI,\n       rule_tac x = \"Z\" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)"], ["proof (state)\ngoal (7 subgoals):\n 1. insert x (X \\<union> Y \\<union> Z) = insert x X \\<union> Y \\<union> Z\n 2. insert x X \\<subseteq> range p\n 3. Y \\<subseteq> range q\n 4. Z \\<subseteq> - range p\n 5. Z \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"insert x (X \\<union> Y \\<union> Z) = insert x X \\<union> Y \\<union> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (X \\<union> Y \\<union> Z) = insert x X \\<union> Y \\<union> Z", "by simp"], ["proof (state)\nthis:\n  insert x (X \\<union> Y \\<union> Z) = insert x X \\<union> Y \\<union> Z\n\ngoal (6 subgoals):\n 1. insert x X \\<subseteq> range p\n 2. Y \\<subseteq> range q\n 3. Z \\<subseteq> - range p\n 4. Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. insert x X \\<subseteq> range p\n 2. Y \\<subseteq> range q\n 3. Z \\<subseteq> - range p\n 4. Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"insert x X \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x X \\<subseteq> range p", "using A and G"], ["proof (prove)\nusing this:\n  X \\<subseteq> range p\n  x \\<in> range p\n\ngoal (1 subgoal):\n 1. insert x X \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  insert x X \\<subseteq> range p\n\ngoal (5 subgoals):\n 1. Y \\<subseteq> range q\n 2. Z \\<subseteq> - range p\n 3. Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. Y \\<subseteq> range q\n 2. Z \\<subseteq> - range p\n 3. Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"Y \\<subseteq> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> range q", "using B"], ["proof (prove)\nusing this:\n  Y \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> range q", "."], ["proof (state)\nthis:\n  Y \\<subseteq> range q\n\ngoal (4 subgoals):\n 1. Z \\<subseteq> - range p\n 2. Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. Z \\<subseteq> - range p\n 2. Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"Z \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range p", "using C"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range p", "."], ["proof (state)\nthis:\n  Z \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"Z \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range q", "using D"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range q", "."], ["proof (state)\nthis:\n  Z \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "have\n         \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ [inv p x], {})\n            \\<in> failures P \\<or>\n          (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], insert (inv p x) (inv p ` X))\n            \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<or>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     insert (inv p x) (inv p ` X))\n    \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<or>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     insert (inv p x) (inv p ` X))\n    \\<in> failures P", "by (rule process_rule_4)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<or>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   insert (inv p x) (inv p ` X))\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "thus \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` insert x X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<or>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   insert (inv p x) (inv p ` X))\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P", "using False"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<or>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   insert (inv p x) (inv p ` X))\n  \\<in> failures P\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<notin> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` insert x X)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   inv p ` insert x X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "using F"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "."], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<notin> failures P \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @ [inv p x], {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 2. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 2. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "assume G: \"x \\<in> range q\""], ["proof (state)\nthis:\n  x \\<in> range q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> range p; x \\<in> range q\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       {})\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs) @\n                       [inv q x],\n                       {})\n                      \\<in> failures Q \\<or>\n                      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q\n 2. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "show\n     \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], {}) \\<in> failures P \\<and>\n        (map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x], {}) \\<in> failures Q \\<or>\n      xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n      ?A \\<or>\n      xs \\<in> con_comp_divergences P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "proof (cases \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x], {})\n     \\<in> failures Q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "case True"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "moreover"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "have \"{} \\<subseteq> inv p ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> inv p ` X", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> inv p ` X\n\ngoal (2 subgoals):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "with E"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n  {} \\<subseteq> inv p ` X", "have \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n  {} \\<subseteq> inv p ` X\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P", "show ?thesis"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "case False"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<notin> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "have ?A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X' Y' Z'.\n       insert x (X \\<union> Y \\<union> Z) =\n       X' \\<union> Y' \\<union> Z' \\<and>\n       X' \\<subseteq> range p \\<and>\n       Y' \\<subseteq> range q \\<and>\n       Z' \\<subseteq> - range p \\<and>\n       Z' \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n       \\<in> failures Q", "proof (rule_tac x = \"X\" in exI, rule_tac x = \"insert x Y\" in exI,\n       rule_tac x = \"Z\" in exI, (subst conj_assoc [symmetric])+, (rule conjI)+)"], ["proof (state)\ngoal (7 subgoals):\n 1. insert x (X \\<union> Y \\<union> Z) = X \\<union> insert x Y \\<union> Z\n 2. X \\<subseteq> range p\n 3. insert x Y \\<subseteq> range q\n 4. Z \\<subseteq> - range p\n 5. Z \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"insert x (X \\<union> Y \\<union> Z) = X \\<union> insert x Y \\<union> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (X \\<union> Y \\<union> Z) = X \\<union> insert x Y \\<union> Z", "by simp"], ["proof (state)\nthis:\n  insert x (X \\<union> Y \\<union> Z) = X \\<union> insert x Y \\<union> Z\n\ngoal (6 subgoals):\n 1. X \\<subseteq> range p\n 2. insert x Y \\<subseteq> range q\n 3. Z \\<subseteq> - range p\n 4. Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. X \\<subseteq> range p\n 2. insert x Y \\<subseteq> range q\n 3. Z \\<subseteq> - range p\n 4. Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"X \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> range p", "using A"], ["proof (prove)\nusing this:\n  X \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. X \\<subseteq> range p", "."], ["proof (state)\nthis:\n  X \\<subseteq> range p\n\ngoal (5 subgoals):\n 1. insert x Y \\<subseteq> range q\n 2. Z \\<subseteq> - range p\n 3. Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. insert x Y \\<subseteq> range q\n 2. Z \\<subseteq> - range p\n 3. Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"insert x Y \\<subseteq> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x Y \\<subseteq> range q", "using B and G"], ["proof (prove)\nusing this:\n  Y \\<subseteq> range q\n  x \\<in> range q\n\ngoal (1 subgoal):\n 1. insert x Y \\<subseteq> range q", "by simp"], ["proof (state)\nthis:\n  insert x Y \\<subseteq> range q\n\ngoal (4 subgoals):\n 1. Z \\<subseteq> - range p\n 2. Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. Z \\<subseteq> - range p\n 2. Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"Z \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range p", "using C"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range p", "."], ["proof (state)\nthis:\n  Z \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"Z \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range q", "using D"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> - range q", "."], ["proof (state)\nthis:\n  Z \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "show \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P", "."], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "have\n         \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q] @ [inv q x], {})\n            \\<in> failures Q \\<or>\n          (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], insert (inv q x) (inv q ` Y))\n            \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     insert (inv q x) (inv q ` Y))\n    \\<in> failures Q", "using F"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     insert (inv q x) (inv q ` Y))\n    \\<in> failures Q", "by (rule process_rule_4)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   insert (inv q x) (inv q ` Y))\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "thus \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` insert x Y) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   insert (inv q x) (inv q ` Y))\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "using False"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   insert (inv q x) (inv q ` Y))\n  \\<in> failures Q\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<notin> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` insert x Y)\n    \\<in> failures Q", "by simp"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   inv q ` insert x Y)\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<notin> failures Q \\<Longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P \\<and>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n    \\<in> failures Q \\<or>\n    xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) @ [inv q x], {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "assume\n      G: \"x \\<notin> range p\" and\n      H: \"x \\<notin> range q\""], ["proof (state)\nthis:\n  x \\<notin> range p\n  x \\<notin> range q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "have ?A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X' Y' Z'.\n       insert x (X \\<union> Y \\<union> Z) =\n       X' \\<union> Y' \\<union> Z' \\<and>\n       X' \\<subseteq> range p \\<and>\n       Y' \\<subseteq> range q \\<and>\n       Z' \\<subseteq> - range p \\<and>\n       Z' \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n       \\<in> failures Q", "proof (rule_tac x = \"X\" in exI, rule_tac x = \"Y\" in exI,\n     rule_tac x = \"insert x Z\" in exI, (subst conj_assoc [symmetric])+,\n     (rule conjI)+)"], ["proof (state)\ngoal (7 subgoals):\n 1. insert x (X \\<union> Y \\<union> Z) = X \\<union> Y \\<union> insert x Z\n 2. X \\<subseteq> range p\n 3. Y \\<subseteq> range q\n 4. insert x Z \\<subseteq> - range p\n 5. insert x Z \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"insert x (X \\<union> Y \\<union> Z) = X \\<union> Y \\<union> insert x Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (X \\<union> Y \\<union> Z) = X \\<union> Y \\<union> insert x Z", "by simp"], ["proof (state)\nthis:\n  insert x (X \\<union> Y \\<union> Z) = X \\<union> Y \\<union> insert x Z\n\ngoal (6 subgoals):\n 1. X \\<subseteq> range p\n 2. Y \\<subseteq> range q\n 3. insert x Z \\<subseteq> - range p\n 4. insert x Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. X \\<subseteq> range p\n 2. Y \\<subseteq> range q\n 3. insert x Z \\<subseteq> - range p\n 4. insert x Z \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"X \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> range p", "using A"], ["proof (prove)\nusing this:\n  X \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. X \\<subseteq> range p", "."], ["proof (state)\nthis:\n  X \\<subseteq> range p\n\ngoal (5 subgoals):\n 1. Y \\<subseteq> range q\n 2. insert x Z \\<subseteq> - range p\n 3. insert x Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. Y \\<subseteq> range q\n 2. insert x Z \\<subseteq> - range p\n 3. insert x Z \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"Y \\<subseteq> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> range q", "using B"], ["proof (prove)\nusing this:\n  Y \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> range q", "."], ["proof (state)\nthis:\n  Y \\<subseteq> range q\n\ngoal (4 subgoals):\n 1. insert x Z \\<subseteq> - range p\n 2. insert x Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. insert x Z \\<subseteq> - range p\n 2. insert x Z \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"insert x Z \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x Z \\<subseteq> - range p", "using C and G"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range p\n  x \\<notin> range p\n\ngoal (1 subgoal):\n 1. insert x Z \\<subseteq> - range p", "by simp"], ["proof (state)\nthis:\n  insert x Z \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. insert x Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. insert x Z \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"insert x Z \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x Z \\<subseteq> - range q", "using D and H"], ["proof (prove)\nusing this:\n  Z \\<subseteq> - range q\n  x \\<notin> range q\n\ngoal (1 subgoal):\n 1. insert x Z \\<subseteq> - range q", "by simp"], ["proof (state)\nthis:\n  insert x Z \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n    \\<in> failures P", "."], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "show \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "using F"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n    \\<in> failures Q", "."], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> range p; x \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n                      (\\<exists>X' Y' Z'.\n                          insert x (X \\<union> Y \\<union> Z) =\n                          X' \\<union> Y' \\<union> Z' \\<and>\n                          X' \\<subseteq> range p \\<and>\n                          Y' \\<subseteq> range q \\<and>\n                          Z' \\<subseteq> - range p \\<and>\n                          Z' \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p) xs),\n                           inv p ` X')\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q) xs),\n                           inv q ` Y')\n                          \\<in> failures Q) \\<or>\n                      xs \\<in> con_comp_divergences P Q p q", "thus\n     \"xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n      ?A \\<or>\n      xs \\<in> con_comp_divergences P Q p q\""], ["proof (prove)\nusing this:\n  \\<exists>X' Y' Z'.\n     insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n     X' \\<subseteq> range p \\<and>\n     Y' \\<subseteq> range q \\<and>\n     Z' \\<subseteq> - range p \\<and>\n     Z' \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n    (\\<exists>X' Y' Z'.\n        insert x (X \\<union> Y \\<union> Z) =\n        X' \\<union> Y' \\<union> Z' \\<and>\n        X' \\<subseteq> range p \\<and>\n        Y' \\<subseteq> range q \\<and>\n        Z' \\<subseteq> - range p \\<and>\n        Z' \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n        \\<in> failures Q) \\<or>\n    xs \\<in> con_comp_divergences P Q p q", "by simp"], ["proof (state)\nthis:\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [x])), {})\n  \\<in> failures P \\<and>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [x])), {})\n  \\<in> failures Q \\<or>\n  xs @ [x] \\<in> con_comp_divergences P Q p q \\<or>\n  (\\<exists>X' Y' Z'.\n      insert x (X \\<union> Y \\<union> Z) = X' \\<union> Y' \\<union> Z' \\<and>\n      X' \\<subseteq> range p \\<and>\n      Y' \\<subseteq> range q \\<and>\n      Z' \\<subseteq> - range p \\<and>\n      Z' \\<subseteq> - range q \\<and>\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X')\n      \\<in> failures P \\<and>\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y')\n      \\<in> failures Q) \\<or>\n  xs \\<in> con_comp_divergences P Q p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_prop_5:\n \"xs \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    xs @ [x] \\<in> con_comp_divergences P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    xs @ [x] \\<in> con_comp_divergences P Q p q", "proof (simp add: con_comp_divergences_def, erule exE, (erule conjE)+, erule exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            (\\<exists>ys. xs @ [x] = xsa @ ys) \\<and>\n                            set xsa\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xsa)\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xsa)\n                            \\<in> divergences Q", "fix xs' ys'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            (\\<exists>ys. xs @ [x] = xsa @ ys) \\<and>\n                            set xsa\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xsa)\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xsa)\n                            \\<in> divergences Q", "assume\n    A: \"set xs' \\<subseteq> range p \\<union> range q\" and\n    B: \"map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P\" and\n    C: \"map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q\" and\n    D: \"xs = xs' @ ys'\""], ["proof (state)\nthis:\n  set xs' \\<subseteq> range p \\<union> range q\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs') \\<in> divergences P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs') \\<in> divergences Q\n  xs = xs' @ ys'\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            (\\<exists>ys. xs @ [x] = xsa @ ys) \\<and>\n                            set xsa\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xsa)\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xsa)\n                            \\<in> divergences Q", "show \"\\<exists>xs'.\n    (\\<exists>ys'. xs @ [x] = xs' @ ys') \\<and>\n    set xs' \\<subseteq> range p \\<union> range q \\<and>\n    map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n    map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       (\\<exists>ys'. xs @ [x] = xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "proof (rule_tac x = xs' in exI, simp_all add: A B C)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys'. xs @ [x] = xs' @ ys'", "qed (rule_tac x = \"ys' @ [x]\" in exI, simp add: D)"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     (\\<exists>ys'. xs @ [x] = xs' @ ys') \\<and>\n     set xs' \\<subseteq> range p \\<union> range q \\<and>\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n     \\<in> divergences P \\<and>\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n     \\<in> divergences Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_prop_6:\n \"xs \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    (xs, X) \\<in> con_comp_failures P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n    (xs, X) \\<in> con_comp_failures P Q p q", "by (simp add: con_comp_failures_def)"], ["", "lemma con_comp_rep:\n \"Rep_process (P \\<parallel> Q <p, q>) =\n    (con_comp_failures P Q p q, con_comp_divergences P Q p q)\"\n  (is \"_ = ?X\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_process (P \\<parallel> Q <p, q>) =\n    (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "proof (subst con_comp_def, rule Abs_process_inverse, simp add: process_set_def,\n (subst conj_assoc [symmetric])+, (rule conjI)+)"], ["proof (state)\ngoal (6 subgoals):\n 1. process_prop_1 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_2 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 3. process_prop_3 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 4. process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 5. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 6. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "show \"process_prop_1 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_1 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "proof (simp add: process_prop_1_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> con_comp_failures P Q p q", "qed (rule con_comp_prop_1)"], ["proof (state)\nthis:\n  process_prop_1 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n\ngoal (5 subgoals):\n 1. process_prop_2 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_3 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 3. process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 4. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 5. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. process_prop_2 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_3 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 3. process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 4. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 5. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "show \"process_prop_2 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_2 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "proof (simp add: process_prop_2_def del: all_simps, (rule allI)+, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs @ [x], X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n       (xs, {}) \\<in> con_comp_failures P Q p q", "qed (rule con_comp_prop_2)"], ["proof (state)\nthis:\n  process_prop_2 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n\ngoal (4 subgoals):\n 1. process_prop_3 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 3. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 4. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. process_prop_3 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 3. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 4. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "show \"process_prop_3 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_3 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "proof (simp add: process_prop_3_def del: all_simps, (rule allI)+, rule impI,\n   erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs X Y.\n       \\<lbrakk>(xs, Y) \\<in> con_comp_failures P Q p q;\n        X \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xs, X) \\<in> con_comp_failures P Q p q", "qed (rule con_comp_prop_3)"], ["proof (state)\nthis:\n  process_prop_3 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n\ngoal (3 subgoals):\n 1. process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 3. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 3. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "show \"process_prop_4 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "proof (simp add: process_prop_4_def, (rule allI)+, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs, X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n       (xs @ [x], {}) \\<in> con_comp_failures P Q p q \\<or>\n       (xs, insert x X) \\<in> con_comp_failures P Q p q", "qed (rule con_comp_prop_4)"], ["proof (state)\nthis:\n  process_prop_4 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n\ngoal (2 subgoals):\n 1. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n 2. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "show \"process_prop_5 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "proof (simp add: process_prop_5_def, rule allI, rule impI, rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       xs \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n       xs @ [x] \\<in> con_comp_divergences P Q p q", "qed (rule con_comp_prop_5)"], ["proof (state)\nthis:\n  process_prop_5 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n\ngoal (1 subgoal):\n 1. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "show \"process_prop_6 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)", "proof (simp add: process_prop_6_def, rule allI, rule impI, rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs X.\n       xs \\<in> con_comp_divergences P Q p q \\<Longrightarrow>\n       (xs, X) \\<in> con_comp_failures P Q p q", "qed (rule con_comp_prop_6)"], ["proof (state)\nthis:\n  process_prop_6 (con_comp_failures P Q p q, con_comp_divergences P Q p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nHere below, the previous result is applied to derive useful expressions for the outputs of the\nfunctions returning the elements of a process, as defined in \\cite{R1} and \\cite{R2}, when acting on\nthe concurrent composition of a pair of processes.\n\n\\null\n\\<close>"], ["", "lemma con_comp_failures:\n \"failures (P \\<parallel> Q <p, q>) = con_comp_failures P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. failures (P \\<parallel> Q <p, q>) = con_comp_failures P Q p q", "by (simp add: failures_def con_comp_rep)"], ["", "lemma con_comp_divergences:\n \"divergences (P \\<parallel> Q <p, q>) = con_comp_divergences P Q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. divergences (P \\<parallel> Q <p, q>) = con_comp_divergences P Q p q", "by (simp add: divergences_def con_comp_rep)"], ["", "lemma con_comp_futures:\n \"futures (P \\<parallel> Q <p, q>) xs =\n    {(ys, Y). (xs @ ys, Y) \\<in> con_comp_failures P Q p q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. futures (P \\<parallel> Q <p, q>) xs =\n    {(ys, Y). (xs @ ys, Y) \\<in> con_comp_failures P Q p q}", "by (simp add: futures_def con_comp_failures)"], ["", "lemma con_comp_traces:\n \"traces (P \\<parallel> Q <p, q>) = Domain (con_comp_failures P Q p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traces (P \\<parallel> Q <p, q>) = Domain (con_comp_failures P Q p q)", "by (simp add: traces_def con_comp_failures)"], ["", "lemma con_comp_refusals:\n \"refusals (P \\<parallel> Q <p, q>) xs \\<equiv> con_comp_failures P Q p q `` {xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refusals (P \\<parallel> Q <p, q>) xs \\<equiv>\n    con_comp_failures P Q p q `` {xs}", "by (simp add: refusals_def con_comp_failures)"], ["", "lemma con_comp_next_events:\n \"next_events (P \\<parallel> Q <p, q>) xs =\n    {x. xs @ [x] \\<in> Domain (con_comp_failures P Q p q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_events (P \\<parallel> Q <p, q>) xs =\n    {x. xs @ [x] \\<in> Domain (con_comp_failures P Q p q)}", "by (simp add: next_events_def con_comp_traces)"], ["", "text \\<open>\n\\null\n\nIn what follows, three lemmas are proven. The first one, whose proof makes use of the axiom of\nchoice, establishes an additional property required for the above definition of concurrent\ncomposition to be correct, namely that for any two processes whose refusals are closed under set\nunion, their concurrent composition still be such, which is what is expected for any process of\npractical significance (cf. \\cite{R2}). The other two lemmas are auxiliary properties of concurrent\ncomposition used in the proof of the target security conservation theorem.\n\n\\null\n\\<close>"], ["", "lemma con_comp_ref_union_closed:\n  assumes\n    A: \"ref_union_closed P\" and\n    B: \"ref_union_closed Q\"\n  shows \"ref_union_closed (P \\<parallel> Q <p, q>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed (P \\<parallel> Q <p, q>)", "proof (simp add: ref_union_closed_def con_comp_failures con_comp_failures_def\n con_comp_divergences_def del: SUP_identity_eq cong: SUP_cong_simp, (rule allI)+, (rule impI)+,\n erule exE, rule disjI1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "fix xs A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "assume \"\\<forall>X \\<in> A. \\<exists>R S T.\n    X = R \\<union> S \\<union> T \\<and>\n    set xs \\<subseteq> range p \\<union> range q \\<and>\n    R \\<subseteq> range p \\<and>\n    S \\<subseteq> range q \\<and>\n    T \\<subseteq> - range p \\<and>\n    T \\<subseteq> - range q \\<and>\n    (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n    (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` S) \\<in> failures Q\"\n    (is \"\\<forall>X \\<in> A. \\<exists>R S T. ?F X R S T\")"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A.\n     \\<exists>R S T.\n        X = R \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        R \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` R)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` S)\n        \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "hence \"\\<exists>r. \\<forall>X \\<in> A. \\<exists>S T. ?F X (r X) S T\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     \\<exists>R S T.\n        X = R \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        R \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` R)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` S)\n        \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       \\<forall>X\\<in>A.\n          \\<exists>S T.\n             X = r X \\<union> S \\<union> T \\<and>\n             set xs \\<subseteq> range p \\<union> range q \\<and>\n             r X \\<subseteq> range p \\<and>\n             S \\<subseteq> range q \\<and>\n             T \\<subseteq> - range p \\<and>\n             T \\<subseteq> - range q \\<and>\n             (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n              inv p ` r X)\n             \\<in> failures P \\<and>\n             (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n              inv q ` S)\n             \\<in> failures Q", "by (rule bchoice)"], ["proof (state)\nthis:\n  \\<exists>r.\n     \\<forall>X\\<in>A.\n        \\<exists>S T.\n           X = r X \\<union> S \\<union> T \\<and>\n           set xs \\<subseteq> range p \\<union> range q \\<and>\n           r X \\<subseteq> range p \\<and>\n           S \\<subseteq> range q \\<and>\n           T \\<subseteq> - range p \\<and>\n           T \\<subseteq> - range q \\<and>\n           (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n            inv p ` r X)\n           \\<in> failures P \\<and>\n           (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n            inv q ` S)\n           \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     \\<forall>X\\<in>A.\n        \\<exists>S T.\n           X = r X \\<union> S \\<union> T \\<and>\n           set xs \\<subseteq> range p \\<union> range q \\<and>\n           r X \\<subseteq> range p \\<and>\n           S \\<subseteq> range q \\<and>\n           T \\<subseteq> - range p \\<and>\n           T \\<subseteq> - range q \\<and>\n           (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n            inv p ` r X)\n           \\<in> failures P \\<and>\n           (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n            inv q ` S)\n           \\<in> failures Q", "obtain r where \"\\<forall>X \\<in> A. \\<exists>S T. ?F X (r X) S T\""], ["proof (prove)\nusing this:\n  \\<exists>r.\n     \\<forall>X\\<in>A.\n        \\<exists>S T.\n           X = r X \\<union> S \\<union> T \\<and>\n           set xs \\<subseteq> range p \\<union> range q \\<and>\n           r X \\<subseteq> range p \\<and>\n           S \\<subseteq> range q \\<and>\n           T \\<subseteq> - range p \\<and>\n           T \\<subseteq> - range q \\<and>\n           (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n            inv p ` r X)\n           \\<in> failures P \\<and>\n           (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n            inv q ` S)\n           \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<forall>X\\<in>A.\n           \\<exists>S T.\n              X = r X \\<union> S \\<union> T \\<and>\n              set xs \\<subseteq> range p \\<union> range q \\<and>\n              r X \\<subseteq> range p \\<and>\n              S \\<subseteq> range q \\<and>\n              T \\<subseteq> - range p \\<and>\n              T \\<subseteq> - range q \\<and>\n              (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n               inv p ` r X)\n              \\<in> failures P \\<and>\n              (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n               inv q ` S)\n              \\<in> failures Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>X\\<in>A.\n     \\<exists>S T.\n        X = r X \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        r X \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` S)\n        \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "hence \"\\<exists>s. \\<forall>X \\<in> A. \\<exists>T. ?F X (r X) (s X) T\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     \\<exists>S T.\n        X = r X \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        r X \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` S)\n        \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       \\<forall>X\\<in>A.\n          \\<exists>T.\n             X = r X \\<union> s X \\<union> T \\<and>\n             set xs \\<subseteq> range p \\<union> range q \\<and>\n             r X \\<subseteq> range p \\<and>\n             s X \\<subseteq> range q \\<and>\n             T \\<subseteq> - range p \\<and>\n             T \\<subseteq> - range q \\<and>\n             (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n              inv p ` r X)\n             \\<in> failures P \\<and>\n             (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n              inv q ` s X)\n             \\<in> failures Q", "by (rule bchoice)"], ["proof (state)\nthis:\n  \\<exists>s.\n     \\<forall>X\\<in>A.\n        \\<exists>T.\n           X = r X \\<union> s X \\<union> T \\<and>\n           set xs \\<subseteq> range p \\<union> range q \\<and>\n           r X \\<subseteq> range p \\<and>\n           s X \\<subseteq> range q \\<and>\n           T \\<subseteq> - range p \\<and>\n           T \\<subseteq> - range q \\<and>\n           (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n            inv p ` r X)\n           \\<in> failures P \\<and>\n           (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n            inv q ` s X)\n           \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>s.\n     \\<forall>X\\<in>A.\n        \\<exists>T.\n           X = r X \\<union> s X \\<union> T \\<and>\n           set xs \\<subseteq> range p \\<union> range q \\<and>\n           r X \\<subseteq> range p \\<and>\n           s X \\<subseteq> range q \\<and>\n           T \\<subseteq> - range p \\<and>\n           T \\<subseteq> - range q \\<and>\n           (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n            inv p ` r X)\n           \\<in> failures P \\<and>\n           (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n            inv q ` s X)\n           \\<in> failures Q", "obtain s where \"\\<forall>X \\<in> A. \\<exists>T. ?F X (r X) (s X) T\""], ["proof (prove)\nusing this:\n  \\<exists>s.\n     \\<forall>X\\<in>A.\n        \\<exists>T.\n           X = r X \\<union> s X \\<union> T \\<and>\n           set xs \\<subseteq> range p \\<union> range q \\<and>\n           r X \\<subseteq> range p \\<and>\n           s X \\<subseteq> range q \\<and>\n           T \\<subseteq> - range p \\<and>\n           T \\<subseteq> - range q \\<and>\n           (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n            inv p ` r X)\n           \\<in> failures P \\<and>\n           (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n            inv q ` s X)\n           \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<forall>X\\<in>A.\n           \\<exists>T.\n              X = r X \\<union> s X \\<union> T \\<and>\n              set xs \\<subseteq> range p \\<union> range q \\<and>\n              r X \\<subseteq> range p \\<and>\n              s X \\<subseteq> range q \\<and>\n              T \\<subseteq> - range p \\<and>\n              T \\<subseteq> - range q \\<and>\n              (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n               inv p ` r X)\n              \\<in> failures P \\<and>\n              (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n               inv q ` s X)\n              \\<in> failures Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>X\\<in>A.\n     \\<exists>T.\n        X = r X \\<union> s X \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        r X \\<subseteq> range p \\<and>\n        s X \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n        \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "hence \"\\<exists>t. \\<forall>X \\<in> A. ?F X (r X) (s X) (t X)\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     \\<exists>T.\n        X = r X \\<union> s X \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        r X \\<subseteq> range p \\<and>\n        s X \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n        \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       \\<forall>X\\<in>A.\n          X = r X \\<union> s X \\<union> t X \\<and>\n          set xs \\<subseteq> range p \\<union> range q \\<and>\n          r X \\<subseteq> range p \\<and>\n          s X \\<subseteq> range q \\<and>\n          t X \\<subseteq> - range p \\<and>\n          t X \\<subseteq> - range q \\<and>\n          (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n           inv p ` r X)\n          \\<in> failures P \\<and>\n          (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n           inv q ` s X)\n          \\<in> failures Q", "by (rule bchoice)"], ["proof (state)\nthis:\n  \\<exists>t.\n     \\<forall>X\\<in>A.\n        X = r X \\<union> s X \\<union> t X \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        r X \\<subseteq> range p \\<and>\n        s X \\<subseteq> range q \\<and>\n        t X \\<subseteq> - range p \\<and>\n        t X \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n        \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>t.\n     \\<forall>X\\<in>A.\n        X = r X \\<union> s X \\<union> t X \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        r X \\<subseteq> range p \\<and>\n        s X \\<subseteq> range q \\<and>\n        t X \\<subseteq> - range p \\<and>\n        t X \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n        \\<in> failures Q", "obtain t where C: \"\\<forall>X \\<in> A. ?F X (r X) (s X) (t X)\""], ["proof (prove)\nusing this:\n  \\<exists>t.\n     \\<forall>X\\<in>A.\n        X = r X \\<union> s X \\<union> t X \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        r X \\<subseteq> range p \\<and>\n        s X \\<subseteq> range q \\<and>\n        t X \\<subseteq> - range p \\<and>\n        t X \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n        \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<forall>X\\<in>A.\n           X = r X \\<union> s X \\<union> t X \\<and>\n           set xs \\<subseteq> range p \\<union> range q \\<and>\n           r X \\<subseteq> range p \\<and>\n           s X \\<subseteq> range q \\<and>\n           t X \\<subseteq> - range p \\<and>\n           t X \\<subseteq> - range q \\<and>\n           (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n            inv p ` r X)\n           \\<in> failures P \\<and>\n           (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n            inv q ` s X)\n           \\<in> failures Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "assume D: \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>xs A X.\n       \\<lbrakk>\\<forall>X\\<in>A.\n                   \\<exists>Xa Y Z.\n                      X = Xa \\<union> Y \\<union> Z \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      Xa \\<subseteq> range p \\<and>\n                      Y \\<subseteq> range q \\<and>\n                      Z \\<subseteq> - range p \\<and>\n                      Z \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs),\n                       inv p ` Xa)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) xs),\n                       inv q ` Y)\n                      \\<in> failures Q;\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X Y Z.\n                            (\\<Union>X\\<in>A. X) =\n                            X \\<union> Y \\<union> Z \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            X \\<subseteq> range p \\<and>\n                            Y \\<subseteq> range q \\<and>\n                            Z \\<subseteq> - range p \\<and>\n                            Z \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs),\n                             inv p ` X)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs),\n                             inv q ` Y)\n                            \\<in> failures Q", "show \"\\<exists>R S T. ?F (\\<Union>X \\<in> A. X) R S T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       (\\<Union>X\\<in>A. X) = R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` S)\n       \\<in> failures Q", "proof (rule_tac x = \"\\<Union>X \\<in> A. r X\" in exI, rule_tac x = \"\\<Union>X \\<in> A. s X\" in exI,\n   rule_tac x = \"\\<Union>X \\<in> A. t X\" in exI, (subst conj_assoc [symmetric])+,\n   (rule conjI)+)"], ["proof (state)\ngoal (8 subgoals):\n 1. (\\<Union>X\\<in>A. X) =\n    \\<Union> (r ` A) \\<union> \\<Union> (s ` A) \\<union> \\<Union> (t ` A)\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. \\<Union> (r ` A) \\<subseteq> range p\n 4. \\<Union> (s ` A) \\<subseteq> range q\n 5. \\<Union> (t ` A) \\<subseteq> - range p\n 6. \\<Union> (t ` A) \\<subseteq> - range q\n 7. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 8. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "show \"(\\<Union>X \\<in> A. X) = (\\<Union>X \\<in> A. r X) \\<union> (\\<Union>X \\<in> A. s X) \\<union> (\\<Union>X \\<in> A. t X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>X\\<in>A. X) =\n    \\<Union> (r ` A) \\<union> \\<Union> (s ` A) \\<union> \\<Union> (t ` A)", "proof (simp add: set_eq_iff, rule allI, rule iffI, erule_tac [2] disjE,\n     erule_tac [3] disjE, erule_tac [!] bexE)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "fix x X"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "have \"\\<forall>X \\<in> A. X = r X \\<union> s X \\<union> t X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "assume E: \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n  X \\<in> A", "have \"X = r X \\<union> s X \\<union> t X\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. X = r X \\<union> s X \\<union> t X", ".."], ["proof (state)\nthis:\n  X = r X \\<union> s X \\<union> t X\n\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "moreover"], ["proof (state)\nthis:\n  X = r X \\<union> s X \\<union> t X\n\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  X = r X \\<union> s X \\<union> t X\n  x \\<in> X", "have \"x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X\""], ["proof (prove)\nusing this:\n  X = r X \\<union> s X \\<union> t X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X", "by blast"], ["proof (state)\nthis:\n  x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X\n\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "hence \"\\<exists>X \\<in> A. x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X\""], ["proof (prove)\nusing this:\n  x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X", "using E"], ["proof (prove)\nusing this:\n  x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X", ".."], ["proof (state)\nthis:\n  \\<exists>X\\<in>A. x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X\n\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>A. x \\<in> r xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> s xa) \\<or>\n                         (\\<exists>xa\\<in>A. x \\<in> t xa)\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 4. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "thus \"(\\<exists>X \\<in> A. x \\<in> r X) \\<or> (\\<exists>X \\<in> A. x \\<in> s X) \\<or> (\\<exists>X \\<in> A. x \\<in> t X)\""], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>A. x \\<in> r X \\<or> x \\<in> s X \\<or> x \\<in> t X\n\ngoal (1 subgoal):\n 1. (\\<exists>X\\<in>A. x \\<in> r X) \\<or>\n    (\\<exists>X\\<in>A. x \\<in> s X) \\<or> (\\<exists>X\\<in>A. x \\<in> t X)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>X\\<in>A. x \\<in> r X) \\<or>\n  (\\<exists>X\\<in>A. x \\<in> s X) \\<or> (\\<exists>X\\<in>A. x \\<in> t X)\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "fix x X"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "have \"\\<forall>X \\<in> A. X = r X \\<union> s X \\<union> t X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "assume E: \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n  X \\<in> A", "have \"X = r X \\<union> s X \\<union> t X\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. X = r X \\<union> s X \\<union> t X", ".."], ["proof (state)\nthis:\n  X = r X \\<union> s X \\<union> t X\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "moreover"], ["proof (state)\nthis:\n  X = r X \\<union> s X \\<union> t X\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "assume \"x \\<in> r X\""], ["proof (state)\nthis:\n  x \\<in> r X\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  X = r X \\<union> s X \\<union> t X\n  x \\<in> r X", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  X = r X \\<union> s X \\<union> t X\n  x \\<in> r X\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by blast"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> r xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "thus \"\\<exists>X \\<in> A. x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. x \\<in> X", "using E"], ["proof (prove)\nusing this:\n  x \\<in> X\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. x \\<in> X", ".."], ["proof (state)\nthis:\n  \\<exists>X\\<in>A. x \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "fix x X"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "have \"\\<forall>X \\<in> A. X = r X \\<union> s X \\<union> t X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "assume E: \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n  X \\<in> A", "have \"X = r X \\<union> s X \\<union> t X\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. X = r X \\<union> s X \\<union> t X", ".."], ["proof (state)\nthis:\n  X = r X \\<union> s X \\<union> t X\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "moreover"], ["proof (state)\nthis:\n  X = r X \\<union> s X \\<union> t X\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "assume \"x \\<in> s X\""], ["proof (state)\nthis:\n  x \\<in> s X\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  X = r X \\<union> s X \\<union> t X\n  x \\<in> s X", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  X = r X \\<union> s X \\<union> t X\n  x \\<in> s X\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by blast"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> s xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "thus \"\\<exists>X \\<in> A. x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. x \\<in> X", "using E"], ["proof (prove)\nusing this:\n  x \\<in> X\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. x \\<in> X", ".."], ["proof (state)\nthis:\n  \\<exists>X\\<in>A. x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "fix x X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "have \"\\<forall>X \\<in> A. X = r X \\<union> s X \\<union> t X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "assume E: \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n  X \\<in> A", "have \"X = r X \\<union> s X \\<union> t X\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. X = r X \\<union> s X \\<union> t X\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. X = r X \\<union> s X \\<union> t X", ".."], ["proof (state)\nthis:\n  X = r X \\<union> s X \\<union> t X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "moreover"], ["proof (state)\nthis:\n  X = r X \\<union> s X \\<union> t X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "assume \"x \\<in> t X\""], ["proof (state)\nthis:\n  x \\<in> t X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  X = r X \\<union> s X \\<union> t X\n  x \\<in> t X", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  X = r X \\<union> s X \\<union> t X\n  x \\<in> t X\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by blast"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> t xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>A. x \\<in> X", "thus \"\\<exists>X \\<in> A. x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. x \\<in> X", "using E"], ["proof (prove)\nusing this:\n  x \\<in> X\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. x \\<in> X", ".."], ["proof (state)\nthis:\n  \\<exists>X\\<in>A. x \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>X\\<in>A. X) =\n  \\<Union> (r ` A) \\<union> \\<Union> (s ` A) \\<union> \\<Union> (t ` A)\n\ngoal (7 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. \\<Union> (r ` A) \\<subseteq> range p\n 3. \\<Union> (s ` A) \\<subseteq> range q\n 4. \\<Union> (t ` A) \\<subseteq> - range p\n 5. \\<Union> (t ` A) \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. \\<Union> (r ` A) \\<subseteq> range p\n 3. \\<Union> (s ` A) \\<subseteq> range q\n 4. \\<Union> (t ` A) \\<subseteq> - range p\n 5. \\<Union> (t ` A) \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have \"\\<forall>X \\<in> A. set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. set xs \\<subseteq> range p \\<union> range q", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. set xs \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. set xs \\<subseteq> range p \\<union> range q\n\ngoal (7 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. \\<Union> (r ` A) \\<subseteq> range p\n 3. \\<Union> (s ` A) \\<subseteq> range q\n 4. \\<Union> (t ` A) \\<subseteq> - range p\n 5. \\<Union> (t ` A) \\<subseteq> - range q\n 6. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 7. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "thus \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using D"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. set xs \\<subseteq> range p \\<union> range q\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", ".."], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (6 subgoals):\n 1. \\<Union> (r ` A) \\<subseteq> range p\n 2. \\<Union> (s ` A) \\<subseteq> range q\n 3. \\<Union> (t ` A) \\<subseteq> - range p\n 4. \\<Union> (t ` A) \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<Union> (r ` A) \\<subseteq> range p\n 2. \\<Union> (s ` A) \\<subseteq> range q\n 3. \\<Union> (t ` A) \\<subseteq> - range p\n 4. \\<Union> (t ` A) \\<subseteq> - range q\n 5. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 6. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "show \"(\\<Union>X \\<in> A. r X) \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (r ` A) \\<subseteq> range p", "proof (rule subsetI, erule UN_E)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range p", "fix x X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range p", "have \"\\<forall>X \\<in> A. r X \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. r X \\<subseteq> range p", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. r X \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. r X \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range p", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. r X \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range p", "assume \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range p", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>A. r X \\<subseteq> range p\n  X \\<in> A", "have \"r X \\<subseteq> range p\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. r X \\<subseteq> range p\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. r X \\<subseteq> range p", ".."], ["proof (state)\nthis:\n  r X \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range p", "moreover"], ["proof (state)\nthis:\n  r X \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range p", "assume \"x \\<in> r X\""], ["proof (state)\nthis:\n  x \\<in> r X\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range p", "ultimately"], ["proof (chain)\npicking this:\n  r X \\<subseteq> range p\n  x \\<in> r X", "show \"x \\<in> range p\""], ["proof (prove)\nusing this:\n  r X \\<subseteq> range p\n  x \\<in> r X\n\ngoal (1 subgoal):\n 1. x \\<in> range p", ".."], ["proof (state)\nthis:\n  x \\<in> range p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (r ` A) \\<subseteq> range p\n\ngoal (5 subgoals):\n 1. \\<Union> (s ` A) \\<subseteq> range q\n 2. \\<Union> (t ` A) \\<subseteq> - range p\n 3. \\<Union> (t ` A) \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<Union> (s ` A) \\<subseteq> range q\n 2. \\<Union> (t ` A) \\<subseteq> - range p\n 3. \\<Union> (t ` A) \\<subseteq> - range q\n 4. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 5. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "show \"(\\<Union>X \\<in> A. s X) \\<subseteq> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (s ` A) \\<subseteq> range q", "proof (rule subsetI, erule UN_E)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range q", "fix x X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range q", "have \"\\<forall>X \\<in> A. s X \\<subseteq> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. s X \\<subseteq> range q", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. s X \\<subseteq> range q", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. s X \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range q", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. s X \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range q", "assume \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range q", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>A. s X \\<subseteq> range q\n  X \\<in> A", "have \"s X \\<subseteq> range q\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. s X \\<subseteq> range q\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. s X \\<subseteq> range q", ".."], ["proof (state)\nthis:\n  s X \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range q", "moreover"], ["proof (state)\nthis:\n  s X \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range q", "assume \"x \\<in> s X\""], ["proof (state)\nthis:\n  x \\<in> s X\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range q", "ultimately"], ["proof (chain)\npicking this:\n  s X \\<subseteq> range q\n  x \\<in> s X", "show \"x \\<in> range q\""], ["proof (prove)\nusing this:\n  s X \\<subseteq> range q\n  x \\<in> s X\n\ngoal (1 subgoal):\n 1. x \\<in> range q", ".."], ["proof (state)\nthis:\n  x \\<in> range q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (s ` A) \\<subseteq> range q\n\ngoal (4 subgoals):\n 1. \\<Union> (t ` A) \\<subseteq> - range p\n 2. \\<Union> (t ` A) \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Union> (t ` A) \\<subseteq> - range p\n 2. \\<Union> (t ` A) \\<subseteq> - range q\n 3. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 4. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "show \"(\\<Union>X \\<in> A. t X) \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (t ` A) \\<subseteq> - range p", "proof (rule subsetI, erule UN_E)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range p", "fix x X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range p", "have \"\\<forall>X \\<in> A. t X \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. t X \\<subseteq> - range p", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. t X \\<subseteq> - range p", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. t X \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range p", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. t X \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range p", "assume \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range p", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>A. t X \\<subseteq> - range p\n  X \\<in> A", "have \"t X \\<subseteq> - range p\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. t X \\<subseteq> - range p\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. t X \\<subseteq> - range p", ".."], ["proof (state)\nthis:\n  t X \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range p", "moreover"], ["proof (state)\nthis:\n  t X \\<subseteq> - range p\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range p", "assume \"x \\<in> t X\""], ["proof (state)\nthis:\n  x \\<in> t X\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range p", "ultimately"], ["proof (chain)\npicking this:\n  t X \\<subseteq> - range p\n  x \\<in> t X", "show \"x \\<in> - range p\""], ["proof (prove)\nusing this:\n  t X \\<subseteq> - range p\n  x \\<in> t X\n\ngoal (1 subgoal):\n 1. x \\<in> - range p", ".."], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (t ` A) \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. \\<Union> (t ` A) \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<Union> (t ` A) \\<subseteq> - range q\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 3. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "show \"(\\<Union>X \\<in> A. t X) \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (t ` A) \\<subseteq> - range q", "proof (rule subsetI, erule UN_E)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range q", "fix x X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range q", "have \"\\<forall>X \\<in> A. t X \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. t X \\<subseteq> - range q", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A. t X \\<subseteq> - range q", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. t X \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range q", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A. t X \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range q", "assume \"X \\<in> A\""], ["proof (state)\nthis:\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range q", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>A. t X \\<subseteq> - range q\n  X \\<in> A", "have \"t X \\<subseteq> - range q\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A. t X \\<subseteq> - range q\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. t X \\<subseteq> - range q", ".."], ["proof (state)\nthis:\n  t X \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range q", "moreover"], ["proof (state)\nthis:\n  t X \\<subseteq> - range q\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range q", "assume \"x \\<in> t X\""], ["proof (state)\nthis:\n  x \\<in> t X\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>X \\<in> A; x \\<in> t X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> - range q", "ultimately"], ["proof (chain)\npicking this:\n  t X \\<subseteq> - range q\n  x \\<in> t X", "show \"x \\<in> - range q\""], ["proof (prove)\nusing this:\n  t X \\<subseteq> - range q\n  x \\<in> t X\n\ngoal (1 subgoal):\n 1. x \\<in> - range q", ".."], ["proof (state)\nthis:\n  x \\<in> - range q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (t ` A) \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "let ?A' = \"{inv p ` X | X. X \\<in> r ` A}\""], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have\n     \"(\\<exists>X. X \\<in> ?A') \\<longrightarrow>\n      (\\<forall>X \\<in> ?A'. (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], X) \\<in> failures P) \\<longrightarrow>\n        (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], \\<Union>X \\<in> ?A'. X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}) \\<longrightarrow>\n    (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n        \\<in> failures P) \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n    \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  ref_union_closed P\n\ngoal (1 subgoal):\n 1. (\\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}) \\<longrightarrow>\n    (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n        \\<in> failures P) \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n    \\<in> failures P", "by (simp add: ref_union_closed_def)"], ["proof (state)\nthis:\n  (\\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}) \\<longrightarrow>\n  (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n      \\<in> failures P) \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (\\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}) \\<longrightarrow>\n  (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n      \\<in> failures P) \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have \"\\<exists>X. X \\<in> ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}", "using D"], ["proof (prove)\nusing this:\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}", "by blast"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}) \\<longrightarrow>\n  (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n      \\<in> failures P) \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n  \\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}", "have\n     \"(\\<forall>X \\<in> ?A'. (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], X) \\<in> failures P) \\<longrightarrow>\n        (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], \\<Union>X \\<in> ?A'. X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}) \\<longrightarrow>\n  (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n      \\<in> failures P) \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n  \\<exists>X. X \\<in> {inv p ` X |X. X \\<in> r ` A}\n\ngoal (1 subgoal):\n 1. (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n        \\<in> failures P) \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n      \\<in> failures P) \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n      \\<in> failures P) \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have\n     \"\\<forall>X \\<in> ?A'. (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n       \\<in> failures P", "proof (rule ballI, simp, erule exE, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "fix R R'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "assume \"R \\<in> r ` A\""], ["proof (state)\nthis:\n  R \\<in> r ` A\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "hence \"\\<exists>X \\<in> A. R = r X\""], ["proof (prove)\nusing this:\n  R \\<in> r ` A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. R = r X", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>X\\<in>A. R = r X\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "then"], ["proof (chain)\npicking this:\n  \\<exists>X\\<in>A. R = r X", "obtain X where E: \"X \\<in> A\" and F: \"R = r X\""], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>A. R = r X\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; R = r X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  X \\<in> A\n  R = r X\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "have \"\\<forall>X \\<in> A. (map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` r X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A.\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n       \\<in> failures P", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A.\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n       \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A.\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "hence \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` r X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n    \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "assume \"R' = inv p ` R\""], ["proof (state)\nthis:\n  R' = inv p ` R\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv p ` Xa; Xa \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          X)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n  \\<in> failures P\n  R' = inv p ` R", "show \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], R') \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n  \\<in> failures P\n  R' = inv p ` R\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), R')\n    \\<in> failures P", "using F"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n  \\<in> failures P\n  R' = inv p ` R\n  R = r X\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), R')\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), R')\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n     \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n      \\<in> failures P) \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n  \\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n     \\<in> failures P", "have \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], \\<Union>X \\<in> ?A'. X)\n      \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n      (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n      \\<in> failures P) \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n  \\<forall>X\\<in>{inv p ` X |X. X \\<in> r ` A}.\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), X)\n     \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have \"(\\<Union>X \\<in> ?A'. X) = inv p ` (\\<Union>X \\<in> A. r X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X) =\n    inv p ` \\<Union> (r ` A)", "proof (subst set_eq_iff, simp, rule allI, rule iffI, (erule exE, erule conjE)+)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "fix a R R'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "assume \"R \\<in> r ` A\""], ["proof (state)\nthis:\n  R \\<in> r ` A\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "hence \"\\<exists>X \\<in> A. R = r X\""], ["proof (prove)\nusing this:\n  R \\<in> r ` A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. R = r X", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>X\\<in>A. R = r X\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "then"], ["proof (chain)\npicking this:\n  \\<exists>X\\<in>A. R = r X", "obtain X where E: \"X \\<in> A\" and F: \"R = r X\""], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>A. R = r X\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; R = r X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  X \\<in> A\n  R = r X\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "assume \"a \\<in> R'\" and \"R' = inv p ` R\""], ["proof (state)\nthis:\n  a \\<in> R'\n  R' = inv p ` R\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "hence \"a \\<in> inv p ` r X\""], ["proof (prove)\nusing this:\n  a \\<in> R'\n  R' = inv p ` R\n\ngoal (1 subgoal):\n 1. a \\<in> inv p ` r X", "using F"], ["proof (prove)\nusing this:\n  a \\<in> R'\n  R' = inv p ` R\n  R = r X\n\ngoal (1 subgoal):\n 1. a \\<in> inv p ` r X", "by simp"], ["proof (state)\nthis:\n  a \\<in> inv p ` r X\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "hence \"\\<exists>x \\<in> r X. a = inv p x\""], ["proof (prove)\nusing this:\n  a \\<in> inv p ` r X\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>r X. a = inv p x", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>r X. a = inv p x\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>r X. a = inv p x", "obtain x where G: \"x \\<in> r X\" and H: \"a = inv p x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>r X. a = inv p x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> r X; a = inv p x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> r X\n  a = inv p x\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "have \"x \\<in> (\\<Union>X \\<in> A. r X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (r ` A)", "using E and G"], ["proof (prove)\nusing this:\n  X \\<in> A\n  x \\<in> r X\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (r ` A)", "by (rule UN_I)"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (r ` A)\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "with H"], ["proof (chain)\npicking this:\n  a = inv p x\n  x \\<in> \\<Union> (r ` A)", "have \"\\<exists>x \\<in> (\\<Union>X \\<in> A. r X). a = inv p x\""], ["proof (prove)\nusing this:\n  a = inv p x\n  x \\<in> \\<Union> (r ` A)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>\\<Union> (r ` A). a = inv p x", ".."], ["proof (state)\nthis:\n  \\<exists>x\\<in>\\<Union> (r ` A). a = inv p x\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv p ` X; X \\<in> r ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv p ` \\<Union> (r ` A)\n 2. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "thus \"a \\<in> inv p ` (\\<Union>X \\<in> A. r X)\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>\\<Union> (r ` A). a = inv p x\n\ngoal (1 subgoal):\n 1. a \\<in> inv p ` \\<Union> (r ` A)", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  a \\<in> inv p ` \\<Union> (r ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "assume \"a \\<in> inv p ` (\\<Union>X \\<in> A. r X)\""], ["proof (state)\nthis:\n  a \\<in> inv p ` \\<Union> (r ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "hence \"\\<exists>x \\<in> (\\<Union>X \\<in> A. r X). a = inv p x\""], ["proof (prove)\nusing this:\n  a \\<in> inv p ` \\<Union> (r ` A)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>\\<Union> (r ` A). a = inv p x", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>\\<Union> (r ` A). a = inv p x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>\\<Union> (r ` A). a = inv p x", "obtain x where E: \"x \\<in> (\\<Union>X \\<in> A. r X)\" and F: \"a = inv p x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>\\<Union> (r ` A). a = inv p x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> \\<Union> (r ` A); a = inv p x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> \\<Union> (r ` A)\n  a = inv p x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "obtain X where G: \"X \\<in> A\" and H: \"x \\<in> r X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using E"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (r ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; x \\<in> r X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  X \\<in> A\n  x \\<in> r X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv p ` \\<Union> (r ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv p ` X \\<and> X \\<in> r ` A) \\<and>\n          x \\<in> xa", "show \"\\<exists>R'. (\\<exists>R. R' = inv p ` R \\<and> R \\<in> r ` A) \\<and> a \\<in> R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R'.\n       (\\<exists>R. R' = inv p ` R \\<and> R \\<in> r ` A) \\<and> a \\<in> R'", "proof (rule_tac x = \"inv p ` r X\" in exI, rule conjI,\n       rule_tac x = \"r X\" in exI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inv p ` r X = inv p ` r X \\<and> r X \\<in> r ` A\n 2. a \\<in> inv p ` r X", "qed (rule_tac [2] image_eqI, simp add: G, simp add: F, simp add: H)"], ["proof (state)\nthis:\n  \\<exists>R'.\n     (\\<exists>R. R' = inv p ` R \\<and> R \\<in> r ` A) \\<and> a \\<in> R'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X) =\n  inv p ` \\<Union> (r ` A)\n\ngoal (2 subgoals):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P\n 2. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n  (\\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X) =\n  inv p ` \\<Union> (r ` A)", "show \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` (\\<Union>X \\<in> A. r X))\n      \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   \\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X)\n  \\<in> failures P\n  (\\<Union>X\\<in>{inv p ` X |X. X \\<in> r ` A}. X) =\n  inv p ` \\<Union> (r ` A)\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` \\<Union> (r ` A))\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   inv p ` \\<Union> (r ` A))\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "let ?A' = \"{inv q ` X | X. X \\<in> s ` A}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have\n     \"(\\<exists>X. X \\<in> ?A') \\<longrightarrow>\n      (\\<forall>X \\<in> ?A'. (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], X) \\<in> failures Q) \\<longrightarrow>\n        (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], \\<Union>X \\<in> ?A'. X) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}) \\<longrightarrow>\n    (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n        \\<in> failures Q) \\<longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n    \\<in> failures Q", "using B"], ["proof (prove)\nusing this:\n  ref_union_closed Q\n\ngoal (1 subgoal):\n 1. (\\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}) \\<longrightarrow>\n    (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n        \\<in> failures Q) \\<longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n    \\<in> failures Q", "by (simp add: ref_union_closed_def)"], ["proof (state)\nthis:\n  (\\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}) \\<longrightarrow>\n  (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n      \\<in> failures Q) \\<longrightarrow>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (\\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}) \\<longrightarrow>\n  (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n      \\<in> failures Q) \\<longrightarrow>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have \"\\<exists>X. X \\<in> ?A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}", "using D"], ["proof (prove)\nusing this:\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}", "by blast"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}) \\<longrightarrow>\n  (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n      \\<in> failures Q) \\<longrightarrow>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n  \\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}", "have\n     \"(\\<forall>X \\<in> ?A'. (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], X) \\<in> failures Q) \\<longrightarrow>\n        (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], \\<Union>X \\<in> ?A'. X) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (\\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}) \\<longrightarrow>\n  (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n      \\<in> failures Q) \\<longrightarrow>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n  \\<exists>X. X \\<in> {inv q ` X |X. X \\<in> s ` A}\n\ngoal (1 subgoal):\n 1. (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n        \\<in> failures Q) \\<longrightarrow>\n    (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n    \\<in> failures Q", ".."], ["proof (state)\nthis:\n  (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n      \\<in> failures Q) \\<longrightarrow>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n      \\<in> failures Q) \\<longrightarrow>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have\n     \"\\<forall>X \\<in> ?A'. (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], X) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n       \\<in> failures Q", "proof (rule ballI, simp, erule exE, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "fix S S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "assume \"S \\<in> s ` A\""], ["proof (state)\nthis:\n  S \\<in> s ` A\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "hence \"\\<exists>X \\<in> A. S = s X\""], ["proof (prove)\nusing this:\n  S \\<in> s ` A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. S = s X", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>X\\<in>A. S = s X\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>X\\<in>A. S = s X", "obtain X where E: \"X \\<in> A\" and F: \"S = s X\""], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>A. S = s X\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; S = s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  X \\<in> A\n  S = s X\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "have \"\\<forall>X \\<in> A. (map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` s X) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A.\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n       \\<in> failures Q", "using C"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     X = r X \\<union> s X \\<union> t X \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     r X \\<subseteq> range p \\<and>\n     s X \\<subseteq> range q \\<and>\n     t X \\<subseteq> - range p \\<and>\n     t X \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` r X)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>A.\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n       \\<in> failures Q", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>A.\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "hence \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` s X) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n    \\<in> failures Q", "using E"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>A.\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n     \\<in> failures Q\n  X \\<in> A\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n    \\<in> failures Q", ".."], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "assume \"S' = inv q ` S\""], ["proof (state)\nthis:\n  S' = inv q ` S\n\ngoal (1 subgoal):\n 1. \\<And>X Xa.\n       \\<lbrakk>X = inv q ` Xa; Xa \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xs),\n                          X)\n                         \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n  \\<in> failures Q\n  S' = inv q ` S", "show \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], S') \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n  \\<in> failures Q\n  S' = inv q ` S\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), S')\n    \\<in> failures Q", "using F"], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` s X)\n  \\<in> failures Q\n  S' = inv q ` S\n  S = s X\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), S')\n    \\<in> failures Q", "by simp"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), S')\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n      \\<in> failures Q) \\<longrightarrow>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n  \\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n     \\<in> failures Q", "have \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], \\<Union>X \\<in> ?A'. X)\n      \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (\\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n      (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n      \\<in> failures Q) \\<longrightarrow>\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n  \\<forall>X\\<in>{inv q ` X |X. X \\<in> s ` A}.\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), X)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n    \\<in> failures Q", ".."], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "have \"(\\<Union>X \\<in> ?A'. X) = inv q ` (\\<Union>X \\<in> A. s X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X) =\n    inv q ` \\<Union> (s ` A)", "proof (subst set_eq_iff, simp, rule allI, rule iffI, (erule exE, erule conjE)+)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "fix b S S'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "assume \"S \\<in> s ` A\""], ["proof (state)\nthis:\n  S \\<in> s ` A\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "hence \"\\<exists>X \\<in> A. S = s X\""], ["proof (prove)\nusing this:\n  S \\<in> s ` A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>A. S = s X", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>X\\<in>A. S = s X\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "then"], ["proof (chain)\npicking this:\n  \\<exists>X\\<in>A. S = s X", "obtain X where E: \"X \\<in> A\" and F: \"S = s X\""], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>A. S = s X\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; S = s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  X \\<in> A\n  S = s X\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "assume \"b \\<in> S'\" and \"S' = inv q ` S\""], ["proof (state)\nthis:\n  b \\<in> S'\n  S' = inv q ` S\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "hence \"b \\<in> inv q ` s X\""], ["proof (prove)\nusing this:\n  b \\<in> S'\n  S' = inv q ` S\n\ngoal (1 subgoal):\n 1. b \\<in> inv q ` s X", "using F"], ["proof (prove)\nusing this:\n  b \\<in> S'\n  S' = inv q ` S\n  S = s X\n\ngoal (1 subgoal):\n 1. b \\<in> inv q ` s X", "by simp"], ["proof (state)\nthis:\n  b \\<in> inv q ` s X\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "hence \"\\<exists>x \\<in> s X. b = inv q x\""], ["proof (prove)\nusing this:\n  b \\<in> inv q ` s X\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>s X. b = inv q x", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>s X. b = inv q x\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>s X. b = inv q x", "obtain x where G: \"x \\<in> s X\" and H: \"b = inv q x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>s X. b = inv q x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> s X; b = inv q x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> s X\n  b = inv q x\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "have \"x \\<in> (\\<Union>X \\<in> A. s X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (s ` A)", "using E and G"], ["proof (prove)\nusing this:\n  X \\<in> A\n  x \\<in> s X\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (s ` A)", "by (rule UN_I)"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (s ` A)\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "with H"], ["proof (chain)\npicking this:\n  b = inv q x\n  x \\<in> \\<Union> (s ` A)", "have \"\\<exists>x \\<in> (\\<Union>X \\<in> A. s X). b = inv q x\""], ["proof (prove)\nusing this:\n  b = inv q x\n  x \\<in> \\<Union> (s ` A)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>\\<Union> (s ` A). b = inv q x", ".."], ["proof (state)\nthis:\n  \\<exists>x\\<in>\\<Union> (s ` A). b = inv q x\n\ngoal (2 subgoals):\n 1. \\<And>x xa X.\n       \\<lbrakk>x \\<in> xa; xa = inv q ` X; X \\<in> s ` A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv q ` \\<Union> (s ` A)\n 2. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "thus \"b \\<in> inv q ` (\\<Union>X \\<in> A. s X)\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>\\<Union> (s ` A). b = inv q x\n\ngoal (1 subgoal):\n 1. b \\<in> inv q ` \\<Union> (s ` A)", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  b \\<in> inv q ` \\<Union> (s ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "assume \"b \\<in> inv q ` (\\<Union>X \\<in> A. s X)\""], ["proof (state)\nthis:\n  b \\<in> inv q ` \\<Union> (s ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "hence \"\\<exists>x \\<in> (\\<Union>X \\<in> A. s X). b = inv q x\""], ["proof (prove)\nusing this:\n  b \\<in> inv q ` \\<Union> (s ` A)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>\\<Union> (s ` A). b = inv q x", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>\\<Union> (s ` A). b = inv q x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>\\<Union> (s ` A). b = inv q x", "obtain x where E: \"x \\<in> (\\<Union>X \\<in> A. s X)\" and F: \"b = inv q x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>\\<Union> (s ` A). b = inv q x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> \\<Union> (s ` A); b = inv q x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> \\<Union> (s ` A)\n  b = inv q x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "obtain X where G: \"X \\<in> A\" and H: \"x \\<in> s X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using E"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (s ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; x \\<in> s X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  X \\<in> A\n  x \\<in> s X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> inv q ` \\<Union> (s ` A) \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>X. xa = inv q ` X \\<and> X \\<in> s ` A) \\<and>\n          x \\<in> xa", "show \"\\<exists>S'. (\\<exists>S. S' = inv q ` S \\<and> S \\<in> s ` A) \\<and> b \\<in> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S'.\n       (\\<exists>S. S' = inv q ` S \\<and> S \\<in> s ` A) \\<and> b \\<in> S'", "proof (rule_tac x = \"inv q ` s X\" in exI, rule conjI,\n       rule_tac x = \"s X\" in exI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inv q ` s X = inv q ` s X \\<and> s X \\<in> s ` A\n 2. b \\<in> inv q ` s X", "qed (rule_tac [2] image_eqI, simp add: G, simp add: F, simp add: H)"], ["proof (state)\nthis:\n  \\<exists>S'.\n     (\\<exists>S. S' = inv q ` S \\<and> S \\<in> s ` A) \\<and> b \\<in> S'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X) =\n  inv q ` \\<Union> (s ` A)\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n  (\\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X) =\n  inv q ` \\<Union> (s ` A)", "show \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` (\\<Union>X \\<in> A. s X))\n      \\<in> failures Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   \\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X)\n  \\<in> failures Q\n  (\\<Union>X\\<in>{inv q ` X |X. X \\<in> s ` A}. X) =\n  inv q ` \\<Union> (s ` A)\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n     inv q ` \\<Union> (s ` A))\n    \\<in> failures Q", "by simp"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs),\n   inv q ` \\<Union> (s ` A))\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>R S T.\n     (\\<Union>X\\<in>A. X) = R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` S)\n     \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_failures_traces:\n \"(xs, X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    map (inv p) [x\\<leftarrow>xs. x \\<in> range p] \\<in> traces P \\<and>\n    map (inv q) [x\\<leftarrow>xs. x \\<in> range q] \\<in> traces Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, X) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n    map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n    \\<in> traces P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q", "proof (simp add: con_comp_failures_def con_comp_divergences_def, erule disjE,\n (erule exE)+, (erule conjE)+, erule_tac [2] exE, (erule_tac [2] conjE)+,\n erule_tac [2] exE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q\n 2. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "fix X Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q\n 2. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "assume \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` X) \\<in> failures P\""], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q\n 2. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"map (inv p) [x\\<leftarrow>xs. x \\<in> range p] \\<in> traces P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q\n 2. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "moreover"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q\n 2. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "assume \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], inv q ` Y) \\<in> failures Q\""], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q\n 2. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"map (inv q) [x\\<leftarrow>xs. x \\<in> range q] \\<in> traces Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q", "by (rule failures_traces)"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q\n\ngoal (2 subgoals):\n 1. \\<And>Xa Y Z.\n       \\<lbrakk>X = Xa \\<union> Y \\<union> Z;\n        set xs \\<subseteq> range p \\<union> range q; Xa \\<subseteq> range p;\n        Y \\<subseteq> range q; Z \\<subseteq> - range p;\n        Z \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Xa)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q\n 2. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "ultimately"], ["proof (chain)\npicking this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q", "show ?thesis"], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n    \\<in> traces P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q", ".."], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n  \\<in> traces P \\<and>\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "fix vs ws"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "assume A: \"xs = vs @ ws\""], ["proof (state)\nthis:\n  xs = vs @ ws\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "assume \"map (inv p) [x\\<leftarrow>vs. x \\<in> range p] \\<in> divergences P\""], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) vs) \\<in> divergences P\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"map (inv p) [x\\<leftarrow>vs. x \\<in> range p] @ map (inv p) [x\\<leftarrow>ws. x \\<in> range p]\n    \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) vs) \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) vs) @\n    map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws)\n    \\<in> divergences P", "by (rule process_rule_5_general)"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) vs) @\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws)\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"map (inv p) [x\\<leftarrow>xs. x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) vs) @\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws)\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n    \\<in> divergences P", "using A"], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) vs) @\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ws)\n  \\<in> divergences P\n  xs = vs @ ws\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n    \\<in> divergences P", "by simp"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> divergences P\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> divergences P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n    \\<in> failures P", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"map (inv p) [x\\<leftarrow>xs. x \\<in> range p] \\<in> traces P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "moreover"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "assume \"map (inv q) [x\\<leftarrow>vs. x \\<in> range q] \\<in> divergences Q\""], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) vs) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"map (inv q) [x\\<leftarrow>vs. x \\<in> range q] @ map (inv q) [x\\<leftarrow>ws. x \\<in> range q]\n    \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) vs) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) vs) @\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws)\n    \\<in> divergences Q", "by (rule process_rule_5_general)"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) vs) @\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws)\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"map (inv q) [x\\<leftarrow>xs. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) vs) @\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws)\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs)\n    \\<in> divergences Q", "using A"], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) vs) @\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ws)\n  \\<in> divergences Q\n  xs = vs @ ws\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs)\n    \\<in> divergences Q", "by simp"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"(map (inv q) [x\\<leftarrow>xs. x \\<in> range q], {}) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n    \\<in> failures Q", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "hence \"map (inv q) [x\\<leftarrow>xs. x \\<in> range q] \\<in> traces Q\""], ["proof (prove)\nusing this:\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs), {})\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q", "by (rule failures_traces)"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs = xsa @ ys\\<rbrakk>\n       \\<Longrightarrow> map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs)\n                         \\<in> traces P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs)\n                         \\<in> traces Q", "ultimately"], ["proof (chain)\npicking this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q", "show ?thesis"], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) \\<in> traces P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n    \\<in> traces P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q", ".."], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs)\n  \\<in> traces P \\<and>\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs) \\<in> traces Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_failures_divergences:\n \"(xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n  y \\<notin> range p \\<Longrightarrow>\n  y \\<notin> range q \\<Longrightarrow>\n    \\<exists>xs'.\n      (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xs @ y # ys, Y) \\<in> con_comp_failures P Q p q;\n     y \\<notin> range p; y \\<notin> range q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                         set xs' \\<subseteq> range p \\<union> range q \\<and>\n                         map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xs')\n                         \\<in> divergences P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xs')\n                         \\<in> divergences Q", "proof (simp add: con_comp_failures_def con_comp_divergences_def,\n erule exE, (erule conjE)+, erule exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "fix xs' ys'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "assume\n    A: \"y \\<notin> range p\" and\n    B: \"y \\<notin> range q\" and\n    C: \"set xs' \\<subseteq> range p \\<union> range q\" and\n    D: \"map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P\" and\n    E: \"map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q\" and\n    F: \"xs @ y # ys = xs' @ ys'\""], ["proof (state)\nthis:\n  y \\<notin> range p\n  y \\<notin> range q\n  set xs' \\<subseteq> range p \\<union> range q\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs') \\<in> divergences P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs') \\<in> divergences Q\n  xs @ y # ys = xs' @ ys'\n\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "have \"length xs' \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs' \\<le> length xs", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "assume \"\\<not> length xs' \\<le> length xs\""], ["proof (state)\nthis:\n  \\<not> length xs' \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> length xs' \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "have \"take (length xs') (xs @ [y] @ ys) =\n      take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys\"\n      (is \"_ = _ @ ?vs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length xs') (xs @ [y] @ ys) =\n    take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys", "by (simp only: take_append, simp)"], ["proof (state)\nthis:\n  take (length xs') (xs @ [y] @ ys) =\n  take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> length xs' \\<le> length xs\n  take (length xs') (xs @ [y] @ ys) =\n  take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys", "have \"take (length xs') (xs @ y # ys) = xs @ y # ?vs\""], ["proof (prove)\nusing this:\n  \\<not> length xs' \\<le> length xs\n  take (length xs') (xs @ [y] @ ys) =\n  take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys\n\ngoal (1 subgoal):\n 1. take (length xs') (xs @ y # ys) =\n    xs @ y # take (length xs' - Suc (length xs)) ys", "by simp"], ["proof (state)\nthis:\n  take (length xs') (xs @ y # ys) =\n  xs @ y # take (length xs' - Suc (length xs)) ys\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  take (length xs') (xs @ y # ys) =\n  xs @ y # take (length xs' - Suc (length xs)) ys\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "have \"take (length xs') (xs @ y # ys) =\n      take (length xs') (xs' @ ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')", "using F"], ["proof (prove)\nusing this:\n  xs @ y # ys = xs' @ ys'\n\ngoal (1 subgoal):\n 1. take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')", "by simp"], ["proof (state)\nthis:\n  take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  take (length xs') (xs @ y # ys) =\n  xs @ y # take (length xs' - Suc (length xs)) ys\n  take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')", "have \"xs' = xs @ y # ?vs\""], ["proof (prove)\nusing this:\n  take (length xs') (xs @ y # ys) =\n  xs @ y # take (length xs' - Suc (length xs)) ys\n  take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')\n\ngoal (1 subgoal):\n 1. xs' = xs @ y # take (length xs' - Suc (length xs)) ys", "by simp"], ["proof (state)\nthis:\n  xs' = xs @ y # take (length xs' - Suc (length xs)) ys\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "hence \"set (xs @ y # ?vs) \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  xs' = xs @ y # take (length xs' - Suc (length xs)) ys\n\ngoal (1 subgoal):\n 1. set (xs @ y # take (length xs' - Suc (length xs)) ys)\n    \\<subseteq> range p \\<union> range q", "using C"], ["proof (prove)\nusing this:\n  xs' = xs @ y # take (length xs' - Suc (length xs)) ys\n  set xs' \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set (xs @ y # take (length xs' - Suc (length xs)) ys)\n    \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  set (xs @ y # take (length xs' - Suc (length xs)) ys)\n  \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "hence \"y \\<in> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set (xs @ y # take (length xs' - Suc (length xs)) ys)\n  \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. y \\<in> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  y \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<not> length xs' \\<le> length xs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  y \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. False", "using A and B"], ["proof (prove)\nusing this:\n  y \\<in> range p \\<union> range q\n  y \\<notin> range p\n  y \\<notin> range q\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length xs' \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  length xs' \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "have \"xs @ zs =\n    take (length xs') (xs @ zs) @ drop (length xs') (xs @ zs)\"\n    (is \"_ = _ @ ?vs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ zs = take (length xs') (xs @ zs) @ drop (length xs') (xs @ zs)", "by (simp only: append_take_drop_id)"], ["proof (state)\nthis:\n  xs @ zs = take (length xs') (xs @ zs) @ drop (length xs') (xs @ zs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  length xs' \\<le> length xs\n  xs @ zs = take (length xs') (xs @ zs) @ drop (length xs') (xs @ zs)", "have \"xs @ zs = take (length xs') (xs @ y # ys) @ ?vs\""], ["proof (prove)\nusing this:\n  length xs' \\<le> length xs\n  xs @ zs = take (length xs') (xs @ zs) @ drop (length xs') (xs @ zs)\n\ngoal (1 subgoal):\n 1. xs @ zs = take (length xs') (xs @ y # ys) @ drop (length xs') (xs @ zs)", "by simp"], ["proof (state)\nthis:\n  xs @ zs = take (length xs') (xs @ y # ys) @ drop (length xs') (xs @ zs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  xs @ zs = take (length xs') (xs @ y # ys) @ drop (length xs') (xs @ zs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "have \"take (length xs') (xs @ y # ys) =\n    take (length xs') (xs' @ ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')", "using F"], ["proof (prove)\nusing this:\n  xs @ y # ys = xs' @ ys'\n\ngoal (1 subgoal):\n 1. take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')", "by simp"], ["proof (state)\nthis:\n  take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')\n\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  xs @ zs = take (length xs') (xs @ y # ys) @ drop (length xs') (xs @ zs)\n  take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')", "have G: \"xs @ zs = xs' @ ?vs\""], ["proof (prove)\nusing this:\n  xs @ zs = take (length xs') (xs @ y # ys) @ drop (length xs') (xs @ zs)\n  take (length xs') (xs @ y # ys) = take (length xs') (xs' @ ys')\n\ngoal (1 subgoal):\n 1. xs @ zs = xs' @ drop (length xs') (xs @ zs)", "by (simp del: take_append, simp)"], ["proof (state)\nthis:\n  xs @ zs = xs' @ drop (length xs') (xs @ zs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ysa.\n       \\<lbrakk>y \\<notin> range p; y \\<notin> range q;\n        set xsa \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q;\n        xs @ y # ys = xsa @ ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n                            set xs'\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            map (inv p)\n                             (filter (\\<lambda>x. x \\<in> range p) xs')\n                            \\<in> divergences P \\<and>\n                            map (inv q)\n                             (filter (\\<lambda>x. x \\<in> range q) xs')\n                            \\<in> divergences Q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "proof (rule_tac x = xs' in exI, rule conjI, rule_tac x = ?vs in exI)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs @ zs = xs' @ drop (length xs') (xs @ zs)\n 2. set xs' \\<subseteq> range p \\<union> range q \\<and>\n    map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n    \\<in> divergences P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n    \\<in> divergences Q", "qed (subst G, simp_all add: C D E)"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n     set xs' \\<subseteq> range p \\<union> range q \\<and>\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n     \\<in> divergences P \\<and>\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n     \\<in> divergences Q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nIn order to prove that CSP noninterference security is conserved under concurrent composition, the\nfirst issue to be solved is to identify the noninterference policy @{term I'} and the event-domain\nmap @{term D'} with respect to which the output process is secure.\n\nIf the events of the input processes corresponding to those of the output process contained in\n@{term \"range p \\<inter> range q\"} were mapped by the respective event-domain maps @{term D}, @{term E}\ninto distinct security domains, there would be no criterion for determining the domains of the\naforesaid events of the output process, due to the equivalence of the input processes ensuing from\nthe commutative property of concurrent composition. Therefore, @{term D} and @{term E} must map the\nevents of the input processes into security domains of the same type @{typ 'd}, and for each\n@{term x} in @{term \"range p \\<inter> range q\"}, @{term D} and @{term E} must map the events of the input\nprocesses corresponding to @{term x} into the same domain. This requirement is formalized here below\nby means of predicate \\<open>consistent_maps\\<close>.\n\nSimilarly, if distinct noninterference policies applied to the input processes, there would exist\nsome ordered pair of security domains included in one of the policies, but not in the other one.\nThus, again, there would be no criterion for determining the inclusion of such a pair of domains in\nthe policy @{term I'} applying to the output process. As a result, the input processes are required\nto enforce the same noninterference policy @{term I}, so that for any two domains @{term d},\n@{term e} of type @{typ 'd}, the ordered pair comprised of the corresponding security domains for\nthe output process will be included in @{term I'} just in case @{term \"(d, e) \\<in> I\"}.\n\nHowever, in case @{term \"- (range p \\<union> range q) \\<noteq> {}\"}, the event-domain map @{term D'} for the\noutput process must assign a security domain to the fake events in @{term \"- (range p \\<union> range q)\"}\nas well. Since such events lack any meaning, they may all be mapped to the same security domain,\ndistinct from the domains of the meaningful events in @{term \"range p \\<union> range q\"}. A simple way to\ndo this is to identify the type of the security domains for the output process with\n@{typ \"'d option\"}. Then, for any meaningful event @{term x}, @{term D'} will assign @{term x} to\ndomain @{term \"Some d\"}, where @{term d} is the domain of the events of the input processes mapped\nto @{term x}, whereas @{term \"D' y = None\"} for any fake event @{term y}. Such an event-domain map,\ndenoted using notation @{term \"con_comp_map D E p q\"}, is defined here below.\n\nTherefore, for any two security domains @{term \"Some d\"}, @{term \"Some e\"} for the output process,\nthe above considerations about policy @{term I'} entail that @{term \"(Some d, Some e) \\<in> I'\"} just in\ncase @{term \"(d, e) \\<in> I\"}. Furthermore, since fake events may only occur in divergent traces, which\nare extensions of divergences of the input processes comprised of meaningful events, @{term I'} must\nallow the security domain @{term None} of fake events to be affected by any meaningful domain\nmatching pattern \\<open>Some _\\<close>. Such a noninterference policy, denoted using notation\n@{term \"con_comp_pol I\"}, is defined here below. Observe that @{term \"con_comp_pol I\"} keeps being\nreflexive or transitive if @{term I} is.\n\n\\null\n\\<close>"], ["", "definition con_comp_pol ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('d option \\<times> 'd option) set\" where\n\"con_comp_pol I \\<equiv>\n  {(Some d, Some e) | d e. (d, e) \\<in> I} \\<union> {(u, v). v = None}\""], ["", "function con_comp_map ::\n \"('a \\<Rightarrow> 'd) \\<Rightarrow> ('b \\<Rightarrow> 'd) \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> ('b \\<Rightarrow> 'c) \\<Rightarrow> 'c \\<Rightarrow> 'd option\" where\n\"x \\<in> range p \\<Longrightarrow>\n  con_comp_map D E p q x = Some (D (inv p x))\" |\n\"x \\<notin> range p \\<Longrightarrow> x \\<in> range q \\<Longrightarrow>\n  con_comp_map D E p q x = Some (E (inv q x))\" |\n\"x \\<notin> range p \\<Longrightarrow> x \\<notin> range q \\<Longrightarrow>\n  con_comp_map D E p q x = None\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xa p D E q.\n                   \\<lbrakk>xa \\<in> range p; x = (D, E, p, q, xa)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>xa p q D E.\n           \\<lbrakk>xa \\<notin> range p; xa \\<in> range q;\n            x = (D, E, p, q, xa)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>xa p q D E.\n           \\<lbrakk>xa \\<notin> range p; xa \\<notin> range q;\n            x = (D, E, p, q, xa)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>x p D E q xa pa Da Ea qa.\n       \\<lbrakk>x \\<in> range p; xa \\<in> range pa;\n        (D, E, p, q, x) = (Da, Ea, pa, qa, xa)\\<rbrakk>\n       \\<Longrightarrow> Some (D (inv p x)) = Some (Da (inv pa xa))\n 3. \\<And>x p D E q xa pa qa Da Ea.\n       \\<lbrakk>x \\<in> range p; xa \\<notin> range pa; xa \\<in> range qa;\n        (D, E, p, q, x) = (Da, Ea, pa, qa, xa)\\<rbrakk>\n       \\<Longrightarrow> Some (D (inv p x)) = Some (Ea (inv qa xa))\n 4. \\<And>x p D E q xa pa qa Da Ea.\n       \\<lbrakk>x \\<in> range p; xa \\<notin> range pa; xa \\<notin> range qa;\n        (D, E, p, q, x) = (Da, Ea, pa, qa, xa)\\<rbrakk>\n       \\<Longrightarrow> Some (D (inv p x)) = None\n 5. \\<And>x p q D E xa pa qa Da Ea.\n       \\<lbrakk>x \\<notin> range p; x \\<in> range q; xa \\<notin> range pa;\n        xa \\<in> range qa; (D, E, p, q, x) = (Da, Ea, pa, qa, xa)\\<rbrakk>\n       \\<Longrightarrow> Some (E (inv q x)) = Some (Ea (inv qa xa))\n 6. \\<And>x p q D E xa pa qa Da Ea.\n       \\<lbrakk>x \\<notin> range p; x \\<in> range q; xa \\<notin> range pa;\n        xa \\<notin> range qa;\n        (D, E, p, q, x) = (Da, Ea, pa, qa, xa)\\<rbrakk>\n       \\<Longrightarrow> Some (E (inv q x)) = None\n 7. \\<And>x p q D E xa pa qa Da Ea.\n       \\<lbrakk>x \\<notin> range p; x \\<notin> range q;\n        xa \\<notin> range pa; xa \\<notin> range qa;\n        (D, E, p, q, x) = (Da, Ea, pa, qa, xa)\\<rbrakk>\n       \\<Longrightarrow> None = None", "by (atomize_elim, simp_all add: split_paired_all, blast)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All con_comp_map_dom", "by lexicographic_order"], ["", "definition consistent_maps ::\n \"('a \\<Rightarrow> 'd) \\<Rightarrow> ('b \\<Rightarrow> 'd) \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> ('b \\<Rightarrow> 'c) \\<Rightarrow> bool\" where\n\"consistent_maps D E p q \\<equiv>\n  \\<forall>x \\<in> range p \\<inter> range q. D (inv p x) = E (inv q x)\""], ["", "subsection \"Auxiliary intransitive purge functions\""], ["", "text \\<open>\nLet @{term I} be a noninterference policy, @{term D} an event-domain map, @{term U} a domain set,\nand @{term \"xs = x # xs'\"} an event list. Suppose to take event @{term x} just in case it satisfies\npredicate @{term P}, to append @{term xs'} to the resulting list (matching either @{term \"[x]\"} or\n@{term \"[]\"}), and then to compute the intransitive purge of the resulting list with domain set\n@{term U}. If recursion with respect to the input list is added, replacing @{term xs'} with the list\nproduced by the same algorithm using @{term xs'} as input list and @{term \"sinks_aux I D U [x]\"} as\ndomain set, the final result matches that obtained by applying filter @{term P} to the intransitive\npurge of @{term xs} with domain set @{term U}. In fact, in each recursive step, the processed item\nof the input list is retained in the output list just in case it passes filter @{term P} and may be\naffected neither by the domains in @{term U}, nor by the domains of the previous items affected by\nsome domain in @{term U}.\n\nHere below is the formal definition of such purge function, named \\<open>ipurge_tr_aux_foldr\\<close> as its\naction resembles that of function @{term foldr}.\n\n\\null\n\\<close>"], ["", "primrec ipurge_tr_aux_foldr ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n\"ipurge_tr_aux_foldr I D P U [] = []\" |\n\"ipurge_tr_aux_foldr I D P U (x # xs) = ipurge_tr_aux I D U\n   ((if P x then [x] else []) @\n     ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\""], ["", "text \\<open>\n\\null\n\nLikewise, given @{term I}, @{term D}, @{term U}, @{term \"xs = x # xs'\"}, and an event set @{term X},\nsuppose to take @{term x} just in case it satisfies predicate @{term P}, to append\n@{term \"ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs'\"} to the resulting list (matching either\n@{term \"[x]\"} or @{term \"[]\"}), and then to compute the intransitive purge of @{term X} using the\nresulting list as input list and @{term U} as domain set. If recursion with respect to the input\nlist is added, replacing @{term X} with the set produced by the same algorithm using @{term xs'} as\ninput list, @{term X} as input set, and @{term \"sinks_aux I D U [x]\"} as domain set, the final\nresult matches the intransitive purge of @{term X} with input list @{term xs} and domain set\n@{term U}. In fact, each recursive step is such as to remove from @{term X} any event that may be\naffected either by the domains in @{term U}, or by the domains of the items of @{term xs} preceding\nthe processed one which are affected by some domain in @{term U}.\n\nFrom the above considerations on function @{term ipurge_tr_aux_foldr}, it follows that the presence\nof list @{term \"ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs'\"} has no impact on the final\nresult, because none of its items may be affected by the domains in @{term U}.\n\nHere below is the formal definition of such purge function, named \\<open>ipurge_ref_aux_foldr\\<close>,\nwhich at first glance just seems a uselessly complicate and inefficient way to compute the\nintransitive purge of an event set.\n\n\\null\n\\<close>"], ["", "primrec ipurge_ref_aux_foldr ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\nwhere\n\"ipurge_ref_aux_foldr I D P U [] X = ipurge_ref_aux I D U [] X\" |\n\"ipurge_ref_aux_foldr I D P U (x # xs) X = ipurge_ref_aux I D U\n   ((if P x then [x] else []) @\n     ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\""], ["", "text \\<open>\n\\null\n\nThe reason for the introduction of such intransitive purge functions is that the recursive equations\ncontained in their definitions, along with lemma @{thm [source] ipurge_tr_ref_aux_failures_general},\nenable to prove by induction on list @{term ys}, assuming that process @{term P} be secure in\naddition to further, minor premises, the following implication:\n\n\\null\n\n@{term \"(map (inv p) [x\\<leftarrow>xs @ ys. x \\<in> range p], inv p ` Y) \\<in> failures P \\<longrightarrow>\n  (map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n   map (inv p) (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) U ys),\n   inv p ` ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) U ys Y) \\<in> failures P\"}\n\n\\null\n\nIn fact, for @{term \"ys = y # ys'\"}, the induction hypothesis entails that the consequent holds if\n@{term xs}, @{term ys}, and @{term U} are replaced with @{term \"xs @ [y]\"}, @{term ys'}, and\n@{term \"sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\"}, respectively. The proof can then\nbe accomplished by applying lemma @{thm [source] ipurge_tr_ref_aux_failures_general} to the\nresulting future of trace @{term \"map (inv p) [x\\<leftarrow>xs. x \\<in> range p]\"}, moving functions\n@{term ipurge_tr_aux} and @{term \"ipurge_ref_aux\"} into the arguments of @{term \"map (inv p)\"} and\n@{term \"(`) (inv p)\"}, and using the recursive equations contained in the definitions of functions\n@{term ipurge_tr_aux_foldr} and @{term ipurge_ref_aux_foldr}.\n\nThis property, along with the match of the outputs of functions @{term ipurge_tr_aux_foldr} and\n@{term ipurge_ref_aux_foldr} with the filtered intransitive purge of the input event list and the\nintransitive purge of the input event set, respectively, permits to solve the main proof obligations\narising from the demonstration of the target security conservation theorem.\n\nHere below is the proof of the equivalence between function @{term ipurge_tr_aux_foldr} and the\nfiltered intransitive purge of an event list.\n\n\\null\n\\<close>"], ["", "lemma ipurge_tr_aux_foldr_subset:\n \"U \\<subseteq> V \\<Longrightarrow>\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P V xs) =\n    ipurge_tr_aux_foldr I D P V xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> V \\<Longrightarrow>\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P V xs) =\n    ipurge_tr_aux_foldr I D P V xs", "proof (induction xs, simp_all add: ipurge_tr_aux_union [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P V xs) =\n                ipurge_tr_aux_foldr I D P V xs;\n        U \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (P a \\<longrightarrow>\n                          ipurge_tr_aux I D (V \\<union> U)\n                           (a #\n                            ipurge_tr_aux_foldr I D P (sinks_aux I D V [a])\n                             xs) =\n                          ipurge_tr_aux I D V\n                           (a #\n                            ipurge_tr_aux_foldr I D P (sinks_aux I D V [a])\n                             xs)) \\<and>\n                         (\\<not> P a \\<longrightarrow>\n                          ipurge_tr_aux I D (V \\<union> U)\n                           (ipurge_tr_aux_foldr I D P (sinks_aux I D V [a])\n                             xs) =\n                          ipurge_tr_aux I D V\n                           (ipurge_tr_aux_foldr I D P (sinks_aux I D V [a])\n                             xs))", "qed (drule Un_absorb2, simp)"], ["", "lemma ipurge_tr_aux_foldr_eq:\n \"[x\\<leftarrow>ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux_foldr I D P U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D U xs) = ipurge_tr_aux_foldr I D P U xs", "proof (induction xs arbitrary: U, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs U.\n       (\\<And>U.\n           filter P (ipurge_tr_aux I D U xs) =\n           ipurge_tr_aux_foldr I D P U xs) \\<Longrightarrow>\n       filter P (ipurge_tr_aux I D U (a # xs)) =\n       ipurge_tr_aux_foldr I D P U (a # xs)", "fix x xs U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs U.\n       (\\<And>U.\n           filter P (ipurge_tr_aux I D U xs) =\n           ipurge_tr_aux_foldr I D P U xs) \\<Longrightarrow>\n       filter P (ipurge_tr_aux I D U (a # xs)) =\n       ipurge_tr_aux_foldr I D P U (a # xs)", "assume\n    A: \"\\<And>U. [x\\<leftarrow>ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux_foldr I D P U xs\""], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D ?U xs) = ipurge_tr_aux_foldr I D P ?U xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs U.\n       (\\<And>U.\n           filter P (ipurge_tr_aux I D U xs) =\n           ipurge_tr_aux_foldr I D P U xs) \\<Longrightarrow>\n       filter P (ipurge_tr_aux I D U (a # xs)) =\n       ipurge_tr_aux_foldr I D P U (a # xs)", "show \"[x\\<leftarrow>ipurge_tr_aux I D U (x # xs). P x] =\n    ipurge_tr_aux_foldr I D P U (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D U (x # xs)) =\n    ipurge_tr_aux_foldr I D P U (x # xs)", "proof (cases \"\\<exists>u \\<in> U. (u, D x) \\<in> I\",\n   simp_all only: ipurge_tr_aux_foldr.simps ipurge_tr_aux_cons\n   sinks_aux_single_event if_True if_False)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @\n      ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    filter P (x # ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @\n      ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    filter P (x # ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)", "have B: \"[x\\<leftarrow>ipurge_tr_aux I D (insert (D x) U) xs. P x] =\n      ipurge_tr_aux_foldr I D P (insert (D x) U) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux_foldr I D P (insert (D x) U) xs", "using A"], ["proof (prove)\nusing this:\n  filter P (ipurge_tr_aux I D ?U xs) = ipurge_tr_aux_foldr I D P ?U xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux_foldr I D P (insert (D x) U) xs", "."], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @\n      ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n 2. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    filter P (x # ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)", "show \"[x\\<leftarrow>ipurge_tr_aux I D (insert (D x) U) xs. P x] = ipurge_tr_aux I D U\n      ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @\n      ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "proof (cases \"P x\", simp_all add: ipurge_tr_aux_cons True\n     del: con_comp_map.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D (insert (D x) U)\n     (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n 2. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "have \"insert (D x) U \\<subseteq> insert (D x) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (D x) U \\<subseteq> insert (D x) U", ".."], ["proof (state)\nthis:\n  insert (D x) U \\<subseteq> insert (D x) U\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D (insert (D x) U)\n     (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n 2. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "hence \"ipurge_tr_aux I D (insert (D x) U)\n        (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n          ipurge_tr_aux_foldr I D P (insert (D x) U) xs\""], ["proof (prove)\nusing this:\n  insert (D x) U \\<subseteq> insert (D x) U\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (insert (D x) U)\n     (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n    ipurge_tr_aux_foldr I D P (insert (D x) U) xs", "by (rule ipurge_tr_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (insert (D x) U)\n   (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D (insert (D x) U)\n     (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n 2. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "thus \"[x\\<leftarrow>ipurge_tr_aux I D (insert (D x) U) xs. P x] =\n        ipurge_tr_aux I D (insert (D x) U)\n          (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\""], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D (insert (D x) U)\n   (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D (insert (D x) U)\n     (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D (insert (D x) U)\n   (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n  filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D (insert (D x) U)\n     (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "by simp"], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n  ipurge_tr_aux I D (insert (D x) U)\n   (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "have \"U \\<subseteq> insert (D x) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) U", "by (rule subset_insertI)"], ["proof (state)\nthis:\n  U \\<subseteq> insert (D x) U\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "hence \"ipurge_tr_aux I D U\n        (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n          ipurge_tr_aux_foldr I D P (insert (D x) U) xs\""], ["proof (prove)\nusing this:\n  U \\<subseteq> insert (D x) U\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n    ipurge_tr_aux_foldr I D P (insert (D x) U) xs", "by (rule ipurge_tr_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "thus \"[x\\<leftarrow>ipurge_tr_aux I D (insert (D x) U) xs. P x] =\n        ipurge_tr_aux I D U\n          (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\""], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n  filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)", "by simp"], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D (insert (D x) U) xs) =\n  ipurge_tr_aux I D U\n   ((if P x then [x] else []) @\n    ipurge_tr_aux_foldr I D P (insert (D x) U) xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    filter P (x # ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    filter P (x # ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    filter P (x # ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)", "have B: \"[x\\<leftarrow>ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux_foldr I D P U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D U xs) = ipurge_tr_aux_foldr I D P U xs", "using A"], ["proof (prove)\nusing this:\n  filter P (ipurge_tr_aux I D ?U xs) = ipurge_tr_aux_foldr I D P ?U xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D U xs) = ipurge_tr_aux_foldr I D P U xs", "."], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D U xs) = ipurge_tr_aux_foldr I D P U xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I) \\<Longrightarrow>\n    filter P (x # ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)", "show \"[x\\<leftarrow>x # ipurge_tr_aux I D U xs. P x] = ipurge_tr_aux I D U\n      ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (x # ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U\n     ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)", "proof (cases \"P x\", simp_all add: ipurge_tr_aux_cons False\n     del: con_comp_map.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)\n 2. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "have \"U \\<subseteq> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> U", ".."], ["proof (state)\nthis:\n  U \\<subseteq> U\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)\n 2. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "hence \"ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n        ipurge_tr_aux_foldr I D P U xs\""], ["proof (prove)\nusing this:\n  U \\<subseteq> U\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n    ipurge_tr_aux_foldr I D P U xs", "by (rule ipurge_tr_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n  ipurge_tr_aux_foldr I D P U xs\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)\n 2. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "thus \"[x\\<leftarrow>ipurge_tr_aux I D U xs. P x] =\n        ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)\""], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n  ipurge_tr_aux_foldr I D P U xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n  ipurge_tr_aux_foldr I D P U xs\n  filter P (ipurge_tr_aux I D U xs) = ipurge_tr_aux_foldr I D P U xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "by simp"], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D U xs) =\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "have \"U \\<subseteq> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> U", ".."], ["proof (state)\nthis:\n  U \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "hence \"ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n        ipurge_tr_aux_foldr I D P U xs\""], ["proof (prove)\nusing this:\n  U \\<subseteq> U\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n    ipurge_tr_aux_foldr I D P U xs", "by (rule ipurge_tr_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n  ipurge_tr_aux_foldr I D P U xs\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "thus \"[x\\<leftarrow>ipurge_tr_aux I D U xs. P x] =\n        ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)\""], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n  ipurge_tr_aux_foldr I D P U xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs) =\n  ipurge_tr_aux_foldr I D P U xs\n  filter P (ipurge_tr_aux I D U xs) = ipurge_tr_aux_foldr I D P U xs\n\ngoal (1 subgoal):\n 1. filter P (ipurge_tr_aux I D U xs) =\n    ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)", "by simp"], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D U xs) =\n  ipurge_tr_aux I D U (ipurge_tr_aux_foldr I D P U xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter P (x # ipurge_tr_aux I D U xs) =\n  ipurge_tr_aux I D U\n   ((if P x then [x] else []) @ ipurge_tr_aux_foldr I D P U xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter P (ipurge_tr_aux I D U (x # xs)) =\n  ipurge_tr_aux_foldr I D P U (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nHere below is the proof of the equivalence between function @{term ipurge_ref_aux_foldr} and the\nintransitive purge of an event set.\n\n\\null\n\\<close>"], ["", "lemma ipurge_tr_aux_foldr_sinks_aux [rule_format]:\n \"U \\<subseteq> V \\<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", "proof (induction xs arbitrary: V, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs V.\n       \\<lbrakk>\\<And>V.\n                   U \\<subseteq> V \\<longrightarrow>\n                   sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U;\n        U \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U\n                          (ipurge_tr_aux_foldr I D P V (a # xs)) =\n                         U", "fix x xs V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs V.\n       \\<lbrakk>\\<And>V.\n                   U \\<subseteq> V \\<longrightarrow>\n                   sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U;\n        U \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U\n                          (ipurge_tr_aux_foldr I D P V (a # xs)) =\n                         U", "assume\n    A: \"\\<And>V. U \\<subseteq> V \\<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\" and\n    B: \"U \\<subseteq> V\""], ["proof (state)\nthis:\n  U \\<subseteq> ?V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P ?V xs) = U\n  U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a xs V.\n       \\<lbrakk>\\<And>V.\n                   U \\<subseteq> V \\<longrightarrow>\n                   sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U;\n        U \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U\n                          (ipurge_tr_aux_foldr I D P V (a # xs)) =\n                         U", "show \"sinks_aux I D U (ipurge_tr_aux_foldr I D P V (x # xs)) = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux_foldr I D P V (x # xs)) = U", "proof (cases \"P x\", case_tac [!] \"\\<exists>v \\<in> V. (v, D x) \\<in> I\",\n   simp_all (no_asm_simp) add: sinks_aux_cons ipurge_tr_aux_cons)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D (insert (D x) V)\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 3. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 4. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"U \\<subseteq> insert (D x) V \\<longrightarrow>\n      sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\"\n      (is \"_ \\<longrightarrow> sinks_aux I D U ?ys = U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U", "using A"], ["proof (prove)\nusing this:\n  U \\<subseteq> ?V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P ?V xs) = U\n\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U", "."], ["proof (state)\nthis:\n  U \\<subseteq> insert (D x) V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n\ngoal (4 subgoals):\n 1. \\<lbrakk>P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D (insert (D x) V)\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 3. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 4. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "moreover"], ["proof (state)\nthis:\n  U \\<subseteq> insert (D x) V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n\ngoal (4 subgoals):\n 1. \\<lbrakk>P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D (insert (D x) V)\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 3. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 4. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"U \\<subseteq> insert (D x) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) V", "using B"], ["proof (prove)\nusing this:\n  U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) V", "by (rule subset_insertI2)"], ["proof (state)\nthis:\n  U \\<subseteq> insert (D x) V\n\ngoal (4 subgoals):\n 1. \\<lbrakk>P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D (insert (D x) V)\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 3. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 4. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "ultimately"], ["proof (chain)\npicking this:\n  U \\<subseteq> insert (D x) V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n  U \\<subseteq> insert (D x) V", "have \"sinks_aux I D U ?ys = U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> insert (D x) V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n  U \\<subseteq> insert (D x) V\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U", ".."], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n\ngoal (4 subgoals):\n 1. \\<lbrakk>P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D (insert (D x) V)\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 3. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 4. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n\ngoal (4 subgoals):\n 1. \\<lbrakk>P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D (insert (D x) V)\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 3. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 4. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"insert (D x) V \\<subseteq> insert (D x) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (D x) V \\<subseteq> insert (D x) V", ".."], ["proof (state)\nthis:\n  insert (D x) V \\<subseteq> insert (D x) V\n\ngoal (4 subgoals):\n 1. \\<lbrakk>P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D (insert (D x) V)\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 3. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 4. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "hence \"ipurge_tr_aux I D (insert (D x) V)\n      (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = ?ys\"\n      (is \"?zs = _\")"], ["proof (prove)\nusing this:\n  insert (D x) V \\<subseteq> insert (D x) V\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (insert (D x) V)\n     (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) =\n    ipurge_tr_aux_foldr I D P (insert (D x) V) xs", "by (rule ipurge_tr_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (insert (D x) V)\n   (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) V) xs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D (insert (D x) V)\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 3. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 4. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n  ipurge_tr_aux I D (insert (D x) V)\n   (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) V) xs", "show \"sinks_aux I D U ?zs = U\""], ["proof (prove)\nusing this:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n  ipurge_tr_aux I D (insert (D x) V)\n   (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) V) xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U\n     (ipurge_tr_aux I D (insert (D x) V)\n       (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n    U", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U\n   (ipurge_tr_aux I D (insert (D x) V)\n     (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n  U\n\ngoal (3 subgoals):\n 1. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 2. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 3. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 2. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 3. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "assume C: \"\\<not> (\\<exists>v \\<in> V. (v, D x) \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 2. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 3. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"\\<not> (\\<exists>u \\<in> U. (u, D x) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow> False", "assume \"\\<exists>u \\<in> U. (u, D x) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I", "obtain u where D: \"u \\<in> U\" and E: \"(u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> U; (u, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> U\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow> False", "have \"u \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> V", "using B and D"], ["proof (prove)\nusing this:\n  U \\<subseteq> V\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> V", ".."], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow> False", "with E"], ["proof (chain)\npicking this:\n  (u, D x) \\<in> I\n  u \\<in> V", "have \"\\<exists>v \\<in> V. (v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>V. (v, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (u, D x) \\<in> I \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>V. (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>V. (v, D x) \\<in> I\n  \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>P x; \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>v\\<in>U.\n                           (v, D x) \\<in> I) \\<longrightarrow>\n                       sinks_aux I D (insert (D x) U)\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U) \\<and>\n                      ((\\<forall>v\\<in>U.\n                           (v, D x) \\<notin> I) \\<longrightarrow>\n                       sinks_aux I D U\n                        (ipurge_tr_aux I D V\n                          (ipurge_tr_aux_foldr I D P V xs)) =\n                       U)\n 2. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 3. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "thus\n     \"((\\<exists>v \\<in> U. (v, D x) \\<in> I) \\<longrightarrow> sinks_aux I D (insert (D x) U)\n        (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) = U) \\<and>\n      ((\\<forall>v \\<in> U. (v, D x) \\<notin> I) \\<longrightarrow> sinks_aux I D U\n        (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) = U)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. ((\\<exists>v\\<in>U. (v, D x) \\<in> I) \\<longrightarrow>\n     sinks_aux I D (insert (D x) U)\n      (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n     U) \\<and>\n    ((\\<forall>v\\<in>U. (v, D x) \\<notin> I) \\<longrightarrow>\n     sinks_aux I D U\n      (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n     U)", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n    U", "have \"U \\<subseteq> V \\<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\"\n        (is \"_ \\<longrightarrow> sinks_aux I D U ?ys = U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", "using A"], ["proof (prove)\nusing this:\n  U \\<subseteq> ?V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P ?V xs) = U\n\ngoal (1 subgoal):\n 1. U \\<subseteq> V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", "."], ["proof (state)\nthis:\n  U \\<subseteq> V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n    U", "hence \"sinks_aux I D U ?ys = U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", "using B"], ["proof (prove)\nusing this:\n  U \\<subseteq> V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n  U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", ".."], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n    U", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n    U", "have \"V \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> V", ".."], ["proof (state)\nthis:\n  V \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n    U", "hence \"ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) = ?ys\"\n        (is \"?zs = _\")"], ["proof (prove)\nusing this:\n  V \\<subseteq> V\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) =\n    ipurge_tr_aux_foldr I D P V xs", "by (rule ipurge_tr_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) =\n  ipurge_tr_aux_foldr I D P V xs\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. (u, D x) \\<notin> I \\<Longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n    U", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) =\n  ipurge_tr_aux_foldr I D P V xs", "show \"sinks_aux I D U ?zs = U\""], ["proof (prove)\nusing this:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) =\n  ipurge_tr_aux_foldr I D P V xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n    U", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) = U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<exists>v\\<in>U. (v, D x) \\<in> I) \\<longrightarrow>\n   sinks_aux I D (insert (D x) U)\n    (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n   U) \\<and>\n  ((\\<forall>v\\<in>U. (v, D x) \\<notin> I) \\<longrightarrow>\n   sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n   U)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"U \\<subseteq> insert (D x) V \\<longrightarrow>\n      sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\"\n      (is \"_ \\<longrightarrow> sinks_aux I D U ?ys = U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U", "using A"], ["proof (prove)\nusing this:\n  U \\<subseteq> ?V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P ?V xs) = U\n\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U", "."], ["proof (state)\nthis:\n  U \\<subseteq> insert (D x) V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "moreover"], ["proof (state)\nthis:\n  U \\<subseteq> insert (D x) V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"U \\<subseteq> insert (D x) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) V", "using B"], ["proof (prove)\nusing this:\n  U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. U \\<subseteq> insert (D x) V", "by (rule subset_insertI2)"], ["proof (state)\nthis:\n  U \\<subseteq> insert (D x) V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "ultimately"], ["proof (chain)\npicking this:\n  U \\<subseteq> insert (D x) V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n  U \\<subseteq> insert (D x) V", "have \"sinks_aux I D U ?ys = U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> insert (D x) V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n  U \\<subseteq> insert (D x) V\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U", ".."], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"V \\<subseteq> insert (D x) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> insert (D x) V", "by (rule subset_insertI)"], ["proof (state)\nthis:\n  V \\<subseteq> insert (D x) V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "hence \"ipurge_tr_aux I D V\n      (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = ?ys\"\n      (is \"?zs = _\")"], ["proof (prove)\nusing this:\n  V \\<subseteq> insert (D x) V\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) =\n    ipurge_tr_aux_foldr I D P (insert (D x) V) xs", "by (rule ipurge_tr_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) V) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<exists>v\\<in>V. (v, D x) \\<in> I\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n                      U\n 2. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) V) xs", "show \"sinks_aux I D U ?zs = U\""], ["proof (prove)\nusing this:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) = U\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P (insert (D x) V) xs) =\n  ipurge_tr_aux_foldr I D P (insert (D x) V) xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U\n     (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n    U", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U\n   (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P (insert (D x) V) xs)) =\n  U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"U \\<subseteq> V \\<longrightarrow> sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\"\n      (is \"_ \\<longrightarrow> sinks_aux I D U ?ys = U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", "using A"], ["proof (prove)\nusing this:\n  U \\<subseteq> ?V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P ?V xs) = U\n\ngoal (1 subgoal):\n 1. U \\<subseteq> V \\<longrightarrow>\n    sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", "."], ["proof (state)\nthis:\n  U \\<subseteq> V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "hence \"sinks_aux I D U ?ys = U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", "using B"], ["proof (prove)\nusing this:\n  U \\<subseteq> V \\<longrightarrow>\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n  U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U", ".."], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "have \"V \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> V", ".."], ["proof (state)\nthis:\n  V \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "hence \"ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) = ?ys\"\n      (is \"?zs = _\")"], ["proof (prove)\nusing this:\n  V \\<subseteq> V\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) =\n    ipurge_tr_aux_foldr I D P V xs", "by (rule ipurge_tr_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) =\n  ipurge_tr_aux_foldr I D P V xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x;\n     \\<not> (\\<exists>v\\<in>V. (v, D x) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> sinks_aux I D U\n                       (ipurge_tr_aux I D V\n                         (ipurge_tr_aux_foldr I D P V xs)) =\n                      U", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) =\n  ipurge_tr_aux_foldr I D P V xs", "show \"sinks_aux I D U ?zs = U\""], ["proof (prove)\nusing this:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V xs) = U\n  ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs) =\n  ipurge_tr_aux_foldr I D P V xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) =\n    U", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux I D V (ipurge_tr_aux_foldr I D P V xs)) = U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks_aux I D U (ipurge_tr_aux_foldr I D P V (x # xs)) = U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_aux_foldr_ref_aux:\n  assumes A: \"U \\<subseteq> V\"\n  shows \"ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P V xs) X =\n    ipurge_ref_aux I D U [] X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P V xs) X =\n    ipurge_ref_aux I D U [] X", "by (simp add: ipurge_ref_aux_def ipurge_tr_aux_foldr_sinks_aux [OF A])"], ["", "lemma ipurge_ref_aux_foldr_subset [rule_format]:\n \"sinks_aux I D U ys \\<subseteq> V \\<longrightarrow>\n  ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V xs X) =\n    ipurge_ref_aux_foldr I D P V xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> V \\<longrightarrow>\n    ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V xs X) =\n    ipurge_ref_aux_foldr I D P V xs X", "proof (induction xs arbitrary: ys U V, rule_tac [!] impI,\n simp add: ipurge_ref_aux_def, blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys U V.\n       \\<lbrakk>\\<And>ys U V.\n                   sinks_aux I D U ys \\<subseteq> V \\<longrightarrow>\n                   ipurge_ref_aux I D U ys\n                    (ipurge_ref_aux_foldr I D P V xs X) =\n                   ipurge_ref_aux_foldr I D P V xs X;\n        sinks_aux I D U ys \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux I D U ys\n                          (ipurge_ref_aux_foldr I D P V (a # xs) X) =\n                         ipurge_ref_aux_foldr I D P V (a # xs) X", "fix x xs ys U V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys U V.\n       \\<lbrakk>\\<And>ys U V.\n                   sinks_aux I D U ys \\<subseteq> V \\<longrightarrow>\n                   ipurge_ref_aux I D U ys\n                    (ipurge_ref_aux_foldr I D P V xs X) =\n                   ipurge_ref_aux_foldr I D P V xs X;\n        sinks_aux I D U ys \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux I D U ys\n                          (ipurge_ref_aux_foldr I D P V (a # xs) X) =\n                         ipurge_ref_aux_foldr I D P V (a # xs) X", "assume\n    A: \"\\<And>ys U V.\n      sinks_aux I D U ys \\<subseteq> V \\<longrightarrow>\n      ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V xs X) =\n        ipurge_ref_aux_foldr I D P V xs X\" and\n    B: \"sinks_aux I D U ys \\<subseteq> V\""], ["proof (state)\nthis:\n  sinks_aux I D ?U ?ys \\<subseteq> ?V \\<longrightarrow>\n  ipurge_ref_aux I D ?U ?ys (ipurge_ref_aux_foldr I D P ?V xs X) =\n  ipurge_ref_aux_foldr I D P ?V xs X\n  sinks_aux I D U ys \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys U V.\n       \\<lbrakk>\\<And>ys U V.\n                   sinks_aux I D U ys \\<subseteq> V \\<longrightarrow>\n                   ipurge_ref_aux I D U ys\n                    (ipurge_ref_aux_foldr I D P V xs X) =\n                   ipurge_ref_aux_foldr I D P V xs X;\n        sinks_aux I D U ys \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> ipurge_ref_aux I D U ys\n                          (ipurge_ref_aux_foldr I D P V (a # xs) X) =\n                         ipurge_ref_aux_foldr I D P V (a # xs) X", "show \"ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V (x # xs) X) =\n    ipurge_ref_aux_foldr I D P V (x # xs) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V (x # xs) X) =\n    ipurge_ref_aux_foldr I D P V (x # xs) X", "proof (cases \"P x\", simp_all add: ipurge_ref_aux_cons)"], ["proof (state)\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x])\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "have C: \"sinks_aux I D V [x] \\<subseteq> sinks_aux I D V [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D V [x] \\<subseteq> sinks_aux I D V [x]", ".."], ["proof (state)\nthis:\n  sinks_aux I D V [x] \\<subseteq> sinks_aux I D V [x]\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x])\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "show\n     \"ipurge_ref_aux I D U ys (ipurge_ref_aux I D (sinks_aux I D V [x])\n        (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n        (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n      ipurge_ref_aux I D (sinks_aux I D V [x])\n        (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n        (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x])\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "proof (simp add: ipurge_tr_aux_foldr_ref_aux [OF C])"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x]) []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "have \"sinks_aux I D (sinks_aux I D V [x]) [] \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n        ipurge_ref_aux I D (sinks_aux I D V [x]) []\n          (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n        ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\"\n        (is \"?A \\<longrightarrow> ?us = ?vs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D (sinks_aux I D V [x]) []\n    \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "using A"], ["proof (prove)\nusing this:\n  sinks_aux I D ?U ?ys \\<subseteq> ?V \\<longrightarrow>\n  ipurge_ref_aux I D ?U ?ys (ipurge_ref_aux_foldr I D P ?V xs X) =\n  ipurge_ref_aux_foldr I D P ?V xs X\n\ngoal (1 subgoal):\n 1. sinks_aux I D (sinks_aux I D V [x]) []\n    \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "."], ["proof (state)\nthis:\n  sinks_aux I D (sinks_aux I D V [x]) []\n  \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D (sinks_aux I D V [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x]) []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D (sinks_aux I D V [x]) []\n  \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D (sinks_aux I D V [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x]) []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "have ?A"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D (sinks_aux I D V [x]) [] \\<subseteq> sinks_aux I D V [x]", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (sinks_aux I D V [x]) [] \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x]) []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D (sinks_aux I D V [x]) []\n  \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D (sinks_aux I D V [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n  sinks_aux I D (sinks_aux I D V [x]) [] \\<subseteq> sinks_aux I D V [x]", "have \"?us = ?vs\""], ["proof (prove)\nusing this:\n  sinks_aux I D (sinks_aux I D V [x]) []\n  \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D (sinks_aux I D V [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n  sinks_aux I D (sinks_aux I D V [x]) [] \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", ".."], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D V [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x]) []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "thus \"ipurge_ref_aux I D U ys ?us = ?us\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux I D (sinks_aux I D V [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D (sinks_aux I D V [x]) []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "have \"sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n          ipurge_ref_aux I D U ys\n            (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n          ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\"\n          (is \"_ \\<longrightarrow> ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "using A"], ["proof (prove)\nusing this:\n  sinks_aux I D ?U ?ys \\<subseteq> ?V \\<longrightarrow>\n  ipurge_ref_aux I D ?U ?ys (ipurge_ref_aux_foldr I D P ?V xs X) =\n  ipurge_ref_aux_foldr I D P ?V xs X\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "."], ["proof (state)\nthis:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "have \"V \\<subseteq> sinks_aux I D V [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> sinks_aux I D V [x]", "by (rule sinks_aux_subset)"], ["proof (state)\nthis:\n  V \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "hence \"sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]\""], ["proof (prove)\nusing this:\n  V \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]", "using B"], ["proof (prove)\nusing this:\n  V \\<subseteq> sinks_aux I D V [x]\n  sinks_aux I D U ys \\<subseteq> V\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]", "show ?T"], ["proof (prove)\nusing this:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", ".."], ["proof (state)\nthis:\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux I D (sinks_aux I D V [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n  ipurge_ref_aux I D (sinks_aux I D V [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux I D (sinks_aux I D V [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n  ipurge_ref_aux I D (sinks_aux I D V [x])\n   (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "have C: \"V \\<subseteq> sinks_aux I D V [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> sinks_aux I D V [x]", "by (rule sinks_aux_subset)"], ["proof (state)\nthis:\n  V \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "show\n     \"ipurge_ref_aux I D U ys (ipurge_ref_aux I D V\n        (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n        (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n      ipurge_ref_aux I D V\n        (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n        (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V\n       (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "proof (simp add: ipurge_tr_aux_foldr_ref_aux [OF C])"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "have \"sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n        ipurge_ref_aux I D V []\n          (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n        ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\"\n        (is \"?A \\<longrightarrow> ?us = ?vs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n    ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "using A"], ["proof (prove)\nusing this:\n  sinks_aux I D ?U ?ys \\<subseteq> ?V \\<longrightarrow>\n  ipurge_ref_aux I D ?U ?ys (ipurge_ref_aux_foldr I D P ?V xs X) =\n  ipurge_ref_aux_foldr I D P ?V xs X\n\ngoal (1 subgoal):\n 1. sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n    ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "."], ["proof (state)\nthis:\n  sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D V []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D V []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "have ?A"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x]", "using C"], ["proof (prove)\nusing this:\n  V \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x]", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D V []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n  sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x]", "have \"?us = ?vs\""], ["proof (prove)\nusing this:\n  sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D V []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n  sinks_aux I D V [] \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", ".."], ["proof (state)\nthis:\n  ipurge_ref_aux I D V []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "thus \"ipurge_ref_aux I D U ys ?us = ?us\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux I D V []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux I D V []\n       (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n    ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "have \"sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n          ipurge_ref_aux I D U ys\n            (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n          ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\"\n          (is \"_ \\<longrightarrow> ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "using A"], ["proof (prove)\nusing this:\n  sinks_aux I D ?U ?ys \\<subseteq> ?V \\<longrightarrow>\n  ipurge_ref_aux I D ?U ?ys (ipurge_ref_aux_foldr I D P ?V xs X) =\n  ipurge_ref_aux_foldr I D P ?V xs X\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "."], ["proof (state)\nthis:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "have \"sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]", "using B and C"], ["proof (prove)\nusing this:\n  sinks_aux I D U ys \\<subseteq> V\n  V \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]", "show ?T"], ["proof (prove)\nusing this:\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x] \\<longrightarrow>\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n  sinks_aux I D U ys \\<subseteq> sinks_aux I D V [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U ys\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X", ".."], ["proof (state)\nthis:\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux I D V []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n  ipurge_ref_aux I D V []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U ys\n   (ipurge_ref_aux I D V\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)) =\n  ipurge_ref_aux I D V (ipurge_tr_aux_foldr I D P (sinks_aux I D V [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D V [x]) xs X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U ys (ipurge_ref_aux_foldr I D P V (x # xs) X) =\n  ipurge_ref_aux_foldr I D P V (x # xs) X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_ref_aux_foldr_eq:\n \"ipurge_ref_aux I D U xs X = ipurge_ref_aux_foldr I D P U xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U xs X = ipurge_ref_aux_foldr I D P U xs X", "proof (induction xs arbitrary: U, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs U.\n       (\\<And>U.\n           ipurge_ref_aux I D U xs X =\n           ipurge_ref_aux_foldr I D P U xs X) \\<Longrightarrow>\n       ipurge_ref_aux I D U (a # xs) X =\n       ipurge_ref_aux_foldr I D P U (a # xs) X", "fix x xs U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs U.\n       (\\<And>U.\n           ipurge_ref_aux I D U xs X =\n           ipurge_ref_aux_foldr I D P U xs X) \\<Longrightarrow>\n       ipurge_ref_aux I D U (a # xs) X =\n       ipurge_ref_aux_foldr I D P U (a # xs) X", "assume A: \"\\<And>U. ipurge_ref_aux I D U xs X = ipurge_ref_aux_foldr I D P U xs X\""], ["proof (state)\nthis:\n  ipurge_ref_aux I D ?U xs X = ipurge_ref_aux_foldr I D P ?U xs X\n\ngoal (1 subgoal):\n 1. \\<And>a xs U.\n       (\\<And>U.\n           ipurge_ref_aux I D U xs X =\n           ipurge_ref_aux_foldr I D P U xs X) \\<Longrightarrow>\n       ipurge_ref_aux I D U (a # xs) X =\n       ipurge_ref_aux_foldr I D P U (a # xs) X", "show \"ipurge_ref_aux I D U (x # xs) X =\n    ipurge_ref_aux_foldr I D P U (x # xs) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U (x # xs) X =\n    ipurge_ref_aux_foldr I D P U (x # xs) X", "proof (cases \"P x\", simp_all add: ipurge_ref_aux_cons)"], ["proof (state)\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "have \"sinks_aux I D U [x] \\<subseteq> sinks_aux I D U [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U [x] \\<subseteq> sinks_aux I D U [x]", ".."], ["proof (state)\nthis:\n  sinks_aux I D U [x] \\<subseteq> sinks_aux I D U [x]\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "hence\n     \"ipurge_ref_aux I D (sinks_aux I D U [x])\n        (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n        (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n      ipurge_ref_aux I D (sinks_aux I D U [x]) []\n        (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\"\n      (is \"ipurge_ref_aux _ _ _ ?xs' ?X' = _\")"], ["proof (prove)\nusing this:\n  sinks_aux I D U [x] \\<subseteq> sinks_aux I D U [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n    ipurge_ref_aux I D (sinks_aux I D U [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "by (rule ipurge_tr_aux_foldr_ref_aux)"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D U [x])\n   (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux I D (sinks_aux I D U [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "also"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D U [x])\n   (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux I D (sinks_aux I D U [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "have \"sinks_aux I D (sinks_aux I D U [x]) [] \\<subseteq> sinks_aux I D U [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D (sinks_aux I D U [x]) [] \\<subseteq> sinks_aux I D U [x]", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (sinks_aux I D U [x]) [] \\<subseteq> sinks_aux I D U [x]\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "hence \"ipurge_ref_aux I D (sinks_aux I D U [x]) [] ?X' = ?X'\""], ["proof (prove)\nusing this:\n  sinks_aux I D (sinks_aux I D U [x]) [] \\<subseteq> sinks_aux I D U [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x]) []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "by (rule ipurge_ref_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D U [x]) []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "finally"], ["proof (chain)\npicking this:\n  ipurge_ref_aux I D (sinks_aux I D U [x])\n   (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "have \"ipurge_ref_aux I D (sinks_aux I D U [x]) ?xs' ?X' = ?X'\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux I D (sinks_aux I D U [x])\n   (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "."], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D U [x])\n   (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n 2. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "thus \"ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n      ipurge_ref_aux I D (sinks_aux I D U [x]) ?xs' ?X'\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux I D (sinks_aux I D U [x])\n   (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x])\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "show \"ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n        ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "using A"], ["proof (prove)\nusing this:\n  ipurge_ref_aux I D ?U xs X = ipurge_ref_aux_foldr I D P ?U xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "."], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n  ipurge_ref_aux I D (sinks_aux I D U [x])\n   (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "have \"U \\<subseteq> sinks_aux I D U [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> sinks_aux I D U [x]", "by (rule sinks_aux_subset)"], ["proof (state)\nthis:\n  U \\<subseteq> sinks_aux I D U [x]\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "hence\n     \"ipurge_ref_aux I D U\n        (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n        (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n      ipurge_ref_aux I D U []\n        (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\"\n      (is \"ipurge_ref_aux _ _ _ ?xs' ?X' = _\")"], ["proof (prove)\nusing this:\n  U \\<subseteq> sinks_aux I D U [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n    ipurge_ref_aux I D U []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "by (rule ipurge_tr_aux_foldr_ref_aux)"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux I D U []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "also"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux I D U []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "have \"sinks_aux I D U [] \\<subseteq> sinks_aux I D U [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U [] \\<subseteq> sinks_aux I D U [x]", "by (simp, rule sinks_aux_subset)"], ["proof (state)\nthis:\n  sinks_aux I D U [] \\<subseteq> sinks_aux I D U [x]\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "hence \"ipurge_ref_aux I D U [] ?X' = ?X'\""], ["proof (prove)\nusing this:\n  sinks_aux I D U [] \\<subseteq> sinks_aux I D U [x]\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U []\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "by (rule ipurge_ref_aux_foldr_subset)"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U []\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "finally"], ["proof (chain)\npicking this:\n  ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "have \"ipurge_ref_aux I D U ?xs' ?X' = ?X'\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "."], ["proof (state)\nthis:\n  ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "thus \"ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n      ipurge_ref_aux I D U ?xs' ?X'\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D U\n     (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n     (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X) =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X \\<Longrightarrow>\n    ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "show \"ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n        ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "using A"], ["proof (prove)\nusing this:\n  ipurge_ref_aux I D ?U xs X = ipurge_ref_aux_foldr I D P ?U xs X\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n    ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X", "."], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n  ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (sinks_aux I D U [x]) xs X =\n  ipurge_ref_aux I D U (ipurge_tr_aux_foldr I D P (sinks_aux I D U [x]) xs)\n   (ipurge_ref_aux_foldr I D P (sinks_aux I D U [x]) xs X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D U (x # xs) X = ipurge_ref_aux_foldr I D P U (x # xs) X\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nFinally, here below is the proof of the implication involving functions @{term ipurge_tr_aux_foldr}\nand @{term ipurge_ref_aux_foldr} discussed above.\n\n\\null\n\\<close>"], ["", "lemma con_comp_sinks_aux_range:\n  assumes\n    A: \"U \\<subseteq> range Some\" and\n    B: \"set xs \\<subseteq> range p \\<union> range q\"\n  shows \"sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs \\<subseteq> range Some\"\n    (is \"sinks_aux _ ?D' _ _ \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n    \\<subseteq> range Some", "proof (rule subsetI, drule sinks_aux_elem, erule disjE, erule_tac [2] bexE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> range Some\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> range Some\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "assume \"u \\<in> U\""], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> range Some\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> range Some\n  u \\<in> U", "show \"u \\<in> range Some\""], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", ".."], ["proof (state)\nthis:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "fix u x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "with B"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> range p \\<union> range q\n  x \\<in> set xs", "have \"x \\<in> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p \\<union> range q\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> range p \\<union> range q", ".."], ["proof (state)\nthis:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "hence \"?D' x \\<in> range Some\""], ["proof (prove)\nusing this:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x \\<in> range Some", "by (cases \"x \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  con_comp_map D E p q x \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "moreover"], ["proof (state)\nthis:\n  con_comp_map D E p q x \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "assume \"u = ?D' x\""], ["proof (state)\nthis:\n  u = con_comp_map D E p q x\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> set xs; x = con_comp_map D E p q xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range Some", "ultimately"], ["proof (chain)\npicking this:\n  con_comp_map D E p q x \\<in> range Some\n  u = con_comp_map D E p q x", "show \"u \\<in> range Some\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x \\<in> range Some\n  u = con_comp_map D E p q x\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", "by simp"], ["proof (state)\nthis:\n  u \\<in> range Some\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_sinks_aux [rule_format]:\n  assumes A: \"U \\<subseteq> range Some\"\n  shows \"set xs \\<subseteq> range p \\<longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\"\n    (is \"_ \\<longrightarrow> _ = the ` sinks_aux ?I' ?D' _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "proof (induction xs rule: rev_induct, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                sinks_aux I D (the ` U) (map (inv p) xs) =\n                the `\n                sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs;\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n                         the `\n                         sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          (xs @ [x])", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                sinks_aux I D (the ` U) (map (inv p) xs) =\n                the `\n                sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs;\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n                         the `\n                         sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          (xs @ [x])", "assume \"set xs \\<subseteq> range p \\<longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux ?I' ?D' U xs\""], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<longrightarrow>\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                sinks_aux I D (the ` U) (map (inv p) xs) =\n                the `\n                sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs;\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n                         the `\n                         sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<longrightarrow>\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                sinks_aux I D (the ` U) (map (inv p) xs) =\n                the `\n                sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs;\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n                         the `\n                         sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          (xs @ [x])", "assume B: \"set (xs @ [x]) \\<subseteq> range p\""], ["proof (state)\nthis:\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                sinks_aux I D (the ` U) (map (inv p) xs) =\n                the `\n                sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs;\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n                         the `\n                         sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> range p \\<longrightarrow>\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  set (xs @ [x]) \\<subseteq> range p", "have C: \"sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p \\<longrightarrow>\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                sinks_aux I D (the ` U) (map (inv p) xs) =\n                the `\n                sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs;\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n                         the `\n                         sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          (xs @ [x])", "show \"sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux ?I' ?D' U (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])", "proof (cases \"\\<exists>u \\<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \\<in> ?I'\",\n   simp_all (no_asm_simp) del: map_append)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "obtain u where\n      D: \"u \\<in> sinks_aux ?I' ?D' U xs\" and E: \"(u, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs;\n         (u, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "have \"(the u, D (inv p x)) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the u, D (inv p x)) \\<in> I", "using B and E"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> range p\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (the u, D (inv p x)) \\<in> I", "by (simp add: con_comp_pol_def, erule_tac exE, simp)"], ["proof (state)\nthis:\n  (the u, D (inv p x)) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "moreover"], ["proof (state)\nthis:\n  (the u, D (inv p x)) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "have \"the u \\<in> the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "using D"], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by simp"], ["proof (state)\nthis:\n  the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "hence \"the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\""], ["proof (prove)\nusing this:\n  the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)", "using C"], ["proof (prove)\nusing this:\n  the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)", "by simp"], ["proof (state)\nthis:\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "ultimately"], ["proof (chain)\npicking this:\n  (the u, D (inv p x)) \\<in> I\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)", "have \"\\<exists>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs).\n      (d, D (inv p x)) \\<in> I\""], ["proof (prove)\nusing this:\n  (the u, D (inv p x)) \\<in> I\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n       (d, D (inv p x)) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n     (d, D (inv p x)) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "hence \"sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n      insert (D (inv p x)) (sinks_aux I D (the ` U) (map (inv p) xs))\""], ["proof (prove)\nusing this:\n  \\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n     (d, D (inv p x)) \\<in> I\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (D (inv p x)) (sinks_aux I D (the ` U) (map (inv p) xs))", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  insert (D (inv p x)) (sinks_aux I D (the ` U) (map (inv p) xs))\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "thus \"sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n      insert (the (?D' x)) (the ` sinks_aux ?I' ?D' U xs)\""], ["proof (prove)\nusing this:\n  sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  insert (D (inv p x)) (sinks_aux I D (the ` U) (map (inv p) xs))\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)", "using B and C"], ["proof (prove)\nusing this:\n  sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  insert (D (inv p x)) (sinks_aux I D (the ` U) (map (inv p) xs))\n  set (xs @ [x]) \\<subseteq> range p\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    insert (the (con_comp_map D E p q x))\n     (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  insert (the (con_comp_map D E p q x))\n   (the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs.\n             (u, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "have \"\\<not> (\\<exists>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs).\n      (d, D (inv p x)) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n               (d, D (inv p x)) \\<in> I)", "proof (rule notI, erule bexE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\""], ["proof (state)\nthis:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"d \\<in> the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\nusing this:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "using C"], ["proof (prove)\nusing this:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by simp"], ["proof (state)\nthis:\n  d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>u \\<in> sinks_aux ?I' ?D' U xs. d = the u\""], ["proof (prove)\nusing this:\n  d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       d = the u", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u", "obtain u where\n        D: \"u \\<in> sinks_aux ?I' ?D' U xs\" and E: \"d = the u\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs;\n         d = the u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  d = the u\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "have \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using B"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "by (simp, blast)"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p \\<union> range q", "have \"sinks_aux ?I' ?D' U xs \\<subseteq> range Some\""], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n    \\<subseteq> range Some", "by (rule con_comp_sinks_aux_range)"], ["proof (state)\nthis:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"u \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", "using D"], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", ".."], ["proof (state)\nthis:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"u = Some d\""], ["proof (prove)\nusing this:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. u = Some d", "using E"], ["proof (prove)\nusing this:\n  u \\<in> range Some\n  d = the u\n\ngoal (1 subgoal):\n 1. u = Some d", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  u = Some d\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  u = Some d\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(d, D (inv p x)) \\<in> I\""], ["proof (state)\nthis:\n  (d, D (inv p x)) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(Some d, Some (D (inv p x))) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  (d, D (inv p x)) \\<in> I\n\ngoal (1 subgoal):\n 1. (Some d, Some (D (inv p x))) \\<in> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (Some d, Some (D (inv p x))) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  u = Some d\n  (Some d, Some (D (inv p x))) \\<in> con_comp_pol I", "have \"(u, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  u = Some d\n  (Some d, Some (D (inv p x))) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "using B"], ["proof (prove)\nusing this:\n  u = Some d\n  (Some d, Some (D (inv p x))) \\<in> con_comp_pol I\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>u \\<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "using D"], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n  \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs.\n             (u, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n             (d, D (inv p x)) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "thus \"sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n      the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n             (d, D (inv p x)) \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "using C"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n             (d, D (inv p x)) \\<in> I)\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_ipurge_tr_aux [rule_format]:\n  assumes A: \"U \\<subseteq> range Some\"\n  shows \"set xs \\<subseteq> range p \\<longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n    map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\"\n    (is \"_ \\<longrightarrow> _ = map (inv p) (ipurge_tr_aux ?I' ?D' _ _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n    map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)", "proof (induction xs rule: rev_induct, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n                map (inv p)\n                 (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n                   xs);\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D (the ` U)\n                          (map (inv p) (xs @ [x])) =\n                         map (inv p)\n                          (ipurge_tr_aux (con_comp_pol I)\n                            (con_comp_map D E p q) U (xs @ [x]))", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n                map (inv p)\n                 (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n                   xs);\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D (the ` U)\n                          (map (inv p) (xs @ [x])) =\n                         map (inv p)\n                          (ipurge_tr_aux (con_comp_pol I)\n                            (con_comp_map D E p q) U (xs @ [x]))", "assume \"set xs \\<subseteq> range p \\<longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n    map (inv p) (ipurge_tr_aux ?I' ?D' U xs)\""], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<longrightarrow>\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n                map (inv p)\n                 (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n                   xs);\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D (the ` U)\n                          (map (inv p) (xs @ [x])) =\n                         map (inv p)\n                          (ipurge_tr_aux (con_comp_pol I)\n                            (con_comp_map D E p q) U (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<longrightarrow>\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n                map (inv p)\n                 (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n                   xs);\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D (the ` U)\n                          (map (inv p) (xs @ [x])) =\n                         map (inv p)\n                          (ipurge_tr_aux (con_comp_pol I)\n                            (con_comp_map D E p q) U (xs @ [x]))", "assume B: \"set (xs @ [x]) \\<subseteq> range p\""], ["proof (state)\nthis:\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n                map (inv p)\n                 (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n                   xs);\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D (the ` U)\n                          (map (inv p) (xs @ [x])) =\n                         map (inv p)\n                          (ipurge_tr_aux (con_comp_pol I)\n                            (con_comp_map D E p q) U (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> range p \\<longrightarrow>\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n  set (xs @ [x]) \\<subseteq> range p", "have C: \"ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n    map (inv p) (ipurge_tr_aux ?I' ?D' U xs)\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p \\<longrightarrow>\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n    map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> range p \\<longrightarrow>\n                ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n                map (inv p)\n                 (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n                   xs);\n        set (xs @ [x]) \\<subseteq> range p\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_aux I D (the ` U)\n                          (map (inv p) (xs @ [x])) =\n                         map (inv p)\n                          (ipurge_tr_aux (con_comp_pol I)\n                            (con_comp_map D E p q) U (xs @ [x]))", "show \"ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p) (ipurge_tr_aux ?I' ?D' U (xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "proof (cases \"\\<exists>u \\<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \\<in> ?I'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "obtain u where\n      D: \"u \\<in> sinks_aux ?I' ?D' U xs\" and E: \"(u, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs;\n         (u, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "have \"(the u, D (inv p x)) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the u, D (inv p x)) \\<in> I", "using B and E"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> range p\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (the u, D (inv p x)) \\<in> I", "by (simp add: con_comp_pol_def, erule_tac exE, simp)"], ["proof (state)\nthis:\n  (the u, D (inv p x)) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  (the u, D (inv p x)) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "have F: \"the u \\<in> the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "using D"], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by simp"], ["proof (state)\nthis:\n  the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "have \"set xs \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p", "using B"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p", "have \"sinks_aux I D (the ` U) (map (inv p) xs) =\n      the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by (rule con_comp_sinks_aux)"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "hence \"the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\""], ["proof (prove)\nusing this:\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)", "using F"], ["proof (prove)\nusing this:\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  the u \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)", "by simp"], ["proof (state)\nthis:\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  (the u, D (inv p x)) \\<in> I\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)", "have \"\\<exists>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs).\n      (d, D (inv p x)) \\<in> I\""], ["proof (prove)\nusing this:\n  (the u, D (inv p x)) \\<in> I\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n       (d, D (inv p x)) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n     (d, D (inv p x)) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "hence \"ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n      ipurge_tr_aux I D (the ` U) (map (inv p) xs)\""], ["proof (prove)\nusing this:\n  \\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n     (d, D (inv p x)) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    ipurge_tr_aux I D (the ` U) (map (inv p) xs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "have \"map (inv p) (ipurge_tr_aux ?I' ?D' U (xs @ [x])) =\n      map (inv p) (ipurge_tr_aux ?I' ?D' U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n    map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)", "using True"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n    map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)", "by simp"], ["proof (state)\nthis:\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n 2. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs)\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs)\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "using C"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs)\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs.\n             (u, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "have \"\\<not> (\\<exists>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs).\n      (d, D (inv p x)) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n               (d, D (inv p x)) \\<in> I)", "proof (rule notI, erule bexE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\""], ["proof (state)\nthis:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "have \"set xs \\<subseteq> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p", "using B"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p", "have \"sinks_aux I D (the ` U) (map (inv p) xs) =\n        the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by (rule con_comp_sinks_aux)"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "have \"d \\<in> the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\nusing this:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by simp"], ["proof (state)\nthis:\n  d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>u \\<in> sinks_aux ?I' ?D' U xs. d = the u\""], ["proof (prove)\nusing this:\n  d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       d = the u", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u", "obtain u where\n        D: \"u \\<in> sinks_aux ?I' ?D' U xs\" and E: \"d = the u\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs;\n         d = the u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  d = the u\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "have \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using B"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "by (simp, blast)"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p \\<union> range q", "have \"sinks_aux ?I' ?D' U xs \\<subseteq> range Some\""], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n    \\<subseteq> range Some", "by (rule con_comp_sinks_aux_range)"], ["proof (state)\nthis:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"u \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", "using D"], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", ".."], ["proof (state)\nthis:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"u = Some d\""], ["proof (prove)\nusing this:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. u = Some d", "using E"], ["proof (prove)\nusing this:\n  u \\<in> range Some\n  d = the u\n\ngoal (1 subgoal):\n 1. u = Some d", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  u = Some d\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  u = Some d\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(d, D (inv p x)) \\<in> I\""], ["proof (state)\nthis:\n  (d, D (inv p x)) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(Some d, Some (D (inv p x))) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  (d, D (inv p x)) \\<in> I\n\ngoal (1 subgoal):\n 1. (Some d, Some (D (inv p x))) \\<in> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (Some d, Some (D (inv p x))) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  u = Some d\n  (Some d, Some (D (inv p x))) \\<in> con_comp_pol I", "have \"(u, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  u = Some d\n  (Some d, Some (D (inv p x))) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "using B"], ["proof (prove)\nusing this:\n  u = Some d\n  (Some d, Some (D (inv p x))) \\<in> con_comp_pol I\n  set (xs @ [x]) \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>u \\<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "using D"], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       (u, con_comp_map D E p q x) \\<in> con_comp_pol I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs);\n        (d, D (inv p x)) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n  \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs.\n             (u, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n             (d, D (inv p x)) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "hence \"ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n      ipurge_tr_aux I D (the ` U) (map (inv p) xs) @ [inv p x]\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n             (d, D (inv p x)) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    ipurge_tr_aux I D (the ` U) (map (inv p) xs) @ [inv p x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) @ [inv p x]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) @ [inv p x]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "have \"map (inv p) (ipurge_tr_aux ?I' ?D' U (xs @ [x])) =\n      map (inv p) (ipurge_tr_aux ?I' ?D' U xs) @ [inv p x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs) @\n    [inv p x]", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs.\n             (u, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs) @\n    [inv p x]", "by simp"], ["proof (state)\nthis:\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs) @\n  [inv p x]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n                            U xs.\n               (u, con_comp_map D E p q x)\n               \\<in> con_comp_pol I) \\<Longrightarrow>\n    ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) @ [inv p x]\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs) @\n  [inv p x]", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) @ [inv p x]\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs) @\n  [inv p x]\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "using C"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) @ [inv p x]\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x])) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs) @\n  [inv p x]\n  ipurge_tr_aux I D (the ` U) (map (inv p) xs) =\n  map (inv p) (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U) (map (inv p) (xs @ [x])) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_ipurge_ref_aux:\n  assumes\n    A: \"U \\<subseteq> range Some\" and\n    B: \"set xs \\<subseteq> range p\" and\n    C: \"X \\<subseteq> range p\"\n  shows \"ipurge_ref_aux I D (the ` U) (map (inv p) xs) (inv p ` X) =\n    inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U xs X\"\n  (is \"_ = inv p ` ipurge_ref_aux ?I' ?D' _ _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (the ` U) (map (inv p) xs) (inv p ` X) =\n    inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U xs X", "proof (simp add: ipurge_ref_aux_def set_eq_iff image_iff, rule allI, rule iffI,\n erule conjE, erule bexE, erule_tac [2] exE, (erule_tac [2] conjE)+)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>v\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n                   (v, D x) \\<notin> I;\n        xa \\<in> X; x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> X \\<and>\n                            (\\<forall>v\n\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n                                (v, con_comp_map D E p q xa)\n                                \\<notin> con_comp_pol I) \\<and>\n                            x = inv p xa\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> X;\n        \\<forall>v\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                        xs.\n           (v, con_comp_map D E p q xa) \\<notin> con_comp_pol I;\n        x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>X. x = inv p xa) \\<and>\n                         (\\<forall>v\\<in>sinks_aux I D (the ` U)\n    (map (inv p) xs).\n                             (v, D x) \\<notin> I)", "fix a x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>v\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n                   (v, D x) \\<notin> I;\n        xa \\<in> X; x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> X \\<and>\n                            (\\<forall>v\n\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n                                (v, con_comp_map D E p q xa)\n                                \\<notin> con_comp_pol I) \\<and>\n                            x = inv p xa\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> X;\n        \\<forall>v\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                        xs.\n           (v, con_comp_map D E p q xa) \\<notin> con_comp_pol I;\n        x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>X. x = inv p xa) \\<and>\n                         (\\<forall>v\\<in>sinks_aux I D (the ` U)\n    (map (inv p) xs).\n                             (v, D x) \\<notin> I)", "assume\n    D: \"x \\<in> X\" and\n    E: \"a = inv p x\" and\n    F: \"\\<forall>d \\<in> sinks_aux I D (the ` U) (map (inv p) xs). (d, D a) \\<notin> I\""], ["proof (state)\nthis:\n  x \\<in> X\n  a = inv p x\n  \\<forall>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n     (d, D a) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>v\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n                   (v, D x) \\<notin> I;\n        xa \\<in> X; x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> X \\<and>\n                            (\\<forall>v\n\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n                                (v, con_comp_map D E p q xa)\n                                \\<notin> con_comp_pol I) \\<and>\n                            x = inv p xa\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> X;\n        \\<forall>v\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                        xs.\n           (v, con_comp_map D E p q xa) \\<notin> con_comp_pol I;\n        x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>X. x = inv p xa) \\<and>\n                         (\\<forall>v\\<in>sinks_aux I D (the ` U)\n    (map (inv p) xs).\n                             (v, D x) \\<notin> I)", "show \"\\<exists>x. x \\<in> X \\<and> (\\<forall>u \\<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \\<notin> ?I') \\<and>\n    a = inv p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> X \\<and>\n       (\\<forall>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                        xs.\n           (u, con_comp_map D E p q x) \\<notin> con_comp_pol I) \\<and>\n       a = inv p x", "proof (rule_tac x = x in exI, simp add: D E, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "assume G: \"u \\<in> sinks_aux ?I' ?D' U xs\""], ["proof (state)\nthis:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "have \"sinks_aux I D (the ` U) (map (inv p) xs) =\n      the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "using A and B"], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by (rule con_comp_sinks_aux)"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "have \"the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\""], ["proof (prove)\nusing this:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)", "by simp"], ["proof (state)\nthis:\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "with F"], ["proof (chain)\npicking this:\n  \\<forall>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n     (d, D a) \\<notin> I\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)", "have \"(the u, D a) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n     (d, D a) \\<notin> I\n  the u \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. (the u, D a) \\<notin> I", ".."], ["proof (state)\nthis:\n  (the u, D a) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  (the u, D a) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "have \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using B"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "by blast"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p \\<union> range q", "have \"sinks_aux ?I' ?D' U xs \\<subseteq> range Some\""], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n    \\<subseteq> range Some", "by (rule con_comp_sinks_aux_range)"], ["proof (state)\nthis:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"u \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", "using G"], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", ".."], ["proof (state)\nthis:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"\\<exists>d. u = Some d\""], ["proof (prove)\nusing this:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<exists>d. u = Some d", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>d. u = Some d\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "then"], ["proof (chain)\npicking this:\n  \\<exists>d. u = Some d", "obtain d where H: \"u = Some d\""], ["proof (prove)\nusing this:\n  \\<exists>d. u = Some d\n\ngoal (1 subgoal):\n 1. (\\<And>d. u = Some d \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  u = Some d\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  (the u, D a) \\<notin> I\n  u = Some d", "have \"(d, D (inv p x)) \\<notin> I\""], ["proof (prove)\nusing this:\n  (the u, D a) \\<notin> I\n  u = Some d\n\ngoal (1 subgoal):\n 1. (d, D (inv p x)) \\<notin> I", "using E"], ["proof (prove)\nusing this:\n  (the u, D a) \\<notin> I\n  u = Some d\n  a = inv p x\n\ngoal (1 subgoal):\n 1. (d, D (inv p x)) \\<notin> I", "by simp"], ["proof (state)\nthis:\n  (d, D (inv p x)) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"(u, Some (D (inv p x))) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (d, D (inv p x)) \\<notin> I\n\ngoal (1 subgoal):\n 1. (u, Some (D (inv p x))) \\<notin> con_comp_pol I", "using H"], ["proof (prove)\nusing this:\n  (d, D (inv p x)) \\<notin> I\n  u = Some d\n\ngoal (1 subgoal):\n 1. (u, Some (D (inv p x))) \\<notin> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (u, Some (D (inv p x))) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  (u, Some (D (inv p x))) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "have \"x \\<in> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range p", "using C and D"], ["proof (prove)\nusing this:\n  X \\<subseteq> range p\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> range p", ".."], ["proof (state)\nthis:\n  x \\<in> range p\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                xs \\<Longrightarrow>\n       (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  (u, Some (D (inv p x))) \\<notin> con_comp_pol I\n  x \\<in> range p", "show \"(u, ?D' x) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (u, Some (D (inv p x))) \\<notin> con_comp_pol I\n  x \\<in> range p\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> X \\<and>\n     (\\<forall>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n         (u, con_comp_map D E p q x) \\<notin> con_comp_pol I) \\<and>\n     a = inv p x\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> X;\n        \\<forall>v\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                        xs.\n           (v, con_comp_map D E p q xa) \\<notin> con_comp_pol I;\n        x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>X. x = inv p xa) \\<and>\n                         (\\<forall>v\\<in>sinks_aux I D (the ` U)\n    (map (inv p) xs).\n                             (v, D x) \\<notin> I)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> X;\n        \\<forall>v\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                        xs.\n           (v, con_comp_map D E p q xa) \\<notin> con_comp_pol I;\n        x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>X. x = inv p xa) \\<and>\n                         (\\<forall>v\\<in>sinks_aux I D (the ` U)\n    (map (inv p) xs).\n                             (v, D x) \\<notin> I)", "fix a x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> X;\n        \\<forall>v\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                        xs.\n           (v, con_comp_map D E p q xa) \\<notin> con_comp_pol I;\n        x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>X. x = inv p xa) \\<and>\n                         (\\<forall>v\\<in>sinks_aux I D (the ` U)\n    (map (inv p) xs).\n                             (v, D x) \\<notin> I)", "assume\n    D: \"x \\<in> X\" and\n    E: \"a = inv p x\" and\n    F: \"\\<forall>u \\<in> sinks_aux ?I' ?D' U xs. (u, ?D' x) \\<notin> ?I'\""], ["proof (state)\nthis:\n  x \\<in> X\n  a = inv p x\n  \\<forall>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> X;\n        \\<forall>v\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                        xs.\n           (v, con_comp_map D E p q xa) \\<notin> con_comp_pol I;\n        x = inv p xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa\\<in>X. x = inv p xa) \\<and>\n                         (\\<forall>v\\<in>sinks_aux I D (the ` U)\n    (map (inv p) xs).\n                             (v, D x) \\<notin> I)", "show \"(\\<exists>x \\<in> X. a = inv p x) \\<and>\n    (\\<forall>u \\<in> sinks_aux I D (the ` U) (map (inv p) xs). (u, D a) \\<notin> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>X. a = inv p x) \\<and>\n    (\\<forall>u\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n        (u, D a) \\<notin> I)", "proof (rule conjI, rule_tac [2] ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>X. a = inv p x\n 2. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "show \"\\<exists>x \\<in> X. a = inv p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. a = inv p x", "using E and D"], ["proof (prove)\nusing this:\n  a = inv p x\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. a = inv p x", ".."], ["proof (state)\nthis:\n  \\<exists>x\\<in>X. a = inv p x\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "assume \"d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\""], ["proof (state)\nthis:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "moreover"], ["proof (state)\nthis:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "have \"sinks_aux I D (the ` U) (map (inv p) xs) =\n      the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "using A and B"], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. sinks_aux I D (the ` U) (map (inv p) xs) =\n    the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by (rule con_comp_sinks_aux)"], ["proof (state)\nthis:\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "ultimately"], ["proof (chain)\npicking this:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "have \"d \\<in> the ` sinks_aux ?I' ?D' U xs\""], ["proof (prove)\nusing this:\n  d \\<in> sinks_aux I D (the ` U) (map (inv p) xs)\n  sinks_aux I D (the ` U) (map (inv p) xs) =\n  the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs", "by simp"], ["proof (state)\nthis:\n  d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "hence \"\\<exists>u \\<in> sinks_aux ?I' ?D' U xs. d = the u\""], ["proof (prove)\nusing this:\n  d \\<in> the ` sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n       d = the u", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u", "obtain u where G: \"u \\<in> sinks_aux ?I' ?D' U xs\" and H: \"d = the u\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     d = the u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U\n                          xs;\n         d = the u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  d = the u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "have \"(u, ?D' x) \\<notin> ?I'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "using F and G"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs.\n     (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", ".."], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "moreover"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "have \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using B"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "by blast"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p \\<union> range q", "have \"sinks_aux ?I' ?D' U xs \\<subseteq> range Some\""], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n    \\<subseteq> range Some", "by (rule con_comp_sinks_aux_range)"], ["proof (state)\nthis:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "hence \"u \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", "using G"], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n  \\<subseteq> range Some\n  u \\<in> sinks_aux (con_comp_pol I) (con_comp_map D E p q) U xs\n\ngoal (1 subgoal):\n 1. u \\<in> range Some", ".."], ["proof (state)\nthis:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "hence \"u = Some d\""], ["proof (prove)\nusing this:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. u = Some d", "using H"], ["proof (prove)\nusing this:\n  u \\<in> range Some\n  d = the u\n\ngoal (1 subgoal):\n 1. u = Some d", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  u = Some d\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "moreover"], ["proof (state)\nthis:\n  u = Some d\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "have \"x \\<in> range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range p", "using C and D"], ["proof (prove)\nusing this:\n  X \\<subseteq> range p\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> range p", ".."], ["proof (state)\nthis:\n  x \\<in> range p\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "ultimately"], ["proof (chain)\npicking this:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  u = Some d\n  x \\<in> range p", "have \"(d, D (inv p x)) \\<notin> I\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  u = Some d\n  x \\<in> range p\n\ngoal (1 subgoal):\n 1. (d, D (inv p x)) \\<notin> I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (d, D (inv p x)) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> sinks_aux I D (the ` U) (map (inv p) xs) \\<Longrightarrow>\n       (u, D a) \\<notin> I", "thus \"(d, D a) \\<notin> I\""], ["proof (prove)\nusing this:\n  (d, D (inv p x)) \\<notin> I\n\ngoal (1 subgoal):\n 1. (d, D a) \\<notin> I", "using E"], ["proof (prove)\nusing this:\n  (d, D (inv p x)) \\<notin> I\n  a = inv p x\n\ngoal (1 subgoal):\n 1. (d, D a) \\<notin> I", "by simp"], ["proof (state)\nthis:\n  (d, D a) \\<notin> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x\\<in>X. a = inv p x) \\<and>\n  (\\<forall>u\\<in>sinks_aux I D (the ` U) (map (inv p) xs).\n      (u, D a) \\<notin> I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_sinks_filter:\n \"sinks (con_comp_pol I) (con_comp_map D E p q) u\n    [x\\<leftarrow>xs. x \\<in> range p \\<union> range q] =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\"\n  (is \"sinks ?I' ?D' _ _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n       range Some \\<Longrightarrow>\n       sinks (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n       sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n       range Some", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n       range Some \\<Longrightarrow>\n       sinks (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n       sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n       range Some", "assume A: \"sinks ?I' ?D' u [x\\<leftarrow>xs. x \\<in> range p \\<union> range q] =\n    sinks ?I' ?D' u xs \\<inter> range Some\"\n    (is \"sinks _ _ _ ?xs' = _\")"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n       range Some \\<Longrightarrow>\n       sinks (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n       sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n       range Some", "show \"sinks ?I' ?D' u [x\\<leftarrow>xs @ [x]. x \\<in> range p \\<union> range q] =\n    sinks ?I' ?D' u (xs @ [x]) \\<inter> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "proof (cases \"x \\<in> range p \\<union> range q\", simp_all del: Un_iff sinks.simps,\n   cases \"(u, ?D' x) \\<in> ?I' \\<or> (\\<exists>v \\<in> sinks ?I' ?D' u ?xs'. (v, ?D' x) \\<in> ?I')\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "assume\n      B: \"x \\<in> range p \\<union> range q\" and\n      C: \"(u, ?D' x) \\<in> ?I' \\<or> (\\<exists>v \\<in> sinks ?I' ?D' u ?xs'. (v, ?D' x) \\<in> ?I')\""], ["proof (state)\nthis:\n  x \\<in> range p \\<union> range q\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n  (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     xs).\n      (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "have \"sinks ?I' ?D' u (?xs' @ [x]) =\n      insert (?D' x) (sinks ?I' ?D' u ?xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u\n       (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs))", "using C"], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n  (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     xs).\n      (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u\n       (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs))", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "also"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "have \"\\<dots> =\n      insert (?D' x) (sinks ?I' ?D' u xs \\<inter> range Some)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u\n       (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n      range Some)", "using A"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u\n       (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n      range Some)", "by simp"], ["proof (state)\nthis:\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "also"], ["proof (state)\nthis:\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "have \"\\<dots> =\n      insert (?D' x) (sinks ?I' ?D' u xs) \\<inter> insert (?D' x) (range Some)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n      range Some) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n    insert (con_comp_map D E p q x) (range Some)", "by simp"], ["proof (state)\nthis:\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n    range Some) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  insert (con_comp_map D E p q x) (range Some)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "finally"], ["proof (chain)\npicking this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  insert (con_comp_map D E p q x) (range Some)", "have \"sinks ?I' ?D' u (?xs' @ [x]) =\n      insert (?D' x) (sinks ?I' ?D' u xs) \\<inter> insert (?D' x) (range Some)\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  insert (con_comp_map D E p q x) (range Some)\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n    insert (con_comp_map D E p q x) (range Some)", "."], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  insert (con_comp_map D E p q x) (range Some)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "moreover"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  insert (con_comp_map D E p q x) (range Some)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "have \"insert (?D' x) (range Some) = range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (con_comp_map D E p q x) (range Some) = range Some", "using B"], ["proof (prove)\nusing this:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. insert (con_comp_map D E p q x) (range Some) = range Some", "by (rule_tac insert_absorb, cases \"x \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  insert (con_comp_map D E p q x) (range Some) = range Some\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "ultimately"], ["proof (chain)\npicking this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  insert (con_comp_map D E p q x) (range Some)\n  insert (con_comp_map D E p q x) (range Some) = range Some", "have \"sinks ?I' ?D' u (?xs' @ [x]) =\n      insert (?D' x) (sinks ?I' ?D' u xs) \\<inter> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  insert (con_comp_map D E p q x) (range Some)\n  insert (con_comp_map D E p q x) (range Some) = range Some\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n    range Some", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  range Some\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "moreover"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  range Some\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "have \"(u, ?D' x) \\<in> ?I' \\<or>\n      (\\<exists>v \\<in> sinks ?I' ?D' u xs. (v, ?D' x) \\<in> ?I')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n    (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I)", "using A and C"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n  (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     xs).\n      (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n    (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I)", "by (simp, blast)"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n  (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n      (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n     (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                      (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                        xs).\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "ultimately"], ["proof (chain)\npicking this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  range Some\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n  (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n      (v, con_comp_map D E p q x) \\<in> con_comp_pol I)", "show \"sinks ?I' ?D' u (?xs' @ [x]) =\n      sinks ?I' ?D' u (xs @ [x]) \\<inter> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  range Some\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n  (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n      (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n  range Some\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "assume\n      B: \"x \\<in> range p \\<union> range q\" and\n      C: \"\\<not> ((u, ?D' x) \\<in> ?I' \\<or> (\\<exists>v \\<in> sinks ?I' ?D' u ?xs'. (v, ?D' x) \\<in> ?I'))\""], ["proof (state)\nthis:\n  x \\<in> range p \\<union> range q\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           (filter\n                             (\\<lambda>x. x \\<in> range p \\<union> range q)\n                             xs).\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "have \"sinks ?I' ?D' u (?xs' @ [x]) = sinks ?I' ?D' u ?xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)", "using C"], ["proof (prove)\nusing this:\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           (filter\n                             (\\<lambda>x. x \\<in> range p \\<union> range q)\n                             xs).\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "hence \"sinks ?I' ?D' u (?xs' @ [x]) = sinks ?I' ?D' u xs \\<inter> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some", "using A"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "moreover"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "from C"], ["proof (chain)\npicking this:\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           (filter\n                             (\\<lambda>x. x \\<in> range p \\<union> range q)\n                             xs).\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))", "have\n     \"\\<not> ((u, ?D' x) \\<in> ?I' \\<or> (\\<exists>v \\<in> sinks ?I' ?D' u xs. (v, ?D' x) \\<in> ?I'))\""], ["proof (prove)\nusing this:\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           (filter\n                             (\\<lambda>x. x \\<in> range p \\<union> range q)\n                             xs).\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\n\ngoal (1 subgoal):\n 1. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x) \\<in> con_comp_pol I))", "proof (rule_tac notI, simp del: bex_simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<exists>v \\<in> sinks ?I' ?D' u xs. (v, ?D' x) \\<in> ?I'\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I", "obtain v where E: \"v \\<in> sinks ?I' ?D' u xs\" and F: \"(v, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs;\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<exists>d. ?D' x = Some d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d. con_comp_map D E p q x = Some d", "using B"], ["proof (prove)\nusing this:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<exists>d. con_comp_map D E p q x = Some d", "by (cases \"x \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  \\<exists>d. con_comp_map D E p q x = Some d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>d. con_comp_map D E p q x = Some d", "obtain d where \"?D' x = Some d\""], ["proof (prove)\nusing this:\n  \\<exists>d. con_comp_map D E p q x = Some d\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        con_comp_map D E p q x = Some d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  con_comp_map D E p q x = Some d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"(v, Some d) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = Some d\n\ngoal (1 subgoal):\n 1. (v, Some d) \\<in> con_comp_pol I", "using F"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = Some d\n  (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (v, Some d) \\<in> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (v, Some d) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"v \\<in> range Some\""], ["proof (prove)\nusing this:\n  (v, Some d) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", "by (cases v, simp_all add: con_comp_pol_def)"], ["proof (state)\nthis:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "with E"], ["proof (chain)\npicking this:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  v \\<in> range Some", "have \"v \\<in> sinks ?I' ?D' u xs \\<inter> range Some\""], ["proof (prove)\nusing this:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n            range Some", ".."], ["proof (state)\nthis:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n          range Some\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"v \\<in> sinks ?I' ?D' u ?xs'\""], ["proof (prove)\nusing this:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n          range Some\n\ngoal (1 subgoal):\n 1. v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n             (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)", "using A"], ["proof (prove)\nusing this:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n          range Some\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n             (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)", "by simp"], ["proof (state)\nthis:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "with F"], ["proof (chain)\npicking this:\n  (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)", "have \"\\<exists>v \\<in> sinks ?I' ?D' u ?xs'. (v, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                    (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                      xs).\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                  (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                    xs).\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n             \\<not> (\\<exists>v\\<in>sinks (con_comp_pol I)\n                                     (con_comp_map D E p q) u\n                                     (filter\n (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) xs).\n                        (v, con_comp_map D E p q x) \\<in> con_comp_pol I);\n     \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                  (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                    xs).\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                  (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                    xs).\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           (filter\n                             (\\<lambda>x. x \\<in> range p \\<union> range q)\n                             xs).\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           xs.\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n             (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                              (filter\n                                (\\<lambda>x.\n                                    x \\<in> range p \\<union> range q)\n                                xs).\n                 (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      sinks (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x]) \\<inter>\n                      range Some\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "ultimately"], ["proof (chain)\npicking this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           xs.\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))", "show \"sinks ?I' ?D' u (?xs' @ [x]) =\n      sinks ?I' ?D' u (xs @ [x]) \\<inter> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           xs.\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n  range Some\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "assume B: \"x \\<notin> range p \\<union> range q\""], ["proof (state)\nthis:\n  x \\<notin> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "hence \"(u, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  x \\<notin> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "hence \"sinks ?I' ?D' u (xs @ [x]) = insert (?D' x) (sinks ?I' ?D' u xs)\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "moreover"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "have \"insert (?D' x) (sinks ?I' ?D' u xs) \\<inter> range Some =\n      sinks ?I' ?D' u xs \\<inter> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n    range Some =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some", "using B"], ["proof (prove)\nusing this:\n  x \\<notin> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n    range Some =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some", "by simp"], ["proof (state)\nthis:\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  range Some =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "ultimately"], ["proof (chain)\npicking this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  range Some =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some", "have \"sinks ?I' ?D' u (xs @ [x]) \\<inter> range Some =\n      sinks ?I' ?D' u xs \\<inter> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs) \\<inter>\n  range Some =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n  range Some =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "thus \"sinks ?I' ?D' u ?xs' = sinks ?I' ?D' u (xs @ [x]) \\<inter> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n  range Some =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "using A"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n  range Some =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter> range Some\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n    range Some", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n  range Some\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) \\<inter>\n  range Some\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_ipurge_tr_filter:\n \"ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n    [x\\<leftarrow>xs. x \\<in> range p \\<union> range q] =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\"\n  (is \"ipurge_tr ?I' ?D' _ _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        xs \\<Longrightarrow>\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        xs \\<Longrightarrow>\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "assume A: \"ipurge_tr ?I' ?D' u [x\\<leftarrow>xs. x \\<in> range p \\<union> range q] =\n    ipurge_tr ?I' ?D' u xs\"\n    (is \"ipurge_tr _ _ _ ?xs' = _\")"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        xs \\<Longrightarrow>\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "show \"ipurge_tr ?I' ?D' u [x\\<leftarrow>xs @ [x]. x \\<in> range p \\<union> range q] =\n    ipurge_tr ?I' ?D' u (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "proof (cases \"x \\<in> range p \\<union> range q\", simp_all del: Un_iff ipurge_tr.simps,\n   cases \"?D' x \\<in> sinks ?I' ?D' u (?xs' @ [x])\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n             [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "assume\n      B: \"x \\<in> range p \\<union> range q\" and\n      C: \"?D' x \\<in> sinks ?I' ?D' u (?xs' @ [x])\""], ["proof (state)\nthis:\n  x \\<in> range p \\<union> range q\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n         (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n             [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "have \"ipurge_tr ?I' ?D' u (?xs' @ [x]) = ipurge_tr ?I' ?D' u ?xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)", "using C"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n         (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n             [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"ipurge_tr ?I' ?D' u (?xs' @ [x]) = ipurge_tr ?I' ?D' u xs\""], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs)\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n             [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n             [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "have \"?D' x \\<in> sinks ?I' ?D' u [x\\<leftarrow>xs @ [x]. x \\<in> range p \\<union> range q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n             (xs @ [x]))", "using B and C"], ["proof (prove)\nusing this:\n  x \\<in> range p \\<union> range q\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n         (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x])\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n             (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n         (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x]))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n             [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"?D' x \\<in> sinks ?I' ?D' u (xs @ [x])\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n         (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x]))\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by (simp only: con_comp_sinks_filter, blast)"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n             [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 3. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "show \"ipurge_tr ?I' ?D' u (?xs' @ [x]) =\n      ipurge_tr ?I' ?D' u (xs @ [x])\""], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "assume\n      B: \"x \\<in> range p \\<union> range q\" and\n      C: \"\\<not> (?D' x \\<in> sinks ?I' ?D' u (?xs' @ [x]))\""], ["proof (state)\nthis:\n  x \\<in> range p \\<union> range q\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "have \"ipurge_tr ?I' ?D' u (?xs' @ [x]) = ipurge_tr ?I' ?D' u ?xs' @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) @\n    [x]", "using C"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) @\n    [x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) @\n  [x]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"ipurge_tr ?I' ?D' u (?xs' @ [x]) = ipurge_tr ?I' ?D' u xs @ [x]\""], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) @\n  [x]\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) @\n  [x]\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "have \"?D' x \\<notin> sinks ?I' ?D' u [x\\<leftarrow>xs @ [x]. x \\<in> range p \\<union> range q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                (xs @ [x]))", "using B and C"], ["proof (prove)\nusing this:\n  x \\<in> range p \\<union> range q\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x])\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n              (xs @ [x]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"?D' x \\<notin> sinks ?I' ?D' u (xs @ [x]) \\<inter> range Some\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n              (xs @ [x]))\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<inter>\n             range Some", "by (simp only: con_comp_sinks_filter, simp)"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (xs @ [x]) \\<inter>\n           range Some\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"?D' x \\<notin> sinks ?I' ?D' u (xs @ [x])\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (xs @ [x]) \\<inter>\n           range Some\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "using B"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n            (xs @ [x]) \\<inter>\n           range Some\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by (cases \"x \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> range p \\<union> range q;\n     con_comp_map D E p q x\n     \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n               (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                [x])\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (filter\n                         (\\<lambda>x. x \\<in> range p \\<union> range q) xs @\n                        [x]) =\n                      ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n                       (xs @ [x])\n 2. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "show \"ipurge_tr ?I' ?D' u (?xs' @ [x]) =\n      ipurge_tr ?I' ?D' u (xs @ [x])\""], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "assume \"x \\<notin> range p \\<union> range q\""], ["proof (state)\nthis:\n  x \\<notin> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"(u, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  x \\<notin> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"?D' x \\<in> sinks ?I' ?D' u (xs @ [x])\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. x \\<notin> range p \\<union> range q \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "thus \"ipurge_tr ?I' ?D' u ?xs' = ipurge_tr ?I' ?D' u (xs @ [x])\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "using A"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) (xs @ [x])) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_ipurge_ref_filter:\n \"ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u\n    [x\\<leftarrow>xs. x \\<in> range p \\<union> range q] X =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u xs X\"\n  (is \"ipurge_ref ?I' ?D' _ _ _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u\n     (filter (\\<lambda>x. x \\<in> range p \\<union> range q) xs) X =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u xs X", "proof (simp add: ipurge_ref_def con_comp_sinks_filter set_eq_iff del: Un_iff,\n rule allI, rule iffI, simp_all, (erule conjE)+, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                        xs \\<inter>\n                       range Some.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "fix x v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                        xs \\<inter>\n                       range Some.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "assume\n    A: \"(u, ?D' x) \\<notin> ?I'\" and\n    B: \"\\<forall>v \\<in> sinks ?I' ?D' u xs \\<inter> range Some. (v, ?D' x) \\<notin> ?I'\" and\n    C: \"v \\<in> sinks ?I' ?D' u xs\""], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n                 range Some.\n     (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. \\<And>x v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                        xs \\<inter>\n                       range Some.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "show \"(v, ?D' x) \\<notin> ?I'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "proof (cases v, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. v = None \\<Longrightarrow>\n    (None, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 2. \\<And>a.\n       v = Some a \\<Longrightarrow>\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "have \"?D' x \\<in> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. con_comp_map D E p q x \\<in> range Some", "using A"], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x \\<in> range Some", "by (cases \"?D' x\", simp_all add: con_comp_pol_def)"], ["proof (state)\nthis:\n  con_comp_map D E p q x \\<in> range Some\n\ngoal (2 subgoals):\n 1. v = None \\<Longrightarrow>\n    (None, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 2. \\<And>a.\n       v = Some a \\<Longrightarrow>\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "thus \"(None, ?D' x) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x \\<in> range Some\n\ngoal (1 subgoal):\n 1. (None, con_comp_map D E p q x) \\<notin> con_comp_pol I", "by (simp add: image_iff con_comp_pol_def)"], ["proof (state)\nthis:\n  (None, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       v = Some a \\<Longrightarrow>\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       v = Some a \\<Longrightarrow>\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       v = Some a \\<Longrightarrow>\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "assume \"v = Some d\""], ["proof (state)\nthis:\n  v = Some d\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       v = Some a \\<Longrightarrow>\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"v \\<in> range Some\""], ["proof (prove)\nusing this:\n  v = Some d\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", "by simp"], ["proof (state)\nthis:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       v = Some a \\<Longrightarrow>\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "with C"], ["proof (chain)\npicking this:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  v \\<in> range Some", "have \"v \\<in> sinks ?I' ?D' u xs \\<inter> range Some\""], ["proof (prove)\nusing this:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n            range Some", ".."], ["proof (state)\nthis:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n          range Some\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       v = Some a \\<Longrightarrow>\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "with B"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n                 range Some.\n     (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n          range Some", "show \"(v, ?D' x) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n                 range Some.\n     (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<inter>\n          range Some\n\ngoal (1 subgoal):\n 1. (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", ".."], ["proof (state)\nthis:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_secure_aux [rule_format]:\n  assumes\n    A: \"secure P I D\" and\n    B: \"Y \\<subseteq> range p\"\n  shows \"set ys \\<subseteq> range p \\<union> range q \\<longrightarrow> U \\<subseteq> range Some \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs @ ys. x \\<in> range p], inv p ` Y) \\<in> failures P \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n     map (inv p) (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) U ys),\n     inv p ` ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) U ys Y) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n    U \\<subseteq> range Some \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n     inv p ` Y)\n    \\<in> failures P \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) U ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) U ys Y)\n    \\<in> failures P", "proof (induction ys arbitrary: xs U, (rule_tac [!] impI)+, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs U.\n       \\<lbrakk>U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          inv p `\n                          ipurge_ref_aux (con_comp_pol I)\n                           (con_comp_map D E p q) U [] Y)\n                         \\<in> failures P\n 2. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "fix xs U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs U.\n       \\<lbrakk>U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          inv p `\n                          ipurge_ref_aux (con_comp_pol I)\n                           (con_comp_map D E p q) U [] Y)\n                         \\<in> failures P\n 2. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "assume \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` Y) \\<in> failures P\""], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>xs U.\n       \\<lbrakk>U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          inv p `\n                          ipurge_ref_aux (con_comp_pol I)\n                           (con_comp_map D E p q) U [] Y)\n                         \\<in> failures P\n 2. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n  \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>xs U.\n       \\<lbrakk>U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          inv p `\n                          ipurge_ref_aux (con_comp_pol I)\n                           (con_comp_map D E p q) U [] Y)\n                         \\<in> failures P\n 2. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "have\n   \"ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y \\<subseteq> Y\"\n    (is \"?Y' \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y\n    \\<subseteq> Y", "by (rule ipurge_ref_aux_subset)"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y\n  \\<subseteq> Y\n\ngoal (2 subgoals):\n 1. \\<And>xs U.\n       \\<lbrakk>U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          inv p `\n                          ipurge_ref_aux (con_comp_pol I)\n                           (con_comp_map D E p q) U [] Y)\n                         \\<in> failures P\n 2. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "hence \"inv p ` ?Y' \\<subseteq> inv p ` Y\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y\n  \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y\n    \\<subseteq> inv p ` Y", "by (rule image_mono)"], ["proof (state)\nthis:\n  inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y\n  \\<subseteq> inv p ` Y\n\ngoal (2 subgoals):\n 1. \\<And>xs U.\n       \\<lbrakk>U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs),\n                          inv p `\n                          ipurge_ref_aux (con_comp_pol I)\n                           (con_comp_map D E p q) U [] Y)\n                         \\<in> failures P\n 2. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n  \\<in> failures P\n  inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y\n  \\<subseteq> inv p ` Y", "show \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p], inv p ` ?Y') \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs), inv p ` Y)\n  \\<in> failures P\n  inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y\n  \\<subseteq> inv p ` Y\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n     inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y)\n    \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs),\n   inv p ` ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U [] Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "fix y ys xs U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "assume \"\\<And>xs U. set ys \\<subseteq> range p \\<union> range q \\<longrightarrow> U \\<subseteq> range Some \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs @ ys. x \\<in> range p], inv p ` Y) \\<in> failures P \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n     map (inv p) (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) U ys),\n     inv p ` ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) U ys Y) \\<in> failures P\""], ["proof (state)\nthis:\n  set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n  ?U \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (?xs @ ys)), inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ?xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) ?U ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) ?U ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "hence \"set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n    sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y] \\<subseteq> range Some \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>(xs @ [y]) @ ys. x \\<in> range p], inv p ` Y) \\<in> failures P \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] @\n     map (inv p) (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) (sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n         U [y]) ys),\n     inv p ` ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) (sinks_aux (con_comp_pol I) (con_comp_map D E p q)\n         U [y]) ys Y) \\<in> failures P\"\n    (is \"_ \\<longrightarrow> _ \\<longrightarrow> _ \\<longrightarrow>\n      (_ @ map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F ?U' _), _) \\<in> _\")"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n  ?U \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (?xs @ ys)), inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ?xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) ?U ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) ?U ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n    sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n    \\<subseteq> range Some \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n     inv p ` Y)\n    \\<in> failures P \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n    \\<in> failures P", "."], ["proof (state)\nthis:\n  set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "assume C: \"set (y # ys) \\<subseteq> range p \\<union> range q\""], ["proof (state)\nthis:\n  set (y # ys) \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "hence \"set ys \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set (y # ys) \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  set ys \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n  set ys \\<subseteq> range p \\<union> range q", "have \"?U' \\<subseteq> range Some \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>(xs @ [y]) @ ys. x \\<in> range p], inv p ` Y) \\<in> failures P \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] @\n     map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys),\n     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) \\<in> failures P\""], ["proof (prove)\nusing this:\n  set ys \\<subseteq> range p \\<union> range q \\<longrightarrow>\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n  set ys \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n    \\<subseteq> range Some \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n     inv p ` Y)\n    \\<in> failures P \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "assume D: \"U \\<subseteq> range Some\""], ["proof (state)\nthis:\n  U \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "hence \"?U' \\<subseteq> range Some\""], ["proof (prove)\nusing this:\n  U \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n    \\<subseteq> range Some", "proof (cases \"\\<exists>u \\<in> U. (u, ?D' y) \\<in> ?I'\", simp_all add: sinks_aux_single_event)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>u\\<in>U.\n                (u, con_comp_map D E p q y) \\<in> con_comp_pol I;\n     U \\<subseteq> range Some\\<rbrakk>\n    \\<Longrightarrow> con_comp_map D E p q y \\<in> range Some", "have \"y \\<in> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> range p \\<union> range q", "using C"], ["proof (prove)\nusing this:\n  set (y # ys) \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. y \\<in> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  y \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>u\\<in>U.\n                (u, con_comp_map D E p q y) \\<in> con_comp_pol I;\n     U \\<subseteq> range Some\\<rbrakk>\n    \\<Longrightarrow> con_comp_map D E p q y \\<in> range Some", "thus \"?D' y \\<in> range Some\""], ["proof (prove)\nusing this:\n  y \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q y \\<in> range Some", "by (cases \"y \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  con_comp_map D E p q y \\<in> range Some\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some", "have\n   \"(map (inv p) [x\\<leftarrow>(xs @ [y]) @ ys. x \\<in> range p], inv p ` Y) \\<in> failures P \\<longrightarrow>\n    (map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] @\n     map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys),\n     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) \\<in> failures P\""], ["proof (prove)\nusing this:\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n  sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n     inv p ` Y)\n    \\<in> failures P \\<longrightarrow>\n    (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "assume\n   \"(map (inv p) [x\\<leftarrow>xs @ y # ys. x \\<in> range p], inv p ` Y) \\<in> failures P\""], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n   inv p ` Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n   inv p ` Y)\n  \\<in> failures P", "have\n   \"(map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] @\n     map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys),\n     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P \\<longrightarrow>\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n   inv p ` Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "hence\n   \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n     map (inv p) ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys),\n     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n    \\<in> failures P", "by (cases \"y \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    ((if y \\<in> range p then [y] else []) @\n     ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "with A"], ["proof (chain)\npicking this:\n  secure P I D\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    ((if y \\<in> range p then [y] else []) @\n     ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P", "have\n   \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n     ipurge_tr_aux I D (the ` U) (map (inv p) ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys)),\n     ipurge_ref_aux I D (the ` U) (map (inv p) ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys))\n     (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y)) \\<in> failures P\""], ["proof (prove)\nusing this:\n  secure P I D\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    ((if y \\<in> range p then [y] else []) @\n     ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p)\n    (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     ipurge_tr_aux I D (the ` U)\n      (map (inv p)\n        ((if y \\<in> range p then [y] else []) @\n         ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p)\n          (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)),\n     ipurge_ref_aux I D (the ` U)\n      (map (inv p)\n        ((if y \\<in> range p then [y] else []) @\n         ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p)\n          (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n      (inv p `\n       ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y))\n    \\<in> failures P", "by (rule ipurge_tr_ref_aux_failures_general)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   ipurge_tr_aux I D (the ` U)\n    (map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)),\n   ipurge_ref_aux I D (the ` U)\n    (map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y))\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   ipurge_tr_aux I D (the ` U)\n    (map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)),\n   ipurge_ref_aux I D (the ` U)\n    (map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y))\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "have\n   \"ipurge_tr_aux I D (the ` U) (map (inv p) ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys)) =\n    map (inv p) (ipurge_tr_aux ?I' ?D' U ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` U)\n     (map (inv p)\n       ((if y \\<in> range p then [y] else []) @\n        ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p)\n         (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n       ((if y \\<in> range p then [y] else []) @\n        ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p)\n         (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))", "by (rule con_comp_ipurge_tr_aux, simp_all add:\n    D ipurge_tr_aux_foldr_eq [symmetric], blast)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U)\n   (map (inv p)\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` U)\n   (map (inv p)\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "have\n   \"ipurge_ref_aux I D (the ` U) (map (inv p) ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys))\n      (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y) =\n    inv p ` ipurge_ref_aux ?I' ?D' U ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr ?I' ?D' ?F ?U' ys)\n      (ipurge_ref_aux_foldr ?I' ?D' ?F ?U' ys Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (the ` U)\n     (map (inv p)\n       ((if y \\<in> range p then [y] else []) @\n        ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p)\n         (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n     (inv p `\n      ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y) =\n    inv p `\n    ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)\n     (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)", "proof (rule con_comp_ipurge_ref_aux, simp_all add:\n   D ipurge_tr_aux_foldr_eq [symmetric] ipurge_ref_aux_foldr_eq [symmetric], blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n    \\<subseteq> range p", "have \"ipurge_ref_aux ?I' ?D' ?U' ys Y \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n    \\<subseteq> Y", "by (rule ipurge_ref_aux_subset)"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n  \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n    \\<subseteq> range p", "thus \"ipurge_ref_aux ?I' ?D' ?U' ys Y \\<subseteq> range p\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n  \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n    \\<subseteq> range p", "using B"], ["proof (prove)\nusing this:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n  \\<subseteq> Y\n  Y \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n    \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y\n  \\<subseteq> range p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (the ` U)\n   (map (inv p)\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U\n   ((if y \\<in> range p then [y] else []) @\n    ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs U.\n       \\<lbrakk>\\<And>xs U.\n                   set ys\n                   \\<subseteq> range p \\<union> range q \\<longrightarrow>\n                   U \\<subseteq> range Some \\<longrightarrow>\n                   (map (inv p)\n                     (filter (\\<lambda>x. x \\<in> range p) (xs @ ys)),\n                    inv p ` Y)\n                   \\<in> failures P \\<longrightarrow>\n                   (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n                    map (inv p)\n                     (ipurge_tr_aux_foldr (con_comp_pol I)\n                       (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                       U ys),\n                    inv p `\n                    ipurge_ref_aux_foldr (con_comp_pol I)\n                     (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p) U\n                     ys Y)\n                   \\<in> failures P;\n        set (a # ys) \\<subseteq> range p \\<union> range q;\n        U \\<subseteq> range Some;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ a # ys)),\n         inv p ` Y)\n        \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xs) @\n                          map (inv p)\n                           (ipurge_tr_aux_foldr (con_comp_pol I)\n                             (con_comp_map D E p q)\n                             (\\<lambda>x. x \\<in> range p) U (a # ys)),\n                          inv p `\n                          ipurge_ref_aux_foldr (con_comp_pol I)\n                           (con_comp_map D E p q)\n                           (\\<lambda>x. x \\<in> range p) U (a # ys) Y)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   ipurge_tr_aux I D (the ` U)\n    (map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)),\n   ipurge_ref_aux I D (the ` U)\n    (map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y))\n  \\<in> failures P\n  ipurge_tr_aux I D (the ` U)\n   (map (inv p)\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n  ipurge_ref_aux I D (the ` U)\n   (map (inv p)\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U\n   ((if y \\<in> range p then [y] else []) @\n    ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)", "show\n   \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n     map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F U (y # ys)),\n     inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F U (y # ys) Y) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   ipurge_tr_aux I D (the ` U)\n    (map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)),\n   ipurge_ref_aux I D (the ` U)\n    (map (inv p)\n      ((if y \\<in> range p then [y] else []) @\n       ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p)\n        (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p)\n      (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y))\n  \\<in> failures P\n  ipurge_tr_aux I D (the ` U)\n   (map (inv p)\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) U\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n  ipurge_ref_aux I D (the ` U)\n   (map (inv p)\n     ((if y \\<in> range p then [y] else []) @\n      ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p)\n       (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q) U\n   ((if y \\<in> range p then [y] else []) @\n    ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p)\n     (sinks_aux (con_comp_pol I) (con_comp_map D E p q) U [y]) ys Y)\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) U (y # ys)),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) U (y # ys) Y)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) U (y # ys)),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) U (y # ys) Y)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Conservation of noninterference security under concurrent composition\""], ["", "text \\<open>\nEverything is now ready for proving the target security conservation theorem. It states that for any\ntwo processes @{term P}, @{term Q} being secure with respect to the noninterference policy @{term I}\nand the event-domain maps @{term D}, @{term E}, their concurrent composition @{term \"P \\<parallel> Q <p, q>\"}\nis secure with respect to the noninterference policy @{term \"con_comp_pol I\"} and the event-domain\nmap @{term \"con_comp_map D E p q\"}, provided that condition @{term \"consistent_maps D E p q\"} is\nsatisfied.\n\nThe only assumption, in addition to the security of the input processes, is the consistency of the\nrespective event-domain maps. Particularly, this assumption permits to solve the proof obligations\nconcerning the latter input process by just swapping @{term D} for @{term E} and @{term p} for\n@{term q} in the term @{term \"con_comp_map D E p q\"} and then applying the corresponding lemmas\nproven for the former input process.\n\n\\null\n\\<close>"], ["", "lemma con_comp_secure_del_aux_1:\n  assumes\n    A: \"secure P I D\" and\n    B: \"y \\<in> range p \\<or> y \\<in> range q\" and\n    C: \"set ys \\<subseteq> range p \\<union> range q\" and\n    D: \"Y \\<subseteq> range p\" and\n    E: \"(map (inv p) [x\\<leftarrow>xs @ y # ys. x \\<in> range p], inv p ` Y) \\<in> failures P\"\n  shows\n   \"(map (inv p) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys. x \\<in> range p],\n     inv p ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys Y) \\<in> failures P\"\n    (is \"(map (inv p) [x\\<leftarrow>xs @ ipurge_tr ?I' ?D' _ _. _], _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys Y)\n    \\<in> failures P", "proof (simp add:\n ipurge_tr_aux_single_dom [symmetric] ipurge_ref_aux_single_dom [symmetric]\n ipurge_tr_aux_foldr_eq ipurge_ref_aux_foldr_eq [where P = \"\\<lambda>x. x \\<in> range p\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys Y)\n    \\<in> failures P", "have \"(map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] @\n    map (inv p) (ipurge_tr_aux_foldr ?I' ?D' (\\<lambda>x. x \\<in> range p) {?D' y} ys),\n    inv p ` ipurge_ref_aux_foldr ?I' ?D' (\\<lambda>x. x \\<in> range p) {?D' y} ys Y)\n      \\<in> failures P\"\n    (is \"(_ @ map (inv p) (ipurge_tr_aux_foldr _ _ ?F _ _), _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys Y)\n    \\<in> failures P", "proof (rule con_comp_secure_aux [OF A D C])"], ["proof (state)\ngoal (2 subgoals):\n 1. {con_comp_map D E p q y} \\<subseteq> range Some\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n     inv p ` Y)\n    \\<in> failures P", "show \"{?D' y} \\<subseteq> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {con_comp_map D E p q y} \\<subseteq> range Some", "using B"], ["proof (prove)\nusing this:\n  y \\<in> range p \\<or> y \\<in> range q\n\ngoal (1 subgoal):\n 1. {con_comp_map D E p q y} \\<subseteq> range Some", "by (cases \"y \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  {con_comp_map D E p q y} \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n     inv p ` Y)\n    \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n     inv p ` Y)\n    \\<in> failures P", "show \"(map (inv p) [x\\<leftarrow>(xs @ [y]) @ ys. x \\<in> range p], inv p ` Y) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n     inv p ` Y)\n    \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n   inv p ` Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n     inv p ` Y)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys)),\n   inv p ` Y)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys Y)\n    \\<in> failures P", "thus \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n    map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {?D' y} ys),\n    inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {?D' y} ys Y)\n      \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys Y)\n    \\<in> failures P", "proof (cases \"y \\<in> range p\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "assume \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ inv p y #\n      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys),\n      inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)\n      \\<in> failures P\""], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   inv p y #\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "hence \"(inv p y #\n      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys),\n      inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)\n      \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   inv p y #\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (inv p y #\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "hence\n     \"(ipurge_tr I D (D (inv p y))\n         (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)),\n       ipurge_ref I D (D (inv p y))\n         (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys))\n         (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y))\n      \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. (ipurge_tr I D (D (inv p y))\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n     ipurge_ref I D (D (inv p y))\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n      (inv p `\n       ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "using A"], ["proof (prove)\nusing this:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  secure P I D\n\ngoal (1 subgoal):\n 1. (ipurge_tr I D (D (inv p y))\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n     ipurge_ref I D (D (inv p y))\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n      (inv p `\n       ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  (ipurge_tr I D (D (inv p y))\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   ipurge_ref I D (D (inv p y))\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "hence\n     \"(ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n         (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)),\n       ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n         (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys))\n         (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y))\n      \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (ipurge_tr I D (D (inv p y))\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   ipurge_ref I D (D (inv p y))\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. (ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n     ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n      (inv p `\n       ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by (simp add: ipurge_tr_aux_single_dom ipurge_ref_aux_single_dom)"], ["proof (state)\nthis:\n  (ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "have\n     \"ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n        (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)) =\n      map (inv p) (ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}\n        (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n     (map (inv p)\n       (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n       {Some (D (inv p y))}\n       (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))", "by (rule con_comp_ipurge_tr_aux, simp_all add:\n      ipurge_tr_aux_foldr_eq [symmetric], blast)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "have\n     \"ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n        (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys))\n        (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y) =\n      inv p ` ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}\n        (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)\n        (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n     (map (inv p)\n       (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n     (inv p `\n      ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y) =\n    inv p `\n    ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n     (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)", "proof (rule con_comp_ipurge_ref_aux, simp_all add:\n     ipurge_tr_aux_foldr_eq [symmetric] ipurge_ref_aux_foldr_eq [symmetric], blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} ys Y\n    \\<subseteq> range p", "have \"ipurge_ref_aux ?I' ?D' {Some (D (inv p y))} ys Y \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} ys Y\n    \\<subseteq> Y", "by (rule ipurge_ref_aux_subset)"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))} ys Y\n  \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} ys Y\n    \\<subseteq> range p", "thus \"ipurge_ref_aux ?I' ?D' {Some (D (inv p y))} ys Y \\<subseteq> range p\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))} ys Y\n  \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} ys Y\n    \\<subseteq> range p", "using D"], ["proof (prove)\nusing this:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))} ys Y\n  \\<subseteq> Y\n  Y \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} ys Y\n    \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))} ys Y\n  \\<subseteq> range p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n  ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)", "have\n     \"(map (inv p) (ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}\n         (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)),\n       inv p ` ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}\n         (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)\n         (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y))\n      \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n  ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n\ngoal (1 subgoal):\n 1. (map (inv p)\n      (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n        {Some (D (inv p y))}\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n     inv p `\n     ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n      (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by simp"], ["proof (state)\nthis:\n  (map (inv p)\n    (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   inv p `\n   ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n    {Some (D (inv p y))}\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n    (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (map (inv p)\n    (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   inv p `\n   ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n    {Some (D (inv p y))}\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n    (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "have\n     \"ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}\n        (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys) =\n      ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys) =\n    ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys", "by (rule ipurge_tr_aux_foldr_subset, simp)"], ["proof (state)\nthis:\n  ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys) =\n  ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys) =\n  ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "have\n     \"ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}\n        (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys)\n        (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y) =\n      ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n     (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y) =\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y", "by (rule ipurge_ref_aux_foldr_subset, subst ipurge_tr_aux_foldr_sinks_aux, simp)"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y) =\n  ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p)\n    (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   inv p `\n   ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n    {Some (D (inv p y))}\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n    (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys) =\n  ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y) =\n  ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y", "have\n     \"(map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys),\n       inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)\n      \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (map (inv p)\n    (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)),\n   inv p `\n   ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n    {Some (D (inv p y))}\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n    (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys) =\n  ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y) =\n  ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y\n\ngoal (1 subgoal):\n 1. (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by simp"], ["proof (state)\nthis:\n  (map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              inv p y #\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          ys),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} ys Y)\n                      \\<in> failures P", "thus \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys),\n      inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} ys Y)\n      \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n    \\<in> failures P", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} ys Y)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} ys Y)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_secure_add_aux_1:\n  assumes\n    A: \"secure P I D\" and\n    B: \"y \\<in> range p \\<or> y \\<in> range q\" and\n    C: \"set zs \\<subseteq> range p \\<union> range q\" and\n    D: \"Z \\<subseteq> range p\" and\n    E: \"(map (inv p) [x\\<leftarrow>xs @ zs. x \\<in> range p], inv p ` Z) \\<in> failures P\" and\n    F: \"map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] \\<in> traces P\"\n  shows\n   \"(map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs. x \\<in> range p],\n     inv p ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs Z) \\<in> failures P\"\n    (is \"(map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr ?I' ?D' _ _. _], _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z)\n    \\<in> failures P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z)\n    \\<in> failures P", "have\n   \"(map (inv p) [x\\<leftarrow>(xs @ [y]) @ ipurge_tr ?I' ?D' (?D' y) zs. x \\<in> range p],\n     inv p ` ipurge_ref ?I' ?D' (?D' y) zs Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        ((xs @ [y]) @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z)\n    \\<in> failures P", "proof (subst filter_append, simp del: filter_append add:\n   ipurge_tr_aux_single_dom [symmetric] ipurge_ref_aux_single_dom [symmetric]\n   ipurge_tr_aux_foldr_eq ipurge_ref_aux_foldr_eq [where P = \"\\<lambda>x. x \\<in> range p\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs Z)\n    \\<in> failures P", "have \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' (\\<lambda>x. x \\<in> range p) {?D' y} zs),\n      inv p ` ipurge_ref_aux_foldr ?I' ?D' (\\<lambda>x. x \\<in> range p) {?D' y} zs Z)\n        \\<in> failures P\"\n      (is \"(_ @ map (inv p) (ipurge_tr_aux_foldr _ _ ?F _ _), _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs Z)\n    \\<in> failures P", "proof (rule con_comp_secure_aux [OF A D C])"], ["proof (state)\ngoal (2 subgoals):\n 1. {con_comp_map D E p q y} \\<subseteq> range Some\n 2. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n     inv p ` Z)\n    \\<in> failures P", "show \"{?D' y} \\<subseteq> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {con_comp_map D E p q y} \\<subseteq> range Some", "using B"], ["proof (prove)\nusing this:\n  y \\<in> range p \\<or> y \\<in> range q\n\ngoal (1 subgoal):\n 1. {con_comp_map D E p q y} \\<subseteq> range Some", "by (cases \"y \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  {con_comp_map D E p q y} \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n     inv p ` Z)\n    \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n     inv p ` Z)\n    \\<in> failures P", "show \"(map (inv p) [x\\<leftarrow>xs @ zs. x \\<in> range p], inv p ` Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n     inv p ` Z)\n    \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)), inv p ` Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n     inv p ` Z)\n    \\<in> failures P", "."], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)), inv p ` Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs Z)\n    \\<in> failures P", "thus \"(map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] @\n      map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {?D' y} zs),\n      inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {?D' y} zs Z)\n        \\<in> failures P\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs Z)\n    \\<in> failures P", "proof (cases \"y \\<in> range p\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "case True"], ["proof (state)\nthis:\n  y \\<in> range p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "assume \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @\n        map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs),\n        inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z)\n        \\<in> failures P\""], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "hence\n       \"(map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs),\n         inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z)\n        \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "have \"(map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p], {}) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])), {})\n    \\<in> failures P", "using F"], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y]))\n  \\<in> traces P\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])), {})\n    \\<in> failures P", "by (rule traces_failures)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])), {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "hence \"([inv p y], {}) \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])), {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. ([inv p y], {})\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "using True"], ["proof (prove)\nusing this:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])), {})\n  \\<in> failures P\n  y \\<in> range p\n\ngoal (1 subgoal):\n 1. ([inv p y], {})\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  ([inv p y], {})\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ([inv p y], {})\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "have\n       \"(inv p y # ipurge_tr I D (D (inv p y))\n           (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)),\n         ipurge_ref I D (D (inv p y))\n           (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs))\n           (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z))\n        \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ([inv p y], {})\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. (inv p y #\n     ipurge_tr I D (D (inv p y))\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n     ipurge_ref I D (D (inv p y))\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n      (inv p `\n       ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "using A"], ["proof (prove)\nusing this:\n  (map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ([inv p y], {})\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  secure P I D\n\ngoal (1 subgoal):\n 1. (inv p y #\n     ipurge_tr I D (D (inv p y))\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n     ipurge_ref I D (D (inv p y))\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n      (inv p `\n       ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  (inv p y #\n   ipurge_tr I D (D (inv p y))\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   ipurge_ref I D (D (inv p y))\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "hence\n       \"(inv p y # ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n           (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)),\n         ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n           (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs))\n           (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z))\n        \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (inv p y #\n   ipurge_tr I D (D (inv p y))\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   ipurge_ref I D (D (inv p y))\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. (inv p y #\n     ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n     ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n      (map (inv p)\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n      (inv p `\n       ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by (simp add: ipurge_tr_aux_single_dom ipurge_ref_aux_single_dom)"], ["proof (state)\nthis:\n  (inv p y #\n   ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (inv p y #\n   ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "have\n       \"ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n          (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)) =\n        map (inv p) (ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}\n          (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n     (map (inv p)\n       (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)) =\n    map (inv p)\n     (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n       {Some (D (inv p y))}\n       (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))", "by (rule con_comp_ipurge_tr_aux, simp_all add:\n        ipurge_tr_aux_foldr_eq [symmetric], blast)"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "have\n       \"ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n          (map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs))\n          (inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z) =\n        inv p ` ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}\n          (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)\n          (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n     (map (inv p)\n       (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n         (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n     (inv p `\n      ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z) =\n    inv p `\n    ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n     (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)", "proof (rule con_comp_ipurge_ref_aux, simp_all add:\n       ipurge_tr_aux_foldr_eq [symmetric] ipurge_ref_aux_foldr_eq [symmetric], blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} zs Z\n    \\<subseteq> range p", "have \"ipurge_ref_aux ?I' ?D' {Some (D (inv p y))} zs Z \\<subseteq> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} zs Z\n    \\<subseteq> Z", "by (rule ipurge_ref_aux_subset)"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))} zs Z\n  \\<subseteq> Z\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} zs Z\n    \\<subseteq> range p", "thus \"ipurge_ref_aux ?I' ?D' {Some (D (inv p y))} zs Z \\<subseteq> range p\""], ["proof (prove)\nusing this:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))} zs Z\n  \\<subseteq> Z\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} zs Z\n    \\<subseteq> range p", "using D"], ["proof (prove)\nusing this:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))} zs Z\n  \\<subseteq> Z\n  Z \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))} zs Z\n    \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))} zs Z\n  \\<subseteq> range p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (inv p y #\n   ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n  ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)", "have\n       \"(inv p y # map (inv p) (ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}\n           (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)),\n         inv p ` ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}\n           (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)\n           (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z))\n        \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (inv p y #\n   ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n    (map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n    (inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ipurge_tr_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)) =\n  map (inv p)\n   (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n  ipurge_ref_aux I D (the ` {Some (D (inv p y))})\n   (map (inv p)\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs))\n   (inv p `\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z) =\n  inv p `\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n\ngoal (1 subgoal):\n 1. (inv p y #\n     map (inv p)\n      (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n        {Some (D (inv p y))}\n        (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n     inv p `\n     ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n      (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by simp"], ["proof (state)\nthis:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   inv p `\n   ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n    {Some (D (inv p y))}\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n    (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   inv p `\n   ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n    {Some (D (inv p y))}\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n    (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "have\n       \"ipurge_tr_aux ?I' ?D' {Some (D (inv p y))}\n          (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs) =\n        ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs) =\n    ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs", "by (rule ipurge_tr_aux_foldr_subset, simp)"], ["proof (state)\nthis:\n  ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs) =\n  ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs) =\n  ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "have\n       \"ipurge_ref_aux ?I' ?D' {Some (D (inv p y))}\n          (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs)\n          (ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z) =\n        ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n     {Some (D (inv p y))}\n     (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n     (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n       (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z) =\n    ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z", "by (rule ipurge_ref_aux_foldr_subset, subst ipurge_tr_aux_foldr_sinks_aux, simp)"], ["proof (state)\nthis:\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z) =\n  ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   inv p `\n   ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n    {Some (D (inv p y))}\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n    (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs) =\n  ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z) =\n  ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z", "have\n       \"(inv p y # map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F\n           {Some (D (inv p y))} zs),\n         inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F\n           {Some (D (inv p y))} zs Z)\n        \\<in> futures P (map (inv p) [x\\<leftarrow>xs. x \\<in> range p])\""], ["proof (prove)\nusing this:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q)\n      {Some (D (inv p y))}\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)),\n   inv p `\n   ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n    {Some (D (inv p y))}\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n    (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z))\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n  ipurge_tr_aux (con_comp_pol I) (con_comp_map D E p q) {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs) =\n  ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs\n  ipurge_ref_aux (con_comp_pol I) (con_comp_map D E p q)\n   {Some (D (inv p y))}\n   (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs)\n   (ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n     (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z) =\n  ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n   (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z\n\ngoal (1 subgoal):\n 1. (inv p y #\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n    \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))", "by simp"], ["proof (state)\nthis:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n              map (inv p)\n               (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n                 (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n              inv p `\n              ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n               (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n             \\<in> failures P;\n     y \\<in> range p\\<rbrakk>\n    \\<Longrightarrow> (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p) xs) @\n                       inv p y #\n                       map (inv p)\n                        (ipurge_tr_aux_foldr (con_comp_pol I)\n                          (con_comp_map D E p q)\n                          (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))}\n                          zs),\n                       inv p `\n                       ipurge_ref_aux_foldr (con_comp_pol I)\n                        (con_comp_map D E p q) (\\<lambda>x. x \\<in> range p)\n                        {Some (D (inv p y))} zs Z)\n                      \\<in> failures P", "thus \"(map (inv p) [x\\<leftarrow>xs. x \\<in> range p] @ inv p y #\n        map (inv p) (ipurge_tr_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs),\n        inv p ` ipurge_ref_aux_foldr ?I' ?D' ?F {Some (D (inv p y))} zs Z)\n        \\<in> failures P\""], ["proof (prove)\nusing this:\n  (inv p y #\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> futures P (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs))\n\ngoal (1 subgoal):\n 1. (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n     inv p y #\n     map (inv p)\n      (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n        (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n     inv p `\n     ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n    \\<in> failures P", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs) @\n   inv p y #\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {Some (D (inv p y))} zs Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n   map (inv p)\n    (ipurge_tr_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n      (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs),\n   inv p `\n   ipurge_ref_aux_foldr (con_comp_pol I) (con_comp_map D E p q)\n    (\\<lambda>x. x \\<in> range p) {con_comp_map D E p q y} zs Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      ((xs @ [y]) @\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)),\n   inv p `\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z)\n    \\<in> failures P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      ((xs @ [y]) @\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)),\n   inv p `\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @\n       y #\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)),\n   inv p `\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_consistent_maps:\n \"consistent_maps D E p q \\<Longrightarrow> con_comp_map D E p q = con_comp_map E D q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_maps D E p q \\<Longrightarrow>\n    con_comp_map D E p q = con_comp_map E D q p", "using [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_maps D E p q \\<Longrightarrow>\n    con_comp_map D E p q = con_comp_map E D q p", "proof (simp add: consistent_maps_def, rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x\\<in>range p \\<inter> range q.\n          D (inv p x) = E (inv q x) \\<Longrightarrow>\n       con_comp_map D E p q x = con_comp_map E D q p x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x\\<in>range p \\<inter> range q.\n          D (inv p x) = E (inv q x) \\<Longrightarrow>\n       con_comp_map D E p q x = con_comp_map E D q p x", "assume A: \"\\<forall>x \\<in> range p \\<inter> range q. D (inv p x) = E (inv q x)\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>range p \\<inter> range q. D (inv p x) = E (inv q x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x\\<in>range p \\<inter> range q.\n          D (inv p x) = E (inv q x) \\<Longrightarrow>\n       con_comp_map D E p q x = con_comp_map E D q p x", "show \"con_comp_map D E p q x = con_comp_map E D q p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = con_comp_map E D q p x", "proof (rule con_comp_map.cases [of \"(D, E, p, q, x)\"], simp_all, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa pa Da Ea qa.\n       \\<lbrakk>xa \\<in> range pa; D = Da; E = Ea; p = pa; q = qa;\n        x = xa\\<rbrakk>\n       \\<Longrightarrow> Some (Da (inv pa xa)) = con_comp_map Ea Da qa pa xa", "fix p' q' D' E' x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa pa Da Ea qa.\n       \\<lbrakk>xa \\<in> range pa; D = Da; E = Ea; p = pa; q = qa;\n        x = xa\\<rbrakk>\n       \\<Longrightarrow> Some (Da (inv pa xa)) = con_comp_map Ea Da qa pa xa", "assume\n      B: \"p = p'\" and\n      C: \"q = q'\" and\n      D: \"D = D'\" and\n      E: \"E = E'\" and\n      F: \"x' \\<in> range p'\""], ["proof (state)\nthis:\n  p = p'\n  q = q'\n  D = D'\n  E = E'\n  x' \\<in> range p'\n\ngoal (1 subgoal):\n 1. \\<And>xa pa Da Ea qa.\n       \\<lbrakk>xa \\<in> range pa; D = Da; E = Ea; p = pa; q = qa;\n        x = xa\\<rbrakk>\n       \\<Longrightarrow> Some (Da (inv pa xa)) = con_comp_map Ea Da qa pa xa", "show \"Some (D' (inv p' x')) = con_comp_map E' D' q' p' x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (D' (inv p' x')) = con_comp_map E' D' q' p' x'", "proof (cases \"x' \\<in> range q'\", simp_all add: F)"], ["proof (state)\ngoal (1 subgoal):\n 1. x' \\<in> range q' \\<Longrightarrow> D' (inv p' x') = E' (inv q' x')", "case True"], ["proof (state)\nthis:\n  x' \\<in> range q'\n\ngoal (1 subgoal):\n 1. x' \\<in> range q' \\<Longrightarrow> D' (inv p' x') = E' (inv q' x')", "with F"], ["proof (chain)\npicking this:\n  x' \\<in> range p'\n  x' \\<in> range q'", "have \"x' \\<in> range p' \\<inter> range q'\""], ["proof (prove)\nusing this:\n  x' \\<in> range p'\n  x' \\<in> range q'\n\ngoal (1 subgoal):\n 1. x' \\<in> range p' \\<inter> range q'", ".."], ["proof (state)\nthis:\n  x' \\<in> range p' \\<inter> range q'\n\ngoal (1 subgoal):\n 1. x' \\<in> range q' \\<Longrightarrow> D' (inv p' x') = E' (inv q' x')", "hence \"x' \\<in> range p \\<inter> range q\""], ["proof (prove)\nusing this:\n  x' \\<in> range p' \\<inter> range q'\n\ngoal (1 subgoal):\n 1. x' \\<in> range p \\<inter> range q", "using B and C"], ["proof (prove)\nusing this:\n  x' \\<in> range p' \\<inter> range q'\n  p = p'\n  q = q'\n\ngoal (1 subgoal):\n 1. x' \\<in> range p \\<inter> range q", "by simp"], ["proof (state)\nthis:\n  x' \\<in> range p \\<inter> range q\n\ngoal (1 subgoal):\n 1. x' \\<in> range q' \\<Longrightarrow> D' (inv p' x') = E' (inv q' x')", "with A"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>range p \\<inter> range q. D (inv p x) = E (inv q x)\n  x' \\<in> range p \\<inter> range q", "have \"D (inv p x') = E (inv q x')\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>range p \\<inter> range q. D (inv p x) = E (inv q x)\n  x' \\<in> range p \\<inter> range q\n\ngoal (1 subgoal):\n 1. D (inv p x') = E (inv q x')", ".."], ["proof (state)\nthis:\n  D (inv p x') = E (inv q x')\n\ngoal (1 subgoal):\n 1. x' \\<in> range q' \\<Longrightarrow> D' (inv p' x') = E' (inv q' x')", "thus \"D' (inv p' x') = E' (inv q' x')\""], ["proof (prove)\nusing this:\n  D (inv p x') = E (inv q x')\n\ngoal (1 subgoal):\n 1. D' (inv p' x') = E' (inv q' x')", "using B and C and D and E"], ["proof (prove)\nusing this:\n  D (inv p x') = E (inv q x')\n  p = p'\n  q = q'\n  D = D'\n  E = E'\n\ngoal (1 subgoal):\n 1. D' (inv p' x') = E' (inv q' x')", "by simp"], ["proof (state)\nthis:\n  D' (inv p' x') = E' (inv q' x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Some (D' (inv p' x')) = con_comp_map E' D' q' p' x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  con_comp_map D E p q x = con_comp_map E D q p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_secure_del_aux_2:\n  assumes A: \"consistent_maps D E p q\"\n  shows\n   \"secure Q I E \\<Longrightarrow>\n    y \\<in> range p \\<or> y \\<in> range q \\<Longrightarrow>\n    set ys \\<subseteq> range p \\<union> range q \\<Longrightarrow>\n    Y \\<subseteq> range q \\<Longrightarrow>\n    (map (inv q) [x\\<leftarrow>xs @ y # ys. x \\<in> range q], inv q ` Y) \\<in> failures Q \\<Longrightarrow>\n      (map (inv q) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys. x \\<in> range q],\n       inv q ` ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys Y) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set ys \\<subseteq> range p \\<union> range q; Y \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n      inv q ` Y)\n     \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q)\n                          (xs @\n                           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                            (con_comp_map D E p q y) ys)),\n                       inv q `\n                       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                        (con_comp_map D E p q y) ys Y)\n                      \\<in> failures Q", "proof (simp only: con_comp_consistent_maps [OF A], rule con_comp_secure_del_aux_1)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set ys \\<subseteq> range p \\<union> range q; Y \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n      inv q ` Y)\n     \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> secure Q I E\n 2. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set ys \\<subseteq> range p \\<union> range q; Y \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n      inv q ` Y)\n     \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> y \\<in> range q \\<or> y \\<in> range p\n 3. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set ys \\<subseteq> range p \\<union> range q; Y \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n      inv q ` Y)\n     \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> set ys \\<subseteq> range q \\<union> range p\n 4. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set ys \\<subseteq> range p \\<union> range q; Y \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n      inv q ` Y)\n     \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> Y \\<subseteq> range q\n 5. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set ys \\<subseteq> range p \\<union> range q; Y \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n      inv q ` Y)\n     \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q)\n                          (xs @ y # ys)),\n                       inv q ` Y)\n                      \\<in> failures Q", "qed (simp_all, blast+)"], ["", "lemma con_comp_secure_add_aux_2:\n  assumes A: \"consistent_maps D E p q\"\n  shows\n   \"secure Q I E \\<Longrightarrow>\n    y \\<in> range p \\<or> y \\<in> range q \\<Longrightarrow>\n    set zs \\<subseteq> range p \\<union> range q \\<Longrightarrow>\n    Z \\<subseteq> range q \\<Longrightarrow>\n    (map (inv q) [x\\<leftarrow>xs @ zs. x \\<in> range q], inv q ` Z) \\<in> failures Q \\<Longrightarrow>\n    map (inv q) [x\\<leftarrow>xs @ [y]. x \\<in> range q] \\<in> traces Q \\<Longrightarrow>\n      (map (inv q) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range q],\n       inv q ` ipurge_ref (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs Z) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set zs \\<subseteq> range p \\<union> range q; Z \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n      inv q ` Z)\n     \\<in> failures Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n     \\<in> traces Q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q)\n                          (xs @\n                           y #\n                           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                            (con_comp_map D E p q y) zs)),\n                       inv q `\n                       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                        (con_comp_map D E p q y) zs Z)\n                      \\<in> failures Q", "proof (simp only: con_comp_consistent_maps [OF A], rule con_comp_secure_add_aux_1)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set zs \\<subseteq> range p \\<union> range q; Z \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n      inv q ` Z)\n     \\<in> failures Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n     \\<in> traces Q\\<rbrakk>\n    \\<Longrightarrow> secure Q I E\n 2. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set zs \\<subseteq> range p \\<union> range q; Z \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n      inv q ` Z)\n     \\<in> failures Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n     \\<in> traces Q\\<rbrakk>\n    \\<Longrightarrow> y \\<in> range q \\<or> y \\<in> range p\n 3. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set zs \\<subseteq> range p \\<union> range q; Z \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n      inv q ` Z)\n     \\<in> failures Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n     \\<in> traces Q\\<rbrakk>\n    \\<Longrightarrow> set zs \\<subseteq> range q \\<union> range p\n 4. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set zs \\<subseteq> range p \\<union> range q; Z \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n      inv q ` Z)\n     \\<in> failures Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n     \\<in> traces Q\\<rbrakk>\n    \\<Longrightarrow> Z \\<subseteq> range q\n 5. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set zs \\<subseteq> range p \\<union> range q; Z \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n      inv q ` Z)\n     \\<in> failures Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n     \\<in> traces Q\\<rbrakk>\n    \\<Longrightarrow> (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n                       inv q ` Z)\n                      \\<in> failures Q\n 6. \\<lbrakk>secure Q I E; y \\<in> range p \\<or> y \\<in> range q;\n     set zs \\<subseteq> range p \\<union> range q; Z \\<subseteq> range q;\n     (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n      inv q ` Z)\n     \\<in> failures Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n     \\<in> traces Q\\<rbrakk>\n    \\<Longrightarrow> map (inv q)\n                       (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n                      \\<in> traces Q", "qed (simp_all, blast+)"], ["", "lemma con_comp_secure_del_case_1:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\"\n  shows\n   \"\\<exists>R S T.\n      Y = R \\<union> S \\<union> T \\<and>\n      (y \\<in> range p \\<or> y \\<in> range q) \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set ys \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ y # ys. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ y # ys. x \\<in> range q], inv q ` S) \\<in> failures Q \\<Longrightarrow>\n    \\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>                     \n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys) \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys. x \\<in> range q], inv q ` S) \\<in> failures Q\"\n  (is \"_ \\<Longrightarrow> \\<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \\<and> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       Y = R \\<union> S \\<union> T \\<and>\n       (y \\<in> range p \\<or> y \\<in> range q) \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set ys \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n        inv q ` S)\n       \\<in> failures Q \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q", "proof ((erule exE)+, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S T.\n       \\<lbrakk>Y = R \\<union> S \\<union> T;\n        y \\<in> range p \\<or> y \\<in> range q;\n        set xs \\<subseteq> range p \\<union> range q;\n        set ys \\<subseteq> range p \\<union> range q; R \\<subseteq> range p;\n        S \\<subseteq> range q; T \\<subseteq> - range p;\n        T \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n         inv p ` R)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n         inv q ` S)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R S T.\n                            ipurge_ref (con_comp_pol I)\n                             (con_comp_map D E p q) (con_comp_map D E p q y)\n                             ys Y =\n                            R \\<union> S \\<union> T \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            set (ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            R \\<subseteq> range p \\<and>\n                            S \\<subseteq> range q \\<and>\n                            T \\<subseteq> - range p \\<and>\n                            T \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p)\n                                (xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)),\n                             inv p ` R)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q)\n                                (xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)),\n                             inv q ` S)\n                            \\<in> failures Q", "fix R S T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S T.\n       \\<lbrakk>Y = R \\<union> S \\<union> T;\n        y \\<in> range p \\<or> y \\<in> range q;\n        set xs \\<subseteq> range p \\<union> range q;\n        set ys \\<subseteq> range p \\<union> range q; R \\<subseteq> range p;\n        S \\<subseteq> range q; T \\<subseteq> - range p;\n        T \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n         inv p ` R)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n         inv q ` S)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R S T.\n                            ipurge_ref (con_comp_pol I)\n                             (con_comp_map D E p q) (con_comp_map D E p q y)\n                             ys Y =\n                            R \\<union> S \\<union> T \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            set (ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            R \\<subseteq> range p \\<and>\n                            S \\<subseteq> range q \\<and>\n                            T \\<subseteq> - range p \\<and>\n                            T \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p)\n                                (xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)),\n                             inv p ` R)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q)\n                                (xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)),\n                             inv q ` S)\n                            \\<in> failures Q", "assume\n    D: \"Y = R \\<union> S \\<union> T\" and\n    E: \"y \\<in> range p \\<or> y \\<in> range q\" and\n    F: \"set xs \\<subseteq> range p \\<union> range q\" and\n    G: \"set ys \\<subseteq> range p \\<union> range q\" and\n    H: \"R \\<subseteq> range p\" and\n    I: \"S \\<subseteq> range q\" and\n    J: \"T \\<subseteq> - range p\" and\n    K: \"T \\<subseteq> - range q\" and\n    L: \"(map (inv p) [x\\<leftarrow>xs @ y # ys. x \\<in> range p], inv p ` R) \\<in> failures P\" and\n    M: \"(map (inv q) [x\\<leftarrow>xs @ y # ys. x \\<in> range q], inv q ` S) \\<in> failures Q\""], ["proof (state)\nthis:\n  Y = R \\<union> S \\<union> T\n  y \\<in> range p \\<or> y \\<in> range q\n  set xs \\<subseteq> range p \\<union> range q\n  set ys \\<subseteq> range p \\<union> range q\n  R \\<subseteq> range p\n  S \\<subseteq> range q\n  T \\<subseteq> - range p\n  T \\<subseteq> - range q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n   inv p ` R)\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n   inv q ` S)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>R S T.\n       \\<lbrakk>Y = R \\<union> S \\<union> T;\n        y \\<in> range p \\<or> y \\<in> range q;\n        set xs \\<subseteq> range p \\<union> range q;\n        set ys \\<subseteq> range p \\<union> range q; R \\<subseteq> range p;\n        S \\<subseteq> range q; T \\<subseteq> - range p;\n        T \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n         inv p ` R)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n         inv q ` S)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R S T.\n                            ipurge_ref (con_comp_pol I)\n                             (con_comp_map D E p q) (con_comp_map D E p q y)\n                             ys Y =\n                            R \\<union> S \\<union> T \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            set (ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            R \\<subseteq> range p \\<and>\n                            S \\<subseteq> range q \\<and>\n                            T \\<subseteq> - range p \\<and>\n                            T \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p)\n                                (xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)),\n                             inv p ` R)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q)\n                                (xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys)),\n                             inv q ` S)\n                            \\<in> failures Q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q", "proof (rule_tac x = \"ipurge_ref ?I' ?D' (?D' y) ys R\" in exI,\n   rule_tac x = \"ipurge_ref ?I' ?D' (?D' y) ys S\" in exI, rule_tac x = \"{}\" in exI,\n   (subst conj_assoc [symmetric])+, (rule conjI)+, simp_all del: filter_append)"], ["proof (state)\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "have \"ipurge_ref ?I' ?D' (?D' y) ys Y =\n      ipurge_ref ?I' ?D' (?D' y) ys (R \\<union> S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys (R \\<union> S \\<union> T)", "using D"], ["proof (prove)\nusing this:\n  Y = R \\<union> S \\<union> T\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys (R \\<union> S \\<union> T)", "by simp"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys Y =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys (R \\<union> S \\<union> T)\n\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "hence \"ipurge_ref ?I' ?D' (?D' y) ys Y =\n      ipurge_ref ?I' ?D' (?D' y) ys R \\<union>\n      ipurge_ref ?I' ?D' (?D' y) ys S \\<union>\n      ipurge_ref ?I' ?D' (?D' y) ys T\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys Y =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys (R \\<union> S \\<union> T)\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys T", "by (simp add: ipurge_ref_distrib_union)"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys Y =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys T\n\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys Y =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys T\n\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "have \"ipurge_ref ?I' ?D' (?D' y) ys T = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys T =\n    {}", "proof (rule ipurge_ref_empty [of \"?D' y\"], simp, insert E,\n     cases \"y \\<in> range p\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "assume N: \"x \\<in> T\""], ["proof (state)\nthis:\n  x \\<in> T\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "with J"], ["proof (chain)\npicking this:\n  T \\<subseteq> - range p\n  x \\<in> T", "have \"x \\<in> - range p\""], ["proof (prove)\nusing this:\n  T \\<subseteq> - range p\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> - range p", ".."], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "have \"x \\<in> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> - range q", "using K and N"], ["proof (prove)\nusing this:\n  T \\<subseteq> - range q\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> - range q", ".."], ["proof (state)\nthis:\n  x \\<in> - range q\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> - range p\n  x \\<in> - range q", "have \"?D' x = None\""], ["proof (prove)\nusing this:\n  x \\<in> - range p\n  x \\<in> - range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = None", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x = None\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "thus \"(Some (D (inv p y)), ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = None\n\ngoal (1 subgoal):\n 1. (Some (D (inv p y)), con_comp_map D E p q x) \\<in> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (Some (D (inv p y)), con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "assume N: \"x \\<in> T\""], ["proof (state)\nthis:\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "with J"], ["proof (chain)\npicking this:\n  T \\<subseteq> - range p\n  x \\<in> T", "have \"x \\<in> - range p\""], ["proof (prove)\nusing this:\n  T \\<subseteq> - range p\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> - range p", ".."], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "have \"x \\<in> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> - range q", "using K and N"], ["proof (prove)\nusing this:\n  T \\<subseteq> - range q\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> - range q", ".."], ["proof (state)\nthis:\n  x \\<in> - range q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> - range p\n  x \\<in> - range q", "have \"?D' x = None\""], ["proof (prove)\nusing this:\n  x \\<in> - range p\n  x \\<in> - range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = None", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x = None\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "thus \"(Some (E (inv q y)), ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = None\n\ngoal (1 subgoal):\n 1. (Some (E (inv q y)), con_comp_map D E p q x) \\<in> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (Some (E (inv q y)), con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys T =\n  {}\n\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys Y =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys T\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys T =\n  {}", "show \"ipurge_ref ?I' ?D' (?D' y) ys Y =\n      ipurge_ref ?I' ?D' (?D' y) ys R \\<union>\n      ipurge_ref ?I' ?D' (?D' y) ys S\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys Y =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys T\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys T =\n  {}\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys Y =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S", "by simp"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys Y =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S\n\ngoal (6 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 5. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 6. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 5. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 6. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "show \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using F"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "."], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (5 subgoals):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "have \"set (ipurge_tr ?I' ?D' (?D' y) ys) \\<subseteq> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> set ys", "by (rule ipurge_tr_set)"], ["proof (state)\nthis:\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys)\n  \\<subseteq> set ys\n\ngoal (5 subgoals):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "thus \"set (ipurge_tr ?I' ?D' (?D' y) ys) \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys)\n  \\<subseteq> set ys\n\ngoal (1 subgoal):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q", "using G"], ["proof (prove)\nusing this:\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys)\n  \\<subseteq> set ys\n  set ys \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)\n    \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys)\n  \\<subseteq> range p \\<union> range q\n\ngoal (4 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "have \"ipurge_ref ?I' ?D' (?D' y) ys R \\<subseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> R", "by (rule ipurge_ref_subset)"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R\n  \\<subseteq> R\n\ngoal (4 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "thus \"ipurge_ref ?I' ?D' (?D' y) ys R \\<subseteq> range p\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R\n  \\<subseteq> R\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p", "using H"], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R\n  \\<subseteq> R\n  R \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys R\n    \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys R\n  \\<subseteq> range p\n\ngoal (3 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "have \"ipurge_ref ?I' ?D' (?D' y) ys S \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> S", "by (rule ipurge_ref_subset)"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S\n  \\<subseteq> S\n\ngoal (3 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "thus \"ipurge_ref ?I' ?D' (?D' y) ys S \\<subseteq> range q\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q", "using I"], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S\n  \\<subseteq> S\n  S \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys S\n    \\<subseteq> range q", "by simp"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) ys S\n  \\<subseteq> range q\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "show \"(map (inv p) [x\\<leftarrow>xs @ ipurge_tr ?I' ?D' (?D' y) ys. x \\<in> range p],\n      inv p ` ipurge_ref ?I' ?D' (?D' y) ys R) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys R)\n    \\<in> failures P", "by (rule con_comp_secure_del_aux_1 [OF B E G H L])"], ["proof (state)\nthis:\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys)),\n   inv p `\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) ys R)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "show \"(map (inv q) [x\\<leftarrow>xs @ ipurge_tr ?I' ?D' (?D' y) ys. x \\<in> range q],\n      inv q ` ipurge_ref ?I' ?D' (?D' y) ys S) \\<in> failures Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys S)\n    \\<in> failures Q", "by (rule con_comp_secure_del_aux_2 [OF A C E G I M])"], ["proof (state)\nthis:\n  (map (inv q)\n    (filter (\\<lambda>x. x \\<in> range q)\n      (xs @\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys)),\n   inv q `\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) ys S)\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys Y =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) ys)\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) ys)),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) ys)),\n      inv q ` S)\n     \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_secure_del_case_2:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\"\n  shows\n   \"\\<exists>xs'.\n      (\\<exists>ys'. xs @ y # ys = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q \\<Longrightarrow>\n    (\\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys) \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys. x \\<in> range q], inv q ` S) \\<in> failures Q) \\<or>\n    (\\<exists>xs'.\n      (\\<exists>ys'. xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q)\"\n  (is \"_ \\<Longrightarrow> (\\<exists>R S T. ?F R S T ys) \\<or> ?G\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       (\\<exists>ys'. xs @ y # ys = xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q \\<Longrightarrow>\n    (\\<exists>R S T.\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys Y =\n        R \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)\n        \\<subseteq> range p \\<union> range q \\<and>\n        R \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p)\n          (filter (\\<lambda>x. x \\<in> range p)\n            (xs @\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)),\n         inv p ` R)\n        \\<in> failures P \\<and>\n        (map (inv q)\n          (filter (\\<lambda>x. x \\<in> range q)\n            (xs @\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)),\n         inv q ` S)\n        \\<in> failures Q) \\<or>\n    (\\<exists>xs'.\n        (\\<exists>ys'.\n            xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys =\n            xs' @ ys') \\<and>\n        set xs' \\<subseteq> range p \\<union> range q \\<and>\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P \\<and>\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q)", "proof (erule exE, (erule conjE)+, erule exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>set xs' \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q;\n        xs @ y # ys = xs' @ ys'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>R S T.\n                             ipurge_ref (con_comp_pol I)\n                              (con_comp_map D E p q)\n                              (con_comp_map D E p q y) ys Y =\n                             R \\<union> S \\<union> T \\<and>\n                             set xs\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             set (ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             R \\<subseteq> range p \\<and>\n                             S \\<subseteq> range q \\<and>\n                             T \\<subseteq> - range p \\<and>\n                             T \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p)\n                                 (xs @\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)),\n                              inv p ` R)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q)\n                                 (xs @\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)),\n                              inv q ` S)\n                             \\<in> failures Q) \\<or>\n                         (\\<exists>xs'.\n                             (\\<exists>ys'.\n                                 xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys =\n                                 xs' @ ys') \\<and>\n                             set xs'\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs')\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs')\n                             \\<in> divergences Q)", "fix xs' ys'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>set xs' \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q;\n        xs @ y # ys = xs' @ ys'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>R S T.\n                             ipurge_ref (con_comp_pol I)\n                              (con_comp_map D E p q)\n                              (con_comp_map D E p q y) ys Y =\n                             R \\<union> S \\<union> T \\<and>\n                             set xs\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             set (ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             R \\<subseteq> range p \\<and>\n                             S \\<subseteq> range q \\<and>\n                             T \\<subseteq> - range p \\<and>\n                             T \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p)\n                                 (xs @\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)),\n                              inv p ` R)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q)\n                                 (xs @\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)),\n                              inv q ` S)\n                             \\<in> failures Q) \\<or>\n                         (\\<exists>xs'.\n                             (\\<exists>ys'.\n                                 xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys =\n                                 xs' @ ys') \\<and>\n                             set xs'\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs')\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs')\n                             \\<in> divergences Q)", "assume\n    D: \"set xs' \\<subseteq> range p \\<union> range q\" and\n    E: \"map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P\" and\n    F: \"map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q\" and\n    G: \"xs @ y # ys = xs' @ ys'\""], ["proof (state)\nthis:\n  set xs' \\<subseteq> range p \\<union> range q\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs') \\<in> divergences P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs') \\<in> divergences Q\n  xs @ y # ys = xs' @ ys'\n\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>set xs' \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q;\n        xs @ y # ys = xs' @ ys'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>R S T.\n                             ipurge_ref (con_comp_pol I)\n                              (con_comp_map D E p q)\n                              (con_comp_map D E p q y) ys Y =\n                             R \\<union> S \\<union> T \\<and>\n                             set xs\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             set (ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             R \\<subseteq> range p \\<and>\n                             S \\<subseteq> range q \\<and>\n                             T \\<subseteq> - range p \\<and>\n                             T \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p)\n                                 (xs @\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)),\n                              inv p ` R)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q)\n                                 (xs @\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) ys)),\n                              inv q ` S)\n                             \\<in> failures Q) \\<or>\n                         (\\<exists>xs'.\n                             (\\<exists>ys'.\n                                 xs @\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) ys =\n                                 xs' @ ys') \\<and>\n                             set xs'\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs')\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs')\n                             \\<in> divergences Q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>R S T.\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys Y =\n        R \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)\n        \\<subseteq> range p \\<union> range q \\<and>\n        R \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p)\n          (filter (\\<lambda>x. x \\<in> range p)\n            (xs @\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)),\n         inv p ` R)\n        \\<in> failures P \\<and>\n        (map (inv q)\n          (filter (\\<lambda>x. x \\<in> range q)\n            (xs @\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)),\n         inv q ` S)\n        \\<in> failures Q) \\<or>\n    (\\<exists>xs'.\n        (\\<exists>ys'.\n            xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys =\n            xs' @ ys') \\<and>\n        set xs' \\<subseteq> range p \\<union> range q \\<and>\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P \\<and>\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q)", "proof (cases \"length xs < length xs'\", rule disjI1, rule_tac [2] disjI2)"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "case True"], ["proof (state)\nthis:\n  length xs < length xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  length xs < length xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"take (length xs') (xs @ [y] @ ys) =\n      take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length xs') (xs @ [y] @ ys) =\n    take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys", "by (simp only: take_append, simp)"], ["proof (state)\nthis:\n  take (length xs') (xs @ [y] @ ys) =\n  take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  length xs < length xs'\n  take (length xs') (xs @ [y] @ ys) =\n  take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys", "have \"take (length xs') (xs @ [y] @ ys) =\n      xs @ y # take (length xs' - Suc (length xs)) ys\"\n      (is \"_ = _ @ _ # ?vs\")"], ["proof (prove)\nusing this:\n  length xs < length xs'\n  take (length xs') (xs @ [y] @ ys) =\n  take (length xs') (xs @ [y]) @ take (length xs' - Suc (length xs)) ys\n\ngoal (1 subgoal):\n 1. take (length xs') (xs @ [y] @ ys) =\n    xs @ y # take (length xs' - Suc (length xs)) ys", "by simp"], ["proof (state)\nthis:\n  take (length xs') (xs @ [y] @ ys) =\n  xs @ y # take (length xs' - Suc (length xs)) ys\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  take (length xs') (xs @ [y] @ ys) =\n  xs @ y # take (length xs' - Suc (length xs)) ys\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"take (length xs') (xs @ [y] @ ys) =\n      take (length xs') (xs' @ ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length xs') (xs @ [y] @ ys) = take (length xs') (xs' @ ys')", "using G"], ["proof (prove)\nusing this:\n  xs @ y # ys = xs' @ ys'\n\ngoal (1 subgoal):\n 1. take (length xs') (xs @ [y] @ ys) = take (length xs') (xs' @ ys')", "by simp"], ["proof (state)\nthis:\n  take (length xs') (xs @ [y] @ ys) = take (length xs') (xs' @ ys')\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  take (length xs') (xs @ [y] @ ys) =\n  xs @ y # take (length xs' - Suc (length xs)) ys\n  take (length xs') (xs @ [y] @ ys) = take (length xs') (xs' @ ys')", "have H: \"xs @ y # ?vs = xs'\""], ["proof (prove)\nusing this:\n  take (length xs') (xs @ [y] @ ys) =\n  xs @ y # take (length xs' - Suc (length xs)) ys\n  take (length xs') (xs @ [y] @ ys) = take (length xs') (xs' @ ys')\n\ngoal (1 subgoal):\n 1. xs @ y # take (length xs' - Suc (length xs)) ys = xs'", "by simp"], ["proof (state)\nthis:\n  xs @ y # take (length xs' - Suc (length xs)) ys = xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  xs @ y # take (length xs' - Suc (length xs)) ys = xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"y \\<in> set (xs @ y # ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (xs @ y # take (length xs' - Suc (length xs)) ys)", "by simp"], ["proof (state)\nthis:\n  y \\<in> set (xs @ y # take (length xs' - Suc (length xs)) ys)\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  xs @ y # take (length xs' - Suc (length xs)) ys = xs'\n  y \\<in> set (xs @ y # take (length xs' - Suc (length xs)) ys)", "have \"y \\<in> set xs'\""], ["proof (prove)\nusing this:\n  xs @ y # take (length xs' - Suc (length xs)) ys = xs'\n  y \\<in> set (xs @ y # take (length xs' - Suc (length xs)) ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set xs'", "by simp"], ["proof (state)\nthis:\n  y \\<in> set xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "with D"], ["proof (chain)\npicking this:\n  set xs' \\<subseteq> range p \\<union> range q\n  y \\<in> set xs'", "have I: \"y \\<in> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set xs' \\<subseteq> range p \\<union> range q\n  y \\<in> set xs'\n\ngoal (1 subgoal):\n 1. y \\<in> range p \\<union> range q", ".."], ["proof (state)\nthis:\n  y \\<in> range p \\<union> range q\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"set xs \\<subseteq> set (xs @ y # ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set (xs @ y # take (length xs' - Suc (length xs)) ys)", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> set (xs @ y # take (length xs' - Suc (length xs)) ys)\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "hence \"set xs \\<subseteq> set xs'\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> set (xs @ y # take (length xs' - Suc (length xs)) ys)\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set xs'", "using H"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> set (xs @ y # take (length xs' - Suc (length xs)) ys)\n  xs @ y # take (length xs' - Suc (length xs)) ys = xs'\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set xs'", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> set xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "hence J: \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> set xs'\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using D"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> set xs'\n  set xs' \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"\\<exists>R S T. ?F R S T [x\\<leftarrow>ys. x \\<in> range p \\<union> range q]\"\n      (is \"\\<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \\<and> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y)\n             (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y)\n             (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y)\n             (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n        inv q ` S)\n       \\<in> failures Q", "proof (rule con_comp_secure_del_case_1 [OF A B C],\n     rule_tac x = \"range p \\<inter> Y\" in exI, rule_tac x = \"range q \\<inter> Y\" in exI,\n     rule_tac x = \"- range p \\<inter> - range q \\<inter> Y\" in exI,\n     (subst conj_assoc [symmetric])+, (rule conjI)+, simp_all del: filter_append)"], ["proof (state)\ngoal (8 subgoals):\n 1. Y =\n    range p \\<inter> Y \\<union> range q \\<inter> Y \\<union>\n    - range p \\<inter> - range q \\<inter> Y\n 2. y \\<in> range p \\<or> y \\<in> range q\n 3. set xs \\<subseteq> range p \\<union> range q\n 4. {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 5. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 6. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 7. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 8. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "show \"Y = range p \\<inter> Y \\<union> range q \\<inter> Y \\<union> - range p \\<inter> - range q \\<inter> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y =\n    range p \\<inter> Y \\<union> range q \\<inter> Y \\<union>\n    - range p \\<inter> - range q \\<inter> Y", "by blast"], ["proof (state)\nthis:\n  Y =\n  range p \\<inter> Y \\<union> range q \\<inter> Y \\<union>\n  - range p \\<inter> - range q \\<inter> Y\n\ngoal (7 subgoals):\n 1. y \\<in> range p \\<or> y \\<in> range q\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 4. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 5. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. y \\<in> range p \\<or> y \\<in> range q\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 4. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 5. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "show \"y \\<in> range p \\<or> y \\<in> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> range p \\<or> y \\<in> range q", "using I"], ["proof (prove)\nusing this:\n  y \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. y \\<in> range p \\<or> y \\<in> range q", "by simp"], ["proof (state)\nthis:\n  y \\<in> range p \\<or> y \\<in> range q\n\ngoal (6 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 3. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 4. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 5. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 6. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 3. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 4. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 5. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 6. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "show \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using J"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "."], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (5 subgoals):\n 1. {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 2. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 3. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 2. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 3. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "show \"{x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q} \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q", "by blast"], ["proof (state)\nthis:\n  {x \\<in> set ys. x \\<in> range p \\<or> x \\<in> range q}\n  \\<subseteq> range p \\<union> range q\n\ngoal (4 subgoals):\n 1. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 2. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n 2. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "show \"- range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p", "by blast"], ["proof (state)\nthis:\n  - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "show \"- range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q", "by blast"], ["proof (state)\nthis:\n  - range p \\<inter> - range q \\<inter> Y \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "have \"map (inv p) [x\\<leftarrow>xs @ y # ?vs. x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (xs @ y # take (length xs' - Suc (length xs)) ys))\n    \\<in> divergences P", "using E and H"], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs') \\<in> divergences P\n  xs @ y # take (length xs' - Suc (length xs)) ys = xs'\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (xs @ y # take (length xs' - Suc (length xs)) ys))\n    \\<in> divergences P", "by simp"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ y # take (length xs' - Suc (length xs)) ys))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>xs @ y # ?vs. x \\<in> range p] @\n        map (inv p) [x\\<leftarrow>drop (length xs' - Suc (length xs)) ys. x \\<in> range p]\n        \\<in> divergences P\"\n        (is \"_ @ map (inv p) [x\\<leftarrow>?ws. _] \\<in> _\")"], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ y # take (length xs' - Suc (length xs)) ys))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (xs @ y # take (length xs' - Suc (length xs)) ys)) @\n    map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (drop (length xs' - Suc (length xs)) ys))\n    \\<in> divergences P", "by (rule process_rule_5_general)"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ y # take (length xs' - Suc (length xs)) ys)) @\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (drop (length xs' - Suc (length xs)) ys))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>(xs @ y # ?vs) @ ?ws. x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ y # take (length xs' - Suc (length xs)) ys)) @\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (drop (length xs' - Suc (length xs)) ys))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       ((xs @ y # take (length xs' - Suc (length xs)) ys) @\n        drop (length xs' - Suc (length xs)) ys))\n    \\<in> divergences P", "by (subst filter_append, simp)"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     ((xs @ y # take (length xs' - Suc (length xs)) ys) @\n      drop (length xs' - Suc (length xs)) ys))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>(xs @ [y]) @ ys. x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     ((xs @ y # take (length xs' - Suc (length xs)) ys) @\n      drop (length xs' - Suc (length xs)) ys))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys))\n    \\<in> divergences P", "by simp"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>(xs @ [y]) @ [x\\<leftarrow>ys. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       ((xs @ [y]) @\n        filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n    \\<in> divergences P", "proof (subst (asm) filter_append, subst filter_append, subst filter_filter)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv p)\n              (filter (\\<lambda>x. x \\<in> range p) (xs @ [y]) @\n               filter (\\<lambda>x. x \\<in> range p) ys)\n             \\<in> divergences P;\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys))\n     \\<in> divergences P;\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys))\n     \\<in> divergences P\\<rbrakk>\n    \\<Longrightarrow> map (inv p)\n                       (filter (\\<lambda>x. x \\<in> range p) (xs @ [y]) @\n                        filter\n                         (\\<lambda>x.\n                             (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n                             x \\<in> range p)\n                         ys)\n                      \\<in> divergences P", "qed (subgoal_tac \"(\\<lambda>x. (x \\<in> range p \\<or> x \\<in> range q) \\<and> x \\<in> range p) =\n       (\\<lambda>x. x \\<in> range p)\", simp, blast)"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     ((xs @ [y]) @\n      filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>xs @ y # [x\\<leftarrow>ys. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     ((xs @ [y]) @\n      filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (xs @\n        y # filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n    \\<in> divergences P", "by simp"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @\n      y # filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "thus \"(map (inv p) [x\\<leftarrow>xs @ y # [x\\<leftarrow>ys. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range p], inv p ` (range p \\<inter> Y)) \\<in> failures P\""], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @\n      y # filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv p ` (range p \\<inter> Y))\n    \\<in> failures P", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @\n       y # filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n   inv p ` (range p \\<inter> Y))\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "have \"map (inv q) [x\\<leftarrow>xs @ y # ?vs. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (xs @ y # take (length xs' - Suc (length xs)) ys))\n    \\<in> divergences Q", "using F and H"], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs') \\<in> divergences Q\n  xs @ y # take (length xs' - Suc (length xs)) ys = xs'\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (xs @ y # take (length xs' - Suc (length xs)) ys))\n    \\<in> divergences Q", "by simp"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ y # take (length xs' - Suc (length xs)) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>xs @ y # ?vs. x \\<in> range q] @\n        map (inv q) [x\\<leftarrow>drop (length xs' - Suc (length xs)) ys. x \\<in> range q]\n        \\<in> divergences Q\"\n        (is \"_ @ map (inv q) [x\\<leftarrow>?ws. _] \\<in> _\")"], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ y # take (length xs' - Suc (length xs)) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (xs @ y # take (length xs' - Suc (length xs)) ys)) @\n    map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (drop (length xs' - Suc (length xs)) ys))\n    \\<in> divergences Q", "by (rule process_rule_5_general)"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ y # take (length xs' - Suc (length xs)) ys)) @\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (drop (length xs' - Suc (length xs)) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>(xs @ y # ?vs) @ ?ws. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ y # take (length xs' - Suc (length xs)) ys)) @\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (drop (length xs' - Suc (length xs)) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       ((xs @ y # take (length xs' - Suc (length xs)) ys) @\n        drop (length xs' - Suc (length xs)) ys))\n    \\<in> divergences Q", "by (subst filter_append, simp)"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     ((xs @ y # take (length xs' - Suc (length xs)) ys) @\n      drop (length xs' - Suc (length xs)) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>(xs @ [y]) @ ys. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     ((xs @ y # take (length xs' - Suc (length xs)) ys) @\n      drop (length xs' - Suc (length xs)) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) ((xs @ [y]) @ ys))\n    \\<in> divergences Q", "by simp"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ((xs @ [y]) @ ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>(xs @ [y]) @ [x\\<leftarrow>ys. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ((xs @ [y]) @ ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       ((xs @ [y]) @\n        filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n    \\<in> divergences Q", "proof (subst (asm) filter_append, subst filter_append, subst filter_filter)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv q)\n              (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]) @\n               filter (\\<lambda>x. x \\<in> range q) ys)\n             \\<in> divergences Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) ((xs @ [y]) @ ys))\n     \\<in> divergences Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) ((xs @ [y]) @ ys))\n     \\<in> divergences Q\\<rbrakk>\n    \\<Longrightarrow> map (inv q)\n                       (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]) @\n                        filter\n                         (\\<lambda>x.\n                             (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n                             x \\<in> range q)\n                         ys)\n                      \\<in> divergences Q", "qed (subgoal_tac \"(\\<lambda>x. (x \\<in> range p \\<or> x \\<in> range q) \\<and> x \\<in> range q) =\n       (\\<lambda>x. x \\<in> range q)\", simp, blast)"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     ((xs @ [y]) @\n      filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>xs @ y # [x\\<leftarrow>ys. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     ((xs @ [y]) @\n      filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (xs @\n        y # filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n    \\<in> divergences Q", "by simp"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @\n      y # filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "thus \"(map (inv q) [x\\<leftarrow>xs @ y # [x\\<leftarrow>ys. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range q], inv q ` (range q \\<inter> Y)) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @\n      y # filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n     inv q ` (range q \\<inter> Y))\n    \\<in> failures Q", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv q)\n    (filter (\\<lambda>x. x \\<in> range q)\n      (xs @\n       y # filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) ys)),\n   inv q ` (range q \\<inter> Y))\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv q ` S)\n     \\<in> failures Q\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv q ` S)\n     \\<in> failures Q", "obtain R and S and T where\n     \"?F R S T [x\\<leftarrow>ys. x \\<in> range p \\<union> range q]\""], ["proof (prove)\nusing this:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv q ` S)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (\\<And>R S T.\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y)\n         (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n        R \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y)\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n        \\<subseteq> range p \\<union> range q \\<and>\n        R \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p)\n          (filter (\\<lambda>x. x \\<in> range p)\n            (xs @\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y)\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n         inv p ` R)\n        \\<in> failures P \\<and>\n        (map (inv q)\n          (filter (\\<lambda>x. x \\<in> range q)\n            (xs @\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y)\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n         inv q ` S)\n        \\<in> failures Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y)\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n  R \\<union> S \\<union> T \\<and>\n  set xs \\<subseteq> range p \\<union> range q \\<and>\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n  \\<subseteq> range p \\<union> range q \\<and>\n  R \\<subseteq> range p \\<and>\n  S \\<subseteq> range q \\<and>\n  T \\<subseteq> - range p \\<and>\n  T \\<subseteq> - range q \\<and>\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n   inv p ` R)\n  \\<in> failures P \\<and>\n  (map (inv q)\n    (filter (\\<lambda>x. x \\<in> range q)\n      (xs @\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n   inv q ` S)\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "thus \"\\<exists>R S T. ?F R S T ys\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y)\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n  R \\<union> S \\<union> T \\<and>\n  set xs \\<subseteq> range p \\<union> range q \\<and>\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n  \\<subseteq> range p \\<union> range q \\<and>\n  R \\<subseteq> range p \\<and>\n  S \\<subseteq> range q \\<and>\n  T \\<subseteq> - range p \\<and>\n  T \\<subseteq> - range q \\<and>\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n   inv p ` R)\n  \\<in> failures P \\<and>\n  (map (inv q)\n    (filter (\\<lambda>x. x \\<in> range q)\n      (xs @\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n   inv q ` S)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` S)\n       \\<in> failures Q", "proof (rule_tac x = R in exI, rule_tac x = S in exI, rule_tac x = T in exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y)\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n             R \\<union> S \\<union> T \\<and>\n             set xs \\<subseteq> range p \\<union> range q \\<and>\n             set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                   (con_comp_map D E p q y)\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     ys))\n             \\<subseteq> range p \\<union> range q \\<and>\n             R \\<subseteq> range p \\<and>\n             S \\<subseteq> range q \\<and>\n             T \\<subseteq> - range p \\<and>\n             T \\<subseteq> - range q \\<and>\n             (map (inv p)\n               (filter (\\<lambda>x. x \\<in> range p)\n                 (xs @\n                  ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                   (con_comp_map D E p q y)\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     ys))),\n              inv p ` R)\n             \\<in> failures P \\<and>\n             (map (inv q)\n               (filter (\\<lambda>x. x \\<in> range q)\n                 (xs @\n                  ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                   (con_comp_map D E p q y)\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     ys))),\n              inv q ` S)\n             \\<in> failures Q;\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv q ` S)\n     \\<in> failures Q;\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys) Y =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) ys))),\n      inv q ` S)\n     \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                       (con_comp_map D E p q y) ys Y =\n                      R \\<union> S \\<union> T \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                            (con_comp_map D E p q y) ys)\n                      \\<subseteq> range p \\<union> range q \\<and>\n                      R \\<subseteq> range p \\<and>\n                      S \\<subseteq> range q \\<and>\n                      T \\<subseteq> - range p \\<and>\n                      T \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p)\n                          (xs @\n                           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                            (con_comp_map D E p q y) ys)),\n                       inv p ` R)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q)\n                          (xs @\n                           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                            (con_comp_map D E p q y) ys)),\n                       inv q ` S)\n                      \\<in> failures Q", "qed (simp only: con_comp_ipurge_tr_filter con_comp_ipurge_ref_filter)"], ["proof (state)\nthis:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys Y =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) ys)\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) ys)),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) ys)),\n      inv q ` S)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "let\n      ?I' = \"con_comp_pol I\" and\n      ?D' = \"con_comp_map D E p q\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "case False"], ["proof (state)\nthis:\n  \\<not> length xs < length xs'\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  \\<not> length xs < length xs'\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"xs @ ipurge_tr ?I' ?D' (?D' y) ys =\n      take (length xs') (xs @ ipurge_tr ?I' ?D' (?D' y) ys) @\n      drop (length xs') (xs @ ipurge_tr ?I' ?D' (?D' y) ys)\"\n      (is \"_ = _ @ ?vs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys =\n    take (length xs')\n     (xs @\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys) @\n    drop (length xs')\n     (xs @\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys)", "by (simp only: append_take_drop_id)"], ["proof (state)\nthis:\n  xs @\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   ys =\n  take (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys) @\n  drop (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> length xs < length xs'\n  xs @\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   ys =\n  take (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys) @\n  drop (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys)", "have \"xs @ ipurge_tr ?I' ?D' (?D' y) ys =\n      take (length xs') (xs @ y # ys) @ ?vs\""], ["proof (prove)\nusing this:\n  \\<not> length xs < length xs'\n  xs @\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   ys =\n  take (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys) @\n  drop (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys)\n\ngoal (1 subgoal):\n 1. xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys =\n    take (length xs') (xs @ y # ys) @\n    drop (length xs')\n     (xs @\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys)", "by simp"], ["proof (state)\nthis:\n  xs @\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   ys =\n  take (length xs') (xs @ y # ys) @\n  drop (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "hence H: \"xs @ ipurge_tr ?I' ?D' (?D' y) ys = xs' @ ?vs\""], ["proof (prove)\nusing this:\n  xs @\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   ys =\n  take (length xs') (xs @ y # ys) @\n  drop (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys)\n\ngoal (1 subgoal):\n 1. xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys =\n    xs' @\n    drop (length xs')\n     (xs @\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys)", "using G"], ["proof (prove)\nusing this:\n  xs @\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   ys =\n  take (length xs') (xs @ y # ys) @\n  drop (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys)\n  xs @ y # ys = xs' @ ys'\n\ngoal (1 subgoal):\n 1. xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys =\n    xs' @\n    drop (length xs')\n     (xs @\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys)", "by simp"], ["proof (state)\nthis:\n  xs @\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   ys =\n  xs' @\n  drop (length xs')\n   (xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "show ?G"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "proof (rule_tac x = xs' in exI, rule conjI, rule_tac x = ?vs in exI)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs @\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) ys =\n    xs' @\n    drop (length xs')\n     (xs @\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys)\n 2. set xs' \\<subseteq> range p \\<union> range q \\<and>\n    map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n    \\<in> divergences P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n    \\<in> divergences Q", "qed (subst H, simp_all add: D E F)"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     (\\<exists>ys'.\n         xs @\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) ys =\n         xs' @ ys') \\<and>\n     set xs' \\<subseteq> range p \\<union> range q \\<and>\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n     \\<in> divergences P \\<and>\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n     \\<in> divergences Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys Y =\n      R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys)\n      \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p)\n        (filter (\\<lambda>x. x \\<in> range p)\n          (xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys)),\n       inv p ` R)\n      \\<in> failures P \\<and>\n      (map (inv q)\n        (filter (\\<lambda>x. x \\<in> range q)\n          (xs @\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) ys)),\n       inv q ` S)\n      \\<in> failures Q) \\<or>\n  (\\<exists>xs'.\n      (\\<exists>ys'.\n          xs @\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) ys =\n          xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n      \\<in> divergences P \\<and>\n      map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n      \\<in> divergences Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_secure_add_case_1:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\" and\n    D: \"(xs @ y # ys, Y) \\<in> con_comp_failures P Q p q\" and\n    E: \"y \\<in> range p \\<or> y \\<in> range q\"\n  shows\n   \"\\<exists>R S T.\n      Z = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set zs \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ zs. x \\<in> range p], inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ zs. x \\<in> range q], inv q ` S) \\<in> failures Q \\<Longrightarrow>\n    \\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs) \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range p],\n       inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range q],\n       inv q ` S) \\<in> failures Q\"\n  (is \"_ \\<Longrightarrow> \\<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \\<and> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       Z = R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set zs \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n        inv q ` S)\n       \\<in> failures Q \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q", "proof ((erule exE)+, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S T.\n       \\<lbrakk>Z = R \\<union> S \\<union> T;\n        set xs \\<subseteq> range p \\<union> range q;\n        set zs \\<subseteq> range p \\<union> range q; R \\<subseteq> range p;\n        S \\<subseteq> range q; T \\<subseteq> - range p;\n        T \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n         inv p ` R)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n         inv q ` S)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R S T.\n                            ipurge_ref (con_comp_pol I)\n                             (con_comp_map D E p q) (con_comp_map D E p q y)\n                             zs Z =\n                            R \\<union> S \\<union> T \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            set (ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            R \\<subseteq> range p \\<and>\n                            S \\<subseteq> range q \\<and>\n                            T \\<subseteq> - range p \\<and>\n                            T \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p)\n                                (xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)),\n                             inv p ` R)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q)\n                                (xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)),\n                             inv q ` S)\n                            \\<in> failures Q", "fix R S T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S T.\n       \\<lbrakk>Z = R \\<union> S \\<union> T;\n        set xs \\<subseteq> range p \\<union> range q;\n        set zs \\<subseteq> range p \\<union> range q; R \\<subseteq> range p;\n        S \\<subseteq> range q; T \\<subseteq> - range p;\n        T \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n         inv p ` R)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n         inv q ` S)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R S T.\n                            ipurge_ref (con_comp_pol I)\n                             (con_comp_map D E p q) (con_comp_map D E p q y)\n                             zs Z =\n                            R \\<union> S \\<union> T \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            set (ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            R \\<subseteq> range p \\<and>\n                            S \\<subseteq> range q \\<and>\n                            T \\<subseteq> - range p \\<and>\n                            T \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p)\n                                (xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)),\n                             inv p ` R)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q)\n                                (xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)),\n                             inv q ` S)\n                            \\<in> failures Q", "assume\n    F: \"Z = R \\<union> S \\<union> T\" and\n    G: \"set xs \\<subseteq> range p \\<union> range q\" and\n    H: \"set zs \\<subseteq> range p \\<union> range q\" and\n    I: \"R \\<subseteq> range p\" and\n    J: \"S \\<subseteq> range q\" and\n    K: \"T \\<subseteq> - range p\" and\n    L: \"T \\<subseteq> - range q\" and\n    M: \"(map (inv p) [x\\<leftarrow>xs @ zs. x \\<in> range p], inv p ` R) \\<in> failures P\" and\n    N: \"(map (inv q) [x\\<leftarrow>xs @ zs. x \\<in> range q], inv q ` S) \\<in> failures Q\""], ["proof (state)\nthis:\n  Z = R \\<union> S \\<union> T\n  set xs \\<subseteq> range p \\<union> range q\n  set zs \\<subseteq> range p \\<union> range q\n  R \\<subseteq> range p\n  S \\<subseteq> range q\n  T \\<subseteq> - range p\n  T \\<subseteq> - range q\n  (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)), inv p ` R)\n  \\<in> failures P\n  (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)), inv q ` S)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<And>R S T.\n       \\<lbrakk>Z = R \\<union> S \\<union> T;\n        set xs \\<subseteq> range p \\<union> range q;\n        set zs \\<subseteq> range p \\<union> range q; R \\<subseteq> range p;\n        S \\<subseteq> range q; T \\<subseteq> - range p;\n        T \\<subseteq> - range q;\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n         inv p ` R)\n        \\<in> failures P;\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n         inv q ` S)\n        \\<in> failures Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R S T.\n                            ipurge_ref (con_comp_pol I)\n                             (con_comp_map D E p q) (con_comp_map D E p q y)\n                             zs Z =\n                            R \\<union> S \\<union> T \\<and>\n                            set xs\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            set (ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)\n                            \\<subseteq> range p \\<union> range q \\<and>\n                            R \\<subseteq> range p \\<and>\n                            S \\<subseteq> range q \\<and>\n                            T \\<subseteq> - range p \\<and>\n                            T \\<subseteq> - range q \\<and>\n                            (map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p)\n                                (xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)),\n                             inv p ` R)\n                            \\<in> failures P \\<and>\n                            (map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q)\n                                (xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs)),\n                             inv q ` S)\n                            \\<in> failures Q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q", "proof (rule_tac x = \"ipurge_ref ?I' ?D' (?D' y) zs R\" in exI,\n   rule_tac x = \"ipurge_ref ?I' ?D' (?D' y) zs S\" in exI, rule_tac x = \"{}\" in exI,\n   (subst conj_assoc [symmetric])+, (rule conjI)+, simp_all del: filter_append)"], ["proof (state)\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "have \"ipurge_ref ?I' ?D' (?D' y) zs Z =\n      ipurge_ref ?I' ?D' (?D' y) zs (R \\<union> S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs (R \\<union> S \\<union> T)", "using F"], ["proof (prove)\nusing this:\n  Z = R \\<union> S \\<union> T\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs (R \\<union> S \\<union> T)", "by simp"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs Z =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs (R \\<union> S \\<union> T)\n\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "hence \"ipurge_ref ?I' ?D' (?D' y) zs Z =\n      ipurge_ref ?I' ?D' (?D' y) zs R \\<union>\n      ipurge_ref ?I' ?D' (?D' y) zs S \\<union>\n      ipurge_ref ?I' ?D' (?D' y) zs T\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs Z =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs (R \\<union> S \\<union> T)\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs T", "by (simp add: ipurge_ref_distrib_union)"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs Z =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs T\n\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "moreover"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs Z =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs T\n\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "have \"ipurge_ref ?I' ?D' (?D' y) zs T = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs T =\n    {}", "proof (rule ipurge_ref_empty [of \"?D' y\"], simp, insert E,\n     cases \"y \\<in> range p\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "assume O: \"x \\<in> T\""], ["proof (state)\nthis:\n  x \\<in> T\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "with K"], ["proof (chain)\npicking this:\n  T \\<subseteq> - range p\n  x \\<in> T", "have \"x \\<in> - range p\""], ["proof (prove)\nusing this:\n  T \\<subseteq> - range p\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> - range p", ".."], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "have \"x \\<in> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> - range q", "using L and O"], ["proof (prove)\nusing this:\n  T \\<subseteq> - range q\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> - range q", ".."], ["proof (state)\nthis:\n  x \\<in> - range q\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> - range p\n  x \\<in> - range q", "have \"?D' x = None\""], ["proof (prove)\nusing this:\n  x \\<in> - range p\n  x \\<in> - range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = None", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x = None\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (D (inv p y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "thus \"(Some (D (inv p y)), ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = None\n\ngoal (1 subgoal):\n 1. (Some (D (inv p y)), con_comp_map D E p q x) \\<in> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (Some (D (inv p y)), con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "assume O: \"x \\<in> T\""], ["proof (state)\nthis:\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "with K"], ["proof (chain)\npicking this:\n  T \\<subseteq> - range p\n  x \\<in> T", "have \"x \\<in> - range p\""], ["proof (prove)\nusing this:\n  T \\<subseteq> - range p\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> - range p", ".."], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  x \\<in> - range p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "have \"x \\<in> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> - range q", "using L and O"], ["proof (prove)\nusing this:\n  T \\<subseteq> - range q\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> - range q", ".."], ["proof (state)\nthis:\n  x \\<in> - range q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> - range p\n  x \\<in> - range q", "have \"?D' x = None\""], ["proof (prove)\nusing this:\n  x \\<in> - range p\n  x \\<in> - range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = None", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x = None\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> T; y \\<in> range q; y \\<notin> range p\\<rbrakk>\n       \\<Longrightarrow> (Some (E (inv q y)), con_comp_map D E p q x)\n                         \\<in> con_comp_pol I", "thus \"(Some (E (inv q y)), ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = None\n\ngoal (1 subgoal):\n 1. (Some (E (inv q y)), con_comp_map D E p q x) \\<in> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (Some (E (inv q y)), con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs T =\n  {}\n\ngoal (7 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 5. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs Z =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs T\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs T =\n  {}", "show \"ipurge_ref ?I' ?D' (?D' y) zs Z =\n      ipurge_ref ?I' ?D' (?D' y) zs R \\<union>\n      ipurge_ref ?I' ?D' (?D' y) zs S\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs Z =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs T\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs T =\n  {}\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs Z =\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R \\<union>\n    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S", "by simp"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs Z =\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R \\<union>\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S\n\ngoal (6 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 5. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 6. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 4. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 5. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 6. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "show \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using G"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "."], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (5 subgoals):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "have \"set (ipurge_tr ?I' ?D' (?D' y) zs) \\<subseteq> set zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> set zs", "by (rule ipurge_tr_set)"], ["proof (state)\nthis:\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)\n  \\<subseteq> set zs\n\ngoal (5 subgoals):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 3. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "thus \"set (ipurge_tr ?I' ?D' (?D' y) zs) \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)\n  \\<subseteq> set zs\n\ngoal (1 subgoal):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q", "using H"], ["proof (prove)\nusing this:\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)\n  \\<subseteq> set zs\n  set zs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)\n    \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)\n  \\<subseteq> range p \\<union> range q\n\ngoal (4 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "have \"ipurge_ref ?I' ?D' (?D' y) zs R \\<subseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> R", "by (rule ipurge_ref_subset)"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R\n  \\<subseteq> R\n\ngoal (4 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p\n 2. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "thus \"ipurge_ref ?I' ?D' (?D' y) zs R \\<subseteq> range p\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R\n  \\<subseteq> R\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p", "using I"], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R\n  \\<subseteq> R\n  R \\<subseteq> range p\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs R\n    \\<subseteq> range p", "by simp"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs R\n  \\<subseteq> range p\n\ngoal (3 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "have \"ipurge_ref ?I' ?D' (?D' y) zs S \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> S", "by (rule ipurge_ref_subset)"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S\n  \\<subseteq> S\n\ngoal (3 subgoals):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "thus \"ipurge_ref ?I' ?D' (?D' y) zs S \\<subseteq> range q\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q", "using J"], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S\n  \\<subseteq> S\n  S \\<subseteq> range q\n\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs S\n    \\<subseteq> range q", "by simp"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y) zs S\n  \\<subseteq> range q\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "have \"map (inv p) [x\\<leftarrow>xs @ y # ys. x \\<in> range p] \\<in> traces P \\<and>\n      map (inv q) [x\\<leftarrow>xs @ y # ys. x \\<in> range q] \\<in> traces Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys))\n    \\<in> traces P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys))\n    \\<in> traces Q", "using D"], ["proof (prove)\nusing this:\n  (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys))\n    \\<in> traces P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys))\n    \\<in> traces Q", "by (rule con_comp_failures_traces)"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys))\n  \\<in> traces P \\<and>\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys))\n  \\<in> traces Q\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>(xs @ [y]) @ ys. x \\<in> range p] \\<in> traces P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys))\n  \\<in> traces P \\<and>\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys))\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys))\n    \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys))\n  \\<in> traces P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] @\n      map (inv p) [x\\<leftarrow>ys. x \\<in> range p] \\<in> traces P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ((xs @ [y]) @ ys))\n  \\<in> traces P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n    map (inv p) (filter (\\<lambda>x. x \\<in> range p) ys)\n    \\<in> traces P", "by (subst (asm) filter_append, simp)"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ys)\n  \\<in> traces P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>xs @ [y]. x \\<in> range p] \\<in> traces P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y])) @\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) ys)\n  \\<in> traces P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y]))\n    \\<in> traces P", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y]))\n  \\<in> traces P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "thus \"(map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr ?I' ?D' (?D' y) zs. x \\<in> range p],\n      inv p ` ipurge_ref ?I' ?D' (?D' y) zs R) \\<in> failures P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ [y]))\n  \\<in> traces P\n\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv p `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs R)\n    \\<in> failures P", "by (rule con_comp_secure_add_aux_1 [OF B E H I M])"], ["proof (state)\nthis:\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @\n       y #\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)),\n   inv p `\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs R)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "have \"map (inv p) [x\\<leftarrow>xs @ y # ys. x \\<in> range p] \\<in> traces P \\<and>\n      map (inv q) [x\\<leftarrow>xs @ y # ys. x \\<in> range q] \\<in> traces Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys))\n    \\<in> traces P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys))\n    \\<in> traces Q", "using D"], ["proof (prove)\nusing this:\n  (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys))\n    \\<in> traces P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys))\n    \\<in> traces Q", "by (rule con_comp_failures_traces)"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys))\n  \\<in> traces P \\<and>\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys))\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>(xs @ [y]) @ ys. x \\<in> range q] \\<in> traces Q\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys))\n  \\<in> traces P \\<and>\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys))\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) ((xs @ [y]) @ ys))\n    \\<in> traces Q", "by simp"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ((xs @ [y]) @ ys))\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>xs @ [y]. x \\<in> range q] @\n      map (inv q) [x\\<leftarrow>ys. x \\<in> range q] \\<in> traces Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ((xs @ [y]) @ ys))\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y])) @\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) ys)\n    \\<in> traces Q", "by (subst (asm) filter_append, simp)"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y])) @\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ys)\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>xs @ [y]. x \\<in> range q] \\<in> traces Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y])) @\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) ys)\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n    \\<in> traces Q", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "thus \"(map (inv q) [x\\<leftarrow>xs @ y # ipurge_tr ?I' ?D' (?D' y) zs. x \\<in> range q],\n      inv q ` ipurge_ref ?I' ?D' (?D' y) zs S) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ [y]))\n  \\<in> traces Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs)),\n     inv q `\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs S)\n    \\<in> failures Q", "by (rule con_comp_secure_add_aux_2 [OF A C E H J N])"], ["proof (state)\nthis:\n  (map (inv q)\n    (filter (\\<lambda>x. x \\<in> range q)\n      (xs @\n       y #\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs)),\n   inv q `\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs S)\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) zs)\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) zs)),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) zs)),\n      inv q ` S)\n     \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_secure_add_case_2:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\" and\n    D: \"(xs @ y # ys, Y) \\<in> con_comp_failures P Q p q\" and\n    E: \"y \\<in> range p \\<or> y \\<in> range q\"\n  shows\n   \"\\<exists>xs'.\n      (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q \\<Longrightarrow>\n    (\\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z = R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs) \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range p],\n       inv p ` R) \\<in> failures P \\<and>\n      (map (inv q) [x\\<leftarrow>xs @ y # ipurge_tr (con_comp_pol I)\n         (con_comp_map D E p q) (con_comp_map D E p q y) zs. x \\<in> range q],\n       inv q ` S) \\<in> failures Q) \\<or>\n    (\\<exists>xs'.\n      (\\<exists>ys'. xs @ y # ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs = xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P \\<and>\n      map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q)\"\n  (is \"_ \\<Longrightarrow> (\\<exists>R S T. ?F R S T zs) \\<or> ?G\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       (\\<exists>ys'. xs @ zs = xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q \\<Longrightarrow>\n    (\\<exists>R S T.\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z =\n        R \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) zs)\n        \\<subseteq> range p \\<union> range q \\<and>\n        R \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p)\n          (filter (\\<lambda>x. x \\<in> range p)\n            (xs @\n             y #\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) zs)),\n         inv p ` R)\n        \\<in> failures P \\<and>\n        (map (inv q)\n          (filter (\\<lambda>x. x \\<in> range q)\n            (xs @\n             y #\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) zs)),\n         inv q ` S)\n        \\<in> failures Q) \\<or>\n    (\\<exists>xs'.\n        (\\<exists>ys'.\n            xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs =\n            xs' @ ys') \\<and>\n        set xs' \\<subseteq> range p \\<union> range q \\<and>\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P \\<and>\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q)", "proof (erule exE, (erule conjE)+, erule exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>set xs' \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q;\n        xs @ zs = xs' @ ys'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>R S T.\n                             ipurge_ref (con_comp_pol I)\n                              (con_comp_map D E p q)\n                              (con_comp_map D E p q y) zs Z =\n                             R \\<union> S \\<union> T \\<and>\n                             set xs\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             set (ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             R \\<subseteq> range p \\<and>\n                             S \\<subseteq> range q \\<and>\n                             T \\<subseteq> - range p \\<and>\n                             T \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p)\n                                 (xs @\n                                  y #\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)),\n                              inv p ` R)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q)\n                                 (xs @\n                                  y #\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)),\n                              inv q ` S)\n                             \\<in> failures Q) \\<or>\n                         (\\<exists>xs'.\n                             (\\<exists>ys'.\n                                 xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs =\n                                 xs' @ ys') \\<and>\n                             set xs'\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs')\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs')\n                             \\<in> divergences Q)", "fix xs' ys'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>set xs' \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q;\n        xs @ zs = xs' @ ys'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>R S T.\n                             ipurge_ref (con_comp_pol I)\n                              (con_comp_map D E p q)\n                              (con_comp_map D E p q y) zs Z =\n                             R \\<union> S \\<union> T \\<and>\n                             set xs\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             set (ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             R \\<subseteq> range p \\<and>\n                             S \\<subseteq> range q \\<and>\n                             T \\<subseteq> - range p \\<and>\n                             T \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p)\n                                 (xs @\n                                  y #\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)),\n                              inv p ` R)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q)\n                                 (xs @\n                                  y #\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)),\n                              inv q ` S)\n                             \\<in> failures Q) \\<or>\n                         (\\<exists>xs'.\n                             (\\<exists>ys'.\n                                 xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs =\n                                 xs' @ ys') \\<and>\n                             set xs'\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs')\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs')\n                             \\<in> divergences Q)", "assume\n    F: \"set xs' \\<subseteq> range p \\<union> range q\" and\n    G: \"map (inv p) [x\\<leftarrow>xs'. x \\<in> range p] \\<in> divergences P\" and\n    H: \"map (inv q) [x\\<leftarrow>xs'. x \\<in> range q] \\<in> divergences Q\" and\n    I: \"xs @ zs = xs' @ ys'\""], ["proof (state)\nthis:\n  set xs' \\<subseteq> range p \\<union> range q\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs') \\<in> divergences P\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs') \\<in> divergences Q\n  xs @ zs = xs' @ ys'\n\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>set xs' \\<subseteq> range p \\<union> range q;\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P;\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q;\n        xs @ zs = xs' @ ys'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>R S T.\n                             ipurge_ref (con_comp_pol I)\n                              (con_comp_map D E p q)\n                              (con_comp_map D E p q y) zs Z =\n                             R \\<union> S \\<union> T \\<and>\n                             set xs\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             set (ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             R \\<subseteq> range p \\<and>\n                             S \\<subseteq> range q \\<and>\n                             T \\<subseteq> - range p \\<and>\n                             T \\<subseteq> - range q \\<and>\n                             (map (inv p)\n                               (filter (\\<lambda>x. x \\<in> range p)\n                                 (xs @\n                                  y #\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)),\n                              inv p ` R)\n                             \\<in> failures P \\<and>\n                             (map (inv q)\n                               (filter (\\<lambda>x. x \\<in> range q)\n                                 (xs @\n                                  y #\n                                  ipurge_tr (con_comp_pol I)\n                                   (con_comp_map D E p q)\n                                   (con_comp_map D E p q y) zs)),\n                              inv q ` S)\n                             \\<in> failures Q) \\<or>\n                         (\\<exists>xs'.\n                             (\\<exists>ys'.\n                                 xs @\n                                 y #\n                                 ipurge_tr (con_comp_pol I)\n                                  (con_comp_map D E p q)\n                                  (con_comp_map D E p q y) zs =\n                                 xs' @ ys') \\<and>\n                             set xs'\n                             \\<subseteq> range p \\<union> range q \\<and>\n                             map (inv p)\n                              (filter (\\<lambda>x. x \\<in> range p) xs')\n                             \\<in> divergences P \\<and>\n                             map (inv q)\n                              (filter (\\<lambda>x. x \\<in> range q) xs')\n                             \\<in> divergences Q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>R S T.\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z =\n        R \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) zs)\n        \\<subseteq> range p \\<union> range q \\<and>\n        R \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p)\n          (filter (\\<lambda>x. x \\<in> range p)\n            (xs @\n             y #\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) zs)),\n         inv p ` R)\n        \\<in> failures P \\<and>\n        (map (inv q)\n          (filter (\\<lambda>x. x \\<in> range q)\n            (xs @\n             y #\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) zs)),\n         inv q ` S)\n        \\<in> failures Q) \\<or>\n    (\\<exists>xs'.\n        (\\<exists>ys'.\n            xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs =\n            xs' @ ys') \\<and>\n        set xs' \\<subseteq> range p \\<union> range q \\<and>\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n        \\<in> divergences P \\<and>\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n        \\<in> divergences Q)", "proof (cases \"length xs < length xs'\", rule disjI1, rule_tac [2] disjI2)"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "case True"], ["proof (state)\nthis:\n  length xs < length xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  length xs < length xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"take (length xs') (xs @ zs) =\n      take (length xs') xs @ take (length xs' - length xs) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length xs') (xs @ zs) =\n    take (length xs') xs @ take (length xs' - length xs) zs", "by simp"], ["proof (state)\nthis:\n  take (length xs') (xs @ zs) =\n  take (length xs') xs @ take (length xs' - length xs) zs\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  length xs < length xs'\n  take (length xs') (xs @ zs) =\n  take (length xs') xs @ take (length xs' - length xs) zs", "have \"take (length xs') (xs @ zs) =\n      xs @ take (length xs' - length xs) zs\"\n      (is \"_ = _ @ ?vs\")"], ["proof (prove)\nusing this:\n  length xs < length xs'\n  take (length xs') (xs @ zs) =\n  take (length xs') xs @ take (length xs' - length xs) zs\n\ngoal (1 subgoal):\n 1. take (length xs') (xs @ zs) = xs @ take (length xs' - length xs) zs", "by simp"], ["proof (state)\nthis:\n  take (length xs') (xs @ zs) = xs @ take (length xs' - length xs) zs\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  take (length xs') (xs @ zs) = xs @ take (length xs' - length xs) zs\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"take (length xs') (xs @ zs) =\n      take (length xs') (xs' @ ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length xs') (xs @ zs) = take (length xs') (xs' @ ys')", "using I"], ["proof (prove)\nusing this:\n  xs @ zs = xs' @ ys'\n\ngoal (1 subgoal):\n 1. take (length xs') (xs @ zs) = take (length xs') (xs' @ ys')", "by simp"], ["proof (state)\nthis:\n  take (length xs') (xs @ zs) = take (length xs') (xs' @ ys')\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  take (length xs') (xs @ zs) = xs @ take (length xs' - length xs) zs\n  take (length xs') (xs @ zs) = take (length xs') (xs' @ ys')", "have J: \"xs @ ?vs = xs'\""], ["proof (prove)\nusing this:\n  take (length xs') (xs @ zs) = xs @ take (length xs' - length xs) zs\n  take (length xs') (xs @ zs) = take (length xs') (xs' @ ys')\n\ngoal (1 subgoal):\n 1. xs @ take (length xs' - length xs) zs = xs'", "by simp"], ["proof (state)\nthis:\n  xs @ take (length xs' - length xs) zs = xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  xs @ take (length xs' - length xs) zs = xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"set xs \\<subseteq> set (xs @ ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set (xs @ take (length xs' - length xs) zs)", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> set (xs @ take (length xs' - length xs) zs)\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  xs @ take (length xs' - length xs) zs = xs'\n  set xs \\<subseteq> set (xs @ take (length xs' - length xs) zs)", "have \"set xs \\<subseteq> set xs'\""], ["proof (prove)\nusing this:\n  xs @ take (length xs' - length xs) zs = xs'\n  set xs \\<subseteq> set (xs @ take (length xs' - length xs) zs)\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set xs'", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> set xs'\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "hence K: \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> set xs'\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using F"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> set xs'\n  set xs' \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"\\<exists>R S T. ?F R S T [x\\<leftarrow>zs. x \\<in> range p \\<union> range q]\"\n      (is \"\\<exists>_ _ _. ipurge_ref ?I' ?D' _ _ _ = _ \\<and> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y)\n             (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y)\n             (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y)\n             (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n        inv q ` S)\n       \\<in> failures Q", "proof (rule con_comp_secure_add_case_1 [OF A B C D E],\n     rule_tac x = \"range p \\<inter> Z\" in exI, rule_tac x = \"range q \\<inter> Z\" in exI,\n     rule_tac x = \"- range p \\<inter> - range q \\<inter> Z\" in exI,\n     (subst conj_assoc [symmetric])+, (rule conjI)+, simp_all del: filter_append)"], ["proof (state)\ngoal (7 subgoals):\n 1. Z =\n    range p \\<inter> Z \\<union> range q \\<inter> Z \\<union>\n    - range p \\<inter> - range q \\<inter> Z\n 2. set xs \\<subseteq> range p \\<union> range q\n 3. {x \\<in> set zs. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 4. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\n 5. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 6. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 7. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "show \"Z = range p \\<inter> Z \\<union> range q \\<inter> Z \\<union> - range p \\<inter> - range q \\<inter> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z =\n    range p \\<inter> Z \\<union> range q \\<inter> Z \\<union>\n    - range p \\<inter> - range q \\<inter> Z", "by blast"], ["proof (state)\nthis:\n  Z =\n  range p \\<inter> Z \\<union> range q \\<inter> Z \\<union>\n  - range p \\<inter> - range q \\<inter> Z\n\ngoal (6 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. {x \\<in> set zs. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 3. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\n 4. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 5. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 6. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. set xs \\<subseteq> range p \\<union> range q\n 2. {x \\<in> set zs. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 3. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\n 4. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 5. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 6. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "show \"set xs \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "using K"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> range p \\<union> range q", "."], ["proof (state)\nthis:\n  set xs \\<subseteq> range p \\<union> range q\n\ngoal (5 subgoals):\n 1. {x \\<in> set zs. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 2. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\n 3. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {x \\<in> set zs. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q\n 2. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\n 3. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 4. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 5. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "show \"{x \\<in> set zs. x \\<in> range p \\<or> x \\<in> range q} \\<subseteq> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> set zs. x \\<in> range p \\<or> x \\<in> range q}\n    \\<subseteq> range p \\<union> range q", "by blast"], ["proof (state)\nthis:\n  {x \\<in> set zs. x \\<in> range p \\<or> x \\<in> range q}\n  \\<subseteq> range p \\<union> range q\n\ngoal (4 subgoals):\n 1. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\n 2. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\n 2. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 3. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 4. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "show \"- range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p", "by blast"], ["proof (state)\nthis:\n  - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range p\n\ngoal (3 subgoals):\n 1. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n 2. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 3. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "show \"- range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q", "by blast"], ["proof (state)\nthis:\n  - range p \\<inter> - range q \\<inter> Z \\<subseteq> - range q\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "have \"map (inv p) [x\\<leftarrow>xs @ ?vs. x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (xs @ take (length xs' - length xs) zs))\n    \\<in> divergences P", "using G and J"], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs') \\<in> divergences P\n  xs @ take (length xs' - length xs) zs = xs'\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (xs @ take (length xs' - length xs) zs))\n    \\<in> divergences P", "by simp"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ take (length xs' - length xs) zs))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>xs @ ?vs. x \\<in> range p] @\n        map (inv p) [x\\<leftarrow>drop (length xs' - length xs) zs. x \\<in> range p]\n        \\<in> divergences P\"\n        (is \"_ @ map (inv p) [x\\<leftarrow>?ws. _] \\<in> _\")"], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ take (length xs' - length xs) zs))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (xs @ take (length xs' - length xs) zs)) @\n    map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (drop (length xs' - length xs) zs))\n    \\<in> divergences P", "by (rule process_rule_5_general)"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ take (length xs' - length xs) zs)) @\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p) (drop (length xs' - length xs) zs))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>(xs @ ?vs) @ ?ws. x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ take (length xs' - length xs) zs)) @\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p) (drop (length xs' - length xs) zs))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       ((xs @ take (length xs' - length xs) zs) @\n        drop (length xs' - length xs) zs))\n    \\<in> divergences P", "by (subst filter_append, simp)"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     ((xs @ take (length xs' - length xs) zs) @\n      drop (length xs' - length xs) zs))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>xs @ zs. x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     ((xs @ take (length xs' - length xs) zs) @\n      drop (length xs' - length xs) zs))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs))\n    \\<in> divergences P", "by simp"], ["proof (state)\nthis:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "hence \"map (inv p) [x\\<leftarrow>xs @ [x\\<leftarrow>zs. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range p] \\<in> divergences P\""], ["proof (prove)\nusing this:\n  map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. map (inv p)\n     (filter (\\<lambda>x. x \\<in> range p)\n       (xs @ filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs))\n    \\<in> divergences P", "proof (subst (asm) filter_append, subst filter_append, subst filter_filter)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv p)\n              (filter (\\<lambda>x. x \\<in> range p) xs @\n               filter (\\<lambda>x. x \\<in> range p) zs)\n             \\<in> divergences P;\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs))\n     \\<in> divergences P;\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs))\n     \\<in> divergences P\\<rbrakk>\n    \\<Longrightarrow> map (inv p)\n                       (filter (\\<lambda>x. x \\<in> range p) xs @\n                        filter\n                         (\\<lambda>x.\n                             (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n                             x \\<in> range p)\n                         zs)\n                      \\<in> divergences P", "qed (subgoal_tac \"(\\<lambda>x. (x \\<in> range p \\<or> x \\<in> range q) \\<and> x \\<in> range p) =\n       (\\<lambda>x. x \\<in> range p)\", simp, blast)"], ["proof (state)\nthis:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs))\n  \\<in> divergences P\n\ngoal (2 subgoals):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P\n 2. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "thus \"(map (inv p) [x\\<leftarrow>xs @ [x\\<leftarrow>zs. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range p], inv p ` (range p \\<inter> Z)) \\<in> failures P\""], ["proof (prove)\nusing this:\n  map (inv p)\n   (filter (\\<lambda>x. x \\<in> range p)\n     (xs @ filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs))\n  \\<in> divergences P\n\ngoal (1 subgoal):\n 1. (map (inv p)\n      (filter (\\<lambda>x. x \\<in> range p)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv p ` (range p \\<inter> Z))\n    \\<in> failures P", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @ filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n   inv p ` (range p \\<inter> Z))\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "have \"map (inv q) [x\\<leftarrow>xs @ ?vs. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (xs @ take (length xs' - length xs) zs))\n    \\<in> divergences Q", "using H and J"], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs') \\<in> divergences Q\n  xs @ take (length xs' - length xs) zs = xs'\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (xs @ take (length xs' - length xs) zs))\n    \\<in> divergences Q", "by simp"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ take (length xs' - length xs) zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>xs @ ?vs. x \\<in> range q] @\n        map (inv q) [x\\<leftarrow>drop (length xs' - length xs) zs. x \\<in> range q]\n        \\<in> divergences Q\"\n        (is \"_ @ map (inv q) [x\\<leftarrow>?ws. _] \\<in> _\")"], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ take (length xs' - length xs) zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (xs @ take (length xs' - length xs) zs)) @\n    map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (drop (length xs' - length xs) zs))\n    \\<in> divergences Q", "by (rule process_rule_5_general)"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ take (length xs' - length xs) zs)) @\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q) (drop (length xs' - length xs) zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>(xs @ ?vs) @ ?ws. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ take (length xs' - length xs) zs)) @\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q) (drop (length xs' - length xs) zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       ((xs @ take (length xs' - length xs) zs) @\n        drop (length xs' - length xs) zs))\n    \\<in> divergences Q", "by (subst filter_append, simp)"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     ((xs @ take (length xs' - length xs) zs) @\n      drop (length xs' - length xs) zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>xs @ zs. x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     ((xs @ take (length xs' - length xs) zs) @\n      drop (length xs' - length xs) zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs))\n    \\<in> divergences Q", "by simp"], ["proof (state)\nthis:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "hence \"map (inv q) [x\\<leftarrow>xs @ [x\\<leftarrow>zs. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range q] \\<in> divergences Q\""], ["proof (prove)\nusing this:\n  map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. map (inv q)\n     (filter (\\<lambda>x. x \\<in> range q)\n       (xs @ filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs))\n    \\<in> divergences Q", "proof (subst (asm) filter_append, subst filter_append, subst filter_filter)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>map (inv q)\n              (filter (\\<lambda>x. x \\<in> range q) xs @\n               filter (\\<lambda>x. x \\<in> range q) zs)\n             \\<in> divergences Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs))\n     \\<in> divergences Q;\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs))\n     \\<in> divergences Q\\<rbrakk>\n    \\<Longrightarrow> map (inv q)\n                       (filter (\\<lambda>x. x \\<in> range q) xs @\n                        filter\n                         (\\<lambda>x.\n                             (x \\<in> range p \\<or> x \\<in> range q) \\<and>\n                             x \\<in> range q)\n                         zs)\n                      \\<in> divergences Q", "qed (subgoal_tac \"(\\<lambda>x. (x \\<in> range p \\<or> x \\<in> range q) \\<and> x \\<in> range q) =\n       (\\<lambda>x. x \\<in> range q)\", simp, blast)"], ["proof (state)\nthis:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "thus \"(map (inv q) [x\\<leftarrow>xs @ [x\\<leftarrow>zs. x \\<in> range p \\<or> x \\<in> range q].\n        x \\<in> range q], inv q ` (range q \\<inter> Z)) \\<in> failures Q\""], ["proof (prove)\nusing this:\n  map (inv q)\n   (filter (\\<lambda>x. x \\<in> range q)\n     (xs @ filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs))\n  \\<in> divergences Q\n\ngoal (1 subgoal):\n 1. (map (inv q)\n      (filter (\\<lambda>x. x \\<in> range q)\n        (xs @\n         filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n     inv q ` (range q \\<inter> Z))\n    \\<in> failures Q", "by (rule process_rule_6)"], ["proof (state)\nthis:\n  (map (inv q)\n    (filter (\\<lambda>x. x \\<in> range q)\n      (xs @ filter (\\<lambda>x. x \\<in> range p \\<or> x \\<in> range q) zs)),\n   inv q ` (range q \\<inter> Z))\n  \\<in> failures Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv q ` S)\n     \\<in> failures Q\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv q ` S)\n     \\<in> failures Q", "obtain R and S and T where\n     \"?F R S T [x\\<leftarrow>zs. x \\<in> range p \\<union> range q]\""], ["proof (prove)\nusing this:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv q ` S)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. (\\<And>R S T.\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y)\n         (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n        R \\<union> S \\<union> T \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y)\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n        \\<subseteq> range p \\<union> range q \\<and>\n        R \\<subseteq> range p \\<and>\n        S \\<subseteq> range q \\<and>\n        T \\<subseteq> - range p \\<and>\n        T \\<subseteq> - range q \\<and>\n        (map (inv p)\n          (filter (\\<lambda>x. x \\<in> range p)\n            (xs @\n             y #\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y)\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n         inv p ` R)\n        \\<in> failures P \\<and>\n        (map (inv q)\n          (filter (\\<lambda>x. x \\<in> range q)\n            (xs @\n             y #\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y)\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n         inv q ` S)\n        \\<in> failures Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y)\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n  R \\<union> S \\<union> T \\<and>\n  set xs \\<subseteq> range p \\<union> range q \\<and>\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n  \\<subseteq> range p \\<union> range q \\<and>\n  R \\<subseteq> range p \\<and>\n  S \\<subseteq> range q \\<and>\n  T \\<subseteq> - range p \\<and>\n  T \\<subseteq> - range q \\<and>\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @\n       y #\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n   inv p ` R)\n  \\<in> failures P \\<and>\n  (map (inv q)\n    (filter (\\<lambda>x. x \\<in> range q)\n      (xs @\n       y #\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n   inv q ` S)\n  \\<in> failures Q\n\ngoal (2 subgoals):\n 1. length xs < length xs' \\<Longrightarrow>\n    \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q\n 2. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "thus \"\\<exists>R S T. ?F R S T zs\""], ["proof (prove)\nusing this:\n  ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n   (con_comp_map D E p q y)\n   (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n  R \\<union> S \\<union> T \\<and>\n  set xs \\<subseteq> range p \\<union> range q \\<and>\n  set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n  \\<subseteq> range p \\<union> range q \\<and>\n  R \\<subseteq> range p \\<and>\n  S \\<subseteq> range q \\<and>\n  T \\<subseteq> - range p \\<and>\n  T \\<subseteq> - range q \\<and>\n  (map (inv p)\n    (filter (\\<lambda>x. x \\<in> range p)\n      (xs @\n       y #\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n   inv p ` R)\n  \\<in> failures P \\<and>\n  (map (inv q)\n    (filter (\\<lambda>x. x \\<in> range q)\n      (xs @\n       y #\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y)\n        (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n   inv q ` S)\n  \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<exists>R S T.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) zs Z =\n       R \\<union> S \\<union> T \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)\n       \\<subseteq> range p \\<union> range q \\<and>\n       R \\<subseteq> range p \\<and>\n       S \\<subseteq> range q \\<and>\n       T \\<subseteq> - range p \\<and>\n       T \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv p ` R)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            y #\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) zs)),\n        inv q ` S)\n       \\<in> failures Q", "proof (rule_tac x = R in exI, rule_tac x = S in exI, rule_tac x = T in exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y)\n              (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n             R \\<union> S \\<union> T \\<and>\n             set xs \\<subseteq> range p \\<union> range q \\<and>\n             set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                   (con_comp_map D E p q y)\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     zs))\n             \\<subseteq> range p \\<union> range q \\<and>\n             R \\<subseteq> range p \\<and>\n             S \\<subseteq> range q \\<and>\n             T \\<subseteq> - range p \\<and>\n             T \\<subseteq> - range q \\<and>\n             (map (inv p)\n               (filter (\\<lambda>x. x \\<in> range p)\n                 (xs @\n                  y #\n                  ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                   (con_comp_map D E p q y)\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     zs))),\n              inv p ` R)\n             \\<in> failures P \\<and>\n             (map (inv q)\n               (filter (\\<lambda>x. x \\<in> range q)\n                 (xs @\n                  y #\n                  ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                   (con_comp_map D E p q y)\n                   (filter (\\<lambda>x. x \\<in> range p \\<union> range q)\n                     zs))),\n              inv q ` S)\n             \\<in> failures Q;\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv q ` S)\n     \\<in> failures Q;\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y)\n      (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs) Z =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y)\n           (filter (\\<lambda>x. x \\<in> range p \\<union> range q) zs))),\n      inv q ` S)\n     \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                       (con_comp_map D E p q y) zs Z =\n                      R \\<union> S \\<union> T \\<and>\n                      set xs \\<subseteq> range p \\<union> range q \\<and>\n                      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                            (con_comp_map D E p q y) zs)\n                      \\<subseteq> range p \\<union> range q \\<and>\n                      R \\<subseteq> range p \\<and>\n                      S \\<subseteq> range q \\<and>\n                      T \\<subseteq> - range p \\<and>\n                      T \\<subseteq> - range q \\<and>\n                      (map (inv p)\n                        (filter (\\<lambda>x. x \\<in> range p)\n                          (xs @\n                           y #\n                           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                            (con_comp_map D E p q y) zs)),\n                       inv p ` R)\n                      \\<in> failures P \\<and>\n                      (map (inv q)\n                        (filter (\\<lambda>x. x \\<in> range q)\n                          (xs @\n                           y #\n                           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                            (con_comp_map D E p q y) zs)),\n                       inv q ` S)\n                      \\<in> failures Q", "qed (simp only: con_comp_ipurge_tr_filter con_comp_ipurge_ref_filter)"], ["proof (state)\nthis:\n  \\<exists>R S T.\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z =\n     R \\<union> S \\<union> T \\<and>\n     set xs \\<subseteq> range p \\<union> range q \\<and>\n     set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) zs)\n     \\<subseteq> range p \\<union> range q \\<and>\n     R \\<subseteq> range p \\<and>\n     S \\<subseteq> range q \\<and>\n     T \\<subseteq> - range p \\<and>\n     T \\<subseteq> - range q \\<and>\n     (map (inv p)\n       (filter (\\<lambda>x. x \\<in> range p)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) zs)),\n      inv p ` R)\n     \\<in> failures P \\<and>\n     (map (inv q)\n       (filter (\\<lambda>x. x \\<in> range q)\n         (xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) zs)),\n      inv q ` S)\n     \\<in> failures Q\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "let\n      ?I' = \"con_comp_pol I\" and\n      ?D' = \"con_comp_map D E p q\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "case False"], ["proof (state)\nthis:\n  \\<not> length xs < length xs'\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "moreover"], ["proof (state)\nthis:\n  \\<not> length xs < length xs'\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "have \"xs @ y # ipurge_tr ?I' ?D' (?D' y) zs =\n      take (length xs') (xs @ y # ipurge_tr ?I' ?D' (?D' y) zs) @\n      drop (length xs') (xs @ y # ipurge_tr ?I' ?D' (?D' y) zs)\"\n      (is \"_ = _ @ ?vs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs =\n    take (length xs')\n     (xs @\n      y #\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs) @\n    drop (length xs')\n     (xs @\n      y #\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs)", "by (simp only: append_take_drop_id)"], ["proof (state)\nthis:\n  xs @\n  y #\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   zs =\n  take (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs) @\n  drop (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> length xs < length xs'\n  xs @\n  y #\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   zs =\n  take (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs) @\n  drop (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs)", "have \"xs @ y # ipurge_tr ?I' ?D' (?D' y) zs =\n      take (length xs') (xs @ zs) @ ?vs\""], ["proof (prove)\nusing this:\n  \\<not> length xs < length xs'\n  xs @\n  y #\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   zs =\n  take (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs) @\n  drop (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs)\n\ngoal (1 subgoal):\n 1. xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs =\n    take (length xs') (xs @ zs) @\n    drop (length xs')\n     (xs @\n      y #\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs)", "by simp"], ["proof (state)\nthis:\n  xs @\n  y #\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   zs =\n  take (length xs') (xs @ zs) @\n  drop (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "hence J: \"xs @ y # ipurge_tr ?I' ?D' (?D' y) zs = xs' @ ?vs\""], ["proof (prove)\nusing this:\n  xs @\n  y #\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   zs =\n  take (length xs') (xs @ zs) @\n  drop (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs)\n\ngoal (1 subgoal):\n 1. xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs =\n    xs' @\n    drop (length xs')\n     (xs @\n      y #\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs)", "using I"], ["proof (prove)\nusing this:\n  xs @\n  y #\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   zs =\n  take (length xs') (xs @ zs) @\n  drop (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs)\n  xs @ zs = xs' @ ys'\n\ngoal (1 subgoal):\n 1. xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs =\n    xs' @\n    drop (length xs')\n     (xs @\n      y #\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs)", "by simp"], ["proof (state)\nthis:\n  xs @\n  y #\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) (con_comp_map D E p q y)\n   zs =\n  xs' @\n  drop (length xs')\n   (xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs < length xs' \\<Longrightarrow>\n    \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "show ?G"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       (\\<exists>ys'.\n           xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs =\n           xs' @ ys') \\<and>\n       set xs' \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n       \\<in> divergences Q", "proof (rule_tac x = xs' in exI, rule conjI, rule_tac x = ?vs in exI)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs @\n    y #\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n     (con_comp_map D E p q y) zs =\n    xs' @\n    drop (length xs')\n     (xs @\n      y #\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs)\n 2. set xs' \\<subseteq> range p \\<union> range q \\<and>\n    map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n    \\<in> divergences P \\<and>\n    map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n    \\<in> divergences Q", "qed (subst J, simp_all add: F G H)"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     (\\<exists>ys'.\n         xs @\n         y #\n         ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n          (con_comp_map D E p q y) zs =\n         xs' @ ys') \\<and>\n     set xs' \\<subseteq> range p \\<union> range q \\<and>\n     map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n     \\<in> divergences P \\<and>\n     map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n     \\<in> divergences Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>R S T.\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs Z =\n      R \\<union> S \\<union> T \\<and>\n      set xs \\<subseteq> range p \\<union> range q \\<and>\n      set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs)\n      \\<subseteq> range p \\<union> range q \\<and>\n      R \\<subseteq> range p \\<and>\n      S \\<subseteq> range q \\<and>\n      T \\<subseteq> - range p \\<and>\n      T \\<subseteq> - range q \\<and>\n      (map (inv p)\n        (filter (\\<lambda>x. x \\<in> range p)\n          (xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs)),\n       inv p ` R)\n      \\<in> failures P \\<and>\n      (map (inv q)\n        (filter (\\<lambda>x. x \\<in> range q)\n          (xs @\n           y #\n           ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n            (con_comp_map D E p q y) zs)),\n       inv q ` S)\n      \\<in> failures Q) \\<or>\n  (\\<exists>xs'.\n      (\\<exists>ys'.\n          xs @\n          y #\n          ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n           (con_comp_map D E p q y) zs =\n          xs' @ ys') \\<and>\n      set xs' \\<subseteq> range p \\<union> range q \\<and>\n      map (inv p) (filter (\\<lambda>x. x \\<in> range p) xs')\n      \\<in> divergences P \\<and>\n      map (inv q) (filter (\\<lambda>x. x \\<in> range q) xs')\n      \\<in> divergences Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem con_comp_secure:\n  assumes\n    A: \"consistent_maps D E p q\" and\n    B: \"secure P I D\" and\n    C: \"secure Q I E\"\n  shows \"secure (P \\<parallel> Q <p, q>) (con_comp_pol I) (con_comp_map D E p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure (P \\<parallel> Q <p, q>) (con_comp_pol I) (con_comp_map D E p q)", "proof (simp add: secure_def con_comp_futures, (rule allI)+, rule impI,\n erule conjE, rule conjI, (erule rev_mp)+, rotate_tac [2], erule_tac [2] rev_mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs y ys Y zs Z.\n       (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @\n        ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys,\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys Y)\n       \\<in> con_comp_failures P Q p q\n 2. \\<And>xs y ys Y zs Z.\n       (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n       (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @\n        y #\n        ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs,\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z)\n       \\<in> con_comp_failures P Q p q", "fix xs y ys Y zs Z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs y ys Y zs Z.\n       (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @\n        ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys,\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys Y)\n       \\<in> con_comp_failures P Q p q\n 2. \\<And>xs y ys Y zs Z.\n       (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n       (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @\n        y #\n        ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs,\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z)\n       \\<in> con_comp_failures P Q p q", "show\n   \"(xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n    (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n      (xs @ ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys,\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys Y)\n      \\<in> con_comp_failures P Q p q\"\n    (is \"_ \\<longrightarrow> _ \\<longrightarrow> (_ @ ipurge_tr ?I' ?D' _ _, _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n    (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n    (xs @\n     ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys,\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys Y)\n    \\<in> con_comp_failures P Q p q", "proof ((rule impI)+, thin_tac \"(xs @ zs, Z) \\<in> con_comp_failures P Q p q\",\n   simp_all add: con_comp_failures_def con_comp_divergences_def\n   del: filter_append, erule disjE, rule disjI1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>X Ya Z.\n       Y = X \\<union> Ya \\<union> Z \\<and>\n       (y \\<in> range p \\<or> y \\<in> range q) \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set ys \\<subseteq> range p \\<union> range q \\<and>\n       X \\<subseteq> range p \\<and>\n       Ya \\<subseteq> range q \\<and>\n       Z \\<subseteq> - range p \\<and>\n       Z \\<subseteq> - range q \\<and>\n       (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ y # ys)),\n        inv p ` X)\n       \\<in> failures P \\<and>\n       (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ y # ys)),\n        inv q ` Ya)\n       \\<in> failures Q \\<Longrightarrow>\n    \\<exists>X Ya Z.\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n        (con_comp_map D E p q y) ys Y =\n       X \\<union> Ya \\<union> Z \\<and>\n       set xs \\<subseteq> range p \\<union> range q \\<and>\n       set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)\n       \\<subseteq> range p \\<union> range q \\<and>\n       X \\<subseteq> range p \\<and>\n       Ya \\<subseteq> range q \\<and>\n       Z \\<subseteq> - range p \\<and>\n       Z \\<subseteq> - range q \\<and>\n       (map (inv p)\n         (filter (\\<lambda>x. x \\<in> range p)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv p ` X)\n       \\<in> failures P \\<and>\n       (map (inv q)\n         (filter (\\<lambda>x. x \\<in> range q)\n           (xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys)),\n        inv q ` Ya)\n       \\<in> failures Q\n 2. \\<exists>xsa.\n       (\\<exists>ysa. xs @ y # ys = xsa @ ysa) \\<and>\n       set xsa \\<subseteq> range p \\<union> range q \\<and>\n       map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n       \\<in> divergences P \\<and>\n       map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n       \\<in> divergences Q \\<Longrightarrow>\n    (\\<exists>X Ya Z.\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) ys Y =\n        X \\<union> Ya \\<union> Z \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        set (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)\n        \\<subseteq> range p \\<union> range q \\<and>\n        X \\<subseteq> range p \\<and>\n        Ya \\<subseteq> range q \\<and>\n        Z \\<subseteq> - range p \\<and>\n        Z \\<subseteq> - range q \\<and>\n        (map (inv p)\n          (filter (\\<lambda>x. x \\<in> range p)\n            (xs @\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)),\n         inv p ` X)\n        \\<in> failures P \\<and>\n        (map (inv q)\n          (filter (\\<lambda>x. x \\<in> range q)\n            (xs @\n             ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n              (con_comp_map D E p q y) ys)),\n         inv q ` Ya)\n        \\<in> failures Q) \\<or>\n    (\\<exists>xsa.\n        (\\<exists>ysa.\n            xs @\n            ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n             (con_comp_map D E p q y) ys =\n            xsa @ ysa) \\<and>\n        set xsa \\<subseteq> range p \\<union> range q \\<and>\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P \\<and>\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q)", "qed (erule con_comp_secure_del_case_1 [OF A B C],\n   rule con_comp_secure_del_case_2 [OF A B C])"], ["proof (state)\nthis:\n  (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n  (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n  (xs @\n   ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) ys,\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) ys Y)\n  \\<in> con_comp_failures P Q p q\n\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n       (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @\n        y #\n        ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs,\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z)\n       \\<in> con_comp_failures P Q p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n       (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @\n        y #\n        ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs,\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z)\n       \\<in> con_comp_failures P Q p q", "fix xs y ys Y zs Z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n       (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @\n        y #\n        ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs,\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z)\n       \\<in> con_comp_failures P Q p q", "assume D: \"(xs @ y # ys, Y) \\<in> con_comp_failures P Q p q\""], ["proof (state)\nthis:\n  (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q\n\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       (xs @ y # ys, Y) \\<in> con_comp_failures P Q p q \\<Longrightarrow>\n       (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n       (xs @\n        y #\n        ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs,\n        ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z)\n       \\<in> con_comp_failures P Q p q", "show\n   \"(xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n      (xs @ y # ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs,\n       ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n         (con_comp_map D E p q y) zs Z)\n      \\<in> con_comp_failures P Q p q\"\n    (is \"_ \\<longrightarrow> (_ @ _ # ipurge_tr ?I' ?D' _ _, _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n    (xs @\n     y #\n     ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs,\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z)\n    \\<in> con_comp_failures P Q p q", "proof (rule impI, simp_all add: con_comp_failures_def con_comp_divergences_def\n   del: filter_append, cases \"y \\<in> range p \\<or> y \\<in> range q\", simp del: filter_append,\n   erule disjE, rule disjI1, rule_tac [3] disjI2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>y \\<in> range p \\<or> y \\<in> range q;\n     \\<exists>X Y Za.\n        Z = X \\<union> Y \\<union> Za \\<and>\n        set xs \\<subseteq> range p \\<union> range q \\<and>\n        set zs \\<subseteq> range p \\<union> range q \\<and>\n        X \\<subseteq> range p \\<and>\n        Y \\<subseteq> range q \\<and>\n        Za \\<subseteq> - range p \\<and>\n        Za \\<subseteq> - range q \\<and>\n        (map (inv p) (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n         inv p ` X)\n        \\<in> failures P \\<and>\n        (map (inv q) (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n         inv q ` Y)\n        \\<in> failures Q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X Y Za.\n                         ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                          (con_comp_map D E p q y) zs Z =\n                         X \\<union> Y \\<union> Za \\<and>\n                         set xs \\<subseteq> range p \\<union> range q \\<and>\n                         set (ipurge_tr (con_comp_pol I)\n                               (con_comp_map D E p q)\n                               (con_comp_map D E p q y) zs)\n                         \\<subseteq> range p \\<union> range q \\<and>\n                         X \\<subseteq> range p \\<and>\n                         Y \\<subseteq> range q \\<and>\n                         Za \\<subseteq> - range p \\<and>\n                         Za \\<subseteq> - range q \\<and>\n                         (map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p)\n                             (xs @\n                              y #\n                              ipurge_tr (con_comp_pol I)\n                               (con_comp_map D E p q)\n                               (con_comp_map D E p q y) zs)),\n                          inv p ` X)\n                         \\<in> failures P \\<and>\n                         (map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q)\n                             (xs @\n                              y #\n                              ipurge_tr (con_comp_pol I)\n                               (con_comp_map D E p q)\n                               (con_comp_map D E p q y) zs)),\n                          inv q ` Y)\n                         \\<in> failures Q\n 2. \\<lbrakk>y \\<in> range p \\<or> y \\<in> range q;\n     \\<exists>xsa.\n        (\\<exists>ys. xs @ zs = xsa @ ys) \\<and>\n        set xsa \\<subseteq> range p \\<union> range q \\<and>\n        map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n        \\<in> divergences P \\<and>\n        map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n        \\<in> divergences Q\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>X Y Za.\n                          ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                           (con_comp_map D E p q y) zs Z =\n                          X \\<union> Y \\<union> Za \\<and>\n                          set xs \\<subseteq> range p \\<union> range q \\<and>\n                          set (ipurge_tr (con_comp_pol I)\n                                (con_comp_map D E p q)\n                                (con_comp_map D E p q y) zs)\n                          \\<subseteq> range p \\<union> range q \\<and>\n                          X \\<subseteq> range p \\<and>\n                          Y \\<subseteq> range q \\<and>\n                          Za \\<subseteq> - range p \\<and>\n                          Za \\<subseteq> - range q \\<and>\n                          (map (inv p)\n                            (filter (\\<lambda>x. x \\<in> range p)\n                              (xs @\n                               y #\n                               ipurge_tr (con_comp_pol I)\n                                (con_comp_map D E p q)\n                                (con_comp_map D E p q y) zs)),\n                           inv p ` X)\n                          \\<in> failures P \\<and>\n                          (map (inv q)\n                            (filter (\\<lambda>x. x \\<in> range q)\n                              (xs @\n                               y #\n                               ipurge_tr (con_comp_pol I)\n                                (con_comp_map D E p q)\n                                (con_comp_map D E p q y) zs)),\n                           inv q ` Y)\n                          \\<in> failures Q) \\<or>\n                      (\\<exists>xsa.\n                          (\\<exists>ys.\n                              xs @\n                              y #\n                              ipurge_tr (con_comp_pol I)\n                               (con_comp_map D E p q)\n                               (con_comp_map D E p q y) zs =\n                              xsa @ ys) \\<and>\n                          set xsa\n                          \\<subseteq> range p \\<union> range q \\<and>\n                          map (inv p)\n                           (filter (\\<lambda>x. x \\<in> range p) xsa)\n                          \\<in> divergences P \\<and>\n                          map (inv q)\n                           (filter (\\<lambda>x. x \\<in> range q) xsa)\n                          \\<in> divergences Q)\n 3. \\<lbrakk>(\\<exists>X Y Za.\n                 Z = X \\<union> Y \\<union> Za \\<and>\n                 set xs \\<subseteq> range p \\<union> range q \\<and>\n                 set zs \\<subseteq> range p \\<union> range q \\<and>\n                 X \\<subseteq> range p \\<and>\n                 Y \\<subseteq> range q \\<and>\n                 Za \\<subseteq> - range p \\<and>\n                 Za \\<subseteq> - range q \\<and>\n                 (map (inv p)\n                   (filter (\\<lambda>x. x \\<in> range p) (xs @ zs)),\n                  inv p ` X)\n                 \\<in> failures P \\<and>\n                 (map (inv q)\n                   (filter (\\<lambda>x. x \\<in> range q) (xs @ zs)),\n                  inv q ` Y)\n                 \\<in> failures Q) \\<or>\n             (\\<exists>xsa.\n                 (\\<exists>ys. xs @ zs = xsa @ ys) \\<and>\n                 set xsa \\<subseteq> range p \\<union> range q \\<and>\n                 map (inv p) (filter (\\<lambda>x. x \\<in> range p) xsa)\n                 \\<in> divergences P \\<and>\n                 map (inv q) (filter (\\<lambda>x. x \\<in> range q) xsa)\n                 \\<in> divergences Q);\n     \\<not> (y \\<in> range p \\<or> y \\<in> range q)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xsa.\n                         (\\<exists>ys.\n                             xs @\n                             y #\n                             ipurge_tr (con_comp_pol I)\n                              (con_comp_map D E p q)\n                              (con_comp_map D E p q y) zs =\n                             xsa @ ys) \\<and>\n                         set xsa \\<subseteq> range p \\<union> range q \\<and>\n                         map (inv p)\n                          (filter (\\<lambda>x. x \\<in> range p) xsa)\n                         \\<in> divergences P \\<and>\n                         map (inv q)\n                          (filter (\\<lambda>x. x \\<in> range q) xsa)\n                         \\<in> divergences Q", "qed (erule con_comp_secure_add_case_1 [OF A B C D], assumption,\n   erule con_comp_secure_add_case_2 [OF A B C D], assumption,\n   rule con_comp_failures_divergences [OF D], simp_all)"], ["proof (state)\nthis:\n  (xs @ zs, Z) \\<in> con_comp_failures P Q p q \\<longrightarrow>\n  (xs @\n   y #\n   ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs,\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs Z)\n  \\<in> con_comp_failures P Q p q\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Conservation of noninterference security in the absence of fake events\""], ["", "text \\<open>\nIn what follows, it is proven that in the absence of fake events, namely if\n@{term \"range p \\<union> range q = UNIV\"}, the output of the concurrent composition of two secure processes\nis secure with respect to the same noninterference policy enforced by the input processes, and to\nthe event-domain map that simply associates each event to the same security domain as the\ncorresponding events of the input processes.\n\nMore formally, for any two processes @{term P}, @{term Q} being secure with respect to the\nnoninterference policy @{term I} and the event-domain maps @{term D}, @{term E}, their concurrent\ncomposition @{term \"P \\<parallel> Q <p, q>\"} is secure with respect to the same noninterference policy\n@{term I} and the event-domain map @{term \"the \\<circ> con_comp_map D E p q\"}, provided that conditions\n@{term \"range p \\<union> range q = UNIV\"} and @{term \"consistent_maps D E p q\"} are satisfied.\n\n\\null\n\\<close>"], ["", "lemma con_comp_sinks_range:\n \"u \\<in> range Some \\<Longrightarrow>\n  set xs \\<subseteq> range p \\<union> range q \\<Longrightarrow>\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> range Some;\n     set xs \\<subseteq> range p \\<union> range q\\<rbrakk>\n    \\<Longrightarrow> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n                      \\<subseteq> range Some", "by (insert con_comp_sinks_aux_range [of \"{u}\" xs p q I D E],\n simp add: sinks_aux_single_dom)"], ["", "lemma con_comp_sinks_no_fake:\n  assumes\n    A: \"range p \\<union> range q = UNIV\" and\n    B: \"u \\<in> range Some\"\n  shows \"sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\"\n    (is \"_ = the ` sinks ?I' ?D' _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n       the `\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<Longrightarrow>\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n       the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n       the `\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<Longrightarrow>\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n       the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "assume C: \"sinks I (the \\<circ> ?D') (the u) xs = the ` sinks ?I' ?D' u xs\""], ["proof (state)\nthis:\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n  the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n       the `\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<Longrightarrow>\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n       the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "have \"x \\<in> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range p \\<union> range q", "using A"], ["proof (prove)\nusing this:\n  range p \\<union> range q = UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n       the `\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<Longrightarrow>\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n       the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence D: \"?D' x = Some (the (?D' x))\""], ["proof (prove)\nusing this:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = Some (the (con_comp_map D E p q x))", "by (cases \"x \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n       the `\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<Longrightarrow>\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n       the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "have E: \"u = Some (the u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = Some (the u)", "using B"], ["proof (prove)\nusing this:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. u = Some (the u)", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  u = Some (the u)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n       the `\n       sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<Longrightarrow>\n       sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n       the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "show \"sinks I (the \\<circ> ?D') (the u) (xs @ [x]) = the ` sinks ?I' ?D' u (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "proof (cases \"(u, ?D' x) \\<in> ?I' \\<or> (\\<exists>v \\<in> sinks ?I' ?D' u xs. (v, ?D' x) \\<in> ?I')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n    (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n 2. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "case True"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n  (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n      (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n    (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n 2. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"sinks ?I' ?D' u (xs @ [x]) = insert (?D' x) (sinks ?I' ?D' u xs)\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n  (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n      (v, con_comp_map D E p q x) \\<in> con_comp_pol I)\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    insert (con_comp_map D E p q x)\n     (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n    (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n 2. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n    (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n 2. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "have \"(the u, the (?D' x)) \\<in> I \\<or>\n      (\\<exists>d \\<in> sinks I (the \\<circ> ?D') (the u) xs. (d, the (?D' x)) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the u, the (con_comp_map D E p q x)) \\<in> I \\<or>\n    (\\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n        (d, the (con_comp_map D E p q x)) \\<in> I)", "proof (rule disjE [OF True], rule disjI1, rule_tac [2] disjI2)"], ["proof (state)\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    (the u, the (con_comp_map D E p q x)) \\<in> I\n 2. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "assume \"(u, ?D' x) \\<in> ?I'\""], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    (the u, the (con_comp_map D E p q x)) \\<in> I\n 2. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "hence \"(Some (the u), Some (the (?D' x))) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (Some (the u), Some (the (con_comp_map D E p q x))) \\<in> con_comp_pol I", "using D and E"], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<in> con_comp_pol I\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n  u = Some (the u)\n\ngoal (1 subgoal):\n 1. (Some (the u), Some (the (con_comp_map D E p q x))) \\<in> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (Some (the u), Some (the (con_comp_map D E p q x))) \\<in> con_comp_pol I\n\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    (the u, the (con_comp_map D E p q x)) \\<in> I\n 2. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "thus \"(the u, the (?D' x)) \\<in> I\""], ["proof (prove)\nusing this:\n  (Some (the u), Some (the (con_comp_map D E p q x))) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (the u, the (con_comp_map D E p q x)) \\<in> I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (the u, the (con_comp_map D E p q x)) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "assume \"\\<exists>v \\<in> sinks ?I' ?D' u xs. (v, ?D' x) \\<in> ?I'\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I", "obtain v where F: \"v \\<in> sinks ?I' ?D' u xs\" and G: \"(v, ?D' x) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs;\n         (v, con_comp_map D E p q x) \\<in> con_comp_pol I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "have \"sinks ?I' ?D' u xs \\<subseteq> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n    \\<subseteq> range Some", "by (rule con_comp_sinks_range, simp_all add: A B)"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "hence \"v \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", "using F"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", ".."], ["proof (state)\nthis:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "hence \"v = Some (the v)\""], ["proof (prove)\nusing this:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. v = Some (the v)", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  v = Some (the v)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "hence \"(Some (the v), Some (the (?D' x))) \\<in> ?I'\""], ["proof (prove)\nusing this:\n  v = Some (the v)\n\ngoal (1 subgoal):\n 1. (Some (the v), Some (the (con_comp_map D E p q x))) \\<in> con_comp_pol I", "using D and G"], ["proof (prove)\nusing this:\n  v = Some (the v)\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n  (v, con_comp_map D E p q x) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (Some (the v), Some (the (con_comp_map D E p q x))) \\<in> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (Some (the v), Some (the (con_comp_map D E p q x))) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "hence \"(the v, the (?D' x)) \\<in> I\""], ["proof (prove)\nusing this:\n  (Some (the v), Some (the (con_comp_map D E p q x))) \\<in> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (the v, the (con_comp_map D E p q x)) \\<in> I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (the v, the (con_comp_map D E p q x)) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "moreover"], ["proof (state)\nthis:\n  (the v, the (con_comp_map D E p q x)) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "have \"the v \\<in> sinks I (the \\<circ> ?D') (the u) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) xs", "using C and F"], ["proof (prove)\nusing this:\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n  the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. the v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) xs", "by simp"], ["proof (state)\nthis:\n  the v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<in> con_comp_pol I \\<Longrightarrow>\n    \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", "ultimately"], ["proof (chain)\npicking this:\n  (the v, the (con_comp_map D E p q x)) \\<in> I\n  the v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) xs", "show \"\\<exists>d \\<in> sinks I (the \\<circ> ?D') (the u) xs.\n        (d, the (?D' x)) \\<in> I\""], ["proof (prove)\nusing this:\n  (the v, the (con_comp_map D E p q x)) \\<in> I\n  the v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n       (d, the (con_comp_map D E p q x)) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n     (d, the (con_comp_map D E p q x)) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (the u, the (con_comp_map D E p q x)) \\<in> I \\<or>\n  (\\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n      (d, the (con_comp_map D E p q x)) \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n    (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n 2. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"sinks I (the \\<circ> ?D') (the u) (xs @ [x]) =\n      insert (the (?D' x)) (sinks I (the \\<circ> ?D') (the u) xs)\""], ["proof (prove)\nusing this:\n  (the u, the (con_comp_map D E p q x)) \\<in> I \\<or>\n  (\\<exists>d\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u) xs.\n      (d, the (con_comp_map D E p q x)) \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    insert (the (con_comp_map D E p q x))\n     (sinks I (the \\<circ> con_comp_map D E p q) (the u) xs)", "by simp"], ["proof (state)\nthis:\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  insert (the (con_comp_map D E p q x))\n   (sinks I (the \\<circ> con_comp_map D E p q) (the u) xs)\n\ngoal (2 subgoals):\n 1. (u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n    (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<in> con_comp_pol I) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n 2. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  insert (the (con_comp_map D E p q x))\n   (sinks I (the \\<circ> con_comp_map D E p q) (the u) xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  insert (the (con_comp_map D E p q x))\n   (sinks I (the \\<circ> con_comp_map D E p q) (the u) xs)\n\ngoal (1 subgoal):\n 1. sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "using C"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  insert (con_comp_map D E p q x)\n   (sinks (con_comp_pol I) (con_comp_map D E p q) u xs)\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  insert (the (con_comp_map D E p q x))\n   (sinks I (the \\<circ> con_comp_map D E p q) (the u) xs)\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n  the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "case False"], ["proof (state)\nthis:\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           xs.\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\n\ngoal (1 subgoal):\n 1. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"sinks ?I' ?D' u (xs @ [x]) = sinks ?I' ?D' u xs\""], ["proof (prove)\nusing this:\n  \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n          (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                           xs.\n              (v, con_comp_map D E p q x) \\<in> con_comp_pol I))\n\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    sinks (con_comp_pol I) (con_comp_map D E p q) u xs", "by simp"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "have \"\\<not> ((the u, the (?D' x)) \\<in> I \\<or>\n      (\\<exists>v \\<in> sinks I (the \\<circ> ?D') (the u) xs. (v, the (?D' x)) \\<in> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ((the u, the (con_comp_map D E p q x)) \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I (the \\<circ> con_comp_map D E p q)\n                             (the u) xs.\n                (v, the (con_comp_map D E p q x)) \\<in> I))", "proof (insert False, simp, erule conjE, rule conjI, rule_tac [2] ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> (the u, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "assume \"(u, ?D' x) \\<notin> ?I'\""], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> (the u, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "hence \"(Some (the u), Some (the (?D' x))) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (Some (the u), Some (the (con_comp_map D E p q x)))\n    \\<notin> con_comp_pol I", "using D and E"], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n  u = Some (the u)\n\ngoal (1 subgoal):\n 1. (Some (the u), Some (the (con_comp_map D E p q x)))\n    \\<notin> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (Some (the u), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> (the u, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "thus \"(the u, the (?D' x)) \\<notin> I\""], ["proof (prove)\nusing this:\n  (Some (the u), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (the u, the (con_comp_map D E p q x)) \\<notin> I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (the u, the (con_comp_map D E p q x)) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "assume \"d \\<in> sinks I (the \\<circ> ?D') (the u) xs\""], ["proof (state)\nthis:\n  d \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "hence \"d \\<in> the ` sinks ?I' ?D' u xs\""], ["proof (prove)\nusing this:\n  d \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. d \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs", "using C"], ["proof (prove)\nusing this:\n  d \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) xs\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n  the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. d \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs", "by simp"], ["proof (state)\nthis:\n  d \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "hence \"\\<exists>v \\<in> sinks ?I' ?D' u xs. d = the v\""], ["proof (prove)\nusing this:\n  d \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       d = the v", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     d = the v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     d = the v", "obtain v where F: \"v \\<in> sinks ?I' ?D' u xs\" and G: \"d = the v\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     d = the v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs;\n         d = the v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  d = the v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "have \"sinks ?I' ?D' u xs \\<subseteq> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n    \\<subseteq> range Some", "by (rule con_comp_sinks_range, simp_all add: A B)"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "hence \"v \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", "using F"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", ".."], ["proof (state)\nthis:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "hence H: \"v = Some d\""], ["proof (prove)\nusing this:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. v = Some d", "using G"], ["proof (prove)\nusing this:\n  v \\<in> range Some\n  d = the v\n\ngoal (1 subgoal):\n 1. v = Some d", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  v = Some d\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "assume \"\\<forall>v \\<in> sinks ?I' ?D' u xs. (v, ?D' x) \\<notin> ?I'\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "hence \"(v, ?D' x) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "using F"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", ".."], ["proof (state)\nthis:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "hence \"(Some d, Some (the (?D' x))) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (Some d, Some (the (con_comp_map D E p q x))) \\<notin> con_comp_pol I", "using D and H"], ["proof (prove)\nusing this:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n  v = Some d\n\ngoal (1 subgoal):\n 1. (Some d, Some (the (con_comp_map D E p q x))) \\<notin> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (Some d, Some (the (con_comp_map D E p q x))) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                 xs\\<rbrakk>\n       \\<Longrightarrow> (v, the (con_comp_map D E p q x)) \\<notin> I", "thus \"(d, the (?D' x)) \\<notin> I\""], ["proof (prove)\nusing this:\n  (Some d, Some (the (con_comp_map D E p q x))) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (d, the (con_comp_map D E p q x)) \\<notin> I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (d, the (con_comp_map D E p q x)) \\<notin> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> ((the u, the (con_comp_map D E p q x)) \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                           xs.\n              (v, the (con_comp_map D E p q x)) \\<in> I))\n\ngoal (1 subgoal):\n 1. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "hence \"sinks I (the \\<circ> ?D') (the u) (xs @ [x]) = sinks I (the \\<circ> ?D') (the u) xs\""], ["proof (prove)\nusing this:\n  \\<not> ((the u, the (con_comp_map D E p q x)) \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I (the \\<circ> con_comp_map D E p q) (the u)\n                           xs.\n              (v, the (con_comp_map D E p q x)) \\<in> I))\n\ngoal (1 subgoal):\n 1. sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) xs", "by simp"], ["proof (state)\nthis:\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. \\<not> ((u, con_comp_map D E p q x) \\<in> con_comp_pol I \\<or>\n            (\\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                             xs.\n                (v, con_comp_map D E p q x)\n                \\<in> con_comp_pol I)) \\<Longrightarrow>\n    sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "using C"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) xs =\n  the ` sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_ipurge_tr_no_fake:\n  assumes\n    A: \"range p \\<union> range q = UNIV\" and\n    B: \"u \\<in> range Some\"\n  shows \"ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs\"\n    (is \"ipurge_tr ?I' ?D' _ _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n       ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u)\n        xs \\<Longrightarrow>\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n       ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n       ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u)\n        xs \\<Longrightarrow>\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n       ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "assume C: \"ipurge_tr ?I' ?D' u xs = ipurge_tr I (the \\<circ> ?D') (the u) xs\""], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n       ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u)\n        xs \\<Longrightarrow>\n       ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n       ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "show \"ipurge_tr ?I' ?D' u (xs @ [x]) = ipurge_tr I (the \\<circ> ?D') (the u) (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "proof (cases \"?D' x \\<in> sinks ?I' ?D' u (xs @ [x])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n 2. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "case True"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (2 subgoals):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n 2. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "hence \"ipurge_tr ?I' ?D' u (xs @ [x]) = ipurge_tr ?I' ?D' u xs\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (2 subgoals):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n 2. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (2 subgoals):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n 2. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "have \"the (?D' x) \\<in> the ` sinks ?I' ?D' u (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "using True"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  the (con_comp_map D E p q x)\n  \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (2 subgoals):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n 2. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "hence \"the (?D' x) \\<in> sinks I (the \\<circ> ?D') (the u) (xs @ [x])\""], ["proof (prove)\nusing this:\n  the (con_comp_map D E p q x)\n  \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "by (subst con_comp_sinks_no_fake [OF A B])"], ["proof (state)\nthis:\n  the (con_comp_map D E p q x)\n  \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n\ngoal (2 subgoals):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n 2. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "hence \"ipurge_tr I (the \\<circ> ?D') (the u) (xs @ [x]) =\n      ipurge_tr I (the \\<circ> ?D') (the u) xs\""], ["proof (prove)\nusing this:\n  the (con_comp_map D E p q x)\n  \\<in> sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (2 subgoals):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n 2. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "using C"], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "case False"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "hence \"ipurge_tr ?I' ?D' u (xs @ [x]) = ipurge_tr ?I' ?D' u xs @ [x]\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "have \"the (?D' x) \\<notin> the ` sinks ?I' ?D' u (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<notin> the `\n             sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "assume \"the (?D' x) \\<in> the ` sinks ?I' ?D' u (xs @ [x])\""], ["proof (state)\nthis:\n  the (con_comp_map D E p q x)\n  \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "hence \"\\<exists>v \\<in> sinks ?I' ?D' u (xs @ [x]). the (?D' x) = the v\""], ["proof (prove)\nusing this:\n  the (con_comp_map D E p q x)\n  \\<in> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u\n                    (xs @ [x]).\n       the (con_comp_map D E p q x) = the v", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]).\n     the (con_comp_map D E p q x) = the v\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]).\n     the (con_comp_map D E p q x) = the v", "obtain v where\n        D: \"v \\<in> sinks ?I' ?D' u (xs @ [x])\" and E: \"the (?D' x) = the v\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]).\n     the (con_comp_map D E p q x) = the v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u\n                          (xs @ [x]);\n         the (con_comp_map D E p q x) = the v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n  the (con_comp_map D E p q x) = the v\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "have \"x \\<in> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range p \\<union> range q", "using A"], ["proof (prove)\nusing this:\n  range p \\<union> range q = UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "hence \"\\<exists>d. ?D' x = Some d\""], ["proof (prove)\nusing this:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<exists>d. con_comp_map D E p q x = Some d", "by (cases \"x \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  \\<exists>d. con_comp_map D E p q x = Some d\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>d. con_comp_map D E p q x = Some d", "obtain d where \"?D' x = Some d\""], ["proof (prove)\nusing this:\n  \\<exists>d. con_comp_map D E p q x = Some d\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        con_comp_map D E p q x = Some d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  con_comp_map D E p q x = Some d\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  con_comp_map D E p q x = Some d\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "have \"sinks ?I' ?D' u (xs @ [x]) \\<subseteq> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n    \\<subseteq> range Some", "by (rule con_comp_sinks_range, simp_all add: A B)"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "hence \"v \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n  \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", "using D"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n  \\<subseteq> range Some\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", ".."], ["proof (state)\nthis:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "hence \"\\<exists>d'. v = Some d'\""], ["proof (prove)\nusing this:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<exists>d'. v = Some d'", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  \\<exists>d'. v = Some d'\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>d'. v = Some d'", "obtain d' where \"v = Some d'\""], ["proof (prove)\nusing this:\n  \\<exists>d'. v = Some d'\n\ngoal (1 subgoal):\n 1. (\\<And>d'. v = Some d' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v = Some d'\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  con_comp_map D E p q x = Some d\n  v = Some d'", "have \"?D' x = v\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = Some d\n  v = Some d'\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = v", "using E"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = Some d\n  v = Some d'\n  the (con_comp_map D E p q x) = the v\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = v", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x = v\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "hence \"?D' x \\<in> sinks ?I' ?D' u (xs @ [x])\""], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = v\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "using D"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x = v\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<in> the `\n          sinks (con_comp_pol I) (con_comp_map D E p q) u\n           (xs @ [x]) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  con_comp_map D E p q x\n  \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n  con_comp_map D E p q x\n  \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  the (con_comp_map D E p q x)\n  \\<notin> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "hence \"the (?D' x) \\<notin> sinks I (the \\<circ> ?D') (the u) (xs @ [x])\""], ["proof (prove)\nusing this:\n  the (con_comp_map D E p q x)\n  \\<notin> the ` sinks (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x])\n\ngoal (1 subgoal):\n 1. the (con_comp_map D E p q x)\n    \\<notin> sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "by (subst con_comp_sinks_no_fake [OF A B])"], ["proof (state)\nthis:\n  the (con_comp_map D E p q x)\n  \\<notin> sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "hence \"ipurge_tr I (the \\<circ> ?D') (the u) (xs @ [x]) =\n      ipurge_tr I (the \\<circ> ?D') (the u) xs @ [x]\""], ["proof (prove)\nusing this:\n  the (con_comp_map D E p q x)\n  \\<notin> sinks I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs @ [x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs @ [x]\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x\n    \\<notin> sinks (con_comp_pol I) (con_comp_map D E p q) u\n              (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs @ [x]", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs @ [x]\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "using C"], ["proof (prove)\nusing this:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs @ [x]\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs @ [x]\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u xs =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) xs\n\ngoal (1 subgoal):\n 1. ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n    ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr (con_comp_pol I) (con_comp_map D E p q) u (xs @ [x]) =\n  ipurge_tr I (the \\<circ> con_comp_map D E p q) (the u) (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma con_comp_ipurge_ref_no_fake:\n  assumes\n    A: \"range p \\<union> range q = UNIV\" and\n    B: \"u \\<in> range Some\"\n  shows \"ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u xs X =\n    ipurge_ref I (the \\<circ> con_comp_map D E p q) (the u) xs X\"\n    (is \"ipurge_ref ?I' ?D' _ _ _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref (con_comp_pol I) (con_comp_map D E p q) u xs X =\n    ipurge_ref I (the \\<circ> con_comp_map D E p q) (the u) xs X", "proof (simp add: ipurge_ref_def set_eq_iff, rule allI,\n simp_all add: con_comp_sinks_no_fake [OF A B])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<and>\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (v, con_comp_map D E p q x) \\<notin> con_comp_pol I)) =\n       (x \\<in> X \\<and>\n        (the u, the (con_comp_map D E p q x)) \\<notin> I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (the v, the (con_comp_map D E p q x)) \\<notin> I))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<and>\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (v, con_comp_map D E p q x) \\<notin> con_comp_pol I)) =\n       (x \\<in> X \\<and>\n        (the u, the (con_comp_map D E p q x)) \\<notin> I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (the v, the (con_comp_map D E p q x)) \\<notin> I))", "have \"x \\<in> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range p \\<union> range q", "using A"], ["proof (prove)\nusing this:\n  range p \\<union> range q = UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<and>\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (v, con_comp_map D E p q x) \\<notin> con_comp_pol I)) =\n       (x \\<in> X \\<and>\n        (the u, the (con_comp_map D E p q x)) \\<notin> I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (the v, the (con_comp_map D E p q x)) \\<notin> I))", "hence C: \"?D' x = Some (the (?D' x))\""], ["proof (prove)\nusing this:\n  x \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q x = Some (the (con_comp_map D E p q x))", "by (cases \"x \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<and>\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (v, con_comp_map D E p q x) \\<notin> con_comp_pol I)) =\n       (x \\<in> X \\<and>\n        (the u, the (con_comp_map D E p q x)) \\<notin> I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (the v, the (con_comp_map D E p q x)) \\<notin> I))", "have D: \"u = Some (the u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = Some (the u)", "using B"], ["proof (prove)\nusing this:\n  u \\<in> range Some\n\ngoal (1 subgoal):\n 1. u = Some (the u)", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  u = Some (the u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<and>\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (v, con_comp_map D E p q x) \\<notin> con_comp_pol I)) =\n       (x \\<in> X \\<and>\n        (the u, the (con_comp_map D E p q x)) \\<notin> I \\<and>\n        (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n            (the v, the (con_comp_map D E p q x)) \\<notin> I))", "show\n   \"(x \\<in> X \\<and> (u, ?D' x) \\<notin> con_comp_pol I \\<and>\n      (\\<forall>v \\<in> sinks ?I' ?D' u xs. (v, ?D' x) \\<notin> con_comp_pol I)) =\n    (x \\<in> X \\<and> (the u, the (?D' x)) \\<notin> I \\<and>\n      (\\<forall>v \\<in> sinks ?I' ?D' u xs. (the v, the (?D' x)) \\<notin> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> X \\<and>\n     (u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n     (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n         (v, con_comp_map D E p q x) \\<notin> con_comp_pol I)) =\n    (x \\<in> X \\<and>\n     (the u, the (con_comp_map D E p q x)) \\<notin> I \\<and>\n     (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n         (the v, the (con_comp_map D E p q x)) \\<notin> I))", "proof (rule iffI, (erule_tac [!] conjE)+, simp_all, rule_tac [!] conjI,\n   rule_tac [2] ballI, rule_tac [4] ballI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> X; (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> (the u, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 3. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 4. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "assume \"(u, ?D' x) \\<notin> ?I'\""], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> X; (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> (the u, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 3. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 4. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"(Some (the u), Some (the (?D' x))) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (Some (the u), Some (the (con_comp_map D E p q x)))\n    \\<notin> con_comp_pol I", "using C and D"], ["proof (prove)\nusing this:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n  u = Some (the u)\n\ngoal (1 subgoal):\n 1. (Some (the u), Some (the (con_comp_map D E p q x)))\n    \\<notin> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (Some (the u), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> X; (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\\<rbrakk>\n    \\<Longrightarrow> (the u, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 3. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 4. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "thus \"(the u, the (?D' x)) \\<notin> I\""], ["proof (prove)\nusing this:\n  (Some (the u), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (the u, the (con_comp_map D E p q x)) \\<notin> I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (the u, the (con_comp_map D E p q x)) \\<notin> I\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "fix v"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "assume \"\\<forall>v \\<in> sinks ?I' ?D' u xs. (v, ?D' x) \\<notin> ?I'\" and\n      E: \"v \\<in> sinks ?I' ?D' u xs\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"(v, ?D' x) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", ".."], ["proof (state)\nthis:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "have \"sinks ?I' ?D' u xs \\<subseteq> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n    \\<subseteq> range Some", "by (rule con_comp_sinks_range, simp_all add: A B)"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"v \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", "using E"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", ".."], ["proof (state)\nthis:\n  v \\<in> range Some\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"v = Some (the v)\""], ["proof (prove)\nusing this:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. v = Some (the v)", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  v = Some (the v)\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v = Some (the v)", "have \"(Some (the v), Some (the (?D' x))) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v = Some (the v)\n\ngoal (1 subgoal):\n 1. (Some (the v), Some (the (con_comp_map D E p q x)))\n    \\<notin> con_comp_pol I", "using C"], ["proof (prove)\nusing this:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n  v = Some (the v)\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n\ngoal (1 subgoal):\n 1. (Some (the v), Some (the (con_comp_map D E p q x)))\n    \\<notin> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (Some (the v), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X;\n        (u, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (v, con_comp_map D E p q x) \\<notin> con_comp_pol I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (the v, the (con_comp_map D E p q x)) \\<notin> I\n 2. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 3. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "thus \"(the v, the (?D' x)) \\<notin> I\""], ["proof (prove)\nusing this:\n  (Some (the v), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (the v, the (con_comp_map D E p q x)) \\<notin> I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (the v, the (con_comp_map D E p q x)) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 2. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 2. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "assume \"(the u, the (?D' x)) \\<notin> I\""], ["proof (state)\nthis:\n  (the u, the (con_comp_map D E p q x)) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 2. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"(Some (the u), Some (the (?D' x))) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (the u, the (con_comp_map D E p q x)) \\<notin> I\n\ngoal (1 subgoal):\n 1. (Some (the u), Some (the (con_comp_map D E p q x)))\n    \\<notin> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (Some (the u), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n     \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n        (the v, the (con_comp_map D E p q x)) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n 2. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "thus \"(u, ?D' x) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (Some (the u), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "using C and D"], ["proof (prove)\nusing this:\n  (Some (the u), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n  u = Some (the u)\n\ngoal (1 subgoal):\n 1. (u, con_comp_map D E p q x) \\<notin> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (u, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "assume \"\\<forall>v \\<in> sinks ?I' ?D' u xs. (the v, the (?D' x)) \\<notin> I\" and\n      E: \"v \\<in> sinks ?I' ?D' u xs\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (the v, the (con_comp_map D E p q x)) \\<notin> I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"(the v, the (?D' x)) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n     (the v, the (con_comp_map D E p q x)) \\<notin> I\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. (the v, the (con_comp_map D E p q x)) \\<notin> I", ".."], ["proof (state)\nthis:\n  (the v, the (con_comp_map D E p q x)) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"(Some (the v), Some (the (?D' x))) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (the v, the (con_comp_map D E p q x)) \\<notin> I\n\ngoal (1 subgoal):\n 1. (Some (the v), Some (the (con_comp_map D E p q x)))\n    \\<notin> con_comp_pol I", "by (simp add: con_comp_pol_def)"], ["proof (state)\nthis:\n  (Some (the v), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "moreover"], ["proof (state)\nthis:\n  (Some (the v), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "have \"sinks ?I' ?D' u xs \\<subseteq> range Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n    \\<subseteq> range Some", "by (rule con_comp_sinks_range, simp_all add: A B)"], ["proof (state)\nthis:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"v \\<in> range Some\""], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", "using E"], ["proof (prove)\nusing this:\n  sinks (con_comp_pol I) (con_comp_map D E p q) u xs \\<subseteq> range Some\n  v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\n\ngoal (1 subgoal):\n 1. v \\<in> range Some", ".."], ["proof (state)\nthis:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "hence \"v = Some (the v)\""], ["proof (prove)\nusing this:\n  v \\<in> range Some\n\ngoal (1 subgoal):\n 1. v = Some (the v)", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  v = Some (the v)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x \\<in> X; (the u, the (con_comp_map D E p q x)) \\<notin> I;\n        \\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n           (the v, the (con_comp_map D E p q x)) \\<notin> I;\n        v \\<in> sinks (con_comp_pol I) (con_comp_map D E p q) u xs\\<rbrakk>\n       \\<Longrightarrow> (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "ultimately"], ["proof (chain)\npicking this:\n  (Some (the v), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n  v = Some (the v)", "show \"(v, ?D' x) \\<notin> ?I'\""], ["proof (prove)\nusing this:\n  (Some (the v), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n  v = Some (the v)\n\ngoal (1 subgoal):\n 1. (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "using C"], ["proof (prove)\nusing this:\n  (Some (the v), Some (the (con_comp_map D E p q x)))\n  \\<notin> con_comp_pol I\n  v = Some (the v)\n  con_comp_map D E p q x = Some (the (con_comp_map D E p q x))\n\ngoal (1 subgoal):\n 1. (v, con_comp_map D E p q x) \\<notin> con_comp_pol I", "by simp"], ["proof (state)\nthis:\n  (v, con_comp_map D E p q x) \\<notin> con_comp_pol I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> X \\<and>\n   (u, con_comp_map D E p q x) \\<notin> con_comp_pol I \\<and>\n   (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (v, con_comp_map D E p q x) \\<notin> con_comp_pol I)) =\n  (x \\<in> X \\<and>\n   (the u, the (con_comp_map D E p q x)) \\<notin> I \\<and>\n   (\\<forall>v\\<in>sinks (con_comp_pol I) (con_comp_map D E p q) u xs.\n       (the v, the (con_comp_map D E p q x)) \\<notin> I))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem con_comp_secure_no_fake:\n  assumes\n    A: \"range p \\<union> range q = UNIV\" and\n    B: \"consistent_maps D E p q\" and\n    C: \"secure P I D\" and\n    D: \"secure Q I E\"\n  shows \"secure (P \\<parallel> Q <p, q>) I (the \\<circ> con_comp_map D E p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure (P \\<parallel> Q <p, q>) I (the \\<circ> con_comp_map D E p q)", "proof (insert con_comp_secure [OF B C D], simp add: secure_def,\n (rule allI)+, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>\\<forall>xs y ys Y zs Z.\n                   (y # ys, Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (zs, Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>)\n                          xs \\<longrightarrow>\n                   (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (y #\n                    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs;\n        (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n        (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys Y)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                         (y #\n                          ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs Z)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs", "fix xs y ys Y zs Z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>\\<forall>xs y ys Y zs Z.\n                   (y # ys, Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (zs, Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>)\n                          xs \\<longrightarrow>\n                   (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (y #\n                    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs;\n        (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n        (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys Y)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                         (y #\n                          ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs Z)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs", "let\n    ?I' = \"con_comp_pol I\" and\n    ?D' = \"con_comp_map D E p q\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>\\<forall>xs y ys Y zs Z.\n                   (y # ys, Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (zs, Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>)\n                          xs \\<longrightarrow>\n                   (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (y #\n                    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs;\n        (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n        (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys Y)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                         (y #\n                          ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs Z)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs", "have \"y \\<in> range p \\<union> range q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> range p \\<union> range q", "using A"], ["proof (prove)\nusing this:\n  range p \\<union> range q = UNIV\n\ngoal (1 subgoal):\n 1. y \\<in> range p \\<union> range q", "by simp"], ["proof (state)\nthis:\n  y \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>\\<forall>xs y ys Y zs Z.\n                   (y # ys, Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (zs, Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>)\n                          xs \\<longrightarrow>\n                   (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (y #\n                    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs;\n        (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n        (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys Y)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                         (y #\n                          ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs Z)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs", "hence E: \"?D' y \\<in> range Some\""], ["proof (prove)\nusing this:\n  y \\<in> range p \\<union> range q\n\ngoal (1 subgoal):\n 1. con_comp_map D E p q y \\<in> range Some", "by (cases \"y \\<in> range p\", simp_all)"], ["proof (state)\nthis:\n  con_comp_map D E p q y \\<in> range Some\n\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>\\<forall>xs y ys Y zs Z.\n                   (y # ys, Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (zs, Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>)\n                          xs \\<longrightarrow>\n                   (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (y #\n                    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs;\n        (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n        (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys Y)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                         (y #\n                          ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs Z)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs", "assume \"\\<forall>xs y ys Y zs Z.\n    (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n    (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<longrightarrow>\n      (ipurge_tr ?I' ?D' (?D' y) ys, ipurge_ref ?I' ?D' (?D' y) ys Y)\n        \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n      (y # ipurge_tr ?I' ?D' (?D' y) zs, ipurge_ref ?I' ?D' (?D' y) zs Z)\n        \\<in> futures (P \\<parallel> Q <p, q>) xs\" and\n   \"(y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n    (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\""], ["proof (state)\nthis:\n  \\<forall>xs y ys Y zs Z.\n     (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n     (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<longrightarrow>\n     (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys,\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys Y)\n     \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n     (y #\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs,\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs Z)\n     \\<in> futures (P \\<parallel> Q <p, q>) xs\n  (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n  (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>\\<forall>xs y ys Y zs Z.\n                   (y # ys, Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (zs, Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>)\n                          xs \\<longrightarrow>\n                   (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (y #\n                    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs;\n        (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n        (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys Y)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                         (y #\n                          ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs Z)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs", "hence\n   \"(ipurge_tr ?I' ?D' (?D' y) ys, ipurge_ref ?I' ?D' (?D' y) ys Y)\n      \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n    (y # ipurge_tr ?I' ?D' (?D' y) zs, ipurge_ref ?I' ?D' (?D' y) zs Z)\n      \\<in> futures (P \\<parallel> Q <p, q>) xs\""], ["proof (prove)\nusing this:\n  \\<forall>xs y ys Y zs Z.\n     (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n     (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<longrightarrow>\n     (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys,\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) ys Y)\n     \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n     (y #\n      ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs,\n      ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n       (con_comp_map D E p q y) zs Z)\n     \\<in> futures (P \\<parallel> Q <p, q>) xs\n  (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n  (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\n\ngoal (1 subgoal):\n 1. (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys,\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) ys Y)\n    \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n    (y #\n     ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs,\n     ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n      (con_comp_map D E p q y) zs Z)\n    \\<in> futures (P \\<parallel> Q <p, q>) xs", "by blast"], ["proof (state)\nthis:\n  (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) ys,\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) ys Y)\n  \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n  (y #\n   ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs,\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs Z)\n  \\<in> futures (P \\<parallel> Q <p, q>) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>\\<forall>xs y ys Y zs Z.\n                   (y # ys, Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (zs, Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>)\n                          xs \\<longrightarrow>\n                   (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) ys Y)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                   (y #\n                    ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs,\n                    ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n                     (con_comp_map D E p q y) zs Z)\n                   \\<in> futures (P \\<parallel> Q <p, q>) xs;\n        (y # ys, Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n        (zs, Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) ys Y)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n                         (y #\n                          ipurge_tr I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs,\n                          ipurge_ref I (the \\<circ> con_comp_map D E p q)\n                           (the (con_comp_map D E p q y)) zs Z)\n                         \\<in> futures (P \\<parallel> Q <p, q>) xs", "thus\n   \"(ipurge_tr I (the \\<circ> ?D') (the (?D' y)) ys,\n      ipurge_ref I (the \\<circ> ?D') (the (?D' y)) ys Y) \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n    (y # ipurge_tr I (the \\<circ> ?D') (the (?D' y)) zs,\n      ipurge_ref I (the \\<circ> ?D') (the (?D' y)) zs Z) \\<in> futures (P \\<parallel> Q <p, q>) xs\""], ["proof (prove)\nusing this:\n  (ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) ys,\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) ys Y)\n  \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n  (y #\n   ipurge_tr (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs,\n   ipurge_ref (con_comp_pol I) (con_comp_map D E p q)\n    (con_comp_map D E p q y) zs Z)\n  \\<in> futures (P \\<parallel> Q <p, q>) xs\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n      (the (con_comp_map D E p q y)) ys,\n     ipurge_ref I (the \\<circ> con_comp_map D E p q)\n      (the (con_comp_map D E p q y)) ys Y)\n    \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n    (y #\n     ipurge_tr I (the \\<circ> con_comp_map D E p q)\n      (the (con_comp_map D E p q y)) zs,\n     ipurge_ref I (the \\<circ> con_comp_map D E p q)\n      (the (con_comp_map D E p q y)) zs Z)\n    \\<in> futures (P \\<parallel> Q <p, q>) xs", "by (simp add: con_comp_ipurge_tr_no_fake [OF A E]\n    con_comp_ipurge_ref_no_fake [OF A E])"], ["proof (state)\nthis:\n  (ipurge_tr I (the \\<circ> con_comp_map D E p q)\n    (the (con_comp_map D E p q y)) ys,\n   ipurge_ref I (the \\<circ> con_comp_map D E p q)\n    (the (con_comp_map D E p q y)) ys Y)\n  \\<in> futures (P \\<parallel> Q <p, q>) xs \\<and>\n  (y #\n   ipurge_tr I (the \\<circ> con_comp_map D E p q)\n    (the (con_comp_map D E p q y)) zs,\n   ipurge_ref I (the \\<circ> con_comp_map D E p q)\n    (the (con_comp_map D E p q y)) zs Z)\n  \\<in> futures (P \\<parallel> Q <p, q>) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}