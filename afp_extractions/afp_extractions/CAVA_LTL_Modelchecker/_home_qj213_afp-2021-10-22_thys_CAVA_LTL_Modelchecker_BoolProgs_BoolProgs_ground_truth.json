{"file_name": "/home/qj213/afp-2021-10-22/thys/CAVA_LTL_Modelchecker/BoolProgs/BoolProgs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CAVA_LTL_Modelchecker", "problem_names": ["lemmas reachable_configs_induct = reachable_configs.induct[split_format(complete),case_names 0 1]", "lemma finite_max_next_pcs: \"finite(max_next_pcs bp)\"", "lemma (in linorder) le_Max_insertI1: \"\\<lbrakk> finite A; x \\<le> b \\<rbrakk> \\<Longrightarrow> x \\<le> Max (insert b A)\"", "lemma (in linorder) le_Max_insertI2: \"\\<lbrakk> finite A; A \\<noteq> {}; x \\<le> Max A \\<rbrakk> \\<Longrightarrow> x \\<le> Max (insert b A)\"", "lemma max_next_pcs_not_empty:\n  \"pc<length bp \\<Longrightarrow> x : set (exec (bp!pc) (pc,s)) \\<Longrightarrow> max_next_pcs bp \\<noteq> {}\"", "lemma Max_lem2: \n  assumes \"pc < length bp\" \n  and \"(pc', s') \\<in> set (exec (bp!pc) (pc, s))\"\n  shows \"pc' \\<le> Max (max_next_pcs bp)\"", "lemma Max_lem1: \"\\<lbrakk> pc < length bp; (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> pc' \\<le> Max (insert x (max_next_pcs bp))\"", "lemma [simp]: \"length (list_of_array a) = array_length a\"", "lemma aux2: \n  assumes A: \"pc < array_length ins\" \n  assumes B: \"ofs \\<in> offsets_is (list_of_array ins)\"\n  shows \"nat (1 + int pc + ofs) < pc_bound ins\"", "lemma array_idx_in_set: \n  \"\\<lbrakk> pc < array_length ins; array_get ins pc = x \\<rbrakk> \n  \\<Longrightarrow> x \\<in> set (list_of_array ins)\"", "lemma rcs_aux: \n  assumes \"pc < pc_bound bp\"    \n  assumes \"pc'\\<in>set (exec' bp s pc)\"\n  shows \"pc' < pc_bound bp\"", "lemma exec_bound:\n  assumes PCB: \"pc < array_length bp\"\n  assumes SB: \"s \\<in> state_bound bp s0\"\n  shows \"set (exec (array_get bp pc) (pc,s)) \\<subseteq> config_bound bp s0\"", "lemma in_bound_step: \n  notes [simp del] = exec.simps\n  assumes BOUND: \"c \\<in> config_bound bp s0\"\n  assumes STEP: \"c'\\<in>set (nexts bp c)\"\n  shows \"c' \\<in> config_bound bp s0\"", "lemma reachable_configs_in_bound:\n  \"c \\<in> config_bound bp s0 \\<Longrightarrow> reachable_configs bp c \\<subseteq> config_bound bp s0\"", "lemma reachable_configs_out_of_bound: \"(pc',s')\\<in>reachable_configs bp (pc,s) \n  \\<Longrightarrow> \\<not> pc < pc_bound bp \\<Longrightarrow> (pc',s') = (pc,s)\"", "lemma finite_bexp_vars[simp, intro!]: \"finite (bexp_vars be)\"", "lemma finite_instr_vars[simp, intro!]: \"finite (instr_vars ins)\"", "lemma finite_bprog_vars[simp, intro!]: \"finite (bprog_vars bp)\"", "lemma finite_state_bound[simp, intro!]: \"finite (state_bound bp s0)\"", "lemma finite_config_bound[simp, intro!]: \"finite (config_bound bp s0)\"", "lemma reachable_configs_finite[simp, intro!]: \n  \"finite (reachable_configs bp c)\""], "translations": [["", "lemmas reachable_configs_induct = reachable_configs.induct[split_format(complete),case_names 0 1]"], ["", "fun offsets :: \"instr \\<Rightarrow> int set\" where\n\"offsets (AssI _ _) = {0}\" |\n\"offsets (TestI _ i) = {0,i}\" |\n\"offsets (ChoiceI bis) = set(map snd bis) \\<union> {0}\" |\n\"offsets (GotoI i) = {i}\""], ["", "definition offsets_is :: \"instr list \\<Rightarrow> int set\" where\n\"offsets_is ins = (UN instr : set ins. offsets instr)\""], ["", "definition max_next_pcs :: \"instr list \\<Rightarrow> nat set\" where\n\"max_next_pcs ins = {nat(int(length ins + 1) + i) |i. i : offsets_is ins}\""], ["", "lemma finite_max_next_pcs: \"finite(max_next_pcs bp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "fix instr"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "have \"finite (offsets instr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (offsets instr)", "by(cases instr) auto"], ["proof (state)\nthis:\n  finite (offsets instr)\n\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "}"], ["proof (state)\nthis:\n  finite (offsets ?instr2)\n\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "moreover"], ["proof (state)\nthis:\n  finite (offsets ?instr2)\n\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "{"], ["proof (state)\nthis:\n  finite (offsets ?instr2)\n\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "fix ins"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "have \"max_next_pcs ins = (UN i : offsets_is ins. {nat(int(length ins + 1) + i)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_next_pcs ins =\n    (\\<Union>i\\<in>offsets_is ins. {nat (int (length ins + 1) + i)})", "by(auto simp add: max_next_pcs_def)"], ["proof (state)\nthis:\n  max_next_pcs ins =\n  (\\<Union>i\\<in>offsets_is ins. {nat (int (length ins + 1) + i)})\n\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "}"], ["proof (state)\nthis:\n  max_next_pcs ?ins2 =\n  (\\<Union>i\\<in>offsets_is ?ins2. {nat (int (length ?ins2 + 1) + i)})\n\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "ultimately"], ["proof (chain)\npicking this:\n  finite (offsets ?instr2)\n  max_next_pcs ?ins2 =\n  (\\<Union>i\\<in>offsets_is ?ins2. {nat (int (length ?ins2 + 1) + i)})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (offsets ?instr2)\n  max_next_pcs ?ins2 =\n  (\\<Union>i\\<in>offsets_is ?ins2. {nat (int (length ?ins2 + 1) + i)})\n\ngoal (1 subgoal):\n 1. finite (max_next_pcs bp)", "by(auto simp add: offsets_is_def)"], ["proof (state)\nthis:\n  finite (max_next_pcs bp)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move *)"], ["", "lemma (in linorder) le_Max_insertI1: \"\\<lbrakk> finite A; x \\<le> b \\<rbrakk> \\<Longrightarrow> x \\<le> Max (insert b A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; x \\<le> b\\<rbrakk>\n    \\<Longrightarrow> x \\<le> Max (insert b A)", "by (metis Max_ge finite.insertI insert_iff order_trans)"], ["", "lemma (in linorder) le_Max_insertI2: \"\\<lbrakk> finite A; A \\<noteq> {}; x \\<le> Max A \\<rbrakk> \\<Longrightarrow> x \\<le> Max (insert b A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}; x \\<le> Max A\\<rbrakk>\n    \\<Longrightarrow> x \\<le> Max (insert b A)", "by(auto simp add: max_def not_le simp del: Max_less_iff)"], ["", "lemma max_next_pcs_not_empty:\n  \"pc<length bp \\<Longrightarrow> x : set (exec (bp!pc) (pc,s)) \\<Longrightarrow> max_next_pcs bp \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length bp; x \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> max_next_pcs bp \\<noteq> {}", "apply(drule nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (exec (bp ! pc) (pc, s));\n     bp ! pc \\<in> set bp\\<rbrakk>\n    \\<Longrightarrow> max_next_pcs bp \\<noteq> {}", "apply(fastforce simp: max_next_pcs_def offsets_is_def split: instr.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_lem2: \n  assumes \"pc < length bp\" \n  and \"(pc', s') \\<in> set (exec (bp!pc) (pc, s))\"\n  shows \"pc' \\<le> Max (max_next_pcs bp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc' \\<le> Max (max_next_pcs bp)", "using assms"], ["proof (prove)\nusing this:\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n\ngoal (1 subgoal):\n 1. pc' \\<le> Max (max_next_pcs bp)", "proof (cases \"bp ! pc\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 2. \\<And>x21 x22.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 3. \\<And>x3.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 4. \\<And>x4.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "case (ChoiceI l)"], ["proof (state)\nthis:\n  bp ! pc = ChoiceI l\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 2. \\<And>x21 x22.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 3. \\<And>x3.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 4. \\<And>x4.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc' \\<le> Max (max_next_pcs bp)", "proof (cases \"pc' = pc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pc' = pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 2. pc' \\<noteq> pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "case True"], ["proof (state)\nthis:\n  pc' = pc\n\ngoal (2 subgoals):\n 1. pc' = pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 2. pc' \\<noteq> pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "with assms ChoiceI"], ["proof (chain)\npicking this:\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  bp ! pc = ChoiceI l\n  pc' = pc", "show ?thesis"], ["proof (prove)\nusing this:\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  bp ! pc = ChoiceI l\n  pc' = pc\n\ngoal (1 subgoal):\n 1. pc' \\<le> Max (max_next_pcs bp)", "by (auto simp: Max_ge_iff max_next_pcs_not_empty finite_max_next_pcs) \n         (force simp add: max_next_pcs_def offsets_is_def dest: nth_mem)"], ["proof (state)\nthis:\n  pc' \\<le> Max (max_next_pcs bp)\n\ngoal (1 subgoal):\n 1. pc' \\<noteq> pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pc' \\<noteq> pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "case False"], ["proof (state)\nthis:\n  pc' \\<noteq> pc\n\ngoal (1 subgoal):\n 1. pc' \\<noteq> pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "with ChoiceI assms"], ["proof (chain)\npicking this:\n  bp ! pc = ChoiceI l\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  pc' \\<noteq> pc", "obtain b i where \n      bi: \"bval b s\" \"(b,i) \\<in> set l\" \"pc' = nat(int(pc+1)+i)\""], ["proof (prove)\nusing this:\n  bp ! pc = ChoiceI l\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  pc' \\<noteq> pc\n\ngoal (1 subgoal):\n 1. (\\<And>b i.\n        \\<lbrakk>bval b s; (b, i) \\<in> set l;\n         pc' = nat (int (pc + 1) + i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  bval b s\n  (b, i) \\<in> set l\n  pc' = nat (int (pc + 1) + i)\n\ngoal (1 subgoal):\n 1. pc' \\<noteq> pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "with ChoiceI assms"], ["proof (chain)\npicking this:\n  bp ! pc = ChoiceI l\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  bval b s\n  (b, i) \\<in> set l\n  pc' = nat (int (pc + 1) + i)", "have \"i \\<in> \\<Union>(offsets ` (set bp))\""], ["proof (prove)\nusing this:\n  bp ! pc = ChoiceI l\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  bval b s\n  (b, i) \\<in> set l\n  pc' = nat (int (pc + 1) + i)\n\ngoal (1 subgoal):\n 1. i \\<in> \\<Union> (offsets ` set bp)", "by (force dest: nth_mem)"], ["proof (state)\nthis:\n  i \\<in> \\<Union> (offsets ` set bp)\n\ngoal (1 subgoal):\n 1. pc' \\<noteq> pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "with bi assms"], ["proof (chain)\npicking this:\n  bval b s\n  (b, i) \\<in> set l\n  pc' = nat (int (pc + 1) + i)\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  i \\<in> \\<Union> (offsets ` set bp)", "have \"\\<exists>a. (a \\<in> max_next_pcs bp \\<and> pc' \\<le> a)\""], ["proof (prove)\nusing this:\n  bval b s\n  (b, i) \\<in> set l\n  pc' = nat (int (pc + 1) + i)\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  i \\<in> \\<Union> (offsets ` set bp)\n\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in> max_next_pcs bp \\<and> pc' \\<le> a", "unfolding max_next_pcs_def offsets_is_def"], ["proof (prove)\nusing this:\n  bval b s\n  (b, i) \\<in> set l\n  pc' = nat (int (pc + 1) + i)\n  pc < length bp\n  (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\n  i \\<in> \\<Union> (offsets ` set bp)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       a \\<in> {nat (int (length bp + 1) + i) |i.\n                i \\<in> \\<Union> (offsets ` set bp)} \\<and>\n       pc' \\<le> a", "by force"], ["proof (state)\nthis:\n  \\<exists>a. a \\<in> max_next_pcs bp \\<and> pc' \\<le> a\n\ngoal (1 subgoal):\n 1. pc' \\<noteq> pc \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a. a \\<in> max_next_pcs bp \\<and> pc' \\<le> a\n\ngoal (1 subgoal):\n 1. pc' \\<le> Max (max_next_pcs bp)", "by (auto simp: Max_ge_iff max_next_pcs_not_empty[OF assms] finite_max_next_pcs)"], ["proof (state)\nthis:\n  pc' \\<le> Max (max_next_pcs bp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pc' \\<le> Max (max_next_pcs bp)\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 2. \\<And>x21 x22.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)\n 3. \\<And>x4.\n       \\<lbrakk>pc < length bp;\n        (pc', s') \\<in> set (exec (bp ! pc) (pc, s));\n        bp ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "qed (auto simp: Max_ge_iff max_next_pcs_not_empty finite_max_next_pcs,\n     (force simp add: max_next_pcs_def offsets_is_def dest: nth_mem split: if_split_asm)+)"], ["", "lemma Max_lem1: \"\\<lbrakk> pc < length bp; (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> pc' \\<le> Max (insert x (max_next_pcs bp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length bp;\n     (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> pc' \\<le> Max (insert x (max_next_pcs bp))", "apply(rule le_Max_insertI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pc < length bp;\n     (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> finite (max_next_pcs bp)\n 2. \\<lbrakk>pc < length bp;\n     (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> max_next_pcs bp \\<noteq> {}\n 3. \\<lbrakk>pc < length bp;\n     (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "apply (simp add: finite_max_next_pcs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pc < length bp;\n     (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> max_next_pcs bp \\<noteq> {}\n 2. \\<lbrakk>pc < length bp;\n     (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "apply(simp add: max_next_pcs_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length bp;\n     (pc', s') \\<in> set (exec (bp ! pc) (pc, s))\\<rbrakk>\n    \\<Longrightarrow> pc' \\<le> Max (max_next_pcs bp)", "apply(auto intro!: Max_lem2 simp del:exec.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"pc_bound bp \\<equiv> max \n    (Max (max_next_pcs (list_of_array bp)) + 1)\n    (array_length bp + 1)\""], ["", "declare exec'.simps[simp del]"], ["", "lemma [simp]: \"length (list_of_array a) = array_length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of_array a) = array_length a", "by (cases a) auto"], ["", "lemma aux2: \n  assumes A: \"pc < array_length ins\" \n  assumes B: \"ofs \\<in> offsets_is (list_of_array ins)\"\n  shows \"nat (1 + int pc + ofs) < pc_bound ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (1 + int pc + ofs) < pc_bound ins", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat (1 + int pc + ofs) < pc_bound ins", "have \"nat (int (1 + array_length ins) + ofs) \n    \\<in> max_next_pcs (list_of_array ins)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (int (1 + array_length ins) + ofs)\n    \\<in> max_next_pcs (list_of_array ins)", "using B"], ["proof (prove)\nusing this:\n  ofs \\<in> offsets_is (list_of_array ins)\n\ngoal (1 subgoal):\n 1. nat (int (1 + array_length ins) + ofs)\n    \\<in> max_next_pcs (list_of_array ins)", "unfolding max_next_pcs_def"], ["proof (prove)\nusing this:\n  ofs \\<in> offsets_is (list_of_array ins)\n\ngoal (1 subgoal):\n 1. nat (int (1 + array_length ins) + ofs)\n    \\<in> {nat (int (length (list_of_array ins) + 1) + i) |i.\n           i \\<in> offsets_is (list_of_array ins)}", "by auto"], ["proof (state)\nthis:\n  nat (int (1 + array_length ins) + ofs)\n  \\<in> max_next_pcs (list_of_array ins)\n\ngoal (1 subgoal):\n 1. nat (1 + int pc + ofs) < pc_bound ins", "with A"], ["proof (chain)\npicking this:\n  pc < array_length ins\n  nat (int (1 + array_length ins) + ofs)\n  \\<in> max_next_pcs (list_of_array ins)", "show ?thesis"], ["proof (prove)\nusing this:\n  pc < array_length ins\n  nat (int (1 + array_length ins) + ofs)\n  \\<in> max_next_pcs (list_of_array ins)\n\ngoal (1 subgoal):\n 1. nat (1 + int pc + ofs) < pc_bound ins", "unfolding pc_bound_def"], ["proof (prove)\nusing this:\n  pc < array_length ins\n  nat (int (1 + array_length ins) + ofs)\n  \\<in> max_next_pcs (list_of_array ins)\n\ngoal (1 subgoal):\n 1. nat (1 + int pc + ofs)\n    < max (Max (max_next_pcs (list_of_array ins)) + 1)\n       (array_length ins + 1)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < array_length ins;\n     nat (int (1 + array_length ins) + ofs)\n     \\<in> max_next_pcs (list_of_array ins)\\<rbrakk>\n    \\<Longrightarrow> nat (1 + int pc + ofs)\n                      < max (Max (max_next_pcs (list_of_array ins)) + 1)\n                         (array_length ins + 1)", "apply (rule max.strict_coboundedI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < array_length ins;\n     nat (int (1 + array_length ins) + ofs)\n     \\<in> max_next_pcs (list_of_array ins)\\<rbrakk>\n    \\<Longrightarrow> nat (1 + int pc + ofs)\n                      < Max (max_next_pcs (list_of_array ins)) + 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < array_length ins;\n     nat (1 + int (array_length ins) + ofs)\n     \\<in> max_next_pcs (list_of_array ins)\\<rbrakk>\n    \\<Longrightarrow> nat (1 + int pc + ofs)\n                      < Suc (Max (max_next_pcs (list_of_array ins)))", "apply (drule Max_ge[OF finite_max_next_pcs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < array_length ins;\n     nat (1 + int (array_length ins) + ofs)\n     \\<le> Max (max_next_pcs (list_of_array ins))\\<rbrakk>\n    \\<Longrightarrow> nat (1 + int pc + ofs)\n                      < Suc (Max (max_next_pcs (list_of_array ins)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat (1 + int pc + ofs) < pc_bound ins\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma array_idx_in_set: \n  \"\\<lbrakk> pc < array_length ins; array_get ins pc = x \\<rbrakk> \n  \\<Longrightarrow> x \\<in> set (list_of_array ins)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < array_length ins; array_get ins pc = x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (list_of_array ins)", "by (induct ins) auto"], ["", "lemma rcs_aux: \n  assumes \"pc < pc_bound bp\"    \n  assumes \"pc'\\<in>set (exec' bp s pc)\"\n  shows \"pc' < pc_bound bp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc' < pc_bound bp", "using assms"], ["proof (prove)\nusing this:\n  pc < pc_bound bp\n  pc' \\<in> set (exec' bp s pc)\n\ngoal (1 subgoal):\n 1. pc' < pc_bound bp", "proof (induction bp s pc arbitrary: pc' rule: exec'.induct[case_names C])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ins s pc pc'.\n       \\<lbrakk>\\<And>x21 x22 pc'.\n                   \\<lbrakk>pc < array_length ins;\n                    array_get ins pc = TestI x21 x22; bval x21 s;\n                    pc + 1 < pc_bound ins;\n                    pc' \\<in> set (exec' ins s (pc + 1))\\<rbrakk>\n                   \\<Longrightarrow> pc' < pc_bound ins;\n        \\<And>x21 x22 x pc'.\n           \\<lbrakk>pc < array_length ins; array_get ins pc = TestI x21 x22;\n            \\<not> bval x21 s; x = nat (int (pc + 1) + x22); pc < x;\n            x < pc_bound ins; pc' \\<in> set (exec' ins s x)\\<rbrakk>\n           \\<Longrightarrow> pc' < pc_bound ins;\n        \\<And>x3 x xa pc'.\n           \\<lbrakk>pc < array_length ins; array_get ins pc = ChoiceI x3;\n            x =\n            concat\n             (map (\\<lambda>(b, i).\n                      if bval b s then [nat (int (pc + 1) + i)] else [])\n               x3);\n            x \\<noteq> []; xa \\<in> set x; pc < xa; xa < pc_bound ins;\n            pc' \\<in> set (exec' ins s xa)\\<rbrakk>\n           \\<Longrightarrow> pc' < pc_bound ins;\n        \\<And>x4 x pc'.\n           \\<lbrakk>pc < array_length ins; array_get ins pc = GotoI x4;\n            x = nat (int (pc + 1) + x4); pc < x; x < pc_bound ins;\n            pc' \\<in> set (exec' ins s x)\\<rbrakk>\n           \\<Longrightarrow> pc' < pc_bound ins;\n        pc < pc_bound ins; pc' \\<in> set (exec' ins s pc)\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins", "case (C ins s pc pc')"], ["proof (state)\nthis:\n  \\<lbrakk>pc < array_length ins; array_get ins pc = TestI ?x21.0 ?x22.0;\n   bval ?x21.0 s; pc + 1 < pc_bound ins;\n   ?pc' \\<in> set (exec' ins s (pc + 1))\\<rbrakk>\n  \\<Longrightarrow> ?pc' < pc_bound ins\n  \\<lbrakk>pc < array_length ins; array_get ins pc = TestI ?x21.0 ?x22.0;\n   \\<not> bval ?x21.0 s; ?x = nat (int (pc + 1) + ?x22.0); pc < ?x;\n   ?x < pc_bound ins; ?pc' \\<in> set (exec' ins s ?x)\\<rbrakk>\n  \\<Longrightarrow> ?pc' < pc_bound ins\n  \\<lbrakk>pc < array_length ins; array_get ins pc = ChoiceI ?x3.0;\n   ?x =\n   concat\n    (map (\\<lambda>(b, i).\n             if bval b s then [nat (int (pc + 1) + i)] else [])\n      ?x3.0);\n   ?x \\<noteq> []; ?xa \\<in> set ?x; pc < ?xa; ?xa < pc_bound ins;\n   ?pc' \\<in> set (exec' ins s ?xa)\\<rbrakk>\n  \\<Longrightarrow> ?pc' < pc_bound ins\n  \\<lbrakk>pc < array_length ins; array_get ins pc = GotoI ?x4.0;\n   ?x = nat (int (pc + 1) + ?x4.0); pc < ?x; ?x < pc_bound ins;\n   ?pc' \\<in> set (exec' ins s ?x)\\<rbrakk>\n  \\<Longrightarrow> ?pc' < pc_bound ins\n  pc < pc_bound ins\n  pc' \\<in> set (exec' ins s pc)\n\ngoal (1 subgoal):\n 1. \\<And>ins s pc pc'.\n       \\<lbrakk>\\<And>x21 x22 pc'.\n                   \\<lbrakk>pc < array_length ins;\n                    array_get ins pc = TestI x21 x22; bval x21 s;\n                    pc + 1 < pc_bound ins;\n                    pc' \\<in> set (exec' ins s (pc + 1))\\<rbrakk>\n                   \\<Longrightarrow> pc' < pc_bound ins;\n        \\<And>x21 x22 x pc'.\n           \\<lbrakk>pc < array_length ins; array_get ins pc = TestI x21 x22;\n            \\<not> bval x21 s; x = nat (int (pc + 1) + x22); pc < x;\n            x < pc_bound ins; pc' \\<in> set (exec' ins s x)\\<rbrakk>\n           \\<Longrightarrow> pc' < pc_bound ins;\n        \\<And>x3 x xa pc'.\n           \\<lbrakk>pc < array_length ins; array_get ins pc = ChoiceI x3;\n            x =\n            concat\n             (map (\\<lambda>(b, i).\n                      if bval b s then [nat (int (pc + 1) + i)] else [])\n               x3);\n            x \\<noteq> []; xa \\<in> set x; pc < xa; xa < pc_bound ins;\n            pc' \\<in> set (exec' ins s xa)\\<rbrakk>\n           \\<Longrightarrow> pc' < pc_bound ins;\n        \\<And>x4 x pc'.\n           \\<lbrakk>pc < array_length ins; array_get ins pc = GotoI x4;\n            x = nat (int (pc + 1) + x4); pc < x; x < pc_bound ins;\n            pc' \\<in> set (exec' ins s x)\\<rbrakk>\n           \\<Longrightarrow> pc' < pc_bound ins;\n        pc < pc_bound ins; pc' \\<in> set (exec' ins s pc)\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins", "from C.prems"], ["proof (chain)\npicking this:\n  pc < pc_bound ins\n  pc' \\<in> set (exec' ins s pc)", "show ?case"], ["proof (prove)\nusing this:\n  pc < pc_bound ins\n  pc' \\<in> set (exec' ins s pc)\n\ngoal (1 subgoal):\n 1. pc' < pc_bound ins", "apply (subst (asm) exec'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < pc_bound ins;\n     pc'\n     \\<in> set (if pc < array_length ins\n                then case array_get ins pc of AssI ns bs \\<Rightarrow> [pc]\n                     | TestI b d \\<Rightarrow>\n                         if bval b s then exec' ins s (pc + 1)\n                         else let pc' = nat (int (pc + 1) + d)\n                              in if pc < pc' then exec' ins s pc' else [pc']\n                     | ChoiceI bis \\<Rightarrow>\n                         let succs =\n                               concat\n                                (map (\\<lambda>(b, i).\n   if bval b s then [nat (int (pc + 1) + i)] else [])\n                                  bis)\n                         in if succs = [] then [pc]\n                            else concat\n                                  (map (\\<lambda>pc'.\n     if pc < pc' then exec' ins s pc' else [pc'])\n                                    succs)\n                     | GotoI d \\<Rightarrow>\n                         let pc' = nat (int (pc + 1) + d)\n                         in if pc < pc' then exec' ins s pc' else [pc']\n                else [pc])\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (split if_split_asm instr.split_asm)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = AssI x11 x12; pc' \\<in> set [pc]\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<And>x21 x22.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI x21 x22;\n        pc'\n        \\<in> set (if bval x21 s then exec' ins s (pc + 1)\n                   else let pc' = nat (int (pc + 1) + x22)\n                        in if pc < pc' then exec' ins s pc'\n                           else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 5. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (simp add: pc_bound_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI x21 x22;\n        pc'\n        \\<in> set (if bval x21 s then exec' ins s (pc + 1)\n                   else let pc' = nat (int (pc + 1) + x22)\n                        in if pc < pc' then exec' ins s pc'\n                           else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (simp split: if_split_asm add: Let_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI x21 x22; bval x21 s;\n        pc' \\<in> set (exec' ins s (Suc pc))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<And>x21 x22.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI x21 x22; \\<not> bval x21 s;\n        pc < nat (1 + int pc + x22);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + x22)))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 5. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (frule (2) C.IH(1), auto) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI x21 x22; bval x21 s;\n        pc' \\<in> set (exec' ins s (Suc pc))\\<rbrakk>\n       \\<Longrightarrow> Suc pc < pc_bound ins\n 2. \\<And>x21 x22.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI x21 x22; \\<not> bval x21 s;\n        pc < nat (1 + int pc + x22);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + x22)))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 5. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (auto simp: pc_bound_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI x21 x22; \\<not> bval x21 s;\n        pc < nat (1 + int pc + x22);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + x22)))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (frule (2) C.IH(2), auto) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI x21 x22; \\<not> bval x21 s;\n        pc < nat (1 + int pc + x22);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + x22)))\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + x22) < pc_bound ins\n 2. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (rename_tac bexp int)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>bexp inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI bexp inta; \\<not> bval bexp s;\n        pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + inta) < pc_bound ins\n 2. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (subgoal_tac \"int \\<in> offsets_is (list_of_array ins)\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>bexp inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI bexp inta; \\<not> bval bexp s;\n        pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)));\n        inta \\<in> offsets_is (list_of_array ins)\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + inta) < pc_bound ins\n 2. \\<And>bexp inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI bexp inta; \\<not> bval bexp s;\n        pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> inta \\<in> offsets_is (list_of_array ins)\n 3. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 5. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (blast intro: aux2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>bexp inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI bexp inta; \\<not> bval bexp s;\n        pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> inta \\<in> offsets_is (list_of_array ins)\n 2. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (auto simp: offsets_is_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>bexp inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = TestI bexp inta; \\<not> bval bexp s;\n        pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list_of_array ins).\n                            inta \\<in> offsets x\n 2. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (rule_tac x=\"TestI bexp int\" in bexI, auto simp: array_idx_in_set) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI x3;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            x3)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (rename_tac list)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list;\n        pc'\n        \\<in> set (let succs =\n                         concat\n                          (map (\\<lambda>(b, i).\n                                   if bval b s then [nat (int (pc + 1) + i)]\n                                   else [])\n                            list)\n                   in if succs = [] then [pc]\n                      else concat\n                            (map (\\<lambda>pc'.\n                                     if pc < pc' then exec' ins s pc'\n                                     else [pc'])\n                              succs))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (clarsimp split: if_split_asm simp add: Let_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list a b.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list;\n        (\\<exists>x\\<in>(\\<Union>x\\<in>set list.\n                            {xa.\n                             \\<exists>uu_ uua_.\n                                (uua_, uu_) = x \\<and>\n                                bval uua_ s \\<and>\n                                xa = nat (1 + int pc + uu_)}) \\<inter>\n                        Collect ((<) pc).\n            pc' \\<in> set (exec' ins s x)) \\<or>\n        (\\<exists>x\\<in>set list.\n            \\<exists>uu_ uua_.\n               (uua_, uu_) = x \\<and>\n               bval uua_ s \\<and> pc' = nat (1 + int pc + uu_)) \\<and>\n        \\<not> pc < pc';\n        (a, b) \\<in> set list; bval a s\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (elim disjE conjE, auto) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (frule (1) C.IH(3), auto) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba); bval aa s;\n        \\<forall>xs\\<in>set list.\n           (case xs of\n            (b, i) \\<Rightarrow>\n              if bval b s then [nat (int (pc + 1) + i)] else []) =\n           []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set list.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               bval uua_ s \\<and>\n                               nat (1 + int pc + ba) =\n                               nat (1 + int pc + uu_)\n 3. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + ba) < pc_bound ins\n 4. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 5. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (force)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set list.\n                            \\<exists>uu_ uua_.\n                               (uua_, uu_) = x \\<and>\n                               bval uua_ s \\<and>\n                               nat (1 + int pc + ba) =\n                               nat (1 + int pc + uu_)\n 2. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + ba) < pc_bound ins\n 3. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + ba) < pc_bound ins\n 2. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (subgoal_tac \"ba \\<in> offsets_is (list_of_array ins)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba); bval aa s;\n        ba \\<in> offsets_is (list_of_array ins)\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + ba) < pc_bound ins\n 2. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> offsets_is (list_of_array ins)\n 3. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 4. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (blast intro: aux2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> offsets_is (list_of_array ins)\n 2. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (auto simp: offsets_is_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list a b aa ba.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = ChoiceI list; (a, b) \\<in> set list; bval a s;\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + ba)));\n        (aa, ba) \\<in> set list; pc < nat (1 + int pc + ba);\n        bval aa s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list_of_array ins).\n                            ba \\<in> offsets x\n 2. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 3. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (rule_tac x=\"ChoiceI list\" in bexI, auto simp: array_idx_in_set) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x4.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI x4;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + x4)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (rename_tac int)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI inta;\n        pc'\n        \\<in> set (let pc' = nat (int (pc + 1) + inta)\n                   in if pc < pc' then exec' ins s pc' else [pc'])\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (simp split: if_split_asm add: Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI inta; pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> pc' < pc_bound ins\n 2. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (frule (1) C.IH(4), auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI inta; pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + inta) < pc_bound ins\n 2. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (subgoal_tac \"int \\<in> offsets_is (list_of_array ins)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI inta; pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)));\n        inta \\<in> offsets_is (list_of_array ins)\\<rbrakk>\n       \\<Longrightarrow> nat (1 + int pc + inta) < pc_bound ins\n 2. \\<And>inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI inta; pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> inta \\<in> offsets_is (list_of_array ins)\n 3. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (blast intro: aux2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI inta; pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> inta \\<in> offsets_is (list_of_array ins)\n 2. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (auto simp: offsets_is_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>inta.\n       \\<lbrakk>pc < pc_bound ins; pc < array_length ins;\n        array_get ins pc = GotoI inta; pc < nat (1 + int pc + inta);\n        pc' \\<in> set (exec' ins s (nat (1 + int pc + inta)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list_of_array ins).\n                            inta \\<in> offsets x\n 2. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply (rule_tac x=\"GotoI int\" in bexI, auto simp: array_idx_in_set) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < pc_bound ins; \\<not> pc < array_length ins;\n     pc' \\<in> set [pc]\\<rbrakk>\n    \\<Longrightarrow> pc' < pc_bound ins", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pc' < pc_bound ins\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec bexp_vars :: \"bexp \\<Rightarrow> nat set\" where\n  \"bexp_vars TT = {}\"\n| \"bexp_vars FF = {}\"\n| \"bexp_vars (V n) = {n}\"\n| \"bexp_vars (Not b) = bexp_vars b\"\n| \"bexp_vars (And b1 b2) = bexp_vars b1 \\<union> bexp_vars b2\"\n| \"bexp_vars (Or b1 b2) = bexp_vars b1 \\<union> bexp_vars b2\""], ["", "primrec instr_vars :: \"instr \\<Rightarrow> nat set\" where\n  \"instr_vars (AssI xs bs) = set xs \\<union> \\<Union>(bexp_vars`set bs)\"\n| \"instr_vars (TestI b _) = bexp_vars b\"\n| \"instr_vars (ChoiceI cs) = \\<Union>(bexp_vars`fst`set cs)\"\n| \"instr_vars (GotoI _) = {}\""], ["", "find_consts \"'a array \\<Rightarrow> 'a list\""], ["", "definition bprog_vars :: \"bprog \\<Rightarrow> nat set\" where \n  \"bprog_vars bp = \\<Union>(instr_vars`set (list_of_array bp))\""], ["", "definition \"state_bound bp s0 \n  \\<equiv> {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}\""], ["", "abbreviation \"config_bound bp s0 \\<equiv> {0..< pc_bound bp} \\<times> state_bound bp s0\""], ["", "lemma exec_bound:\n  assumes PCB: \"pc < array_length bp\"\n  assumes SB: \"s \\<in> state_bound bp s0\"\n  shows \"set (exec (array_get bp pc) (pc,s)) \\<subseteq> config_bound bp s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (exec (array_get bp pc) (pc, s)) \\<subseteq> config_bound bp s0", "proof (clarsimp simp del: exec.simps, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       a < pc_bound bp\n 2. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       b \\<in> state_bound bp s0", "obtain instrs where BP_eq[simp]: \"bp = Array instrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>instrs.\n        bp = Array instrs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases bp)"], ["proof (state)\nthis:\n  bp = Array instrs\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       a < pc_bound bp\n 2. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       b \\<in> state_bound bp s0", "from PCB"], ["proof (chain)\npicking this:\n  pc < array_length bp", "have PCB'[simp]: \"pc < length instrs\""], ["proof (prove)\nusing this:\n  pc < array_length bp\n\ngoal (1 subgoal):\n 1. pc < length instrs", "by simp"], ["proof (state)\nthis:\n  pc < length instrs\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       a < pc_bound bp\n 2. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       b \\<in> state_bound bp s0", "fix pc' s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       a < pc_bound bp\n 2. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       b \\<in> state_bound bp s0", "assume STEP: \"(pc',s') \\<in> set (exec (array_get bp pc) (pc,s))\""], ["proof (state)\nthis:\n  (pc', s') \\<in> set (exec (array_get bp pc) (pc, s))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       a < pc_bound bp\n 2. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       b \\<in> state_bound bp s0", "hence STEP': \"(pc',s') \\<in> set (exec (instrs!pc) (pc,s))\""], ["proof (prove)\nusing this:\n  (pc', s') \\<in> set (exec (array_get bp pc) (pc, s))\n\ngoal (1 subgoal):\n 1. (pc', s') \\<in> set (exec (instrs ! pc) (pc, s))", "by simp"], ["proof (state)\nthis:\n  (pc', s') \\<in> set (exec (instrs ! pc) (pc, s))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       a < pc_bound bp\n 2. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       b \\<in> state_bound bp s0", "show \"pc' < pc_bound bp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc' < pc_bound bp", "using Max_lem2[OF PCB' STEP']"], ["proof (prove)\nusing this:\n  pc' \\<le> Max (max_next_pcs instrs)\n\ngoal (1 subgoal):\n 1. pc' < pc_bound bp", "unfolding pc_bound_def"], ["proof (prove)\nusing this:\n  pc' \\<le> Max (max_next_pcs instrs)\n\ngoal (1 subgoal):\n 1. pc'\n    < max (Max (max_next_pcs (list_of_array bp)) + 1) (array_length bp + 1)", "by simp"], ["proof (state)\nthis:\n  pc' < pc_bound bp\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (exec (array_get bp pc) (pc, s)) \\<Longrightarrow>\n       b \\<in> state_bound bp s0", "show \"s' \\<in> state_bound bp s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> state_bound bp s0", "using STEP' SB"], ["proof (prove)\nusing this:\n  (pc', s') \\<in> set (exec (instrs ! pc) (pc, s))\n  s \\<in> state_bound bp s0\n\ngoal (1 subgoal):\n 1. s' \\<in> state_bound bp s0", "proof (cases \"instrs!pc\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "case (AssI xs vs)"], ["proof (state)\nthis:\n  instrs ! pc = AssI xs vs\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "have \"set xs \\<subseteq> instr_vars (instrs!pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> instr_vars (instrs ! pc)", "by (simp add: AssI)"], ["proof (state)\nthis:\n  set xs \\<subseteq> instr_vars (instrs ! pc)\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "also"], ["proof (state)\nthis:\n  set xs \\<subseteq> instr_vars (instrs ! pc)\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "have \"\\<dots> \\<subseteq> bprog_vars bp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. instr_vars (instrs ! pc) \\<subseteq> bprog_vars bp", "apply (simp add: bprog_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. instr_vars (instrs ! pc) \\<subseteq> \\<Union> (instr_vars ` set instrs)", "by (metis PCB' UN_upper nth_mem)"], ["proof (state)\nthis:\n  instr_vars (instrs ! pc) \\<subseteq> bprog_vars bp\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "finally"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> bprog_vars bp", "have XSB: \"set xs \\<subseteq> bprog_vars bp\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> bprog_vars bp\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> bprog_vars bp", "."], ["proof (state)\nthis:\n  set xs \\<subseteq> bprog_vars bp\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "{"], ["proof (state)\nthis:\n  set xs \\<subseteq> bprog_vars bp\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "fix x s v"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "assume A: \"x \\<in> bprog_vars bp\" \"s \\<in> state_bound bp s0\""], ["proof (state)\nthis:\n  x \\<in> bprog_vars bp\n  s \\<in> state_bound bp s0\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "have SB_CNV: \"bs_\\<alpha> (set_bit s x v) \n        = (if v then (insert x (bs_\\<alpha> s)) else (bs_\\<alpha> s - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (set_bit_class.set_bit s x v) =\n    (if v then insert x (bs_\\<alpha> s) else bs_\\<alpha> s - {x})", "apply (cases v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<Longrightarrow>\n    bs_\\<alpha> (set_bit_class.set_bit s x v) =\n    (if v then insert x (bs_\\<alpha> s) else bs_\\<alpha> s - {x})\n 2. \\<not> v \\<Longrightarrow>\n    bs_\\<alpha> (set_bit_class.set_bit s x v) =\n    (if v then insert x (bs_\\<alpha> s) else bs_\\<alpha> s - {x})", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<Longrightarrow>\n    bs_\\<alpha> (set_bit_class.set_bit s x True) = insert x (bs_\\<alpha> s)\n 2. \\<not> v \\<Longrightarrow>\n    bs_\\<alpha> (set_bit_class.set_bit s x False) = bs_\\<alpha> s - {x}", "apply (fold bs_insert_def bs_delete_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<Longrightarrow>\n    bs_\\<alpha> (bs_insert x s) = insert x (bs_\\<alpha> s)\n 2. \\<not> v \\<Longrightarrow>\n    bs_\\<alpha> (bs_delete x s) = bs_\\<alpha> s - {x}", "apply (simp_all add: bs_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bs_\\<alpha> (set_bit_class.set_bit s x v) =\n  (if v then insert x (bs_\\<alpha> s) else bs_\\<alpha> s - {x})\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "from A"], ["proof (chain)\npicking this:\n  x \\<in> bprog_vars bp\n  s \\<in> state_bound bp s0", "have \"set_bit s x v \\<in> state_bound bp s0\""], ["proof (prove)\nusing this:\n  x \\<in> bprog_vars bp\n  s \\<in> state_bound bp s0\n\ngoal (1 subgoal):\n 1. set_bit_class.set_bit s x v \\<in> state_bound bp s0", "unfolding state_bound_def"], ["proof (prove)\nusing this:\n  x \\<in> bprog_vars bp\n  s \\<in> {s. bs_\\<alpha> s - bprog_vars bp =\n              bs_\\<alpha> s0 - bprog_vars bp}\n\ngoal (1 subgoal):\n 1. set_bit_class.set_bit s x v\n    \\<in> {s. bs_\\<alpha> s - bprog_vars bp =\n              bs_\\<alpha> s0 - bprog_vars bp}", "by (auto simp: SB_CNV)"], ["proof (state)\nthis:\n  set_bit_class.set_bit s x v \\<in> state_bound bp s0\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> bprog_vars bp; ?sa2 \\<in> state_bound bp s0\\<rbrakk>\n  \\<Longrightarrow> set_bit_class.set_bit ?sa2 ?x2 ?v2\n                    \\<in> state_bound bp s0\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "note aux=this"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> bprog_vars bp; ?sa2 \\<in> state_bound bp s0\\<rbrakk>\n  \\<Longrightarrow> set_bit_class.set_bit ?sa2 ?x2 ?v2\n                    \\<in> state_bound bp s0\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> bprog_vars bp; ?sa2 \\<in> state_bound bp s0\\<rbrakk>\n  \\<Longrightarrow> set_bit_class.set_bit ?sa2 ?x2 ?v2\n                    \\<in> state_bound bp s0\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "fix vs"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "have \"foldl (\\<lambda>s (x, y). set_bit s x y) s (zip xs vs) \n        \\<in> state_bound (Array instrs) s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n    \\<in> state_bound (Array instrs) s0", "using SB XSB"], ["proof (prove)\nusing this:\n  s \\<in> state_bound bp s0\n  set xs \\<subseteq> bprog_vars bp\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n    \\<in> state_bound (Array instrs) s0", "apply (induct xs arbitrary: vs s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs s.\n       \\<lbrakk>s \\<in> state_bound bp s0;\n        set [] \\<subseteq> bprog_vars bp\\<rbrakk>\n       \\<Longrightarrow> foldl\n                          (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s\n                          (zip [] vs)\n                         \\<in> state_bound (Array instrs) s0\n 2. \\<And>a xs vs s.\n       \\<lbrakk>\\<And>vs s.\n                   \\<lbrakk>s \\<in> state_bound bp s0;\n                    set xs \\<subseteq> bprog_vars bp\\<rbrakk>\n                   \\<Longrightarrow> foldl\n(\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n                                     \\<in> state_bound (Array instrs) s0;\n        s \\<in> state_bound bp s0;\n        set (a # xs) \\<subseteq> bprog_vars bp\\<rbrakk>\n       \\<Longrightarrow> foldl\n                          (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s\n                          (zip (a # xs) vs)\n                         \\<in> state_bound (Array instrs) s0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs vs s.\n       \\<lbrakk>\\<And>vs s.\n                   \\<lbrakk>s \\<in> state_bound bp s0;\n                    set xs \\<subseteq> bprog_vars bp\\<rbrakk>\n                   \\<Longrightarrow> foldl\n(\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n                                     \\<in> state_bound (Array instrs) s0;\n        s \\<in> state_bound bp s0;\n        set (a # xs) \\<subseteq> bprog_vars bp\\<rbrakk>\n       \\<Longrightarrow> foldl\n                          (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s\n                          (zip (a # xs) vs)\n                         \\<in> state_bound (Array instrs) s0", "apply (case_tac vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs vs s.\n       \\<lbrakk>\\<And>vs s.\n                   \\<lbrakk>s \\<in> state_bound bp s0;\n                    set xs \\<subseteq> bprog_vars bp\\<rbrakk>\n                   \\<Longrightarrow> foldl\n(\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n                                     \\<in> state_bound (Array instrs) s0;\n        s \\<in> state_bound bp s0; set (a # xs) \\<subseteq> bprog_vars bp;\n        vs = []\\<rbrakk>\n       \\<Longrightarrow> foldl\n                          (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s\n                          (zip (a # xs) vs)\n                         \\<in> state_bound (Array instrs) s0\n 2. \\<And>a xs vs s aa list.\n       \\<lbrakk>\\<And>vs s.\n                   \\<lbrakk>s \\<in> state_bound bp s0;\n                    set xs \\<subseteq> bprog_vars bp\\<rbrakk>\n                   \\<Longrightarrow> foldl\n(\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n                                     \\<in> state_bound (Array instrs) s0;\n        s \\<in> state_bound bp s0; set (a # xs) \\<subseteq> bprog_vars bp;\n        vs = aa # list\\<rbrakk>\n       \\<Longrightarrow> foldl\n                          (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s\n                          (zip (a # xs) vs)\n                         \\<in> state_bound (Array instrs) s0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs vs s aa list.\n       \\<lbrakk>\\<And>vs s.\n                   \\<lbrakk>s \\<in> state_bound bp s0;\n                    set xs \\<subseteq> bprog_vars bp\\<rbrakk>\n                   \\<Longrightarrow> foldl\n(\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n                                     \\<in> state_bound (Array instrs) s0;\n        s \\<in> state_bound bp s0; set (a # xs) \\<subseteq> bprog_vars bp;\n        vs = aa # list\\<rbrakk>\n       \\<Longrightarrow> foldl\n                          (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s\n                          (zip (a # xs) vs)\n                         \\<in> state_bound (Array instrs) s0", "using aux"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> bprog_vars bp; ?sa2 \\<in> state_bound bp s0\\<rbrakk>\n  \\<Longrightarrow> set_bit_class.set_bit ?sa2 ?x2 ?v2\n                    \\<in> state_bound bp s0\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs s aa list.\n       \\<lbrakk>\\<And>vs s.\n                   \\<lbrakk>s \\<in> state_bound bp s0;\n                    set xs \\<subseteq> bprog_vars bp\\<rbrakk>\n                   \\<Longrightarrow> foldl\n(\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n                                     \\<in> state_bound (Array instrs) s0;\n        s \\<in> state_bound bp s0; set (a # xs) \\<subseteq> bprog_vars bp;\n        vs = aa # list\\<rbrakk>\n       \\<Longrightarrow> foldl\n                          (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s\n                          (zip (a # xs) vs)\n                         \\<in> state_bound (Array instrs) s0", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldl (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs vs)\n  \\<in> state_bound (Array instrs) s0\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs ?vsa2)\n  \\<in> state_bound (Array instrs) s0\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "note aux2=this"], ["proof (state)\nthis:\n  foldl (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs ?vsa2)\n  \\<in> state_bound (Array instrs) s0\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = AssI x11 x12\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 4. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "thus ?thesis"], ["proof (prove)\nusing this:\n  foldl (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs ?vsa2)\n  \\<in> state_bound (Array instrs) s0\n\ngoal (1 subgoal):\n 1. s' \\<in> state_bound bp s0", "using STEP'"], ["proof (prove)\nusing this:\n  foldl (\\<lambda>s (x, y). set_bit_class.set_bit s x y) s (zip xs ?vsa2)\n  \\<in> state_bound (Array instrs) s0\n  (pc', s') \\<in> set (exec (instrs ! pc) (pc, s))\n\ngoal (1 subgoal):\n 1. s' \\<in> state_bound bp s0", "by (simp add: AssI)"], ["proof (state)\nthis:\n  s' \\<in> state_bound bp s0\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = TestI x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 2. \\<And>x3.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = ChoiceI x3\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0\n 3. \\<And>x4.\n       \\<lbrakk>(pc', s') \\<in> set (exec (instrs ! pc) (pc, s));\n        s \\<in> state_bound bp s0; instrs ! pc = GotoI x4\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> state_bound bp s0", "qed (auto split: if_split_asm)"], ["proof (state)\nthis:\n  s' \\<in> state_bound bp s0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_bound_step: \n  notes [simp del] = exec.simps\n  assumes BOUND: \"c \\<in> config_bound bp s0\"\n  assumes STEP: \"c'\\<in>set (nexts bp c)\"\n  shows \"c' \\<in> config_bound bp s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c' \\<in> config_bound bp s0", "using BOUND STEP"], ["proof (prove)\nusing this:\n  c \\<in> config_bound bp s0\n  c' \\<in> set (nexts bp c)\n\ngoal (1 subgoal):\n 1. c' \\<in> config_bound bp s0", "apply (cases c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>c \\<in> config_bound bp s0; c' \\<in> set (nexts bp c);\n        c = (a, b)\\<rbrakk>\n       \\<Longrightarrow> c' \\<in> config_bound bp s0", "apply (auto \n    simp add: nexts.simps \n    split: if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba)\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp\n 2. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba)\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> state_bound bp s0\n 3. \\<And>a b pc.\n       \\<lbrakk>c = (a, b); \\<not> a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0; pc \\<in> set (exec' bp b a);\n        c' = (pc, b)\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp", "apply (frule (2) exec_bound[THEN subsetD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba);\n        (aa, ba) \\<in> config_bound bp s0\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp\n 2. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba)\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> state_bound bp s0\n 3. \\<And>a b pc.\n       \\<lbrakk>c = (a, b); \\<not> a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0; pc \\<in> set (exec' bp b a);\n        c' = (pc, b)\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba); aa < pc_bound bp;\n        ba \\<in> state_bound bp s0\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp\n 2. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba)\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> state_bound bp s0\n 3. \\<And>a b pc.\n       \\<lbrakk>c = (a, b); \\<not> a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0; pc \\<in> set (exec' bp b a);\n        c' = (pc, b)\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp", "apply (frule (1) rcs_aux)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba); aa < pc_bound bp;\n        ba \\<in> state_bound bp s0; pc < pc_bound bp\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp\n 2. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba)\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> state_bound bp s0\n 3. \\<And>a b pc.\n       \\<lbrakk>c = (a, b); \\<not> a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0; pc \\<in> set (exec' bp b a);\n        c' = (pc, b)\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba)\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> state_bound bp s0\n 2. \\<And>a b pc.\n       \\<lbrakk>c = (a, b); \\<not> a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0; pc \\<in> set (exec' bp b a);\n        c' = (pc, b)\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp", "apply (frule (2) exec_bound[THEN subsetD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba pc.\n       \\<lbrakk>c = (a, b); a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0;\n        (aa, ba) \\<in> set (exec (array_get bp a) (a, b));\n        pc \\<in> set (exec' bp ba aa); c' = (pc, ba);\n        (aa, ba) \\<in> config_bound bp s0\\<rbrakk>\n       \\<Longrightarrow> ba \\<in> state_bound bp s0\n 2. \\<And>a b pc.\n       \\<lbrakk>c = (a, b); \\<not> a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0; pc \\<in> set (exec' bp b a);\n        c' = (pc, b)\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b pc.\n       \\<lbrakk>c = (a, b); \\<not> a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0; pc \\<in> set (exec' bp b a);\n        c' = (pc, b)\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp", "apply (frule (1) rcs_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b pc.\n       \\<lbrakk>c = (a, b); \\<not> a < array_length bp; a < pc_bound bp;\n        b \\<in> state_bound bp s0; pc \\<in> set (exec' bp b a);\n        c' = (pc, b); pc < pc_bound bp\\<rbrakk>\n       \\<Longrightarrow> pc < pc_bound bp", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reachable_configs_in_bound:\n  \"c \\<in> config_bound bp s0 \\<Longrightarrow> reachable_configs bp c \\<subseteq> config_bound bp s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> config_bound bp s0 \\<Longrightarrow>\n    reachable_configs bp c \\<subseteq> config_bound bp s0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<in> config_bound bp s0;\n        x \\<in> reachable_configs bp c\\<rbrakk>\n       \\<Longrightarrow> x \\<in> config_bound bp s0", "fix c'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<in> config_bound bp s0;\n        x \\<in> reachable_configs bp c\\<rbrakk>\n       \\<Longrightarrow> x \\<in> config_bound bp s0", "assume \"c' \\<in> reachable_configs bp c\" \"c \\<in> config_bound bp s0\""], ["proof (state)\nthis:\n  c' \\<in> reachable_configs bp c\n  c \\<in> config_bound bp s0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<in> config_bound bp s0;\n        x \\<in> reachable_configs bp c\\<rbrakk>\n       \\<Longrightarrow> x \\<in> config_bound bp s0", "thus \"c' \\<in> config_bound bp s0\""], ["proof (prove)\nusing this:\n  c' \\<in> reachable_configs bp c\n  c \\<in> config_bound bp s0\n\ngoal (1 subgoal):\n 1. c' \\<in> config_bound bp s0", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. c \\<in> config_bound bp s0 \\<Longrightarrow> c \\<in> config_bound bp s0\n 2. \\<And>ca x.\n       \\<lbrakk>ca \\<in> reachable_configs bp c;\n        c \\<in> config_bound bp s0 \\<Longrightarrow>\n        ca \\<in> config_bound bp s0;\n        x \\<in> set (nexts bp ca); c \\<in> config_bound bp s0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> config_bound bp s0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca x.\n       \\<lbrakk>ca \\<in> reachable_configs bp c;\n        c \\<in> config_bound bp s0 \\<Longrightarrow>\n        ca \\<in> config_bound bp s0;\n        x \\<in> set (nexts bp ca); c \\<in> config_bound bp s0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> config_bound bp s0", "by (rule in_bound_step)"], ["proof (state)\nthis:\n  c' \\<in> config_bound bp s0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_configs_out_of_bound: \"(pc',s')\\<in>reachable_configs bp (pc,s) \n  \\<Longrightarrow> \\<not> pc < pc_bound bp \\<Longrightarrow> (pc',s') = (pc,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(pc', s') \\<in> reachable_configs bp (pc, s);\n     \\<not> pc < pc_bound bp\\<rbrakk>\n    \\<Longrightarrow> (pc', s') = (pc, s)", "proof (induct rule: reachable_configs_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> pc < pc_bound bp \\<Longrightarrow> (pc, s) = (pc, s)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> reachable_configs bp (pc, s);\n        \\<not> pc < pc_bound bp \\<Longrightarrow> (a, b) = (pc, s);\n        (aa, ba) \\<in> set (nexts bp (a, b));\n        \\<not> pc < pc_bound bp\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) = (pc, s)", "case (1 pc' s' pc'' s'')"], ["proof (state)\nthis:\n  (pc', s') \\<in> reachable_configs bp (pc, s)\n  \\<not> pc < pc_bound bp \\<Longrightarrow> (pc', s') = (pc, s)\n  (pc'', s'') \\<in> set (nexts bp (pc', s'))\n  \\<not> pc < pc_bound bp\n\ngoal (2 subgoals):\n 1. \\<not> pc < pc_bound bp \\<Longrightarrow> (pc, s) = (pc, s)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> reachable_configs bp (pc, s);\n        \\<not> pc < pc_bound bp \\<Longrightarrow> (a, b) = (pc, s);\n        (aa, ba) \\<in> set (nexts bp (a, b));\n        \\<not> pc < pc_bound bp\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) = (pc, s)", "hence [simp]: \"pc'=pc\" \"s'=s\""], ["proof (prove)\nusing this:\n  (pc', s') \\<in> reachable_configs bp (pc, s)\n  \\<not> pc < pc_bound bp \\<Longrightarrow> (pc', s') = (pc, s)\n  (pc'', s'') \\<in> set (nexts bp (pc', s'))\n  \\<not> pc < pc_bound bp\n\ngoal (1 subgoal):\n 1. pc' = pc &&& s' = s", "by auto"], ["proof (state)\nthis:\n  pc' = pc\n  s' = s\n\ngoal (2 subgoals):\n 1. \\<not> pc < pc_bound bp \\<Longrightarrow> (pc, s) = (pc, s)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> reachable_configs bp (pc, s);\n        \\<not> pc < pc_bound bp \\<Longrightarrow> (a, b) = (pc, s);\n        (aa, ba) \\<in> set (nexts bp (a, b));\n        \\<not> pc < pc_bound bp\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) = (pc, s)", "from 1(4)"], ["proof (chain)\npicking this:\n  \\<not> pc < pc_bound bp", "have \"\\<not> pc < array_length bp\""], ["proof (prove)\nusing this:\n  \\<not> pc < pc_bound bp\n\ngoal (1 subgoal):\n 1. \\<not> pc < array_length bp", "unfolding pc_bound_def"], ["proof (prove)\nusing this:\n  \\<not> pc < max (Max (max_next_pcs (list_of_array bp)) + 1)\n               (array_length bp + 1)\n\ngoal (1 subgoal):\n 1. \\<not> pc < array_length bp", "by auto"], ["proof (state)\nthis:\n  \\<not> pc < array_length bp\n\ngoal (2 subgoals):\n 1. \\<not> pc < pc_bound bp \\<Longrightarrow> (pc, s) = (pc, s)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> reachable_configs bp (pc, s);\n        \\<not> pc < pc_bound bp \\<Longrightarrow> (a, b) = (pc, s);\n        (aa, ba) \\<in> set (nexts bp (a, b));\n        \\<not> pc < pc_bound bp\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) = (pc, s)", "with 1(3)"], ["proof (chain)\npicking this:\n  (pc'', s'') \\<in> set (nexts bp (pc', s'))\n  \\<not> pc < array_length bp", "show ?case"], ["proof (prove)\nusing this:\n  (pc'', s'') \\<in> set (nexts bp (pc', s'))\n  \\<not> pc < array_length bp\n\ngoal (1 subgoal):\n 1. (pc'', s'') = (pc, s)", "by (auto simp add: nexts.simps exec'.simps)"], ["proof (state)\nthis:\n  (pc'', s'') = (pc, s)\n\ngoal (1 subgoal):\n 1. \\<not> pc < pc_bound bp \\<Longrightarrow> (pc, s) = (pc, s)", "qed auto"], ["", "lemma finite_bexp_vars[simp, intro!]: \"finite (bexp_vars be)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bexp_vars be)", "by (induction be) auto"], ["", "lemma finite_instr_vars[simp, intro!]: \"finite (instr_vars ins)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (instr_vars ins)", "by (cases ins) auto"], ["", "lemma finite_bprog_vars[simp, intro!]: \"finite (bprog_vars bp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bprog_vars bp)", "unfolding bprog_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (instr_vars ` set (list_of_array bp)))", "by simp"], ["", "lemma finite_state_bound[simp, intro!]: \"finite (state_bound bp s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (state_bound bp s0)", "unfolding state_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}", "apply (rule finite_imageD[where f=bs_\\<alpha>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (bs_\\<alpha> `\n      {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp})\n 2. inj_on bs_\\<alpha>\n     {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}", "apply (rule finite_subset[where \n    B = \"{s. s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. bs_\\<alpha> `\n    {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}\n    \\<subseteq> {s. s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}\n 2. finite {s. s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}\n 3. inj_on bs_\\<alpha>\n     {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {s. s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}\n 2. inj_on bs_\\<alpha>\n     {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}", "apply (rule finite_if_eq_beyond_finite)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (bprog_vars bp)\n 2. inj_on bs_\\<alpha>\n     {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on bs_\\<alpha>\n     {s. bs_\\<alpha> s - bprog_vars bp = bs_\\<alpha> s0 - bprog_vars bp}", "apply (rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {s. bs_\\<alpha> s - bprog_vars bp =\n                            bs_\\<alpha> s0 - bprog_vars bp};\n        y \\<in> {s. bs_\\<alpha> s - bprog_vars bp =\n                    bs_\\<alpha> s0 - bprog_vars bp};\n        bs_\\<alpha> x = bs_\\<alpha> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (fold bs_eq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {s. bs_\\<alpha> s - bprog_vars bp =\n                            bs_\\<alpha> s0 - bprog_vars bp};\n        y \\<in> {s. bs_\\<alpha> s - bprog_vars bp =\n                    bs_\\<alpha> s0 - bprog_vars bp};\n        bs_\\<alpha> x = bs_\\<alpha> y\\<rbrakk>\n       \\<Longrightarrow> bs_eq x y", "apply (auto simp: bs_eq_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_config_bound[simp, intro!]: \"finite (config_bound bp s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (config_bound bp s0)", "by blast"], ["", "lemma reachable_configs_finite[simp, intro!]: \n  \"finite (reachable_configs bp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (reachable_configs bp c)", "proof (cases c, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       c = (a, b) \\<Longrightarrow> finite (reachable_configs bp (a, b))", "fix pc s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       c = (a, b) \\<Longrightarrow> finite (reachable_configs bp (a, b))", "show \"finite (reachable_configs bp (pc, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (reachable_configs bp (pc, s))", "proof (cases \"pc < pc_bound bp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pc < pc_bound bp \\<Longrightarrow> finite (reachable_configs bp (pc, s))\n 2. \\<not> pc < pc_bound bp \\<Longrightarrow>\n    finite (reachable_configs bp (pc, s))", "case False"], ["proof (state)\nthis:\n  \\<not> pc < pc_bound bp\n\ngoal (2 subgoals):\n 1. pc < pc_bound bp \\<Longrightarrow> finite (reachable_configs bp (pc, s))\n 2. \\<not> pc < pc_bound bp \\<Longrightarrow>\n    finite (reachable_configs bp (pc, s))", "from reachable_configs_out_of_bound[OF _ False, where s=s]"], ["proof (chain)\npicking this:\n  (?pc', ?s') \\<in> reachable_configs bp (pc, s) \\<Longrightarrow>\n  (?pc', ?s') = (pc, s)", "have \"reachable_configs bp (pc, s) \\<subseteq> {(pc,s)}\""], ["proof (prove)\nusing this:\n  (?pc', ?s') \\<in> reachable_configs bp (pc, s) \\<Longrightarrow>\n  (?pc', ?s') = (pc, s)\n\ngoal (1 subgoal):\n 1. reachable_configs bp (pc, s) \\<subseteq> {(pc, s)}", "by auto"], ["proof (state)\nthis:\n  reachable_configs bp (pc, s) \\<subseteq> {(pc, s)}\n\ngoal (2 subgoals):\n 1. pc < pc_bound bp \\<Longrightarrow> finite (reachable_configs bp (pc, s))\n 2. \\<not> pc < pc_bound bp \\<Longrightarrow>\n    finite (reachable_configs bp (pc, s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  reachable_configs bp (pc, s) \\<subseteq> {(pc, s)}\n\ngoal (1 subgoal):\n 1. finite (reachable_configs bp (pc, s))", "by (rule finite_subset) auto"], ["proof (state)\nthis:\n  finite (reachable_configs bp (pc, s))\n\ngoal (1 subgoal):\n 1. pc < pc_bound bp \\<Longrightarrow> finite (reachable_configs bp (pc, s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pc < pc_bound bp \\<Longrightarrow> finite (reachable_configs bp (pc, s))", "case True"], ["proof (state)\nthis:\n  pc < pc_bound bp\n\ngoal (1 subgoal):\n 1. pc < pc_bound bp \\<Longrightarrow> finite (reachable_configs bp (pc, s))", "hence \"(pc,s) \\<in> config_bound bp s\""], ["proof (prove)\nusing this:\n  pc < pc_bound bp\n\ngoal (1 subgoal):\n 1. (pc, s) \\<in> config_bound bp s", "by (simp add: state_bound_def)"], ["proof (state)\nthis:\n  (pc, s) \\<in> config_bound bp s\n\ngoal (1 subgoal):\n 1. pc < pc_bound bp \\<Longrightarrow> finite (reachable_configs bp (pc, s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (pc, s) \\<in> config_bound bp s\n\ngoal (1 subgoal):\n 1. finite (reachable_configs bp (pc, s))", "by (rule finite_subset[OF reachable_configs_in_bound]) simp"], ["proof (state)\nthis:\n  finite (reachable_configs bp (pc, s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (reachable_configs bp (pc, s))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"bpc_is_run bpc r \\<equiv> let (bp,c)=bpc in r 0 = c \\<and> (\\<forall>i. r (Suc i) \\<in> set (BoolProgs.nexts bp (r i)))\""], ["", "definition \"bpc_props c \\<equiv> bs_\\<alpha> (snd c)\""], ["", "definition \"bpc_lang bpc \\<equiv> {bpc_props o r | r. bpc_is_run bpc r}\""], ["", "(* Printing *)\n(*definition print_list where\n  \"print_list f sep s = (let f' = (\\<lambda>str s. if str = [] then f s\n                                       else str @ sep @ f s)\n                     in ''['' @ (foldl f' [] s) @ '']'')\"\n\nfun bool_list_to_prop_list where\n  \"bool_list_to_prop_list _ [] props = props\"\n| \"bool_list_to_prop_list n (x#xs) props = (let props' = if x then n#props else props \n                                            in bool_list_to_prop_list (Suc n) xs props')\"\n*)"], ["", "fun print_config :: \n  \"(nat \\<Rightarrow> string) \\<Rightarrow> (bitset \\<Rightarrow> string) \\<Rightarrow> config \\<Rightarrow> string\" where\n  \"print_config f fx (p,s) = f p @ '' '' @ fx s\""], ["", "end"]]}