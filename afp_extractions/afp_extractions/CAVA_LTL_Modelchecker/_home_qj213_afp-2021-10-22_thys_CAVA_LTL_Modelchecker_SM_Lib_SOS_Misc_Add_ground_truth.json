{"file_name": "/home/qj213/afp-2021-10-22/thys/CAVA_LTL_Modelchecker/SM/Lib/SOS_Misc_Add.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CAVA_LTL_Modelchecker", "problem_names": ["lemma finite_ImageI:\n  assumes \"finite A\"  \n  assumes \"\\<And>a. a\\<in>A \\<Longrightarrow> finite (R``{a})\"\n  shows \"finite (R``A)\"", "lemma do_set_push_Image:\n    \"\\<And>g f m. g`(do {x\\<leftarrow>m; f x}) = do {x\\<leftarrow>m; g`f x}\"\n    \"\\<And>g f m. g`(do {let x = m; f x}) = (do {let x=m; g`f x})\"", "lemma case_option_distrib: \"f (case x of Some v \\<Rightarrow> fs v | None \\<Rightarrow> fn) \n    = (case x of Some v \\<Rightarrow> f (fs v) | None \\<Rightarrow> f fn)\"", "lemma case_sum_distrib: \"f (case x of Inl x \\<Rightarrow> fl x | Inr x \\<Rightarrow> fr x) = \n    (case x of Inl x \\<Rightarrow> f (fl x) | Inr x \\<Rightarrow> f (fr x))\"", "lemma do_set_eq_bind:\n    assumes \"m'=m\"\n    assumes \"\\<And>x. x\\<in>m \\<Longrightarrow> f x = g x\"\n    shows \"do {x\\<leftarrow>m; f x} = do {x\\<leftarrow>m'; g x}\"", "lemma finite_bindI[intro]:\n    assumes \"finite m\"\n    assumes \"\\<And>x. x\\<in>m \\<Longrightarrow> finite (f x)\"\n    shows \"finite (do { x\\<leftarrow>m; f x })\"", "lemma assert_option_eqs[simp]:\n    \"assert_option \\<Phi> = Some x \\<longleftrightarrow> \\<Phi>\"  \n    \"assert_option \\<Phi> = None \\<longleftrightarrow> \\<not>\\<Phi>\"", "lemma disj_eq_nota_conv[simp]:\n    \"(a \\<or> b \\<longleftrightarrow> \\<not>a) \\<longleftrightarrow> (a=False \\<and> b=True)\" \n    \"(b \\<or> a \\<longleftrightarrow> \\<not>a) \\<longleftrightarrow> (a=False \\<and> b=True)\" \n    \"(\\<not>a \\<or> b \\<longleftrightarrow> a) \\<longleftrightarrow> (a=True \\<and> b=True)\" \n    \"(b \\<or> \\<not>a \\<longleftrightarrow> a) \\<longleftrightarrow> (a=True \\<and> b=True)\"", "lemma all_disjx_conv[simp]:\n    \"(\\<forall>x. x \\<or> P x) \\<longleftrightarrow> P False\"  \n    \"(\\<forall>x. x \\<or> P (\\<not>x)) \\<longleftrightarrow> P True\"", "lemma neq_Some_bool_cases[consumes 1, case_names None Some]:\n    assumes \"a\\<noteq>Some x\"  \n    obtains \"a=None\" | \"a = Some (\\<not>x)\"", "lemma find_min_idx_None_conv: \n    \"find_min_idx P l = None \\<longleftrightarrow> (\\<forall>a\\<in>set l. \\<not>P a)\"", "lemma find_min_idx_SomeD:\n    \"find_min_idx P l = Some i \\<Longrightarrow> P (l!i) \\<and> i < length l\"", "lemma find_min_idx_SomeD_complete: \n    \"find_min_idx P l = Some i \\<Longrightarrow> (P (l!i) \\<and> i < length l \\<and> (\\<forall>j<i. \\<not>P (l!j)))\""], "translations": [["", "lemma finite_ImageI:\n  assumes \"finite A\"  \n  assumes \"\\<And>a. a\\<in>A \\<Longrightarrow> finite (R``{a})\"\n  shows \"finite (R``A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R `` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (R `` A)", "note [[simproc add: finite_Collect]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. finite (R `` A)", "have \"R``A = \\<Union>{R``{a} | a. a:A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` A = \\<Union> {R `` {a} |a. a \\<in> A}", "by auto"], ["proof (state)\nthis:\n  R `` A = \\<Union> {R `` {a} |a. a \\<in> A}\n\ngoal (1 subgoal):\n 1. finite (R `` A)", "also"], ["proof (state)\nthis:\n  R `` A = \\<Union> {R `` {a} |a. a \\<in> A}\n\ngoal (1 subgoal):\n 1. finite (R `` A)", "have \"finite (\\<Union>{R``{a} | a. a:A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> {R `` {a} |a. a \\<in> A})", "apply (rule finite_Union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {R `` {a} |a. a \\<in> A}\n 2. \\<And>M. M \\<in> {R `` {a} |a. a \\<in> A} \\<Longrightarrow> finite M", "apply (simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M. M \\<in> {R `` {a} |a. a \\<in> A} \\<Longrightarrow> finite M", "apply (clarsimp simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite (\\<Union> {R `` {a} |a. a \\<in> A})\n\ngoal (1 subgoal):\n 1. finite (R `` A)", "finally"], ["proof (chain)\npicking this:\n  finite (R `` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (R `` A)\n\ngoal (1 subgoal):\n 1. finite (R `` A)", "."], ["proof (state)\nthis:\n  finite (R `` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Set monad utilities *)"], ["", "lemma do_set_push_Image:\n    \"\\<And>g f m. g`(do {x\\<leftarrow>m; f x}) = do {x\\<leftarrow>m; g`f x}\"\n    \"\\<And>g f m. g`(do {let x = m; f x}) = (do {let x=m; g`f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g f m. g ` (m \\<bind> f) = m \\<bind> (\\<lambda>x. g ` f x)) &&&\n    (\\<And>g f m. g ` Let m f = (let x = m in g ` f x))", "by fastforce+"], ["", "lemma case_option_distrib: \"f (case x of Some v \\<Rightarrow> fs v | None \\<Rightarrow> fn) \n    = (case x of Some v \\<Rightarrow> f (fs v) | None \\<Rightarrow> f fn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (case x of None \\<Rightarrow> fn | Some v \\<Rightarrow> fs v) =\n    (case x of None \\<Rightarrow> f fn | Some v \\<Rightarrow> f (fs v))", "by (auto split: option.split)"], ["", "lemma case_sum_distrib: \"f (case x of Inl x \\<Rightarrow> fl x | Inr x \\<Rightarrow> fr x) = \n    (case x of Inl x \\<Rightarrow> f (fl x) | Inr x \\<Rightarrow> f (fr x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (case x of Inl x \\<Rightarrow> fl x | Inr x \\<Rightarrow> fr x) =\n    (case x of Inl x \\<Rightarrow> f (fl x) | Inr x \\<Rightarrow> f (fr x))", "by (auto split: sum.split)"], ["", "lemma do_set_eq_bind:\n    assumes \"m'=m\"\n    assumes \"\\<And>x. x\\<in>m \\<Longrightarrow> f x = g x\"\n    shows \"do {x\\<leftarrow>m; f x} = do {x\\<leftarrow>m'; g x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f = m' \\<bind> g", "using assms"], ["proof (prove)\nusing this:\n  m' = m\n  ?x \\<in> m \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. m \\<bind> f = m' \\<bind> g", "by auto"], ["", "lemma finite_bindI[intro]:\n    assumes \"finite m\"\n    assumes \"\\<And>x. x\\<in>m \\<Longrightarrow> finite (f x)\"\n    shows \"finite (do { x\\<leftarrow>m; f x })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (m \\<bind> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (m \\<bind> f)", "have S: \"do { x\\<leftarrow>m; f x } = \\<Union>(f`m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f = \\<Union> (f ` m)", "by auto"], ["proof (state)\nthis:\n  m \\<bind> f = \\<Union> (f ` m)\n\ngoal (1 subgoal):\n 1. finite (m \\<bind> f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (m \\<bind> f)", "apply (subst S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (f ` m))", "using assms"], ["proof (prove)\nusing this:\n  finite m\n  ?x \\<in> m \\<Longrightarrow> finite (f ?x)\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (f ` m))", "by blast"], ["proof (state)\nthis:\n  finite (m \\<bind> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Option monad utilities *)"], ["", "primrec assert_option :: \"bool \\<Rightarrow> unit option\" where\n    \"assert_option True = Some ()\" | \"assert_option False = None\""], ["", "lemma assert_option_eqs[simp]:\n    \"assert_option \\<Phi> = Some x \\<longleftrightarrow> \\<Phi>\"  \n    \"assert_option \\<Phi> = None \\<longleftrightarrow> \\<not>\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (assert_option \\<Phi> = Some x) = \\<Phi> &&&\n    (assert_option \\<Phi> = None) = (\\<not> \\<Phi>)", "by (cases \\<Phi>) auto"], ["", "(* TODO: Move *)"], ["", "lemma disj_eq_nota_conv[simp]:\n    \"(a \\<or> b \\<longleftrightarrow> \\<not>a) \\<longleftrightarrow> (a=False \\<and> b=True)\" \n    \"(b \\<or> a \\<longleftrightarrow> \\<not>a) \\<longleftrightarrow> (a=False \\<and> b=True)\" \n    \"(\\<not>a \\<or> b \\<longleftrightarrow> a) \\<longleftrightarrow> (a=True \\<and> b=True)\" \n    \"(b \\<or> \\<not>a \\<longleftrightarrow> a) \\<longleftrightarrow> (a=True \\<and> b=True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((a \\<or> b) = (\\<not> a)) = (a = False \\<and> b = True) &&&\n     ((b \\<or> a) = (\\<not> a)) = (a = False \\<and> b = True)) &&&\n    ((\\<not> a \\<or> b) = a) = (a = True \\<and> b = True) &&&\n    ((b \\<or> \\<not> a) = a) = (a = True \\<and> b = True)", "by auto"], ["", "lemma all_disjx_conv[simp]:\n    \"(\\<forall>x. x \\<or> P x) \\<longleftrightarrow> P False\"  \n    \"(\\<forall>x. x \\<or> P (\\<not>x)) \\<longleftrightarrow> P True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<or> P x) = P False &&&\n    (\\<forall>x. x \\<or> P (\\<not> x)) = P True", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>x. x \\<or> P x \\<Longrightarrow> P False\n 2. \\<And>x. \\<lbrakk>P False; \\<not> P x\\<rbrakk> \\<Longrightarrow> x\n 3. \\<forall>x. x \\<or> P (\\<not> x) \\<Longrightarrow> P True\n 4. \\<And>x.\n       \\<lbrakk>P True; \\<not> P (\\<not> x)\\<rbrakk> \\<Longrightarrow> x", "apply (drule spec[where x=False], simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. \\<lbrakk>P False; \\<not> P x\\<rbrakk> \\<Longrightarrow> x\n 2. \\<forall>x. x \\<or> P (\\<not> x) \\<Longrightarrow> P True\n 3. \\<And>x.\n       \\<lbrakk>P True; \\<not> P (\\<not> x)\\<rbrakk> \\<Longrightarrow> x", "apply (case_tac x, auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x. x \\<or> P (\\<not> x) \\<Longrightarrow> P True\n 2. \\<And>x.\n       \\<lbrakk>P True; \\<not> P (\\<not> x)\\<rbrakk> \\<Longrightarrow> x", "apply (drule spec[where x=False], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P True; \\<not> P (\\<not> x)\\<rbrakk> \\<Longrightarrow> x", "apply (case_tac x, auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma neq_Some_bool_cases[consumes 1, case_names None Some]:\n    assumes \"a\\<noteq>Some x\"  \n    obtains \"a=None\" | \"a = Some (\\<not>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = None \\<Longrightarrow> thesis;\n     a = Some (\\<not> x) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> Some x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = None \\<Longrightarrow> thesis;\n     a = Some (\\<not> x) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "primrec find_min_idx :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<rightharpoonup> nat\" where\n    \"find_min_idx P [] = None\"\n  | \"find_min_idx P (x#xs) = (\n      if P x then Some 0 else\n      map_option Suc (find_min_idx P xs)\n    )\""], ["", "lemma find_min_idx_None_conv: \n    \"find_min_idx P l = None \\<longleftrightarrow> (\\<forall>a\\<in>set l. \\<not>P a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_min_idx P l = None) = (\\<forall>a\\<in>set l. \\<not> P a)", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (find_min_idx P [] = None) = (\\<forall>a\\<in>set []. \\<not> P a)\n 2. \\<And>a l.\n       (find_min_idx P l = None) =\n       (\\<forall>a\\<in>set l. \\<not> P a) \\<Longrightarrow>\n       (find_min_idx P (a # l) = None) =\n       (\\<forall>a\\<in>set (a # l). \\<not> P a)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma find_min_idx_SomeD:\n    \"find_min_idx P l = Some i \\<Longrightarrow> P (l!i) \\<and> i < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_min_idx P l = Some i \\<Longrightarrow>\n    P (l ! i) \\<and> i < length l", "by (induction l arbitrary: i) (auto split: if_split_asm)"], ["", "lemma find_min_idx_SomeD_complete: \n    \"find_min_idx P l = Some i \\<Longrightarrow> (P (l!i) \\<and> i < length l \\<and> (\\<forall>j<i. \\<not>P (l!j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_min_idx P l = Some i \\<Longrightarrow>\n    P (l ! i) \\<and> i < length l \\<and> (\\<forall>j<i. \\<not> P (l ! j))", "apply (induction l arbitrary: i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       find_min_idx P [] = Some i \\<Longrightarrow>\n       P ([] ! i) \\<and>\n       i < length [] \\<and> (\\<forall>j<i. \\<not> P ([] ! j))\n 2. \\<And>a l i.\n       \\<lbrakk>\\<And>i.\n                   find_min_idx P l = Some i \\<Longrightarrow>\n                   P (l ! i) \\<and>\n                   i < length l \\<and> (\\<forall>j<i. \\<not> P (l ! j));\n        find_min_idx P (a # l) = Some i\\<rbrakk>\n       \\<Longrightarrow> P ((a # l) ! i) \\<and>\n                         i < length (a # l) \\<and>\n                         (\\<forall>j<i. \\<not> P ((a # l) ! j))", "apply (auto split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l z j.\n       \\<lbrakk>\\<not> P a; find_min_idx P l = Some z; j < Suc z;\n        P ((a # l) ! j); P (l ! z); z < length l;\n        \\<forall>j<z. \\<not> P (l ! j)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l z j.\n       \\<lbrakk>\\<not> P a; find_min_idx P l = Some z; j < Suc z;\n        P ((a # l) ! j); P (l ! z); z < length l;\n        \\<forall>j<z. \\<not> P (l ! j); j = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a l z j nat.\n       \\<lbrakk>\\<not> P a; find_min_idx P l = Some z; j < Suc z;\n        P ((a # l) ! j); P (l ! z); z < length l;\n        \\<forall>j<z. \\<not> P (l ! j); j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}