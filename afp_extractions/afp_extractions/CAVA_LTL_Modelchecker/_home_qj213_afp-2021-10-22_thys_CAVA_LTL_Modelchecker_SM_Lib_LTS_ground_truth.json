{"file_name": "/home/qj213/afp-2021-10-22/thys/CAVA_LTL_Modelchecker/SM/Lib/LTS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CAVA_LTL_Modelchecker", "problem_names": ["lemma path_append[simp]: \n      \"path s (p@p') s' \\<longleftrightarrow> (\\<exists>sh. path s p sh \\<and> path sh p' s')\"", "lemma path_trans[trans]:\n      \"step s l sh \\<Longrightarrow> step sh l' s' \\<Longrightarrow> path s [l,l'] s'\"\n      \"step s l sh \\<Longrightarrow> path sh p s' \\<Longrightarrow> path s (l#p) s'\"\n      \"path s p sh \\<Longrightarrow> step sh l s' \\<Longrightarrow> path s (p@[l]) s'\"\n      \"path s p sh \\<Longrightarrow> path sh p' s' \\<Longrightarrow> path s (p@p') s'\"", "lemma path_sngI: \"step s a s' \\<Longrightarrow> path s [a] s'\"", "lemma path_emptyI: \"path s [] s\"", "lemma reachableI: \"path s p s' \\<Longrightarrow> reachable s s'\"", "lemma reachable_trans[trans]:\n      \"reachable s sh \\<Longrightarrow> step sh l s' \\<Longrightarrow> reachable s s'\"\n      \"reachable s sh \\<Longrightarrow> path sh p s' \\<Longrightarrow> reachable s s'\"\n      \"path s p sh \\<Longrightarrow> reachable sh s' \\<Longrightarrow> reachable s s'\"\n      \"step s l sh \\<Longrightarrow> reachable sh s' \\<Longrightarrow> reachable s s'\"", "lemma G_simps[simp]:\n      \"g_V G = UNIV\"\n      \"g_E G = step\"\n      \"g_V0 G = Collect init\"", "lemma path_is_step: \"lts.path c p c' \\<Longrightarrow> (c, c') \\<in> step\\<^sup>*\"", "lemma step_is_path: \"(c, c') \\<in> step\\<^sup>* \\<Longrightarrow> \\<exists>p. lts.path c p c'\"", "lemma step_path_conv: \"(c, c') \\<in> step\\<^sup>* \\<longleftrightarrow> (\\<exists>p. lts.path c p c')\""], "translations": [["", "lemma path_append[simp]: \n      \"path s (p@p') s' \\<longleftrightarrow> (\\<exists>sh. path s p sh \\<and> path sh p' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.path s (p @ p') s' =\n    (\\<exists>sh. local.path s p sh \\<and> local.path sh p' s')", "by (induction p arbitrary: s) auto"], ["", "lemma path_trans[trans]:\n      \"step s l sh \\<Longrightarrow> step sh l' s' \\<Longrightarrow> path s [l,l'] s'\"\n      \"step s l sh \\<Longrightarrow> path sh p s' \\<Longrightarrow> path s (l#p) s'\"\n      \"path s p sh \\<Longrightarrow> step sh l s' \\<Longrightarrow> path s (p@[l]) s'\"\n      \"path s p sh \\<Longrightarrow> path sh p' s' \\<Longrightarrow> path s (p@p') s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>step s l sh; step sh l' s'\\<rbrakk>\n      \\<Longrightarrow> local.path s [l, l'] s') &&&\n     (\\<lbrakk>step s l sh; local.path sh p s'\\<rbrakk>\n      \\<Longrightarrow> local.path s (l # p) s')) &&&\n    (\\<lbrakk>local.path s p sh; step sh l s'\\<rbrakk>\n     \\<Longrightarrow> local.path s (p @ [l]) s') &&&\n    (\\<lbrakk>local.path s p sh; local.path sh p' s'\\<rbrakk>\n     \\<Longrightarrow> local.path s (p @ p') s')", "by auto"], ["", "lemma path_sngI: \"step s a s' \\<Longrightarrow> path s [a] s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step s a s' \\<Longrightarrow> local.path s [a] s'", "by auto"], ["", "lemma path_emptyI: \"path s [] s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.path s [] s", "by auto"], ["", "definition \"reachable s s' \\<equiv> \\<exists>p. path s p s'\""], ["", "lemma reachableI: \"path s p s' \\<Longrightarrow> reachable s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.path s p s' \\<Longrightarrow> reachable s s'", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.path s p s' \\<Longrightarrow> \\<exists>p. local.path s p s'", "by auto"], ["", "lemma reachable_trans[trans]:\n      \"reachable s sh \\<Longrightarrow> step sh l s' \\<Longrightarrow> reachable s s'\"\n      \"reachable s sh \\<Longrightarrow> path sh p s' \\<Longrightarrow> reachable s s'\"\n      \"path s p sh \\<Longrightarrow> reachable sh s' \\<Longrightarrow> reachable s s'\"\n      \"step s l sh \\<Longrightarrow> reachable sh s' \\<Longrightarrow> reachable s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>reachable s sh; step sh l s'\\<rbrakk>\n      \\<Longrightarrow> reachable s s') &&&\n     (\\<lbrakk>reachable s sh; local.path sh p s'\\<rbrakk>\n      \\<Longrightarrow> reachable s s')) &&&\n    (\\<lbrakk>local.path s p sh; reachable sh s'\\<rbrakk>\n     \\<Longrightarrow> reachable s s') &&&\n    (\\<lbrakk>step s l sh; reachable sh s'\\<rbrakk>\n     \\<Longrightarrow> reachable s s')", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>\\<exists>p. local.path s p sh; step sh l s'\\<rbrakk>\n      \\<Longrightarrow> \\<exists>p. local.path s p s') &&&\n     (\\<lbrakk>\\<exists>p. local.path s p sh; local.path sh p s'\\<rbrakk>\n      \\<Longrightarrow> \\<exists>p. local.path s p s')) &&&\n    (\\<lbrakk>local.path s p sh; \\<exists>p. local.path sh p s'\\<rbrakk>\n     \\<Longrightarrow> \\<exists>p. local.path s p s') &&&\n    (\\<lbrakk>step s l sh; \\<exists>p. local.path sh p s'\\<rbrakk>\n     \\<Longrightarrow> \\<exists>p. local.path s p s')", "by (auto dest: path_trans)"], ["", "end"], ["", "locale asystem =\n    lts: LTS astep\n    for init :: \"'c \\<Rightarrow> bool\"\n    and astep :: \"'c \\<Rightarrow> 'a \\<Rightarrow> 'c \\<Rightarrow> bool\"\n  begin"], ["", "definition step :: \"'c digraph\"\n      where \"step \\<equiv> {(c, c'). \\<exists> a. astep c a c'}\""], ["", "definition G :: \"'c graph_rec\"\n      where \"G \\<equiv> \\<lparr> g_V = UNIV, g_E = step, g_V0 = Collect init \\<rparr>\""], ["", "lemma G_simps[simp]:\n      \"g_V G = UNIV\"\n      \"g_E G = step\"\n      \"g_V0 G = Collect init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_V G = UNIV &&& g_E G = step &&& g_V0 G = Collect init", "unfolding G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_V \\<lparr>g_V = UNIV, g_E = step, g_V0 = Collect init\\<rparr> =\n    UNIV &&&\n    g_E \\<lparr>g_V = UNIV, g_E = step, g_V0 = Collect init\\<rparr> =\n    step &&&\n    g_V0 \\<lparr>g_V = UNIV, g_E = step, g_V0 = Collect init\\<rparr> =\n    Collect init", "by simp+"], ["", "sublocale graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph G", "by unfold_locales auto"], ["", "lemma path_is_step: \"lts.path c p c' \\<Longrightarrow> (c, c') \\<in> step\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lts.path c p c' \\<Longrightarrow> (c, c') \\<in> step\\<^sup>*", "unfolding step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lts.path c p c' \\<Longrightarrow>\n    (c, c') \\<in> {(c, c'). \\<exists>a. astep c a c'}\\<^sup>*", "apply (induction p arbitrary: c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       lts.path c [] c' \\<Longrightarrow>\n       (c, c') \\<in> {(c, c'). \\<exists>a. astep c a c'}\\<^sup>*\n 2. \\<And>a p c.\n       \\<lbrakk>\\<And>c.\n                   lts.path c p c' \\<Longrightarrow>\n                   (c, c')\n                   \\<in> {(c, c'). \\<exists>a. astep c a c'}\\<^sup>*;\n        lts.path c (a # p) c'\\<rbrakk>\n       \\<Longrightarrow> (c, c')\n                         \\<in> {(c, c'). \\<exists>a. astep c a c'}\\<^sup>*", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p c sh.\n       \\<lbrakk>\\<And>c.\n                   lts.path c p c' \\<Longrightarrow>\n                   (c, c')\n                   \\<in> {(c, c'). \\<exists>a. astep c a c'}\\<^sup>*;\n        astep c a sh; lts.path sh p c'\\<rbrakk>\n       \\<Longrightarrow> (c, c')\n                         \\<in> {(c, c'). \\<exists>a. astep c a c'}\\<^sup>*", "by (metis (mono_tags, lifting) case_prod_conv converse_rtrancl_into_rtrancl mem_Collect_eq)"], ["", "lemma step_is_path: \"(c, c') \\<in> step\\<^sup>* \\<Longrightarrow> \\<exists>p. lts.path c p c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, c') \\<in> step\\<^sup>* \\<Longrightarrow> \\<exists>p. lts.path c p c'", "proof (induction rule: converse_rtrancl_induct, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p. lts.path c' p c'\n 2. \\<And>y z p.\n       \\<lbrakk>(y, z) \\<in> step; (z, c') \\<in> step\\<^sup>*;\n        lts.path z p c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. lts.path y p c'", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p. lts.path c' p c'\n 2. \\<And>y z p.\n       \\<lbrakk>(y, z) \\<in> step; (z, c') \\<in> step\\<^sup>*;\n        lts.path z p c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. lts.path y p c'", "show \"\\<exists>p. lts.path c p c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. lts.path c p c", "apply (rule exI[where x=\"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lts.path c [] c", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. lts.path c p c\n\ngoal (1 subgoal):\n 1. \\<And>y z p.\n       \\<lbrakk>(y, z) \\<in> step; (z, c') \\<in> step\\<^sup>*;\n        lts.path z p c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. lts.path y p c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z p.\n       \\<lbrakk>(y, z) \\<in> step; (z, c') \\<in> step\\<^sup>*;\n        lts.path z p c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. lts.path y p c'", "fix c ch p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z p.\n       \\<lbrakk>(y, z) \\<in> step; (z, c') \\<in> step\\<^sup>*;\n        lts.path z p c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. lts.path y p c'", "assume \"(c, ch) \\<in> step\" and 1: \"lts.path ch p c'\""], ["proof (state)\nthis:\n  (c, ch) \\<in> step\n  lts.path ch p c'\n\ngoal (1 subgoal):\n 1. \\<And>y z p.\n       \\<lbrakk>(y, z) \\<in> step; (z, c') \\<in> step\\<^sup>*;\n        lts.path z p c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. lts.path y p c'", "then"], ["proof (chain)\npicking this:\n  (c, ch) \\<in> step\n  lts.path ch p c'", "obtain a where \"astep c a ch\""], ["proof (prove)\nusing this:\n  (c, ch) \\<in> step\n  lts.path ch p c'\n\ngoal (1 subgoal):\n 1. (\\<And>a. astep c a ch \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: step_def)"], ["proof (state)\nthis:\n  astep c a ch\n\ngoal (1 subgoal):\n 1. \\<And>y z p.\n       \\<lbrakk>(y, z) \\<in> step; (z, c') \\<in> step\\<^sup>*;\n        lts.path z p c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. lts.path y p c'", "with 1"], ["proof (chain)\npicking this:\n  lts.path ch p c'\n  astep c a ch", "show \"\\<exists>p. lts.path c p c'\""], ["proof (prove)\nusing this:\n  lts.path ch p c'\n  astep c a ch\n\ngoal (1 subgoal):\n 1. \\<exists>p. lts.path c p c'", "apply (rule_tac exI[where x=\"a#p\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lts.path ch p c'; astep c a ch\\<rbrakk>\n    \\<Longrightarrow> lts.path c (a # p) c'", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. lts.path c p c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_path_conv: \"(c, c') \\<in> step\\<^sup>* \\<longleftrightarrow> (\\<exists>p. lts.path c p c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c, c') \\<in> step\\<^sup>*) = (\\<exists>p. lts.path c p c')", "using path_is_step step_is_path"], ["proof (prove)\nusing this:\n  lts.path ?c ?p ?c' \\<Longrightarrow> (?c, ?c') \\<in> step\\<^sup>*\n  (?c, ?c') \\<in> step\\<^sup>* \\<Longrightarrow>\n  \\<exists>p. lts.path ?c p ?c'\n\ngoal (1 subgoal):\n 1. ((c, c') \\<in> step\\<^sup>*) = (\\<exists>p. lts.path c p c')", "by blast"], ["", "end"], ["", "end"]]}