{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/JMM_Type.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemmas jmm_heap_ops_defs =\n  jmm_allocate_def jmm_typeof_addr_def \n  jmm_heap_read_def jmm_heap_write_def\n  jmm_allocated_def jmm_spurious_wakeups_def", "lemma jmm_heap: \"heap addr2thread_id thread_id2addr jmm_allocate jmm_typeof_addr jmm_heap_write P\"", "lemmas jmm'_heap = jmm_heap", "lemma jmm_heap_read_typeable: \"jmm_heap_read_typeable tytok P\"", "lemma jmm'_heap_read_typeable: \"jmm'_heap_read_typeable tytok P\"", "lemma jmm_heap_conf:\n  \"heap_conf addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_write (jmm_hconf P) P\"", "lemmas jmm'_heap_conf = jmm_heap_conf", "lemma jmm_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_read jmm_heap_write (jmm_hconf P) P\"", "lemma jmm'_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm'_hconf P) P\"", "lemma jmm'_heap_conf_read:\n  \"heap_conf_read addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm'_hconf P) P\"", "lemma jmm_allocated_heap: \n  \"allocated_heap addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_write jmm_allocated P\"", "lemmas jmm'_allocated_heap = jmm_allocated_heap"], "translations": [["", "lemmas jmm_heap_ops_defs =\n  jmm_allocate_def jmm_typeof_addr_def \n  jmm_heap_read_def jmm_heap_write_def\n  jmm_allocated_def jmm_spurious_wakeups_def"], ["", "type_synonym 'addr thread_id = \"'addr\""], ["", "abbreviation (input) addr2thread_id :: \"'addr \\<Rightarrow> 'addr thread_id\"\nwhere \"addr2thread_id \\<equiv> \\<lambda>x. x\""], ["", "abbreviation (input) thread_id2addr :: \"'addr thread_id \\<Rightarrow> 'addr\"\nwhere \"thread_id2addr \\<equiv> \\<lambda>x. x\""], ["", "interpretation jmm: heap_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_read jmm_heap_write"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "notation jmm.hext  (\"_ \\<unlhd>jmm _\" [51,51] 50)"], ["", "notation jmm.conf (\"_,_ \\<turnstile>jmm _ :\\<le> _\"  [51,51,51,51] 50)"], ["", "notation jmm.addr_loc_type (\"_,_ \\<turnstile>jmm _@_ : _\" [50, 50, 50, 50, 50] 51)"], ["", "notation jmm.confs (\"_,_ \\<turnstile>jmm _ [:\\<le>] _\"  [51,51,51,51] 50)"], ["", "notation jmm.tconf (\"_,_ \\<turnstile>jmm _ \\<surd>t\" [51,51,51] 50)"], ["", "text \\<open>Now a variation of the JMM with a different read operation that permits to read only type-conformant values\\<close>"], ["", "interpretation jmm': heap_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr \"jmm.heap_read_typed P\" jmm_heap_write\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "notation jmm'.hext (\"_ \\<unlhd>jmm'' _\" [51,51] 50)"], ["", "notation jmm'.conf (\"_,_ \\<turnstile>jmm'' _ :\\<le> _\"  [51,51,51,51] 50)"], ["", "notation jmm'.addr_loc_type (\"_,_ \\<turnstile>jmm'' _@_ : _\" [50, 50, 50, 50, 50] 51)"], ["", "notation jmm'.confs (\"_,_ \\<turnstile>jmm'' _ [:\\<le>] _\"  [51,51,51,51] 50)"], ["", "notation jmm'.tconf (\"_,_ \\<turnstile>jmm'' _ \\<surd>t\" [51,51,51] 50)"], ["", "subsection \\<open>Heap locale interpretations\\<close>"], ["", "subsection \\<open>Locale \\<open>heap\\<close>\\<close>"], ["", "lemma jmm_heap: \"heap addr2thread_id thread_id2addr jmm_allocate jmm_typeof_addr jmm_heap_write P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate jmm_typeof_addr\n     jmm_heap_write P", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> jmm_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> h \\<unlhd>jmm' h'\n 4. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "fix h' a h hT"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> jmm_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> h \\<unlhd>jmm' h'\n 4. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "assume \"(h', a) \\<in> jmm_allocate h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> jmm_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> h \\<unlhd>jmm' h'\n 4. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "thus \"jmm_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (1 subgoal):\n 1. jmm_typeof_addr h' a = \\<lfloor>hT\\<rfloor>", "by(auto simp add: jmm_heap_ops_defs)"], ["proof (state)\nthis:\n  jmm_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> h \\<unlhd>jmm' h'\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> h \\<unlhd>jmm' h'\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "fix h' :: \"('addr :: addr) JMM_heap\" and h hT a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> h \\<unlhd>jmm' h'\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "assume \"(h', a) \\<in> jmm_allocate h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow> h \\<unlhd>jmm' h'\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "thus \"h \\<unlhd>jmm h'\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (1 subgoal):\n 1. h \\<unlhd>jmm' h'", "by(fastforce simp add: jmm_heap_ops_defs intro: jmm.hextI)"], ["proof (state)\nthis:\n  h \\<unlhd>jmm' h'\n\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "fix h a al v and h' :: \"('addr :: addr) JMM_heap\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "assume \"jmm_heap_write h a al v h'\""], ["proof (state)\nthis:\n  jmm_heap_write h a al v h'\n\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>jmm' h'", "thus \"h \\<unlhd>jmm h'\""], ["proof (prove)\nusing this:\n  jmm_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd>jmm' h'", "by cases auto"], ["proof (state)\nthis:\n  h \\<unlhd>jmm' h'\n\ngoal (1 subgoal):\n 1. \\<And>h a C.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a", "qed simp"], ["", "interpretation jmm: heap\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_read jmm_heap_write\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate jmm_typeof_addr\n     jmm_heap_write P", "by(rule jmm_heap)"], ["", "declare jmm.typeof_addr_thread_id2_addr_addr2thread_id [simp del]"], ["", "lemmas jmm'_heap = jmm_heap"], ["", "interpretation jmm': heap\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr \"jmm.heap_read_typed P\" jmm_heap_write\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_allocate jmm_typeof_addr\n     jmm_heap_write P", "by(rule jmm'_heap)"], ["", "declare jmm'.typeof_addr_thread_id2_addr_addr2thread_id [simp del]"], ["", "subsection \\<open>Locale \\<open>heap_conf\\<close>\\<close>"], ["", "interpretation jmm: heap_conf_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_read jmm_heap_write \"jmm_hconf P\"\n  P\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation (input) jmm'_hconf :: \"'m prog \\<Rightarrow> 'addr JMM_heap \\<Rightarrow> bool\" (\"_ \\<turnstile>jmm'' _ \\<surd>\" [51,51] 50)\nwhere \"jmm'_hconf == jmm_hconf\""], ["", "interpretation jmm': heap_conf_base\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr \"jmm.heap_read_typed P\" jmm_heap_write \"jmm'_hconf P\"\n  P\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation jmm_heap_read_typeable :: \"('addr :: addr) itself \\<Rightarrow> 'm prog \\<Rightarrow> bool\"\nwhere \"jmm_heap_read_typeable tytok P \\<equiv> jmm.heap_read_typeable (jmm_hconf P :: 'addr JMM_heap \\<Rightarrow> bool) P\""], ["", "abbreviation jmm'_heap_read_typeable :: \"('addr :: addr) itself \\<Rightarrow> 'm prog \\<Rightarrow> bool\"\nwhere \"jmm'_heap_read_typeable tytok P \\<equiv> jmm'.heap_read_typeable TYPE('m) P (jmm_hconf P :: 'addr JMM_heap \\<Rightarrow> bool) P\""], ["", "lemma jmm_heap_read_typeable: \"jmm_heap_read_typeable tytok P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm.heap_read_typeable (jmm_hconf P) P", "by(rule jmm.heap_read_typeableI)(simp add: jmm_heap_read_def)"], ["", "lemma jmm'_heap_read_typeable: \"jmm'_heap_read_typeable tytok P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_read_typeable jmm_typeof_addr (jmm.heap_read_typed P)\n     (jmm_hconf P) P", "by(rule jmm'.heap_read_typeableI)(auto simp add: jmm.heap_read_typed_def jmm_heap_read_def dest: jmm'.addr_loc_type_fun)"], ["", "lemma jmm_heap_conf:\n  \"heap_conf addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_write (jmm_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr jmm_heap_write (jmm_hconf P) P", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. P \\<turnstile>jmm jmm_empty \\<surd>\n 2. \\<And>h a hT.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>jmm h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 3. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 4. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "show \"P \\<turnstile>jmm jmm_empty \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile>jmm jmm_empty \\<surd>", "by(simp add: jmm_hconf_def)"], ["proof (state)\nthis:\n  P \\<turnstile>jmm jmm_empty \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>jmm h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>jmm h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "fix h a hT"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>jmm h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "assume \"jmm_typeof_addr h a = \\<lfloor>hT\\<rfloor>\" \"P \\<turnstile>jmm h \\<surd>\""], ["proof (state)\nthis:\n  jmm_typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile>jmm h \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>jmm_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>jmm h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "thus \"is_htype P hT\""], ["proof (prove)\nusing this:\n  jmm_typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile>jmm h \\<surd>\n\ngoal (1 subgoal):\n 1. is_htype P hT", "by(auto simp add: jmm_hconf_def jmm_heap_ops_defs intro: ranI)"], ["proof (state)\nthis:\n  is_htype P hT\n\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "fix h' h hT a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "assume \"(h', a) \\<in> jmm_allocate h hT\" \"P \\<turnstile>jmm h \\<surd>\" \"is_htype P hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> jmm_allocate h hT\n  P \\<turnstile>jmm h \\<surd>\n  is_htype P hT\n\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> jmm_allocate h hT;\n        P \\<turnstile>jmm h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "thus \"P \\<turnstile>jmm h' \\<surd>\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> jmm_allocate h hT\n  P \\<turnstile>jmm h \\<surd>\n  is_htype P hT\n\ngoal (1 subgoal):\n 1. P \\<turnstile>jmm h' \\<surd>", "by(fastforce simp add: jmm_hconf_def jmm_heap_ops_defs ran_def split: if_split_asm)"], ["proof (state)\nthis:\n  P \\<turnstile>jmm h' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "fix h a al v h' T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "assume \"jmm_heap_write h a al v h'\" \"P \\<turnstile>jmm h \\<surd>\"\n    and \"jmm.addr_loc_type P h a al T\" and \"P,h \\<turnstile>jmm v :\\<le> T\""], ["proof (state)\nthis:\n  jmm_heap_write h a al v h'\n  P \\<turnstile>jmm h \\<surd>\n  P,h \\<turnstile>jmm' a@al : T\n  P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>jmm_heap_write h a al v h'; P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>jmm h' \\<surd>", "thus \"P \\<turnstile>jmm h' \\<surd>\""], ["proof (prove)\nusing this:\n  jmm_heap_write h a al v h'\n  P \\<turnstile>jmm h \\<surd>\n  P,h \\<turnstile>jmm' a@al : T\n  P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. P \\<turnstile>jmm h' \\<surd>", "by(cases) simp"], ["proof (state)\nthis:\n  P \\<turnstile>jmm h' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation jmm: heap_conf\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_read jmm_heap_write \"jmm_hconf P\"\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr jmm_heap_write (jmm_hconf P) P", "by(rule jmm_heap_conf)"], ["", "lemmas jmm'_heap_conf = jmm_heap_conf"], ["", "interpretation jmm': heap_conf\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr \"jmm.heap_read_typed P\" jmm_heap_write \"jmm'_hconf P\"\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr jmm_heap_write (jmm_hconf P) P", "by(rule jmm'_heap_conf)"], ["", "subsection \\<open>Locale \\<open>heap_progress\\<close>\\<close>"], ["", "lemma jmm_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_read jmm_heap_write (jmm_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr jmm_heap_read jmm_heap_write (jmm_hconf P) P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "fix h a al T"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "assume \"P \\<turnstile>jmm h \\<surd>\"\n    and al: \"jmm.addr_loc_type P h a al T\""], ["proof (state)\nthis:\n  P \\<turnstile>jmm h \\<surd>\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm_heap_read h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "show \"\\<exists>v. jmm_heap_read h a al v \\<and> P,h \\<turnstile>jmm v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       jmm_heap_read h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T", "using jmm.defval_conf[of P h T]"], ["proof (prove)\nusing this:\n  P,h \\<turnstile>jmm' default_val T :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       jmm_heap_read h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T", "unfolding jmm_heap_ops_defs"], ["proof (prove)\nusing this:\n  heap_base.conf (\\<lambda>h. h) P h (default_val T) T\n\ngoal (1 subgoal):\n 1. \\<exists>v. True \\<and> heap_base.conf (\\<lambda>h. h) P h v T", "by blast"], ["proof (state)\nthis:\n  \\<exists>v. jmm_heap_read h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "fix h a al T v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "assume \"jmm.addr_loc_type P h a al T\""], ["proof (state)\nthis:\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "show \"\\<exists>h'. jmm_heap_write h a al v h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h'. jmm_heap_write h a al v h'", "by(auto intro: jmm_heap_write.intros)"], ["proof (state)\nthis:\n  \\<exists>h'. jmm_heap_write h a al v h'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation jmm: heap_progress\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_read jmm_heap_write \"jmm_hconf P\"\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr jmm_heap_read jmm_heap_write (jmm_hconf P) P", "by(rule jmm_heap_progress)"], ["", "lemma jmm'_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm'_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm_hconf P) P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm.heap_read_typed P h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "fix h a al T"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm.heap_read_typed P h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "assume \"P \\<turnstile>jmm' h \\<surd>\"\n    and al: \"jmm'.addr_loc_type P h a al T\""], ["proof (state)\nthis:\n  P \\<turnstile>jmm h \\<surd>\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>;\n        P,h \\<turnstile>jmm' a@al : T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            jmm.heap_read_typed P h a al v \\<and>\n                            P,h \\<turnstile>jmm' v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "thus \"\\<exists>v. jmm.heap_read_typed P h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile>jmm h \\<surd>\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       jmm.heap_read_typed P h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T", "unfolding jmm.heap_read_typed_def jmm_heap_read_def"], ["proof (prove)\nusing this:\n  P \\<turnstile>jmm h \\<surd>\n  P,h \\<turnstile>jmm' a@al : T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       (True \\<and>\n        (\\<forall>T.\n            P,h \\<turnstile>jmm' a@al : T \\<longrightarrow>\n            P,h \\<turnstile>jmm' v :\\<le> T)) \\<and>\n       P,h \\<turnstile>jmm' v :\\<le> T", "by(auto dest: jmm'.addr_loc_type_fun intro: jmm'.defval_conf)"], ["proof (state)\nthis:\n  \\<exists>v.\n     jmm.heap_read_typed P h a al v \\<and> P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "fix h a al T v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "assume \"jmm'.addr_loc_type P h a al T\"\n    and \"P,h \\<turnstile>jmm' v :\\<le> T\""], ["proof (state)\nthis:\n  P,h \\<turnstile>jmm' a@al : T\n  P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>jmm h \\<surd>; P,h \\<turnstile>jmm' a@al : T;\n        P,h \\<turnstile>jmm' v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. jmm_heap_write h a al v h'", "thus \"\\<exists>h'. jmm_heap_write h a al v h'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>jmm' a@al : T\n  P,h \\<turnstile>jmm' v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>h'. jmm_heap_write h a al v h'", "by(auto intro: jmm_heap_write.intros)"], ["proof (state)\nthis:\n  \\<exists>h'. jmm_heap_write h a al v h'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation jmm': heap_progress\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr \"jmm.heap_read_typed P\" jmm_heap_write \"jmm'_hconf P\"\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm_hconf P) P", "by(rule jmm'_heap_progress)"], ["", "subsection \\<open>Locale \\<open>heap_conf_read\\<close>\\<close>"], ["", "lemma jmm'_heap_conf_read:\n  \"heap_conf_read addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm'_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm_hconf P) P", "by(rule jmm.heap_conf_read_heap_read_typed)"], ["", "interpretation jmm': heap_conf_read\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr \"jmm.heap_read_typed P\" jmm_heap_write \"jmm'_hconf P\"\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm_hconf P) P", "by(rule jmm'_heap_conf_read)"], ["", "interpretation jmm': heap_typesafe\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr \"jmm.heap_read_typed P\" jmm_heap_write \"jmm'_hconf P\"\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_typesafe (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr (jmm.heap_read_typed P) jmm_heap_write (jmm_hconf P) P", ".."], ["", "subsection \\<open>Locale \\<open>allocated_heap\\<close>\\<close>"], ["", "lemma jmm_allocated_heap: \n  \"allocated_heap addr2thread_id thread_id2addr jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_write jmm_allocated P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated_heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr jmm_heap_write jmm_allocated P", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. jmm_allocated jmm_empty = {}\n 2. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 3. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "show \"jmm_allocated jmm_empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jmm_allocated jmm_empty = {}", "by(auto simp add: jmm_heap_ops_defs)"], ["proof (state)\nthis:\n  jmm_allocated jmm_empty = {}\n\ngoal (2 subgoals):\n 1. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "fix h' a h hT"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "assume \"(h', a) \\<in> jmm_allocate h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (2 subgoals):\n 1. \\<And>h' a h hT.\n       (h', a) \\<in> jmm_allocate h hT \\<Longrightarrow>\n       jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n       a \\<notin> jmm_allocated h\n 2. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "thus \"jmm_allocated h' = insert a (jmm_allocated h) \\<and> a \\<notin> jmm_allocated h\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> jmm_allocate h hT\n\ngoal (1 subgoal):\n 1. jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n    a \\<notin> jmm_allocated h", "by(auto simp add: jmm_heap_ops_defs split: if_split_asm)"], ["proof (state)\nthis:\n  jmm_allocated h' = insert a (jmm_allocated h) \\<and>\n  a \\<notin> jmm_allocated h\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "fix h a al v h'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "assume \"jmm_heap_write h a al v h'\""], ["proof (state)\nthis:\n  jmm_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h'.\n       jmm_heap_write h a al v h' \\<Longrightarrow>\n       jmm_allocated h' = jmm_allocated h", "thus \"jmm_allocated h' = jmm_allocated h\""], ["proof (prove)\nusing this:\n  jmm_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. jmm_allocated h' = jmm_allocated h", "by cases simp"], ["proof (state)\nthis:\n  jmm_allocated h' = jmm_allocated h\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation jmm: allocated_heap\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr jmm_heap_read jmm_heap_write\n  jmm_allocated\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated_heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr jmm_heap_write jmm_allocated P", "by(rule jmm_allocated_heap)"], ["", "lemmas jmm'_allocated_heap = jmm_allocated_heap"], ["", "interpretation jmm': allocated_heap\n  addr2thread_id thread_id2addr\n  jmm_spurious_wakeups\n  jmm_empty jmm_allocate jmm_typeof_addr \"jmm.heap_read_typed P\" jmm_heap_write\n  jmm_allocated\n  P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated_heap (\\<lambda>x. x) (\\<lambda>x. x) jmm_empty jmm_allocate\n     jmm_typeof_addr jmm_heap_write jmm_allocated P", "by(rule jmm'_allocated_heap)"], ["", "subsection \\<open>Syntax translations\\<close>"], ["", "notation jmm'.external_WT' (\"_,_ \\<turnstile>jmm'' (_\\<bullet>_'(_')) : _\" [50,0,0,0,50] 60)"], ["", "abbreviation jmm'_red_external :: \n  \"'m prog \\<Rightarrow> 'addr thread_id \\<Rightarrow> 'addr JMM_heap \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> 'addr val list\n  \\<Rightarrow> ('addr :: addr, 'addr thread_id, 'addr JMM_heap) external_thread_action \n  \\<Rightarrow> 'addr extCallRet \\<Rightarrow> 'addr JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm'_red_external P \\<equiv> jmm'.red_external (TYPE('m)) P P\""], ["", "abbreviation jmm'_red_external_syntax :: \n  \"'m prog \\<Rightarrow> 'addr thread_id \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> 'addr JMM_heap\n  \\<Rightarrow> ('addr :: addr, 'addr thread_id, 'addr JMM_heap) external_thread_action \n  \\<Rightarrow> 'addr extCallRet \\<Rightarrow> 'addr JMM_heap \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile>jmm'' (\\<langle>(_\\<bullet>_'(_')),/_\\<rangle>) -_\\<rightarrow>ext (\\<langle>(_),/(_)\\<rangle>)\" [50, 0, 0, 0, 0, 0, 0, 0, 0] 51)\nwhere\n  \"P,t \\<turnstile>jmm' \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle> \\<equiv> jmm'_red_external P t h a M vs ta va h'\""], ["", "abbreviation jmm'_red_external_aggr :: \n  \"'m prog \\<Rightarrow> 'addr thread_id \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> 'addr JMM_heap \n    \\<Rightarrow> (('addr :: addr, 'addr thread_id, 'addr JMM_heap) external_thread_action \\<times> 'addr extCallRet \\<times> 'addr JMM_heap) set\"\nwhere \"jmm'_red_external_aggr P \\<equiv> jmm'.red_external_aggr TYPE('m) P P\""], ["", "abbreviation jmm'_heap_copy_loc :: \n  \"'m prog \\<Rightarrow> 'addr \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr JMM_heap\n  \\<Rightarrow> ('addr :: addr, 'addr thread_id) obs_event list \\<Rightarrow> 'addr JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm'_heap_copy_loc \\<equiv> jmm'.heap_copy_loc TYPE('m)\""], ["", "abbreviation jmm'_heap_copies :: \n  \"'m prog \\<Rightarrow> 'addr \\<Rightarrow> 'addr \\<Rightarrow> addr_loc list \\<Rightarrow> 'addr JMM_heap\n  \\<Rightarrow> ('addr :: addr, 'addr thread_id) obs_event list \\<Rightarrow> 'addr JMM_heap \\<Rightarrow> bool\"\nwhere \"jmm'_heap_copies \\<equiv> jmm'.heap_copies TYPE('m)\""], ["", "abbreviation jmm'_heap_clone ::\n  \"'m prog \\<Rightarrow> 'addr JMM_heap \\<Rightarrow> 'addr \\<Rightarrow> 'addr JMM_heap\n  \\<Rightarrow> (('addr :: addr, 'addr thread_id) obs_event list \\<times> 'addr) option \\<Rightarrow> bool\"\nwhere \"jmm'_heap_clone P \\<equiv> jmm'.heap_clone TYPE('m) P P\""], ["", "end"]]}