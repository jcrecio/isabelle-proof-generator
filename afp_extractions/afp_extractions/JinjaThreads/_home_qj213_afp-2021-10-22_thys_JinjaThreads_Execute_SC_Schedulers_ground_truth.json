{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/SC_Schedulers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma sc_state_\\<alpha>_sc_start_state_refine [simp]:\n  \"sc_state_\\<alpha> (sc_start_state_refine (rm_empty ()) rm_update (rm_empty ()) (rs_empty ()) f P C M vs) = sc_start_state f P C M vs\""], "translations": [["", "lemma sc_state_\\<alpha>_sc_start_state_refine [simp]:\n  \"sc_state_\\<alpha> (sc_start_state_refine (rm_empty ()) rm_update (rm_empty ()) (rs_empty ()) f P C M vs) = sc_start_state f P C M vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_refine_base.state_\\<alpha> rm.\\<alpha> rm.\\<alpha> rs.\\<alpha>\n     (heap_base.start_state_refine (\\<lambda>x. x) (rm.empty ())\n       (sc_allocate P) (rm.empty ()) rm.update (rm.empty ()) (rs.empty ()) f\n       P C M vs) =\n    sc_start_state f P C M vs", "by(simp add: heap_base.start_state_refine_def state_refine_base.state_\\<alpha>.simps split_beta sc.start_state_def rm_correct rs_correct)"], ["", "locale sc_scheduler =\n  scheduler\n    final r convert_RA \n    schedule \"output\" pick_wakeup \\<sigma>_invar\n    rm_\\<alpha> rm_invar rm_lookup rm_update\n    rm_\\<alpha> rm_invar rm_lookup rm_update rm_delete rm_iteratei\n    rs_\\<alpha> rs_invar rs_memb rs_ins rs_delete\n    invariant\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t :: linorder,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and schedule :: \"('l,'t,'x,'m,'w,'o,('t, 'x \\<times> 'l \\<Rightarrow>f nat) rm,('t, 'w wait_set_status) rm, 't rs, 's) scheduler\"\n  and \"output\" :: \"'s \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\"\n  and pick_wakeup :: \"'s \\<Rightarrow> 't \\<Rightarrow> 'w \\<Rightarrow> ('t, 'w wait_set_status) RBT.rbt \\<Rightarrow> 't option\"\n  and \\<sigma>_invar :: \"'s \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  and invariant :: \"('l,'t,'x,'m,'w) state set\""], ["", "locale sc_round_robin_base =\n  round_robin_base\n    final r convert_RA \"output\"\n    rm_\\<alpha> rm_invar rm_lookup rm_update \n    rm_\\<alpha> rm_invar rm_lookup rm_update rm_delete rm_iteratei rm_sel\n    rs_\\<alpha> rs_invar rs_memb rs_ins rs_delete\n    fifo_\\<alpha> fifo_invar fifo_empty fifo_isEmpty fifo_enqueue fifo_dequeue fifo_push\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t :: linorder,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \"output\" :: \"'t fifo round_robin \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\""], ["", "locale sc_round_robin =\n  round_robin \n    final r convert_RA \"output\"\n    rm_\\<alpha> rm_invar rm_lookup rm_update \n    rm_\\<alpha> rm_invar rm_lookup rm_update rm_delete rm_iteratei rm_sel\n    rs_\\<alpha> rs_invar rs_memb rs_ins rs_delete\n    fifo_\\<alpha> fifo_invar fifo_empty fifo_isEmpty fifo_enqueue fifo_dequeue fifo_push\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t :: linorder,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \"output\" :: \"'t fifo round_robin \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\""], ["", "sublocale sc_round_robin < sc_round_robin_base"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "locale sc_random_scheduler_base =\n  random_scheduler_base\n    final r convert_RA \"output\"\n    rm_\\<alpha> rm_invar rm_lookup rm_update rm_iteratei \n    rm_\\<alpha> rm_invar rm_lookup rm_update rm_delete rm_iteratei rm_sel\n    rs_\\<alpha> rs_invar rs_memb rs_ins rs_delete\n    lsi_\\<alpha> lsi_invar lsi_empty lsi_ins_dj lsi_to_list\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t :: linorder,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \"output\" :: \"random_scheduler \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\""], ["", "locale sc_random_scheduler =\n  random_scheduler\n    final r convert_RA \"output\"\n    rm_\\<alpha> rm_invar rm_lookup rm_update rm_iteratei \n    rm_\\<alpha> rm_invar rm_lookup rm_update rm_delete rm_iteratei rm_sel\n    rs_\\<alpha> rs_invar rs_memb rs_ins rs_delete\n    lsi_\\<alpha> lsi_invar lsi_empty lsi_ins_dj lsi_to_list\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t :: linorder,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \"output\" :: \"random_scheduler \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\""], ["", "sublocale sc_random_scheduler < sc_random_scheduler_base"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>No spurious wake-ups in generated code\\<close>"], ["", "overloading sc_spurious_wakeups \\<equiv> sc_spurious_wakeups\nbegin"], ["", "definition sc_spurious_wakeups [code]: \"sc_spurious_wakeups \\<equiv> False\""], ["", "end"], ["", "end"]]}