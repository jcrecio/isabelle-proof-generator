{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/BV/LBVJVM.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma check_certD [intro?]:\n  \"check_cert P mxs mxl n cert \\<Longrightarrow> cert_ok cert n Err (OK None) (states P mxs mxl)\"", "lemma (in start_context) wt_lbv_wt_step:\n  assumes lbv: \"wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\"\n  shows \"\\<exists>\\<tau>s \\<in> list (size is) A. wt_step r Err step \\<tau>s \\<and> OK first \\<sqsubseteq>\\<^sub>r \\<tau>s!0\"", "lemma (in start_context) wt_lbv_wt_method:\n  assumes lbv: \"wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\"  \n  shows \"\\<exists>\\<tau>s. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\"", "lemma (in start_context) wt_method_wt_lbv:\n  assumes wt: \"wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\" \n  defines [simp]: \"cert \\<equiv> mk_cert P mxs T\\<^sub>r xt is \\<tau>s\"\n  \n  shows \"wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\"", "theorem jvm_lbv_correct:\n  \"wt_jvm_prog_lbv P Cert \\<Longrightarrow> wf_jvm_prog P\"", "theorem jvm_lbv_complete:\n  assumes wt: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\" \n  shows \"wt_jvm_prog_lbv P (prg_cert P \\<Phi>)\""], "translations": [["", "lemma check_certD [intro?]:\n  \"check_cert P mxs mxl n cert \\<Longrightarrow> cert_ok cert n Err (OK None) (states P mxs mxl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_cert P mxs mxl n cert \\<Longrightarrow>\n    cert_ok cert n Err (OK None) (states P mxs mxl)", "by (unfold cert_ok_def check_cert_def check_types_def) auto"], ["", "lemma (in start_context) wt_lbv_wt_step:\n  assumes lbv: \"wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\"\n  shows \"\\<exists>\\<tau>s \\<in> list (size is) A. wt_step r Err step \\<tau>s \\<and> OK first \\<sqsubseteq>\\<^sub>r \\<tau>s!0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "from wf"], ["proof (chain)\npicking this:\n  wf_prog p P", "have \"semilat (JVM_SemiType.sl P mxs mxl)\""], ["proof (prove)\nusing this:\n  wf_prog p P\n\ngoal (1 subgoal):\n 1. semilat (JVM_SemiType.sl P mxs mxl)", ".."], ["proof (state)\nthis:\n  semilat (JVM_SemiType.sl P mxs mxl)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "hence \"semilat (A, r, f)\""], ["proof (prove)\nusing this:\n  semilat (JVM_SemiType.sl P mxs mxl)\n\ngoal (1 subgoal):\n 1. semilat (A, r, f)", "by (simp add: sl_def2)"], ["proof (state)\nthis:\n  semilat (A, r, f)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  semilat (A, r, f)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "have \"top r Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Semilat.top r Err", "by (simp add: JVM_le_Err_conv)"], ["proof (state)\nthis:\n  Semilat.top r Err\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  Semilat.top r Err\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "have \"Err \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Err \\<in> A", "by (simp add: JVM_states_unfold)"], ["proof (state)\nthis:\n  Err \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  Err \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "have \"bottom r (OK None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bottom r (OK None)", "by (simp add: JVM_le_Err_conv bottom_def lesub_def Err.le_def split: err.split)"], ["proof (state)\nthis:\n  bottom r (OK None)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  bottom r (OK None)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "have \"OK None \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OK None \\<in> A", "by (simp add: JVM_states_unfold)"], ["proof (state)\nthis:\n  OK None \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  OK None \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "note bounded_step"], ["proof (state)\nthis:\n  bounded step (length is)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  bounded step (length is)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "from lbv"], ["proof (chain)\npicking this:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"cert_ok cert (size is) Err (OK None) A\""], ["proof (prove)\nusing this:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\n\ngoal (1 subgoal):\n 1. cert_ok cert (length is) Err (OK None) A", "by (unfold wt_lbv_def) (auto dest: check_certD)"], ["proof (state)\nthis:\n  cert_ok cert (length is) Err (OK None) A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  cert_ok cert (length is) Err (OK None) A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "note exec_pres_type"], ["proof (state)\nthis:\n  pres_type step (length is) A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  pres_type step (length is) A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "from lbv"], ["proof (chain)\npicking this:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"wtl_inst_list is cert f r Err (OK None) step 0 (OK first) \\<noteq> Err\""], ["proof (prove)\nusing this:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\n\ngoal (1 subgoal):\n 1. wtl_inst_list is cert f r Err (OK None) step 0 (OK first) \\<noteq> Err", "by (simp add: wt_lbv_def lbvjvm_def step_def_exec [symmetric])"], ["proof (state)\nthis:\n  wtl_inst_list is cert f r Err (OK None) step 0 (OK first) \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  wtl_inst_list is cert f r Err (OK None) step 0 (OK first) \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "note first_in_A"], ["proof (state)\nthis:\n  OK first \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "moreover"], ["proof (state)\nthis:\n  OK first \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "from lbv"], ["proof (chain)\npicking this:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"0 < size is\""], ["proof (prove)\nusing this:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\n\ngoal (1 subgoal):\n 1. 0 < length is", "by (simp add: wt_lbv_def)"], ["proof (state)\nthis:\n  0 < length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "ultimately"], ["proof (chain)\npicking this:\n  semilat (A, r, f)\n  Semilat.top r Err\n  Err \\<in> A\n  bottom r (OK None)\n  OK None \\<in> A\n  bounded step (length is)\n  cert_ok cert (length is) Err (OK None) A\n  pres_type step (length is) A\n  wtl_inst_list is cert f r Err (OK None) step 0 (OK first) \\<noteq> Err\n  OK first \\<in> A\n  0 < length is", "show ?thesis"], ["proof (prove)\nusing this:\n  semilat (A, r, f)\n  Semilat.top r Err\n  Err \\<in> A\n  bottom r (OK None)\n  OK None \\<in> A\n  bounded step (length is)\n  cert_ok cert (length is) Err (OK None) A\n  pres_type step (length is) A\n  wtl_inst_list is cert f r Err (OK None) step 0 (OK first) \\<noteq> Err\n  OK first \\<in> A\n  0 < length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s\\<in>list (length is) A.\n       wt_step r Err step \\<tau>s \\<and>\n       OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0", "by (rule lbvs.wtl_sound_strong [OF lbvs.intro, OF lbv.intro lbvs_axioms.intro, OF Semilat.intro lbv_axioms.intro])"], ["proof (state)\nthis:\n  \\<exists>\\<tau>s\\<in>list (length is) A.\n     wt_step r Err step \\<tau>s \\<and>\n     OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in start_context) wt_lbv_wt_method:\n  assumes lbv: \"wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\"  \n  shows \"\\<exists>\\<tau>s. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from lbv"], ["proof (chain)\npicking this:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have l: \"is \\<noteq> []\""], ["proof (prove)\nusing this:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\n\ngoal (1 subgoal):\n 1. is \\<noteq> []", "by (simp add: wt_lbv_def)"], ["proof (state)\nthis:\n  is \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  is \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from wf lbv C Ts"], ["proof (chain)\npicking this:\n  wf_prog p P\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\n  is_class P C\n  set Ts \\<subseteq> types P", "obtain \\<tau>s where \n    list:  \"\\<tau>s \\<in> list (size is) A\" and\n    step:  \"wt_step r Err step \\<tau>s\" and    \n    start: \"OK first \\<sqsubseteq>\\<^sub>r \\<tau>s!0\""], ["proof (prove)\nusing this:\n  wf_prog p P\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\n  is_class P C\n  set Ts \\<subseteq> types P\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>s.\n        \\<lbrakk>\\<tau>s \\<in> list (length is) A;\n         wt_step r Err step \\<tau>s;\n         OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: wt_lbv_wt_step)"], ["proof (state)\nthis:\n  \\<tau>s \\<in> list (length is) A\n  wt_step r Err step \\<tau>s\n  OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from list"], ["proof (chain)\npicking this:\n  \\<tau>s \\<in> list (length is) A", "have [simp]: \"size \\<tau>s = size is\""], ["proof (prove)\nusing this:\n  \\<tau>s \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. length \\<tau>s = length is", "by simp"], ["proof (state)\nthis:\n  length \\<tau>s = length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "have \"size (map ok_val \\<tau>s) = size is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ok_val \\<tau>s) = length is", "by simp"], ["proof (state)\nthis:\n  length (map ok_val \\<tau>s) = length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  length (map ok_val \\<tau>s) = length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from l"], ["proof (chain)\npicking this:\n  is \\<noteq> []", "have 0: \"0 < size \\<tau>s\""], ["proof (prove)\nusing this:\n  is \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length \\<tau>s", "by simp"], ["proof (state)\nthis:\n  0 < length \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "with step"], ["proof (chain)\npicking this:\n  wt_step r Err step \\<tau>s\n  0 < length \\<tau>s", "obtain \\<tau>s0 where \"\\<tau>s!0 = OK \\<tau>s0\""], ["proof (prove)\nusing this:\n  wt_step r Err step \\<tau>s\n  0 < length \\<tau>s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>s0.\n        \\<tau>s ! 0 = OK \\<tau>s0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (unfold wt_step_def) blast"], ["proof (state)\nthis:\n  \\<tau>s ! 0 = OK \\<tau>s0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "with start 0"], ["proof (chain)\npicking this:\n  OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0\n  0 < length \\<tau>s\n  \\<tau>s ! 0 = OK \\<tau>s0", "have \"wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s)\""], ["proof (prove)\nusing this:\n  OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s ! 0\n  0 < length \\<tau>s\n  \\<tau>s ! 0 = OK \\<tau>s0\n\ngoal (1 subgoal):\n 1. wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s)", "by (simp add: wt_start_def JVM_le_Err_conv lesub_def Err.le_def)"], ["proof (state)\nthis:\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "{"], ["proof (state)\nthis:\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from list"], ["proof (chain)\npicking this:\n  \\<tau>s \\<in> list (length is) A", "have \"check_types P mxs mxl \\<tau>s\""], ["proof (prove)\nusing this:\n  \\<tau>s \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. check_types P mxs mxl \\<tau>s", "by (simp add: check_types_def)"], ["proof (state)\nthis:\n  check_types P mxs mxl \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "also"], ["proof (state)\nthis:\n  check_types P mxs mxl \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from step"], ["proof (chain)\npicking this:\n  wt_step r Err step \\<tau>s", "have \"\\<forall>x \\<in> set \\<tau>s. x \\<noteq> Err\""], ["proof (prove)\nusing this:\n  wt_step r Err step \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set \\<tau>s. x \\<noteq> Err", "by (auto simp add: all_set_conv_all_nth wt_step_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set \\<tau>s. x \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "hence [symmetric]: \"map OK (map ok_val \\<tau>s) = \\<tau>s\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set \\<tau>s. x \\<noteq> Err\n\ngoal (1 subgoal):\n 1. map OK (map ok_val \\<tau>s) = \\<tau>s", "by (auto intro!: map_idI)"], ["proof (state)\nthis:\n  \\<tau>s = map OK (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "finally"], ["proof (chain)\npicking this:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s))", "have \"check_types P mxs mxl (map OK (map ok_val \\<tau>s))\""], ["proof (prove)\nusing this:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s))\n\ngoal (1 subgoal):\n 1. check_types P mxs mxl (map OK (map ok_val \\<tau>s))", "."], ["proof (state)\nthis:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "}"], ["proof (state)\nthis:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "{"], ["proof (state)\nthis:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "note bounded_step"], ["proof (state)\nthis:\n  bounded step (length is)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  bounded step (length is)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from list"], ["proof (chain)\npicking this:\n  \\<tau>s \\<in> list (length is) A", "have \"set \\<tau>s \\<subseteq> A\""], ["proof (prove)\nusing this:\n  \\<tau>s \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. set \\<tau>s \\<subseteq> A", "by simp"], ["proof (state)\nthis:\n  set \\<tau>s \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  set \\<tau>s \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from step"], ["proof (chain)\npicking this:\n  wt_step r Err step \\<tau>s", "have \"wt_err_step (sup_state_opt P) step \\<tau>s\""], ["proof (prove)\nusing this:\n  wt_step r Err step \\<tau>s\n\ngoal (1 subgoal):\n 1. wt_err_step (sup_state_opt P) step \\<tau>s", "by (simp add: wt_err_step_def JVM_le_Err_conv)"], ["proof (state)\nthis:\n  wt_err_step (sup_state_opt P) step \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "ultimately"], ["proof (chain)\npicking this:\n  bounded step (length is)\n  set \\<tau>s \\<subseteq> A\n  wt_err_step (sup_state_opt P) step \\<tau>s", "have \"wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s)\""], ["proof (prove)\nusing this:\n  bounded step (length is)\n  set \\<tau>s \\<subseteq> A\n  wt_err_step (sup_state_opt P) step \\<tau>s\n\ngoal (1 subgoal):\n 1. wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s)", "by (auto intro: wt_err_imp_wt_app_eff simp add: exec_def states_def)"], ["proof (state)\nthis:\n  wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "}"], ["proof (state)\nthis:\n  wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "ultimately"], ["proof (chain)\npicking this:\n  is \\<noteq> []\n  length (map ok_val \\<tau>s) = length is\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s)\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s))\n  wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s)", "have \"wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s)\""], ["proof (prove)\nusing this:\n  is \\<noteq> []\n  length (map ok_val \\<tau>s) = length is\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s)\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s))\n  wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s)", "by (simp add: wt_method_def2 check_types_def del: map_map)"], ["proof (state)\nthis:\n  wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", ".."], ["proof (state)\nthis:\n  \\<exists>\\<tau>s. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in start_context) wt_method_wt_lbv:\n  assumes wt: \"wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\" \n  defines [simp]: \"cert \\<equiv> mk_cert P mxs T\\<^sub>r xt is \\<tau>s\"\n  \n  shows \"wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "let ?\\<tau>s  = \"map OK \\<tau>s\""], ["proof (state)\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "let ?cert = \"make_cert step ?\\<tau>s (OK None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from wt"], ["proof (chain)\npicking this:\n  wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "obtain \n    0:        \"0 < size is\" and\n    size:     \"size is = size ?\\<tau>s\" and\n    ck_types: \"check_types P mxs mxl ?\\<tau>s\" and\n    wt_start: \"wt_start P C Ts mxl\\<^sub>0 \\<tau>s\" and\n    app_eff:  \"wt_app_eff (sup_state_opt P) app eff \\<tau>s\""], ["proof (prove)\nusing this:\n  wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 < length is; length is = length (map OK \\<tau>s);\n      check_types P mxs mxl (map OK \\<tau>s);\n      wt_start P C Ts mxl\\<^sub>0 \\<tau>s;\n      wt_app_eff (sup_state_opt P) app eff \\<tau>s\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp add: wt_method_def2 check_types_def)"], ["proof (state)\nthis:\n  0 < length is\n  length is = length (map OK \\<tau>s)\n  check_types P mxs mxl (map OK \\<tau>s)\n  wt_start P C Ts mxl\\<^sub>0 \\<tau>s\n  wt_app_eff (sup_state_opt P) app eff \\<tau>s\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from wf"], ["proof (chain)\npicking this:\n  wf_prog p P", "have \"semilat (JVM_SemiType.sl P mxs mxl)\""], ["proof (prove)\nusing this:\n  wf_prog p P\n\ngoal (1 subgoal):\n 1. semilat (JVM_SemiType.sl P mxs mxl)", ".."], ["proof (state)\nthis:\n  semilat (JVM_SemiType.sl P mxs mxl)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "hence \"semilat (A, r, f)\""], ["proof (prove)\nusing this:\n  semilat (JVM_SemiType.sl P mxs mxl)\n\ngoal (1 subgoal):\n 1. semilat (A, r, f)", "by (simp add: sl_def2)"], ["proof (state)\nthis:\n  semilat (A, r, f)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  semilat (A, r, f)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"top r Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Semilat.top r Err", "by (simp add: JVM_le_Err_conv)"], ["proof (state)\nthis:\n  Semilat.top r Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  Semilat.top r Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"Err \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Err \\<in> A", "by (simp add: JVM_states_unfold)"], ["proof (state)\nthis:\n  Err \\<in> A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  Err \\<in> A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"bottom r (OK None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bottom r (OK None)", "by (simp add: JVM_le_Err_conv bottom_def lesub_def Err.le_def split: err.split)"], ["proof (state)\nthis:\n  bottom r (OK None)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  bottom r (OK None)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"OK None \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OK None \\<in> A", "by (simp add: JVM_states_unfold)"], ["proof (state)\nthis:\n  OK None \\<in> A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  OK None \\<in> A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from wf"], ["proof (chain)\npicking this:\n  wf_prog p P", "have \"mono r step (size is) A\""], ["proof (prove)\nusing this:\n  wf_prog p P\n\ngoal (1 subgoal):\n 1. SemilatAlg.mono r step (length is) A", "by (rule step_mono)"], ["proof (state)\nthis:\n  SemilatAlg.mono r step (length is) A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "hence \"mono r step (size ?\\<tau>s) A\""], ["proof (prove)\nusing this:\n  SemilatAlg.mono r step (length is) A\n\ngoal (1 subgoal):\n 1. SemilatAlg.mono r step (length (map OK \\<tau>s)) A", "by (simp add: size)"], ["proof (state)\nthis:\n  SemilatAlg.mono r step (length (map OK \\<tau>s)) A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  SemilatAlg.mono r step (length (map OK \\<tau>s)) A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from exec_pres_type"], ["proof (chain)\npicking this:\n  pres_type step (length is) A", "have \"pres_type step (size ?\\<tau>s) A\""], ["proof (prove)\nusing this:\n  pres_type step (length is) A\n\ngoal (1 subgoal):\n 1. pres_type step (length (map OK \\<tau>s)) A", "by (simp add: size)"], ["proof (state)\nthis:\n  pres_type step (length (map OK \\<tau>s)) A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  pres_type step (length (map OK \\<tau>s)) A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from ck_types"], ["proof (chain)\npicking this:\n  check_types P mxs mxl (map OK \\<tau>s)", "have \\<tau>s_in_A: \"set ?\\<tau>s \\<subseteq> A\""], ["proof (prove)\nusing this:\n  check_types P mxs mxl (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. set (map OK \\<tau>s) \\<subseteq> A", "by (simp add: check_types_def)"], ["proof (state)\nthis:\n  set (map OK \\<tau>s) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "hence \"\\<forall>pc. pc < size ?\\<tau>s \\<longrightarrow> ?\\<tau>s!pc \\<in> A \\<and> ?\\<tau>s!pc \\<noteq> Err\""], ["proof (prove)\nusing this:\n  set (map OK \\<tau>s) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<forall>pc<length (map OK \\<tau>s).\n       map OK \\<tau>s ! pc \\<in> A \\<and> map OK \\<tau>s ! pc \\<noteq> Err", "by auto"], ["proof (state)\nthis:\n  \\<forall>pc<length (map OK \\<tau>s).\n     map OK \\<tau>s ! pc \\<in> A \\<and> map OK \\<tau>s ! pc \\<noteq> Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  \\<forall>pc<length (map OK \\<tau>s).\n     map OK \\<tau>s ! pc \\<in> A \\<and> map OK \\<tau>s ! pc \\<noteq> Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from bounded_step"], ["proof (chain)\npicking this:\n  bounded step (length is)", "have \"bounded step (size ?\\<tau>s)\""], ["proof (prove)\nusing this:\n  bounded step (length is)\n\ngoal (1 subgoal):\n 1. bounded step (length (map OK \\<tau>s))", "by (simp add: size)"], ["proof (state)\nthis:\n  bounded step (length (map OK \\<tau>s))\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  bounded step (length (map OK \\<tau>s))\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"OK None \\<noteq> Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OK None \\<noteq> Err", "by simp"], ["proof (state)\nthis:\n  OK None \\<noteq> Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  OK None \\<noteq> Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from bounded_step size \\<tau>s_in_A app_eff"], ["proof (chain)\npicking this:\n  bounded step (length is)\n  length is = length (map OK \\<tau>s)\n  set (map OK \\<tau>s) \\<subseteq> A\n  wt_app_eff (sup_state_opt P) app eff \\<tau>s", "have \"wt_err_step (sup_state_opt P) step ?\\<tau>s\""], ["proof (prove)\nusing this:\n  bounded step (length is)\n  length is = length (map OK \\<tau>s)\n  set (map OK \\<tau>s) \\<subseteq> A\n  wt_app_eff (sup_state_opt P) app eff \\<tau>s\n\ngoal (1 subgoal):\n 1. wt_err_step (sup_state_opt P) step (map OK \\<tau>s)", "by (auto intro: wt_app_eff_imp_wt_err simp add: exec_def states_def)"], ["proof (state)\nthis:\n  wt_err_step (sup_state_opt P) step (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "hence \"wt_step r Err step ?\\<tau>s\""], ["proof (prove)\nusing this:\n  wt_err_step (sup_state_opt P) step (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_step r Err step (map OK \\<tau>s)", "by (simp add: wt_err_step_def JVM_le_Err_conv)"], ["proof (state)\nthis:\n  wt_step r Err step (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  wt_step r Err step (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from 0 size"], ["proof (chain)\npicking this:\n  0 < length is\n  length is = length (map OK \\<tau>s)", "have \"0 < size \\<tau>s\""], ["proof (prove)\nusing this:\n  0 < length is\n  length is = length (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. 0 < length \\<tau>s", "by auto"], ["proof (state)\nthis:\n  0 < length \\<tau>s\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "hence \"?\\<tau>s!0 = OK (\\<tau>s!0)\""], ["proof (prove)\nusing this:\n  0 < length \\<tau>s\n\ngoal (1 subgoal):\n 1. map OK \\<tau>s ! 0 = OK (\\<tau>s ! 0)", "by simp"], ["proof (state)\nthis:\n  map OK \\<tau>s ! 0 = OK (\\<tau>s ! 0)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "with wt_start"], ["proof (chain)\npicking this:\n  wt_start P C Ts mxl\\<^sub>0 \\<tau>s\n  map OK \\<tau>s ! 0 = OK (\\<tau>s ! 0)", "have \"OK first \\<sqsubseteq>\\<^sub>r ?\\<tau>s!0\""], ["proof (prove)\nusing this:\n  wt_start P C Ts mxl\\<^sub>0 \\<tau>s\n  map OK \\<tau>s ! 0 = OK (\\<tau>s ! 0)\n\ngoal (1 subgoal):\n 1. OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0", "by (clarsimp simp add: wt_start_def lesub_def Err.le_def JVM_le_Err_conv)"], ["proof (state)\nthis:\n  OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "note first_in_A"], ["proof (state)\nthis:\n  OK first \\<in> A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  OK first \\<in> A\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "have \"OK first \\<noteq> Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OK first \\<noteq> Err", "by simp"], ["proof (state)\nthis:\n  OK first \\<noteq> Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  OK first \\<noteq> Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "note size"], ["proof (state)\nthis:\n  length is = length (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "ultimately"], ["proof (chain)\npicking this:\n  semilat (A, r, f)\n  Semilat.top r Err\n  Err \\<in> A\n  bottom r (OK None)\n  OK None \\<in> A\n  SemilatAlg.mono r step (length (map OK \\<tau>s)) A\n  pres_type step (length (map OK \\<tau>s)) A\n  \\<forall>pc<length (map OK \\<tau>s).\n     map OK \\<tau>s ! pc \\<in> A \\<and> map OK \\<tau>s ! pc \\<noteq> Err\n  bounded step (length (map OK \\<tau>s))\n  OK None \\<noteq> Err\n  wt_step r Err step (map OK \\<tau>s)\n  OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n  OK first \\<in> A\n  OK first \\<noteq> Err\n  length is = length (map OK \\<tau>s)", "have \"wtl_inst_list is ?cert f r Err (OK None) step 0 (OK first) \\<noteq> Err\""], ["proof (prove)\nusing this:\n  semilat (A, r, f)\n  Semilat.top r Err\n  Err \\<in> A\n  bottom r (OK None)\n  OK None \\<in> A\n  SemilatAlg.mono r step (length (map OK \\<tau>s)) A\n  pres_type step (length (map OK \\<tau>s)) A\n  \\<forall>pc<length (map OK \\<tau>s).\n     map OK \\<tau>s ! pc \\<in> A \\<and> map OK \\<tau>s ! pc \\<noteq> Err\n  bounded step (length (map OK \\<tau>s))\n  OK None \\<noteq> Err\n  wt_step r Err step (map OK \\<tau>s)\n  OK first \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n  OK first \\<in> A\n  OK first \\<noteq> Err\n  length is = length (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wtl_inst_list is (make_cert step (map OK \\<tau>s) (OK None)) f r Err\n     (OK None) step 0 (OK first) \\<noteq>\n    Err", "by (rule lbvc.wtl_complete [OF lbvc.intro, OF lbv.intro lbvc_axioms.intro, OF Semilat.intro lbv_axioms.intro])"], ["proof (state)\nthis:\n  wtl_inst_list is (make_cert step (map OK \\<tau>s) (OK None)) f r Err\n   (OK None) step 0 (OK first) \\<noteq>\n  Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  wtl_inst_list is (make_cert step (map OK \\<tau>s) (OK None)) f r Err\n   (OK None) step 0 (OK first) \\<noteq>\n  Err\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from 0 size"], ["proof (chain)\npicking this:\n  0 < length is\n  length is = length (map OK \\<tau>s)", "have \"\\<tau>s \\<noteq> []\""], ["proof (prove)\nusing this:\n  0 < length is\n  length is = length (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<tau>s \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<tau>s \\<noteq> []\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  \\<tau>s \\<noteq> []\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "from ck_types"], ["proof (chain)\npicking this:\n  check_types P mxs mxl (map OK \\<tau>s)", "have \"check_types P mxs mxl ?cert\""], ["proof (prove)\nusing this:\n  check_types P mxs mxl (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. check_types P mxs mxl (make_cert step (map OK \\<tau>s) (OK None))", "by (auto simp add: make_cert_def check_types_def JVM_states_unfold cong del: image_cong_simp)"], ["proof (state)\nthis:\n  check_types P mxs mxl (make_cert step (map OK \\<tau>s) (OK None))\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "moreover"], ["proof (state)\nthis:\n  check_types P mxs mxl (make_cert step (map OK \\<tau>s) (OK None))\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "note 0 size"], ["proof (state)\nthis:\n  0 < length is\n  length is = length (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "ultimately"], ["proof (chain)\npicking this:\n  wtl_inst_list is (make_cert step (map OK \\<tau>s) (OK None)) f r Err\n   (OK None) step 0 (OK first) \\<noteq>\n  Err\n  \\<tau>s \\<noteq> []\n  check_types P mxs mxl (make_cert step (map OK \\<tau>s) (OK None))\n  0 < length is\n  length is = length (map OK \\<tau>s)", "show ?thesis"], ["proof (prove)\nusing this:\n  wtl_inst_list is (make_cert step (map OK \\<tau>s) (OK None)) f r Err\n   (OK None) step 0 (OK first) \\<noteq>\n  Err\n  \\<tau>s \\<noteq> []\n  check_types P mxs mxl (make_cert step (map OK \\<tau>s) (OK None))\n  0 < length is\n  length is = length (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is", "by (simp add: wt_lbv_def lbvjvm_def mk_cert_def step_def_exec [symmetric]\n                  check_cert_def make_cert_def nth_append)"], ["proof (state)\nthis:\n  wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 xt cert is\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "theorem jvm_lbv_correct:\n  \"wt_jvm_prog_lbv P Cert \\<Longrightarrow> wf_jvm_prog P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P Cert \\<Longrightarrow> wf_jvm_prog P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P Cert \\<Longrightarrow> wf_jvm_prog P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P Cert \\<Longrightarrow> wf_jvm_prog P", "let ?\\<Phi> = \"\\<lambda>C mn. let (C,Ts,T\\<^sub>r,meth) = method P C mn; (mxs,mxl\\<^sub>0,is,xt) = the meth in \n              SOME \\<tau>s. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\""], ["proof (state)\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P Cert \\<Longrightarrow> wf_jvm_prog P", "assume wt: \"wt_jvm_prog_lbv P Cert\""], ["proof (state)\nthis:\n  wt_jvm_prog_lbv P Cert\n\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P Cert \\<Longrightarrow> wf_jvm_prog P", "hence \"wf_jvm_prog\\<^bsub>?\\<Phi>\\<^esub> P\""], ["proof (prove)\nusing this:\n  wt_jvm_prog_lbv P Cert\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<lambda>C mn.\n                          let (C, Ts, T\\<^sub>r, meth) = method P C mn;\n                              (mxs, mxl\\<^sub>0, is, xt) = the meth\n                          in SOME \\<tau>s.\n                                wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0\n                                 is xt \\<tau>s\\<^esub>\n     P", "apply (unfold wf_jvm_prog_phi_def wt_jvm_prog_lbv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog\n     (\\<lambda>P C (mn, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, b, et).\n         wt_lbv P C Ts T\\<^sub>r mxs mxl\\<^sub>0 et (Cert C mn) b)\n     P \\<Longrightarrow>\n    wf_prog\n     (\\<lambda>Pa C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method Pa C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n          (let (C, Ts, T\\<^sub>r, meth) = method P C M;\n               (mxs, mxl\\<^sub>0, is, xt) = the meth\n           in Eps (wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt)))\n     P", "apply (erule wf_prog_lift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wf_md C M Ts Ca T m.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P;\n        case (M, Ts, T, m) of\n        (mn, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, b, et) \\<Rightarrow>\n          wt_lbv P Ca Ts T\\<^sub>r mxs mxl\\<^sub>0 et (Cert Ca mn)\n           b\\<rbrakk>\n       \\<Longrightarrow> case (M, Ts, T, m) of\n                         (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_method P Ca Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                            (let (C, Ts, T\\<^sub>r, meth) = method P Ca M;\n                                 (mxs, mxl\\<^sub>0, is, xt) = the meth\n                             in Eps (wt_method P C Ts T\\<^sub>r mxs\nmxl\\<^sub>0 is xt))", "apply(auto intro: someI_ex[OF start_context.wt_lbv_wt_method [OF start_context.intro]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<lambda>C mn.\n                        let (C, Ts, T\\<^sub>r, meth) = method P C mn;\n                            (mxs, mxl\\<^sub>0, is, xt) = the meth\n                        in SOME \\<tau>s.\n                              wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is\n                               xt \\<tau>s\\<^esub>\n   P\n\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P Cert \\<Longrightarrow> wf_jvm_prog P", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<lambda>C mn.\n                        let (C, Ts, T\\<^sub>r, meth) = method P C mn;\n                            (mxs, mxl\\<^sub>0, is, xt) = the meth\n                        in SOME \\<tau>s.\n                              wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is\n                               xt \\<tau>s\\<^esub>\n   P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog P", "by (unfold wf_jvm_prog_def) blast"], ["proof (state)\nthis:\n  wf_jvm_prog P\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "theorem jvm_lbv_complete:\n  assumes wt: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\" \n  shows \"wt_jvm_prog_lbv P (prg_cert P \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P (prg_cert P \\<Phi>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P (prg_cert P \\<Phi>)", "using wt"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. wt_jvm_prog_lbv P (prg_cert P \\<Phi>)", "apply (unfold wf_jvm_prog_phi_def wt_jvm_prog_lbv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n     P \\<Longrightarrow>\n    wf_prog\n     (\\<lambda>Pa C (mn, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, b, et).\n         wt_lbv Pa C Ts T\\<^sub>r mxs mxl\\<^sub>0 et\n          (prg_cert P \\<Phi> C mn) b)\n     P", "apply (erule wf_prog_lift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wf_md C M Ts Ca T m.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = \\<lfloor>m\\<rfloor> in Ca;\n        is_class P Ca; set Ts \\<subseteq> types P;\n        case (M, Ts, T, m) of\n        (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n          wt_method P Ca Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n           (\\<Phi> Ca M)\\<rbrakk>\n       \\<Longrightarrow> case (M, Ts, T, m) of\n                         (mn, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, b,\n                          et) \\<Rightarrow>\n                           wt_lbv P Ca Ts T\\<^sub>r mxs mxl\\<^sub>0 et\n                            (prg_cert P \\<Phi> Ca mn) b", "apply (auto simp add: prg_cert_def \n              intro!: start_context.wt_method_wt_lbv start_context.intro)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "end"]]}