{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/ExternalCall_Execute.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma heap_copy_loc_code:\n  \"heap_copy_loc a a' al h =\n   (do {\n      v \\<leftarrow> heap_read h a al;\n      h' \\<leftarrow> heap_write h a' al v;\n      {([ReadMem a al v, WriteMem a' al v], h')}\n   })\"", "lemma heap_copies_code:\n  shows heap_copies_Nil: \n  \"heap_copies a a' [] h = {([], h)}\"\n  and heap_copies_Cons:\n  \"heap_copies a a' (al # als) h =\n  (do {\n     (ob, h') \\<leftarrow> heap_copy_loc a a' al h;\n     (obs, h'') \\<leftarrow> heap_copies a a' als h';\n     {(ob @ obs, h'')}\n  })\"", "lemma heap_clone_code:\n  \"heap_clone P h a =\n  (case typeof_addr h a of\n    \\<lfloor>Class_type C\\<rfloor> \\<Rightarrow> \n      let HA = allocate h (Class_type C) \n      in if HA = {} then {(h, None)} else do {\n          (h', a') \\<leftarrow> HA;\n          FDTs \\<leftarrow> set_of_pred (Fields_i_i_o P C);\n          (obs, h'') \\<leftarrow> heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h';\n          {(h'', \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>)}\n        }\n  | \\<lfloor>Array_type T n\\<rfloor> \\<Rightarrow> \n      let HA = allocate h (Array_type T n)\n      in if HA = {} then {(h, None)} else do {\n        (h', a') \\<leftarrow> HA;\n        FDTs \\<leftarrow> set_of_pred (Fields_i_i_o P Object);\n        (obs, h'') \\<leftarrow> heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h';\n        {(h'', \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>)}\n      }\n  | _ \\<Rightarrow> {})\"", "lemma red_external_aggr_code:\n  \"red_external_aggr P t a M vs h =\n   (if M = wait then\n      let ad_t = thread_id2addr t\n      in {(\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, execute.RetEXC InterruptedException, h),\n          (\\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>, RetStaySame, h),\n          (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, execute.RetEXC IllegalMonitorState, h),\n          (\\<lbrace>Notified\\<rbrace>, RetVal Unit, h),\n          (\\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>, execute.RetEXC InterruptedException, h)} \\<union>\n          (if spurious_wakeups then {(\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>, RetVal Unit, h)} else {})\n    else if M = notify then\n       {(\\<lbrace>Notify a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>, RetVal Unit, h),\n        (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, execute.RetEXC IllegalMonitorState, h)}\n    else if M = notifyAll then \n       {(\\<lbrace>NotifyAll a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a \\<rbrace>, RetVal Unit, h),\n        (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, execute.RetEXC IllegalMonitorState, h)}\n    else if M = clone then\n       do {\n         (h', obsa) \\<leftarrow> heap_clone P h a;\n         {case obsa of None \\<Rightarrow> (\\<epsilon>, execute.RetEXC OutOfMemory, h')\n           | Some (obs, a') \\<Rightarrow> ((K$ [], [], [], [], [], obs), RetVal (Addr a'), h')}\n       }\n    else if M = hashcode then {(\\<epsilon>, RetVal (Intg (word_of_int (hash_addr a))), h)}\n    else if M = print then {(\\<lbrace>ExternalCall a M vs Unit\\<rbrace>, RetVal Unit, h)}\n    else if M = currentThread then {(\\<epsilon>, RetVal (Addr (thread_id2addr t)), h)}\n    else if M = interrupted then \n      {(\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, RetVal (Bool True), h),\n       (\\<lbrace>IsInterrupted t False\\<rbrace>, RetVal (Bool False), h)}\n    else if M = yield then {(\\<lbrace>Yield\\<rbrace>, RetVal Unit, h)}\n    else\n      let T = ty_of_htype (the (typeof_addr h a))\n      in if P \\<turnstile> T \\<le> Class Thread then\n        let t_a = addr2thread_id a \n        in if M = start then \n             {(\\<lbrace>NewThread t_a (the_Class T, run, a) h, ThreadStart t_a\\<rbrace>, RetVal Unit, h),\n              (\\<lbrace>ThreadExists t_a True\\<rbrace>, execute.RetEXC IllegalThreadState, h)}\n           else if M = join then\n             {(\\<lbrace>Join t_a, IsInterrupted t False, ThreadJoin t_a\\<rbrace>, RetVal Unit, h),\n              (\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, execute.RetEXC InterruptedException, h)}\n           else if M = interrupt then\n             {(\\<lbrace>ThreadExists t_a True, WakeUp t_a, Interrupt t_a, ObsInterrupt t_a\\<rbrace>, RetVal Unit, h),\n              (\\<lbrace>ThreadExists t_a False\\<rbrace>, RetVal Unit, h)}\n           else if M = isInterrupted then\n             {(\\<lbrace>IsInterrupted t_a False\\<rbrace>, RetVal (Bool False), h),\n              (\\<lbrace>IsInterrupted t_a True, ObsInterrupted t_a\\<rbrace>, RetVal (Bool True), h)}\n         else {(\\<lbrace>\\<rbrace>, undefined)}\n    else {(\\<lbrace>\\<rbrace>, undefined)})\"", "lemmas [code] =\n  heap_execute.heap_copy_loc_code\n  heap_execute.heap_copies_code\n  heap_execute.heap_clone_code\n  heap_execute.red_external_aggr_code"], "translations": [["", "lemma heap_copy_loc_code:\n  \"heap_copy_loc a a' al h =\n   (do {\n      v \\<leftarrow> heap_read h a al;\n      h' \\<leftarrow> heap_write h a' al v;\n      {([ReadMem a al v, WriteMem a' al v], h')}\n   })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_copy_loc a a' al h =\n    heap_read h a al \\<bind>\n    (\\<lambda>v.\n        heap_write h a' al v \\<bind>\n        (\\<lambda>h'. {([ReadMem a al v, WriteMem a' al v], h')}))", "by(auto simp add: execute.heap_copy_loc.simps)"], ["", "definition heap_copies :: \"'addr \\<Rightarrow> 'addr \\<Rightarrow> addr_loc list \\<Rightarrow> 'heap \\<Rightarrow> (('addr, 'thread_id) obs_event list \\<times> 'heap) set\"\nwhere [simp]: \"heap_copies a a' al h = {(obs, h'). execute.heap_copies a a' al h obs h'}\""], ["", "lemma heap_copies_code:\n  shows heap_copies_Nil: \n  \"heap_copies a a' [] h = {([], h)}\"\n  and heap_copies_Cons:\n  \"heap_copies a a' (al # als) h =\n  (do {\n     (ob, h') \\<leftarrow> heap_copy_loc a a' al h;\n     (obs, h'') \\<leftarrow> heap_copies a a' als h';\n     {(ob @ obs, h'')}\n  })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_copies a a' [] h = {([], h)} &&&\n    heap_copies a a' (al # als) h =\n    heap_copy_loc a a' al h \\<bind>\n    (\\<lambda>(ob, h').\n        heap_copies a a' als h' \\<bind>\n        (\\<lambda>(obs, h''). {(ob @ obs, h'')}))", "by(fastforce elim!: execute.heap_copies_cases intro: execute.heap_copies.intros)+"], ["", "definition heap_clone :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> 'addr \\<Rightarrow> ('heap \\<times> (('addr, 'thread_id) obs_event list \\<times> 'addr) option) set\"\nwhere [simp]: \"heap_clone P h a = {(h', obsa). execute.heap_clone P h a h' obsa}\""], ["", "lemma heap_clone_code:\n  \"heap_clone P h a =\n  (case typeof_addr h a of\n    \\<lfloor>Class_type C\\<rfloor> \\<Rightarrow> \n      let HA = allocate h (Class_type C) \n      in if HA = {} then {(h, None)} else do {\n          (h', a') \\<leftarrow> HA;\n          FDTs \\<leftarrow> set_of_pred (Fields_i_i_o P C);\n          (obs, h'') \\<leftarrow> heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h';\n          {(h'', \\<lfloor>(NewHeapElem a' (Class_type C) # obs, a')\\<rfloor>)}\n        }\n  | \\<lfloor>Array_type T n\\<rfloor> \\<Rightarrow> \n      let HA = allocate h (Array_type T n)\n      in if HA = {} then {(h, None)} else do {\n        (h', a') \\<leftarrow> HA;\n        FDTs \\<leftarrow> set_of_pred (Fields_i_i_o P Object);\n        (obs, h'') \\<leftarrow> heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h';\n        {(h'', \\<lfloor>(NewHeapElem a' (Array_type T n) # obs, a')\\<rfloor>)}\n      }\n  | _ \\<Rightarrow> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_clone P h a =\n    (case typeof_addr h a of None \\<Rightarrow> {}\n     | \\<lfloor>Class_type C\\<rfloor> \\<Rightarrow>\n         let HA = allocate h (Class_type C)\n         in if HA = {} then {(h, None)}\n            else HA \\<bind>\n                 (\\<lambda>(h', a').\n                     set_of_pred (Fields_i_i_o P C) \\<bind>\n                     (\\<lambda>FDTs.\n                         heap_copies a a'\n                          (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n                          h' \\<bind>\n                         (\\<lambda>(obs, h'').\n                             {(h'',\n                               \\<lfloor>(NewHeapElem a' (Class_type C) #\n   obs,\n   a')\\<rfloor>)})))\n     | \\<lfloor>Array_type T n\\<rfloor> \\<Rightarrow>\n         let HA = allocate h (Array_type T n)\n         in if HA = {} then {(h, None)}\n            else HA \\<bind>\n                 (\\<lambda>(h', a').\n                     set_of_pred (Fields_i_i_o P Object) \\<bind>\n                     (\\<lambda>FDTs.\n                         heap_copies a a'\n                          (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n                           map ACell [0..<n])\n                          h' \\<bind>\n                         (\\<lambda>(obs, h'').\n                             {(h'',\n                               \\<lfloor>(NewHeapElem a' (Array_type T n) #\n   obs,\n   a')\\<rfloor>)}))))", "by (auto 4 3 elim!: execute.heap_clone.cases split: ty.splits\n  prod.split_asm htype.splits intro: execute.heap_clone.intros\n  simp add: eval_Fields_conv split_beta prod_eq_iff)\n    (auto simp add: eval_Fields_conv Bex_def)"], ["", "definition red_external_aggr :: \n  \"'m prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> 'heap \\<Rightarrow> \n  (('addr, 'thread_id, 'heap) external_thread_action \\<times> 'addr extCallRet \\<times> 'heap) set\"\nwhere [simp]:\n  \"red_external_aggr P t a M vs h = execute.red_external_aggr P t a M vs h\""], ["", "lemma red_external_aggr_code:\n  \"red_external_aggr P t a M vs h =\n   (if M = wait then\n      let ad_t = thread_id2addr t\n      in {(\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, execute.RetEXC InterruptedException, h),\n          (\\<lbrace>Suspend a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>, RetStaySame, h),\n          (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, execute.RetEXC IllegalMonitorState, h),\n          (\\<lbrace>Notified\\<rbrace>, RetVal Unit, h),\n          (\\<lbrace>WokenUp, ClearInterrupt t, ObsInterrupted t\\<rbrace>, execute.RetEXC InterruptedException, h)} \\<union>\n          (if spurious_wakeups then {(\\<lbrace>Unlock\\<rightarrow>a, Lock\\<rightarrow>a, ReleaseAcquire\\<rightarrow>a, IsInterrupted t False, SyncUnlock a\\<rbrace>, RetVal Unit, h)} else {})\n    else if M = notify then\n       {(\\<lbrace>Notify a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a\\<rbrace>, RetVal Unit, h),\n        (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, execute.RetEXC IllegalMonitorState, h)}\n    else if M = notifyAll then \n       {(\\<lbrace>NotifyAll a, Unlock\\<rightarrow>a, Lock\\<rightarrow>a \\<rbrace>, RetVal Unit, h),\n        (\\<lbrace>UnlockFail\\<rightarrow>a\\<rbrace>, execute.RetEXC IllegalMonitorState, h)}\n    else if M = clone then\n       do {\n         (h', obsa) \\<leftarrow> heap_clone P h a;\n         {case obsa of None \\<Rightarrow> (\\<epsilon>, execute.RetEXC OutOfMemory, h')\n           | Some (obs, a') \\<Rightarrow> ((K$ [], [], [], [], [], obs), RetVal (Addr a'), h')}\n       }\n    else if M = hashcode then {(\\<epsilon>, RetVal (Intg (word_of_int (hash_addr a))), h)}\n    else if M = print then {(\\<lbrace>ExternalCall a M vs Unit\\<rbrace>, RetVal Unit, h)}\n    else if M = currentThread then {(\\<epsilon>, RetVal (Addr (thread_id2addr t)), h)}\n    else if M = interrupted then \n      {(\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, RetVal (Bool True), h),\n       (\\<lbrace>IsInterrupted t False\\<rbrace>, RetVal (Bool False), h)}\n    else if M = yield then {(\\<lbrace>Yield\\<rbrace>, RetVal Unit, h)}\n    else\n      let T = ty_of_htype (the (typeof_addr h a))\n      in if P \\<turnstile> T \\<le> Class Thread then\n        let t_a = addr2thread_id a \n        in if M = start then \n             {(\\<lbrace>NewThread t_a (the_Class T, run, a) h, ThreadStart t_a\\<rbrace>, RetVal Unit, h),\n              (\\<lbrace>ThreadExists t_a True\\<rbrace>, execute.RetEXC IllegalThreadState, h)}\n           else if M = join then\n             {(\\<lbrace>Join t_a, IsInterrupted t False, ThreadJoin t_a\\<rbrace>, RetVal Unit, h),\n              (\\<lbrace>IsInterrupted t True, ClearInterrupt t, ObsInterrupted t\\<rbrace>, execute.RetEXC InterruptedException, h)}\n           else if M = interrupt then\n             {(\\<lbrace>ThreadExists t_a True, WakeUp t_a, Interrupt t_a, ObsInterrupt t_a\\<rbrace>, RetVal Unit, h),\n              (\\<lbrace>ThreadExists t_a False\\<rbrace>, RetVal Unit, h)}\n           else if M = isInterrupted then\n             {(\\<lbrace>IsInterrupted t_a False\\<rbrace>, RetVal (Bool False), h),\n              (\\<lbrace>IsInterrupted t_a True, ObsInterrupted t_a\\<rbrace>, RetVal (Bool True), h)}\n         else {(\\<lbrace>\\<rbrace>, undefined)}\n    else {(\\<lbrace>\\<rbrace>, undefined)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red_external_aggr P t a M vs h =\n    (if M = wait\n     then let ad_t = thread_id2addr t\n          in {(\\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n               ClearInterrupt t, ObsInterrupted t\\<rbrace>,\n               execute.RetEXC InterruptedException, h),\n              (\\<lbrace>Suspend a, (Unlock, a), (Lock, a),\n               (ReleaseAcquire, a), IsInterrupted t False,\n               SyncUnlock a\\<rbrace>, RetStaySame, h),\n              (\\<lbrace>(UnlockFail, a)\\<rbrace>,\n               execute.RetEXC IllegalMonitorState, h),\n              (\\<lbrace>Notified\\<rbrace>, RetVal Unit, h),\n              (\\<lbrace>WokenUp, ClearInterrupt t,\n               ObsInterrupted t\\<rbrace>,\n               execute.RetEXC InterruptedException, h)} \\<union>\n             (if spurious_wakeups\n              then {(\\<lbrace>(Unlock, a), (Lock, a), (ReleaseAcquire, a),\n                     IsInterrupted t False, SyncUnlock a\\<rbrace>,\n                     RetVal Unit, h)}\n              else {})\n     else if M = notify\n          then {(\\<lbrace>Notify a, (Unlock, a), (Lock, a)\\<rbrace>,\n                 RetVal Unit, h),\n                (\\<lbrace>(UnlockFail, a)\\<rbrace>,\n                 execute.RetEXC IllegalMonitorState, h)}\n          else if M = notifyAll\n               then {(\\<lbrace>NotifyAll a, (Unlock, a), (Lock, a)\\<rbrace>,\n                      RetVal Unit, h),\n                     (\\<lbrace>(UnlockFail, a)\\<rbrace>,\n                      execute.RetEXC IllegalMonitorState, h)}\n               else if M = clone\n                    then heap_clone P h a \\<bind>\n                         (\\<lambda>(h', obsa).\n                             {case obsa of\n                              None \\<Rightarrow>\n                                (\\<lbrace>\\<rbrace>,\n                                 execute.RetEXC OutOfMemory, h')\n                              | \\<lfloor>(obs, a')\\<rfloor> \\<Rightarrow>\n                                  ((K$ [], [], [], [], [], obs),\n                                   RetVal (Addr a'), h')})\n                    else if M = hashcode\n                         then {(\\<lbrace>\\<rbrace>,\n                                RetVal (Intg (word_of_int (hash_addr a))),\n                                h)}\n                         else if M = print\n                              then {(\\<lbrace>ExternalCall a M vs\n         Unit\\<rbrace>,\n                                     RetVal Unit, h)}\n                              else if M = currentThread\n                                   then {(\\<lbrace>\\<rbrace>,\n    RetVal (Addr (thread_id2addr t)), h)}\n                                   else if M = interrupted\n  then {(\\<lbrace>IsInterrupted t True, ClearInterrupt t,\n         ObsInterrupted t\\<rbrace>, RetVal (Bool True), h),\n        (\\<lbrace>IsInterrupted t False\\<rbrace>, RetVal (Bool False), h)}\n  else if M = yield then {(\\<lbrace>Yield\\<rbrace>, RetVal Unit, h)}\n       else let T = ty_of_htype (the (typeof_addr h a))\n            in if P \\<turnstile> T \\<le> Class Thread\n               then let t_a = addr2thread_id a\n                    in if M = start\n                       then {(\\<lbrace>NewThread t_a (the_Class T, run, a)\n  h,\n                              ThreadStart t_a\\<rbrace>, RetVal Unit, h),\n                             (\\<lbrace>ThreadExists t_a True\\<rbrace>,\n                              execute.RetEXC IllegalThreadState, h)}\n                       else if M = join\n                            then {(\\<lbrace>Join t_a, IsInterrupted t False,\n                                   ThreadJoin t_a\\<rbrace>, RetVal Unit, h),\n                                  (\\<lbrace>IsInterrupted t True,\n                                   ClearInterrupt t,\n                                   ObsInterrupted t\\<rbrace>,\n                                   execute.RetEXC InterruptedException, h)}\n                            else if M = interrupt\n                                 then {(\\<lbrace>ThreadExists t_a True,\n  WakeUp t_a, Interrupt t_a, ObsInterrupt t_a\\<rbrace>, RetVal Unit, h),\n (\\<lbrace>ThreadExists t_a False\\<rbrace>, RetVal Unit, h)}\n                                 else if M = isInterrupted\nthen {(\\<lbrace>IsInterrupted t_a False\\<rbrace>, RetVal (Bool False), h),\n      (\\<lbrace>IsInterrupted t_a True, ObsInterrupted t_a\\<rbrace>,\n       RetVal (Bool True), h)}\nelse {(\\<lbrace>\\<rbrace>, undefined)}\n               else {(\\<lbrace>\\<rbrace>, undefined)})", "by (auto simp add: execute.red_external_aggr_def\n  split del: option.splits) auto"], ["", "end"], ["", "lemmas [code] =\n  heap_execute.heap_copy_loc_code\n  heap_execute.heap_copies_code\n  heap_execute.heap_clone_code\n  heap_execute.red_external_aggr_code"], ["", "end"]]}