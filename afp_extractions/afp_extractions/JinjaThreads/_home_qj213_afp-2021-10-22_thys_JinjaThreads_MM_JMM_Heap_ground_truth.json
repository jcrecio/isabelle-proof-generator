{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/JMM_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma w_addrs_empty [simp]: \"w_addrs (\\<lambda>_. {}) = {}\"", "lemma allocate_allocated_mono: \"(h', a) \\<in> allocate h C \\<Longrightarrow> allocated h \\<subseteq> allocated h'\"", "lemma\n  shows start_addrs_allocated: \"allocated start_heap = set start_addrs\"\n  and distinct_start_addrs': \"distinct start_addrs\"", "lemma w_addrs_start_heap_obs: \"w_addrs (w_values P vs (map NormalAction start_heap_obs)) \\<subseteq> w_addrs vs\"", "lemma addr_loc_default_conf:\n  \"P \\<turnstile> class_type_of CTn has F:T (fm) in C \n  \\<Longrightarrow> P,h \\<turnstile> addr_loc_default P CTn (CField C F) :\\<le> T\"", "lemma vs_confI:\n  \"(\\<And>ad al v. v \\<in> vs (ad, al) \\<Longrightarrow> \\<exists>T. P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T) \\<Longrightarrow> vs_conf P h vs\"", "lemma vs_confD:\n  \"\\<lbrakk> vs_conf P h vs; v \\<in> vs (ad, al) \\<rbrakk> \\<Longrightarrow> \\<exists>T. P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T\"", "lemma vs_conf_insert_iff:\n  \"vs_conf P h (vs((ad, al) := insert v (vs (ad, al)))) \n  \\<longleftrightarrow> vs_conf P h vs \\<and> (\\<exists>T. P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T)\"", "lemma vs_conf_hext: \"\\<lbrakk> vs_conf P h vs; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> vs_conf P h' vs\"", "lemma vs_conf_allocate:\n  \"\\<lbrakk> vs_conf P h vs; (h', a) \\<in> allocate h hT; is_htype P hT \\<rbrakk> \n  \\<Longrightarrow> vs_conf P h' (w_value P vs (NormalAction (NewHeapElem a hT)))\"", "lemma heap_read_typeableI:\n  \"(\\<And>h ad al v T. \\<lbrakk> P,h \\<turnstile> ad@al : T; P,h \\<turnstile> v :\\<le> T; hconf h \\<rbrakk> \\<Longrightarrow> heap_read h ad al v) \\<Longrightarrow> heap_read_typeable hconf P\"", "lemma heap_read_typeableD:\n  \"\\<lbrakk> heap_read_typeable hconf P; P,h \\<turnstile> ad@al : T; P,h \\<turnstile> v :\\<le> T; hconf h \\<rbrakk> \\<Longrightarrow> heap_read h ad al v\"", "lemma heap_read_typedI:\n  \"\\<lbrakk> heap_read h ad al v; \\<And>T. P,h \\<turnstile> ad@al : T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T \\<rbrakk> \\<Longrightarrow> heap_read_typed P h ad al v\"", "lemma heap_read_typed_into_heap_read:\n  \"heap_read_typed P h ad al v \\<Longrightarrow> heap_read h ad al v\"", "lemma heap_read_typed_typed:\n  \"\\<lbrakk> heap_read_typed P h ad al v; P,h \\<turnstile> ad@al : T \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\"", "lemma heap_conf_read_heap_read_typed:\n  \"heap_conf_read addr2thread_id thread_id2addr empty_heap allocate typeof_addr (heap_read_typed P) heap_write hconf P\"", "lemma start_addrs_dom_w_values:\n  assumes wf: \"wf_syscls P\"\n  and a: \"a \\<in> set start_addrs\"\n  and adal: \"P,start_heap \\<turnstile> a@al : T\"\n  shows \"w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs) (a, al) \\<noteq> {}\""], "translations": [["", "lemma w_addrs_empty [simp]: \"w_addrs (\\<lambda>_. {}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_addrs (\\<lambda>_. {}) = {}", "by(simp add: w_addrs_def)"], ["", "locale allocated_heap_base = heap_base +\n  constrains addr2thread_id :: \"('addr :: addr) \\<Rightarrow> 'thread_id\"\n  and thread_id2addr :: \"'thread_id \\<Rightarrow> 'addr\"\n  and spurious_wakeups :: bool\n  and empty_heap :: \"'heap\"\n  and allocate :: \"'heap \\<Rightarrow> htype \\<Rightarrow> ('heap \\<times> 'addr) set\"\n  and typeof_addr :: \"'heap \\<Rightarrow> 'addr \\<rightharpoonup> htype\"\n  and heap_read :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\n  and heap_write :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  fixes allocated :: \"'heap \\<Rightarrow> 'addr set\""], ["", "locale allocated_heap = \n  allocated_heap_base +\n  heap +\n  constrains addr2thread_id :: \"('addr :: addr) \\<Rightarrow> 'thread_id\"\n  and thread_id2addr :: \"'thread_id \\<Rightarrow> 'addr\"\n  and spurious_wakeups :: bool\n  and empty_heap :: \"'heap\"\n  and allocate :: \"'heap \\<Rightarrow> htype \\<Rightarrow> ('heap \\<times> 'addr) set\"\n  and typeof_addr :: \"'heap \\<Rightarrow> 'addr \\<rightharpoonup> htype\"\n  and heap_read :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\n  and heap_write :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  and allocated :: \"'heap \\<Rightarrow> 'addr set\"\n  and P :: \"'m prog\"\n\n  assumes allocated_empty: \"allocated empty_heap = {}\"\n  and allocate_allocatedD:\n  \"(h', a) \\<in> allocate h hT \\<Longrightarrow> allocated h' = insert a (allocated h) \\<and> a \\<notin> allocated h\"\n  and heap_write_allocated_same:\n  \"heap_write h a al v h' \\<Longrightarrow> allocated h' = allocated h\"\nbegin"], ["", "lemma allocate_allocated_mono: \"(h', a) \\<in> allocate h C \\<Longrightarrow> allocated h \\<subseteq> allocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h', a) \\<in> allocate h C \\<Longrightarrow>\n    allocated h \\<subseteq> allocated h'", "by(simp_all add: allocate_allocatedD)"], ["", "lemma\n  shows start_addrs_allocated: \"allocated start_heap = set start_addrs\"\n  and distinct_start_addrs': \"distinct start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated start_heap = set start_addrs &&& distinct start_addrs", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. allocated start_heap = set start_addrs\n 2. distinct start_addrs", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. allocated start_heap = set start_addrs\n 2. distinct start_addrs", "fix h ads b and xs :: \"cname list\""], ["proof (state)\ngoal (2 subgoals):\n 1. allocated start_heap = set start_addrs\n 2. distinct start_addrs", "let \"?start_addrs h ads b xs\" = \"fst (snd (foldl create_initial_object (h, ads, b) xs))\""], ["proof (state)\ngoal (2 subgoals):\n 1. allocated start_heap = set start_addrs\n 2. distinct start_addrs", "let \"?start_heap h ads b xs\" = \"fst (foldl create_initial_object (h, ads, b) xs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. allocated start_heap = set start_addrs\n 2. distinct start_addrs", "assume \"allocated h = set ads\""], ["proof (state)\nthis:\n  allocated h = set ads\n\ngoal (2 subgoals):\n 1. allocated start_heap = set start_addrs\n 2. distinct start_addrs", "hence \"allocated (?start_heap h ads b xs) = set (?start_addrs h ads b xs) \\<and>\n           (distinct ads \\<longrightarrow> distinct (?start_addrs h ads b xs))\"\n      (is \"?concl xs h ads b\")"], ["proof (prove)\nusing this:\n  allocated h = set ads\n\ngoal (1 subgoal):\n 1. allocated (fst (foldl create_initial_object (h, ads, b) xs)) =\n    set (fst (snd (foldl create_initial_object (h, ads, b) xs))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct (fst (snd (foldl create_initial_object (h, ads, b) xs))))", "proof(induct xs arbitrary: h ads b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h ads b.\n       allocated h = set ads \\<Longrightarrow>\n       allocated (fst (foldl create_initial_object (h, ads, b) [])) =\n       set (fst (snd (foldl create_initial_object (h, ads, b) []))) \\<and>\n       (distinct ads \\<longrightarrow>\n        distinct (fst (snd (foldl create_initial_object (h, ads, b) []))))\n 2. \\<And>a xs h ads b.\n       \\<lbrakk>\\<And>h ads b.\n                   allocated h = set ads \\<Longrightarrow>\n                   allocated\n                    (fst (foldl create_initial_object (h, ads, b) xs)) =\n                   set (fst (snd (foldl create_initial_object (h, ads, b)\n                                   xs))) \\<and>\n                   (distinct ads \\<longrightarrow>\n                    distinct\n                     (fst (snd (foldl create_initial_object (h, ads, b)\n                                 xs))));\n        allocated h = set ads\\<rbrakk>\n       \\<Longrightarrow> allocated\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (a # xs))) =\n                         set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "case Nil"], ["proof (state)\nthis:\n  allocated h = set ads\n\ngoal (2 subgoals):\n 1. \\<And>h ads b.\n       allocated h = set ads \\<Longrightarrow>\n       allocated (fst (foldl create_initial_object (h, ads, b) [])) =\n       set (fst (snd (foldl create_initial_object (h, ads, b) []))) \\<and>\n       (distinct ads \\<longrightarrow>\n        distinct (fst (snd (foldl create_initial_object (h, ads, b) []))))\n 2. \\<And>a xs h ads b.\n       \\<lbrakk>\\<And>h ads b.\n                   allocated h = set ads \\<Longrightarrow>\n                   allocated\n                    (fst (foldl create_initial_object (h, ads, b) xs)) =\n                   set (fst (snd (foldl create_initial_object (h, ads, b)\n                                   xs))) \\<and>\n                   (distinct ads \\<longrightarrow>\n                    distinct\n                     (fst (snd (foldl create_initial_object (h, ads, b)\n                                 xs))));\n        allocated h = set ads\\<rbrakk>\n       \\<Longrightarrow> allocated\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (a # xs))) =\n                         set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "thus ?case"], ["proof (prove)\nusing this:\n  allocated h = set ads\n\ngoal (1 subgoal):\n 1. allocated (fst (foldl create_initial_object (h, ads, b) [])) =\n    set (fst (snd (foldl create_initial_object (h, ads, b) []))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct (fst (snd (foldl create_initial_object (h, ads, b) []))))", "by auto"], ["proof (state)\nthis:\n  allocated (fst (foldl create_initial_object (h, ads, b) [])) =\n  set (fst (snd (foldl create_initial_object (h, ads, b) []))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) []))))\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b.\n       \\<lbrakk>\\<And>h ads b.\n                   allocated h = set ads \\<Longrightarrow>\n                   allocated\n                    (fst (foldl create_initial_object (h, ads, b) xs)) =\n                   set (fst (snd (foldl create_initial_object (h, ads, b)\n                                   xs))) \\<and>\n                   (distinct ads \\<longrightarrow>\n                    distinct\n                     (fst (snd (foldl create_initial_object (h, ads, b)\n                                 xs))));\n        allocated h = set ads\\<rbrakk>\n       \\<Longrightarrow> allocated\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (a # xs))) =\n                         set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b.\n       \\<lbrakk>\\<And>h ads b.\n                   allocated h = set ads \\<Longrightarrow>\n                   allocated\n                    (fst (foldl create_initial_object (h, ads, b) xs)) =\n                   set (fst (snd (foldl create_initial_object (h, ads, b)\n                                   xs))) \\<and>\n                   (distinct ads \\<longrightarrow>\n                    distinct\n                     (fst (snd (foldl create_initial_object (h, ads, b)\n                                 xs))));\n        allocated h = set ads\\<rbrakk>\n       \\<Longrightarrow> allocated\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (a # xs))) =\n                         set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "case (Cons x xs)"], ["proof (state)\nthis:\n  allocated ?h14 = set ?ads14 \\<Longrightarrow>\n  allocated (fst (foldl create_initial_object (?h14, ?ads14, ?b14) xs)) =\n  set (fst (snd (foldl create_initial_object (?h14, ?ads14, ?b14)\n                  xs))) \\<and>\n  (distinct ?ads14 \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (?h14, ?ads14, ?b14) xs))))\n  allocated h = set ads\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b.\n       \\<lbrakk>\\<And>h ads b.\n                   allocated h = set ads \\<Longrightarrow>\n                   allocated\n                    (fst (foldl create_initial_object (h, ads, b) xs)) =\n                   set (fst (snd (foldl create_initial_object (h, ads, b)\n                                   xs))) \\<and>\n                   (distinct ads \\<longrightarrow>\n                    distinct\n                     (fst (snd (foldl create_initial_object (h, ads, b)\n                                 xs))));\n        allocated h = set ads\\<rbrakk>\n       \\<Longrightarrow> allocated\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (a # xs))) =\n                         set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "note ads = \\<open>allocated h = set ads\\<close>"], ["proof (state)\nthis:\n  allocated h = set ads\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b.\n       \\<lbrakk>\\<And>h ads b.\n                   allocated h = set ads \\<Longrightarrow>\n                   allocated\n                    (fst (foldl create_initial_object (h, ads, b) xs)) =\n                   set (fst (snd (foldl create_initial_object (h, ads, b)\n                                   xs))) \\<and>\n                   (distinct ads \\<longrightarrow>\n                    distinct\n                     (fst (snd (foldl create_initial_object (h, ads, b)\n                                 xs))));\n        allocated h = set ads\\<rbrakk>\n       \\<Longrightarrow> allocated\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (a # xs))) =\n                         set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "proof(cases \"b \\<and> allocate h (Class_type x) \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n 2. \\<not> (b \\<and>\n            allocate h (Class_type x) \\<noteq> {}) \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "case False"], ["proof (state)\nthis:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n\ngoal (2 subgoals):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n 2. \\<not> (b \\<and>\n            allocate h (Class_type x) \\<noteq> {}) \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n\ngoal (1 subgoal):\n 1. allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "using ads"], ["proof (prove)\nusing this:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n  allocated h = set ads\n\ngoal (1 subgoal):\n 1. allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "by(simp add: create_initial_object_simps zip_append1)"], ["proof (state)\nthis:\n  allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n  set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "case [simp]: True"], ["proof (state)\nthis:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "then"], ["proof (chain)\npicking this:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}", "obtain h' a' \n          where h'a': \"(SOME ha. ha \\<in> allocate h (Class_type x)) = (h', a')\"\n          and new_obj: \"(h', a') \\<in> allocate h (Class_type x)\""], ["proof (prove)\nusing this:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>h' a'.\n        \\<lbrakk>(SOME haa. haa \\<in> allocate h (Class_type x)) = (h', a');\n         (h', a') \\<in> allocate h (Class_type x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"(SOME ha. ha \\<in> allocate h (Class_type x))\")(auto simp del: True dest: allocate_Eps)"], ["proof (state)\nthis:\n  (SOME haa. haa \\<in> allocate h (Class_type x)) = (h', a')\n  (h', a') \\<in> allocate h (Class_type x)\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "from new_obj"], ["proof (chain)\npicking this:\n  (h', a') \\<in> allocate h (Class_type x)", "have \"allocated h' = insert a' (allocated h)\" \"a' \\<notin> allocated h\""], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h (Class_type x)\n\ngoal (1 subgoal):\n 1. allocated h' = insert a' (allocated h) &&& a' \\<notin> allocated h", "by(auto dest: allocate_allocatedD)"], ["proof (state)\nthis:\n  allocated h' = insert a' (allocated h)\n  a' \\<notin> allocated h\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "with ads"], ["proof (chain)\npicking this:\n  allocated h = set ads\n  allocated h' = insert a' (allocated h)\n  a' \\<notin> allocated h", "have \"allocated h' = set (ads @ [a'])\""], ["proof (prove)\nusing this:\n  allocated h = set ads\n  allocated h' = insert a' (allocated h)\n  a' \\<notin> allocated h\n\ngoal (1 subgoal):\n 1. allocated h' = set (ads @ [a'])", "by auto"], ["proof (state)\nthis:\n  allocated h' = set (ads @ [a'])\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "hence \"?concl xs h' (ads @ [a']) True\""], ["proof (prove)\nusing this:\n  allocated h' = set (ads @ [a'])\n\ngoal (1 subgoal):\n 1. allocated\n     (fst (foldl create_initial_object (h', ads @ [a'], True) xs)) =\n    set (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                    xs))) \\<and>\n    (distinct (ads @ [a']) \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))", "by(rule Cons)"], ["proof (state)\nthis:\n  allocated (fst (foldl create_initial_object (h', ads @ [a'], True) xs)) =\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                  xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "moreover"], ["proof (state)\nthis:\n  allocated (fst (foldl create_initial_object (h', ads @ [a'], True) xs)) =\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                  xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "have \"a' \\<notin> set ads\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<notin> set ads", "using \\<open>a' \\<notin> allocated h\\<close> ads"], ["proof (prove)\nusing this:\n  a' \\<notin> allocated h\n  allocated h = set ads\n\ngoal (1 subgoal):\n 1. a' \\<notin> set ads", "by blast"], ["proof (state)\nthis:\n  a' \\<notin> set ads\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "ultimately"], ["proof (chain)\npicking this:\n  allocated (fst (foldl create_initial_object (h', ads @ [a'], True) xs)) =\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                  xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n  a' \\<notin> set ads", "show ?thesis"], ["proof (prove)\nusing this:\n  allocated (fst (foldl create_initial_object (h', ads @ [a'], True) xs)) =\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                  xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n  a' \\<notin> set ads\n\ngoal (1 subgoal):\n 1. allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n    set (fst (snd (foldl create_initial_object (h, ads, b)\n                    (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "by(simp add: create_initial_object_simps new_obj h'a')"], ["proof (state)\nthis:\n  allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n  set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  allocated (fst (foldl create_initial_object (h, ads, b) (x # xs))) =\n  set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  allocated (fst (foldl create_initial_object (h, ads, b) xs)) =\n  set (fst (snd (foldl create_initial_object (h, ads, b) xs))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) xs))))\n\ngoal (2 subgoals):\n 1. allocated start_heap = set start_addrs\n 2. distinct start_addrs", "}"], ["proof (state)\nthis:\n  allocated ?h16 = set ?ads16 \\<Longrightarrow>\n  allocated (fst (foldl create_initial_object (?h16, ?ads16, ?b16) ?xs16)) =\n  set (fst (snd (foldl create_initial_object (?h16, ?ads16, ?b16)\n                  ?xs16))) \\<and>\n  (distinct ?ads16 \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (?h16, ?ads16, ?b16) ?xs16))))\n\ngoal (2 subgoals):\n 1. allocated start_heap = set start_addrs\n 2. distinct start_addrs", "from this[of empty_heap \"[]\" True initialization_list]"], ["proof (chain)\npicking this:\n  allocated empty_heap = set [] \\<Longrightarrow>\n  allocated\n   (fst (foldl create_initial_object (empty_heap, [], True)\n          initialization_list)) =\n  set (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                  initialization_list))) \\<and>\n  (distinct [] \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                initialization_list))))", "show \"allocated start_heap = set start_addrs\"\n    and distinct_start_addrs: \"distinct start_addrs\""], ["proof (prove)\nusing this:\n  allocated empty_heap = set [] \\<Longrightarrow>\n  allocated\n   (fst (foldl create_initial_object (empty_heap, [], True)\n          initialization_list)) =\n  set (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                  initialization_list))) \\<and>\n  (distinct [] \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                initialization_list))))\n\ngoal (1 subgoal):\n 1. allocated start_heap = set start_addrs &&& distinct start_addrs", "unfolding start_heap_def start_addrs_def start_heap_data_def"], ["proof (prove)\nusing this:\n  allocated empty_heap = set [] \\<Longrightarrow>\n  allocated\n   (fst (foldl create_initial_object (empty_heap, [], True)\n          initialization_list)) =\n  set (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                  initialization_list))) \\<and>\n  (distinct [] \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                initialization_list))))\n\ngoal (1 subgoal):\n 1. allocated\n     (fst (foldl create_initial_object (empty_heap, [], True)\n            initialization_list)) =\n    set (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                    initialization_list))) &&&\n    distinct\n     (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                 initialization_list)))", "by(auto simp add: allocated_empty)"], ["proof (state)\nthis:\n  allocated start_heap = set start_addrs\n  distinct start_addrs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma w_addrs_start_heap_obs: \"w_addrs (w_values P vs (map NormalAction start_heap_obs)) \\<subseteq> w_addrs vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "let ?NewObj = \"\\<lambda>a C. NewHeapElem a (Class_type C) :: ('addr, 'thread_id) obs_event\""], ["proof (state)\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "let \"?start_heap_obs xs\" = \"map (\\<lambda>(C, a). ?NewObj a C) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "have \"w_addrs (w_values P vs (map NormalAction (?start_heap_obs xs))) \\<subseteq> w_addrs vs\"\n      (is \"?concl xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. w_addrs\n     (w_values P vs\n       (map NormalAction\n         (map (\\<lambda>a.\n                  case a of\n                  (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n           xs)))\n    \\<subseteq> w_addrs vs", "proof(induct xs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) [])))\n       \\<subseteq> w_addrs vs\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) [])))\n       \\<subseteq> w_addrs vs\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. w_addrs\n     (w_values P vs\n       (map NormalAction\n         (map (\\<lambda>a.\n                  case a of\n                  (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n           [])))\n    \\<subseteq> w_addrs vs", "by simp"], ["proof (state)\nthis:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>a.\n                case a of (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n         [])))\n  \\<subseteq> w_addrs vs\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "case (Cons x xs)"], ["proof (state)\nthis:\n  w_addrs\n   (w_values P ?vs14\n     (map NormalAction\n       (map (\\<lambda>a.\n                case a of (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n         xs)))\n  \\<subseteq> w_addrs ?vs14\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "have \"w_addrs (w_values P vs (map NormalAction (map (\\<lambda>(C, a). ?NewObj a C) (x # xs))))\n        = w_addrs (w_values P (w_value P vs (NormalAction (?NewObj (snd x) (fst x)))) (map NormalAction (map (\\<lambda>(C, a). ?NewObj a C) xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_addrs\n     (w_values P vs\n       (map NormalAction\n         (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (x # xs)))) =\n    w_addrs\n     (w_values P\n       (w_value P vs\n         (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n       (map NormalAction\n         (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))", "by(simp add: split_beta)"], ["proof (state)\nthis:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (x # xs)))) =\n  w_addrs\n   (w_values P\n     (w_value P vs\n       (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n     (map NormalAction\n       (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "also"], ["proof (state)\nthis:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (x # xs)))) =\n  w_addrs\n   (w_values P\n     (w_value P vs\n       (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n     (map NormalAction\n       (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "have \"\\<dots> \\<subseteq> w_addrs (w_value P vs (NormalAction (?NewObj (snd x) (fst x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_addrs\n     (w_values P\n       (w_value P vs\n         (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n       (map NormalAction\n         (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n    \\<subseteq> w_addrs\n                 (w_value P vs\n                   (NormalAction\n                     (NewHeapElem (snd x) (Class_type (fst x)))))", "by(rule Cons)"], ["proof (state)\nthis:\n  w_addrs\n   (w_values P\n     (w_value P vs\n       (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n     (map NormalAction\n       (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n  \\<subseteq> w_addrs\n               (w_value P vs\n                 (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "also"], ["proof (state)\nthis:\n  w_addrs\n   (w_values P\n     (w_value P vs\n       (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n     (map NormalAction\n       (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n  \\<subseteq> w_addrs\n               (w_value P vs\n                 (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "have \"\\<dots> \\<subseteq> w_addrs vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_addrs\n     (w_value P vs\n       (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n    \\<subseteq> w_addrs vs", "by(auto simp add: w_addrs_def default_val_not_Addr Addr_not_default_val)"], ["proof (state)\nthis:\n  w_addrs\n   (w_value P vs (NormalAction (NewHeapElem (snd x) (Class_type (fst x)))))\n  \\<subseteq> w_addrs vs\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           w_addrs\n            (w_values P vs\n              (map NormalAction\n                (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) xs)))\n           \\<subseteq> w_addrs vs) \\<Longrightarrow>\n       w_addrs\n        (w_values P vs\n          (map NormalAction\n            (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (a # xs))))\n       \\<subseteq> w_addrs vs", "finally"], ["proof (chain)\npicking this:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (x # xs))))\n  \\<subseteq> w_addrs vs", "show ?case"], ["proof (prove)\nusing this:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>(C, a). NewHeapElem a (Class_type C)) (x # xs))))\n  \\<subseteq> w_addrs vs\n\ngoal (1 subgoal):\n 1. w_addrs\n     (w_values P vs\n       (map NormalAction\n         (map (\\<lambda>a.\n                  case a of\n                  (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n           (x # xs))))\n    \\<subseteq> w_addrs vs", "."], ["proof (state)\nthis:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>a.\n                case a of (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n         (x # xs))))\n  \\<subseteq> w_addrs vs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>a.\n                case a of (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n         xs)))\n  \\<subseteq> w_addrs vs\n\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "}"], ["proof (state)\nthis:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>a.\n                case a of (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n         ?xs16)))\n  \\<subseteq> w_addrs vs\n\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "thus ?thesis"], ["proof (prove)\nusing this:\n  w_addrs\n   (w_values P vs\n     (map NormalAction\n       (map (\\<lambda>a.\n                case a of (C, a) \\<Rightarrow> NewHeapElem a (Class_type C))\n         ?xs16)))\n  \\<subseteq> w_addrs vs\n\ngoal (1 subgoal):\n 1. w_addrs (w_values P vs (map NormalAction start_heap_obs))\n    \\<subseteq> w_addrs vs", "by(simp add: start_heap_obs_def)"], ["proof (state)\nthis:\n  w_addrs (w_values P vs (map NormalAction start_heap_obs))\n  \\<subseteq> w_addrs vs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context heap_base begin"], ["", "lemma addr_loc_default_conf:\n  \"P \\<turnstile> class_type_of CTn has F:T (fm) in C \n  \\<Longrightarrow> P,h \\<turnstile> addr_loc_default P CTn (CField C F) :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> class_type_of CTn has F:T (fm) in C \\<Longrightarrow>\n    P,h \\<turnstile> addr_loc_default P CTn (CField C F) :\\<le> T", "apply(cases CTn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>P \\<turnstile> class_type_of CTn has F:T (fm) in C;\n        CTn = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> addr_loc_default P CTn\n     (CField C F) :\\<le> T\n 2. \\<And>x21 x22.\n       \\<lbrakk>P \\<turnstile> class_type_of CTn has F:T (fm) in C;\n        CTn = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> addr_loc_default P CTn\n     (CField C F) :\\<le> T", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>P \\<turnstile> class_type_of CTn has F:T (fm) in C;\n        CTn = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> addr_loc_default P CTn\n     (CField C F) :\\<le> T", "apply(frule has_field_decl_above)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>P \\<turnstile> class_type_of CTn has F:T (fm) in C;\n        CTn = Array_type x21 x22;\n        P \\<turnstile> class_type_of CTn \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> addr_loc_default P CTn\n     (CField C F) :\\<le> T", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition vs_conf :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> ('addr \\<times> addr_loc \\<Rightarrow> 'addr val set) \\<Rightarrow> bool\"\nwhere \"vs_conf P h vs \\<longleftrightarrow> (\\<forall>ad al v. v \\<in> vs (ad, al) \\<longrightarrow> (\\<exists>T. P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T))\""], ["", "lemma vs_confI:\n  \"(\\<And>ad al v. v \\<in> vs (ad, al) \\<Longrightarrow> \\<exists>T. P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T) \\<Longrightarrow> vs_conf P h vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ad al v.\n        v \\<in> vs (ad, al) \\<Longrightarrow>\n        \\<exists>T.\n           P,h \\<turnstile> ad@al : T \\<and>\n           P,h \\<turnstile> v :\\<le> T) \\<Longrightarrow>\n    vs_conf P h vs", "unfolding vs_conf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ad al v.\n        v \\<in> vs (ad, al) \\<Longrightarrow>\n        \\<exists>T.\n           P,h \\<turnstile> ad@al : T \\<and>\n           P,h \\<turnstile> v :\\<le> T) \\<Longrightarrow>\n    \\<forall>ad al v.\n       v \\<in> vs (ad, al) \\<longrightarrow>\n       (\\<exists>T.\n           P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T)", "by blast"], ["", "lemma vs_confD:\n  \"\\<lbrakk> vs_conf P h vs; v \\<in> vs (ad, al) \\<rbrakk> \\<Longrightarrow> \\<exists>T. P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs_conf P h vs; v \\<in> vs (ad, al)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P,h \\<turnstile> ad@al : T \\<and>\n                         P,h \\<turnstile> v :\\<le> T", "unfolding vs_conf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ad al v.\n                v \\<in> vs (ad, al) \\<longrightarrow>\n                (\\<exists>T.\n                    P,h \\<turnstile> ad@al : T \\<and>\n                    P,h \\<turnstile> v :\\<le> T);\n     v \\<in> vs (ad, al)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P,h \\<turnstile> ad@al : T \\<and>\n                         P,h \\<turnstile> v :\\<le> T", "by blast"], ["", "lemma vs_conf_insert_iff:\n  \"vs_conf P h (vs((ad, al) := insert v (vs (ad, al)))) \n  \\<longleftrightarrow> vs_conf P h vs \\<and> (\\<exists>T. P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h (vs((ad, al) := insert v (vs (ad, al)))) =\n    (vs_conf P h vs \\<and>\n     (\\<exists>T.\n         P,h \\<turnstile> ad@al : T \\<and> P,h \\<turnstile> v :\\<le> T))", "by(auto 4 3 elim: vs_confD intro: vs_confI split: if_split_asm)"], ["", "end"], ["", "context heap begin"], ["", "lemma vs_conf_hext: \"\\<lbrakk> vs_conf P h vs; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> vs_conf P h' vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs_conf P h vs; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> vs_conf P h' vs", "by(blast intro!: vs_confI intro: conf_hext addr_loc_type_hext_mono dest: vs_confD)"], ["", "lemma vs_conf_allocate:\n  \"\\<lbrakk> vs_conf P h vs; (h', a) \\<in> allocate h hT; is_htype P hT \\<rbrakk> \n  \\<Longrightarrow> vs_conf P h' (w_value P vs (NormalAction (NewHeapElem a hT)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs_conf P h vs; (h', a) \\<in> allocate h hT;\n     is_htype P hT\\<rbrakk>\n    \\<Longrightarrow> vs_conf P h'\n                       (w_value P vs (NormalAction (NewHeapElem a hT)))", "apply(drule vs_conf_hext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(h', a) \\<in> allocate h hT; is_htype P hT\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> ?h'\n 2. \\<lbrakk>(h', a) \\<in> allocate h hT; is_htype P hT;\n     vs_conf P ?h' vs\\<rbrakk>\n    \\<Longrightarrow> vs_conf P h'\n                       (w_value P vs (NormalAction (NewHeapElem a hT)))", "apply(erule hext_allocate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(h', a) \\<in> allocate h hT; is_htype P hT;\n     vs_conf P h' vs\\<rbrakk>\n    \\<Longrightarrow> vs_conf P h'\n                       (w_value P vs (NormalAction (NewHeapElem a hT)))", "apply(auto intro!: vs_confI simp add: addr_locs_def split: if_split_asm htype.split_asm)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x1 D F fm T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type x1); is_class P x1;\n        vs_conf P h' vs; hT = Class_type x1;\n        P \\<turnstile> x1 has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ta.\n                            P,h' \\<turnstile> a@CField D F : Ta \\<and>\n                            P,h' \\<turnstile> default_val T :\\<le> Ta\n 2. \\<And>v x1 D F fm T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type x1); is_class P x1;\n        vs_conf P h' vs; hT = Class_type x1;\n        P \\<turnstile> x1 has F:T (fm) in D;\n        v \\<in> vs (a, CField D F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P,h' \\<turnstile> a@CField D F : T \\<and>\n                            P,h' \\<turnstile> v :\\<le> T\n 3. \\<And>x21 x22 n'.\n       \\<lbrakk>(h', a) \\<in> allocate h (Array_type x21 x22);\n        case ground_type x21 of NT \\<Rightarrow> False\n        | Class x \\<Rightarrow> is_class P x | _ \\<Rightarrow> True;\n        vs_conf P h' vs; hT = Array_type x21 x22; n' < x22\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P,h' \\<turnstile> a@ACell n' : T \\<and>\n                            P,h' \\<turnstile> default_val x21 :\\<le> T\n 4. \\<And>x21 x22 F fm T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Array_type x21 x22);\n        case ground_type x21 of NT \\<Rightarrow> False\n        | Class x \\<Rightarrow> is_class P x | _ \\<Rightarrow> True;\n        vs_conf P h' vs; hT = Array_type x21 x22;\n        P \\<turnstile> Object has F:T (fm) in Object\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ta.\n                            P,h' \\<turnstile> a@CField Object F : Ta \\<and>\n                            P,h' \\<turnstile> default_val T :\\<le> Ta\n 5. \\<And>v x21 x22 n'.\n       \\<lbrakk>(h', a) \\<in> allocate h (Array_type x21 x22);\n        case ground_type x21 of NT \\<Rightarrow> False\n        | Class x \\<Rightarrow> is_class P x | _ \\<Rightarrow> True;\n        vs_conf P h' vs; hT = Array_type x21 x22; v \\<in> vs (a, ACell n');\n        n' < x22\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P,h' \\<turnstile> a@ACell n' : T \\<and>\n                            P,h' \\<turnstile> v :\\<le> T\n 6. \\<And>v x21 x22 F fm T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Array_type x21 x22);\n        case ground_type x21 of NT \\<Rightarrow> False\n        | Class x \\<Rightarrow> is_class P x | _ \\<Rightarrow> True;\n        vs_conf P h' vs; hT = Array_type x21 x22;\n        v \\<in> vs (a, CField Object F);\n        P \\<turnstile> Object has F:T (fm) in Object\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P,h' \\<turnstile> a@CField Object F : T \\<and>\n                            P,h' \\<turnstile> v :\\<le> T\n 7. \\<And>ad al v x1.\n       \\<lbrakk>v \\<in> vs (ad, al);\n        (h', a) \\<in> allocate h (Class_type x1); is_class P x1;\n        vs_conf P h' vs; hT = Class_type x1; a \\<noteq> ad\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P,h' \\<turnstile> ad@al : T \\<and>\n                            P,h' \\<turnstile> v :\\<le> T\n 8. \\<And>ad al v x1.\n       \\<lbrakk>v \\<in> vs (ad, al);\n        (h', a) \\<in> allocate h (Class_type x1); is_class P x1;\n        vs_conf P h' vs; hT = Class_type x1;\n        \\<forall>D F.\n           al = CField D F \\<longrightarrow>\n           (\\<forall>fm T.\n               \\<not> P \\<turnstile> x1 has F:T (fm) in D)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P,h' \\<turnstile> ad@al : T \\<and>\n                            P,h' \\<turnstile> v :\\<le> T\n 9. \\<And>ad al v x21 x22.\n       \\<lbrakk>v \\<in> vs (ad, al);\n        (h', a) \\<in> allocate h (Array_type x21 x22);\n        case ground_type x21 of NT \\<Rightarrow> False\n        | Class C \\<Rightarrow> is_class P C | _ \\<Rightarrow> True;\n        vs_conf P h' vs; hT = Array_type x21 x22; a \\<noteq> ad\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P,h' \\<turnstile> ad@al : T \\<and>\n                            P,h' \\<turnstile> v :\\<le> T\n 10. \\<And>ad al v x21 x22.\n        \\<lbrakk>v \\<in> vs (ad, al);\n         (h', a) \\<in> allocate h (Array_type x21 x22);\n         case ground_type x21 of NT \\<Rightarrow> False\n         | Class C \\<Rightarrow> is_class P C | _ \\<Rightarrow> True;\n         vs_conf P h' vs; hT = Array_type x21 x22;\n         \\<forall>n'. al = ACell n' \\<longrightarrow> \\<not> n' < x22;\n         \\<forall>F.\n            al = CField Object F \\<longrightarrow>\n            (\\<forall>fm T.\n                \\<not> P \\<turnstile> Object has F:T (fm) in Object)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>T.\n                             P,h' \\<turnstile> ad@al : T \\<and>\n                             P,h' \\<turnstile> v :\\<le> T", "apply(auto 3 3 intro: addr_loc_type.intros defval_conf dest: allocate_SomeD elim: has_field_is_class vs_confD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 D F fm T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type x1); is_class P x1;\n        vs_conf P h' vs; hT = Class_type x1;\n        P \\<turnstile> x1 has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ta.\n                            P,h' \\<turnstile> a@CField D F : Ta \\<and>\n                            P,h' \\<turnstile> default_val T :\\<le> Ta\n 2. \\<And>x21 x22 F fm T.\n       \\<lbrakk>(h', a) \\<in> allocate h (Array_type x21 x22);\n        case ground_type x21 of NT \\<Rightarrow> False\n        | Class x \\<Rightarrow> is_class P x | _ \\<Rightarrow> True;\n        vs_conf P h' vs; hT = Array_type x21 x22;\n        P \\<turnstile> Object has F:T (fm) in Object\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ta.\n                            P,h' \\<turnstile> a@CField Object F : Ta \\<and>\n                            P,h' \\<turnstile> default_val T :\\<le> Ta", "apply(rule exI conjI addr_loc_type.intros|drule allocate_SomeD|erule has_field_is_class|simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>\n  \\<open>heap_read_typeable\\<close> must not be defined in @{term heap_conf_base} (where it should be) because\n  this would lead to duplicate definitions of \\<open>heap_read_typeable\\<close> in contexts where @{term heap_conf_base} \n  is imported twice with different parameters, e.g., @{term P} and @{term \"J2JVM P\"} in @{term \"J_JVM_heap_conf_read\"}.\n\\<close>"], ["", "context heap_base begin"], ["", "definition heap_read_typeable :: \"('heap \\<Rightarrow> bool) \\<Rightarrow> 'm prog \\<Rightarrow> bool\"\nwhere \"heap_read_typeable hconf P \\<longleftrightarrow> (\\<forall>h ad al v T. hconf h \\<longrightarrow> P,h \\<turnstile> ad@al : T \\<longrightarrow> P,h \\<turnstile> v :\\<le> T \\<longrightarrow> heap_read h ad al v)\""], ["", "lemma heap_read_typeableI:\n  \"(\\<And>h ad al v T. \\<lbrakk> P,h \\<turnstile> ad@al : T; P,h \\<turnstile> v :\\<le> T; hconf h \\<rbrakk> \\<Longrightarrow> heap_read h ad al v) \\<Longrightarrow> heap_read_typeable hconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h ad al v T.\n        \\<lbrakk>P,h \\<turnstile> ad@al : T; P,h \\<turnstile> v :\\<le> T;\n         hconf h\\<rbrakk>\n        \\<Longrightarrow> heap_read h ad al v) \\<Longrightarrow>\n    heap_read_typeable hconf P", "unfolding heap_read_typeable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h ad al v T.\n        \\<lbrakk>P,h \\<turnstile> ad@al : T; P,h \\<turnstile> v :\\<le> T;\n         hconf h\\<rbrakk>\n        \\<Longrightarrow> heap_read h ad al v) \\<Longrightarrow>\n    \\<forall>h ad al v T.\n       hconf h \\<longrightarrow>\n       P,h \\<turnstile> ad@al : T \\<longrightarrow>\n       P,h \\<turnstile> v :\\<le> T \\<longrightarrow> heap_read h ad al v", "by blast"], ["", "lemma heap_read_typeableD:\n  \"\\<lbrakk> heap_read_typeable hconf P; P,h \\<turnstile> ad@al : T; P,h \\<turnstile> v :\\<le> T; hconf h \\<rbrakk> \\<Longrightarrow> heap_read h ad al v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_read_typeable hconf P; P,h \\<turnstile> ad@al : T;\n     P,h \\<turnstile> v :\\<le> T; hconf h\\<rbrakk>\n    \\<Longrightarrow> heap_read h ad al v", "unfolding heap_read_typeable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h ad al v T.\n                hconf h \\<longrightarrow>\n                P,h \\<turnstile> ad@al : T \\<longrightarrow>\n                P,h \\<turnstile> v :\\<le> T \\<longrightarrow>\n                heap_read h ad al v;\n     P,h \\<turnstile> ad@al : T; P,h \\<turnstile> v :\\<le> T;\n     hconf h\\<rbrakk>\n    \\<Longrightarrow> heap_read h ad al v", "by blast"], ["", "end"], ["", "context heap_base begin"], ["", "definition heap_read_typed :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\nwhere \"heap_read_typed P h ad al v \\<longleftrightarrow> heap_read h ad al v \\<and> (\\<forall>T. P,h \\<turnstile> ad@al : T \\<longrightarrow> P,h \\<turnstile> v :\\<le> T)\""], ["", "lemma heap_read_typedI:\n  \"\\<lbrakk> heap_read h ad al v; \\<And>T. P,h \\<turnstile> ad@al : T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T \\<rbrakk> \\<Longrightarrow> heap_read_typed P h ad al v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_read h ad al v;\n     \\<And>T.\n        P,h \\<turnstile> ad@al : T \\<Longrightarrow>\n        P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> heap_read_typed P h ad al v", "unfolding heap_read_typed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_read h ad al v;\n     \\<And>T.\n        P,h \\<turnstile> ad@al : T \\<Longrightarrow>\n        P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> heap_read h ad al v \\<and>\n                      (\\<forall>T.\n                          P,h \\<turnstile> ad@al : T \\<longrightarrow>\n                          P,h \\<turnstile> v :\\<le> T)", "by blast"], ["", "lemma heap_read_typed_into_heap_read:\n  \"heap_read_typed P h ad al v \\<Longrightarrow> heap_read h ad al v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_read_typed P h ad al v \\<Longrightarrow> heap_read h ad al v", "unfolding heap_read_typed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_read h ad al v \\<and>\n    (\\<forall>T.\n        P,h \\<turnstile> ad@al : T \\<longrightarrow>\n        P,h \\<turnstile> v :\\<le> T) \\<Longrightarrow>\n    heap_read h ad al v", "by blast"], ["", "lemma heap_read_typed_typed:\n  \"\\<lbrakk> heap_read_typed P h ad al v; P,h \\<turnstile> ad@al : T \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_read_typed P h ad al v;\n     P,h \\<turnstile> ad@al : T\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T", "unfolding heap_read_typed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_read h ad al v \\<and>\n             (\\<forall>T.\n                 P,h \\<turnstile> ad@al : T \\<longrightarrow>\n                 P,h \\<turnstile> v :\\<le> T);\n     P,h \\<turnstile> ad@al : T\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T", "by blast"], ["", "end"], ["", "context heap_conf begin"], ["", "lemma heap_conf_read_heap_read_typed:\n  \"heap_conf_read addr2thread_id thread_id2addr empty_heap allocate typeof_addr (heap_read_typed P) heap_write hconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read addr2thread_id thread_id2addr empty_heap allocate\n     typeof_addr (heap_read_typed P) heap_write hconf P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>heap_read_typed P h a al v; P,h \\<turnstile> a@al : T;\n        hconf h\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T", "fix h a al v T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>heap_read_typed P h a al v; P,h \\<turnstile> a@al : T;\n        hconf h\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T", "assume \"heap_read_typed P h a al v\" \"P,h \\<turnstile> a@al : T\""], ["proof (state)\nthis:\n  heap_read_typed P h a al v\n  P,h \\<turnstile> a@al : T\n\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>heap_read_typed P h a al v; P,h \\<turnstile> a@al : T;\n        hconf h\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T", "thus \"P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  heap_read_typed P h a al v\n  P,h \\<turnstile> a@al : T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> T", "by(rule heap_read_typed_typed)"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context heap begin"], ["", "lemma start_addrs_dom_w_values:\n  assumes wf: \"wf_syscls P\"\n  and a: \"a \\<in> set start_addrs\"\n  and adal: \"P,start_heap \\<turnstile> a@al : T\"\n  shows \"w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs) (a, al) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n     (a, al) \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n     (a, al) \\<noteq>\n    {}", "from a"], ["proof (chain)\npicking this:\n  a \\<in> set start_addrs", "obtain CTn where CTn: \"NewHeapElem a CTn \\<in> set start_heap_obs\""], ["proof (prove)\nusing this:\n  a \\<in> set start_addrs\n\ngoal (1 subgoal):\n 1. (\\<And>CTn.\n        NewHeapElem a CTn \\<in> set start_heap_obs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_start_addrs_conv_NewHeapElem"], ["proof (prove)\nusing this:\n  \\<exists>CTn. NewHeapElem a CTn \\<in> set start_heap_obs\n\ngoal (1 subgoal):\n 1. (\\<And>CTn.\n        NewHeapElem a CTn \\<in> set start_heap_obs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  NewHeapElem a CTn \\<in> set start_heap_obs\n\ngoal (1 subgoal):\n 1. w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n     (a, al) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  NewHeapElem a CTn \\<in> set start_heap_obs", "obtain obs obs' where obs: \"start_heap_obs = obs @ NewHeapElem a CTn # obs'\""], ["proof (prove)\nusing this:\n  NewHeapElem a CTn \\<in> set start_heap_obs\n\ngoal (1 subgoal):\n 1. (\\<And>obs obs'.\n        start_heap_obs = obs @ NewHeapElem a CTn # obs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: split_list)"], ["proof (state)\nthis:\n  start_heap_obs = obs @ NewHeapElem a CTn # obs'\n\ngoal (1 subgoal):\n 1. w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n     (a, al) \\<noteq>\n    {}", "have \"w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs)) (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n     (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n    {}", "proof(cases CTn)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       CTn = Class_type x1 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}\n 2. \\<And>x21 x22.\n       CTn = Array_type x21 x22 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}", "case [simp]: (Class_type C)"], ["proof (state)\nthis:\n  CTn = Class_type C\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       CTn = Class_type x1 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}\n 2. \\<And>x21 x22.\n       CTn = Array_type x21 x22 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}", "with wf CTn"], ["proof (chain)\npicking this:\n  wf_syscls P\n  NewHeapElem a CTn \\<in> set start_heap_obs\n  CTn = Class_type C", "have \"typeof_addr start_heap a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  wf_syscls P\n  NewHeapElem a CTn \\<in> set start_heap_obs\n  CTn = Class_type C\n\ngoal (1 subgoal):\n 1. typeof_addr start_heap a = \\<lfloor>Class_type C\\<rfloor>", "by(auto intro: NewHeapElem_start_heap_obsD)"], ["proof (state)\nthis:\n  typeof_addr start_heap a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       CTn = Class_type x1 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}\n 2. \\<And>x21 x22.\n       CTn = Array_type x21 x22 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}", "with adal"], ["proof (chain)\npicking this:\n  P,start_heap \\<turnstile> a@al : T\n  typeof_addr start_heap a = \\<lfloor>Class_type C\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  P,start_heap \\<turnstile> a@al : T\n  typeof_addr start_heap a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n     (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n    {}", "by cases auto"], ["proof (state)\nthis:\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       CTn = Array_type x21 x22 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       CTn = Array_type x21 x22 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}", "case [simp]: (Array_type T n)"], ["proof (state)\nthis:\n  CTn = Array_type T n\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       CTn = Array_type x21 x22 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}", "with wf CTn"], ["proof (chain)\npicking this:\n  wf_syscls P\n  NewHeapElem a CTn \\<in> set start_heap_obs\n  CTn = Array_type T n", "have \"typeof_addr start_heap a = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  wf_syscls P\n  NewHeapElem a CTn \\<in> set start_heap_obs\n  CTn = Array_type T n\n\ngoal (1 subgoal):\n 1. typeof_addr start_heap a = \\<lfloor>Array_type T n\\<rfloor>", "by(auto dest: NewHeapElem_start_heap_obsD)"], ["proof (state)\nthis:\n  typeof_addr start_heap a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       CTn = Array_type x21 x22 \\<Longrightarrow>\n       w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n        (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n       {}", "with adal"], ["proof (chain)\npicking this:\n  P,start_heap \\<turnstile> a@al : T\n  typeof_addr start_heap a = \\<lfloor>Array_type T n\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  P,start_heap \\<turnstile> a@al : T\n  typeof_addr start_heap a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n     (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n    {}", "by cases(auto dest: has_field_decl_above)"], ["proof (state)\nthis:\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n     (a, al) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n     (a, al) \\<noteq>\n    {}", "have \"w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs)) (NormalAction (NewHeapElem a CTn :: ('addr, 'thread_id) obs_event))\n    (a, al) \\<subseteq> w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs) (a, al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n     (NormalAction (NewHeapElem a CTn)) (a, al)\n    \\<subseteq> w_values P (\\<lambda>_. {})\n                 (map NormalAction start_heap_obs) (a, al)", "by(simp add: obs del: w_value.simps)(rule w_values_mono)"], ["proof (state)\nthis:\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al)\n  \\<subseteq> w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n               (a, al)\n\ngoal (1 subgoal):\n 1. w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n     (a, al) \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n  {}\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al)\n  \\<subseteq> w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n               (a, al)", "show ?thesis"], ["proof (prove)\nusing this:\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al) \\<noteq>\n  {}\n  w_value P (w_values P (\\<lambda>_. {}) (map NormalAction obs))\n   (NormalAction (NewHeapElem a CTn)) (a, al)\n  \\<subseteq> w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n               (a, al)\n\ngoal (1 subgoal):\n 1. w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n     (a, al) \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  w_values P (\\<lambda>_. {}) (map NormalAction start_heap_obs)\n   (a, al) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}