{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Basic/Auxiliary.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma nat_add_max_le[simp]:\n  \"((n::nat) + max i j \\<le> m) = (n + i \\<le> m \\<and> n + j \\<le> m)\"", "lemma Suc_add_max_le[simp]:\n  \"(Suc(n + max i j) \\<le> m) = (Suc(n + i) \\<le> m \\<and> Suc(n + j) \\<le> m)\"", "lemma less_min_eq1:\n  \"(a :: 'a :: order) < b \\<Longrightarrow> min a b = a\"", "lemma less_min_eq2:\n  \"(a :: 'a :: order) > b \\<Longrightarrow> min a b = b\"", "lemma Option_bind_eq_None_conv:\n  \"x \\<bind> y = None \\<longleftrightarrow> x = None \\<or> (\\<exists>x'. x = Some x' \\<and> y x' = None)\"", "lemma Option_bind_eq_Some_conv:\n  \"x \\<bind> y = Some z \\<longleftrightarrow> (\\<exists>x'. x = Some x' \\<and> y x' = Some z)\"", "lemma map_upds_xchg_snd:\n  \"\\<lbrakk> length xs \\<le> length ys; length xs \\<le> length zs; \\<forall>i. i < length xs \\<longrightarrow> ys ! i = zs ! i \\<rbrakk>\n  \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>] zs)\"", "lemma distinct_fst_Nil [simp]:\n  \"distinct_fst []\"", "lemma distinct_fst_Cons [simp]:\n  \"distinct_fst ((k,x)#kxs) = (distinct_fst kxs \\<and> (\\<forall>y. (k,y) \\<notin> set kxs))\"", "lemma distinct_fstD: \"\\<lbrakk> distinct_fst xs; (x, y) \\<in> set xs; (x, z) \\<in> set xs \\<rbrakk> \\<Longrightarrow> y = z\"", "lemma map_of_SomeI:\n  \"\\<lbrakk> distinct_fst kxs; (k,x) \\<in> set kxs \\<rbrakk> \\<Longrightarrow> map_of kxs k = Some x\"", "lemma rel_option_Some1:\n  \"rel_option R (Some x) y \\<longleftrightarrow> (\\<exists>y'. y = Some y' \\<and> R x y')\"", "lemma rel_option_Some2:\n  \"rel_option R x (Some y) \\<longleftrightarrow> (\\<exists>x'. x = Some x' \\<and> R x' y)\"", "lemma rel_list_all2_Cons [iff]:\n  \"list_all2 (fun_of S) (x#xs) (y#ys) = \n   ((x,y) \\<in> S \\<and> list_all2 (fun_of S) xs ys)\"", "lemma rel_list_all2_Cons1:\n  \"list_all2 (fun_of S) (x#xs) ys = \n  (\\<exists>z zs. ys = z#zs \\<and> (x,z) \\<in> S \\<and> list_all2 (fun_of S) xs zs)\"", "lemma rel_list_all2_Cons2:\n  \"list_all2 (fun_of S) xs (y#ys) = \n  (\\<exists>z zs. xs = z#zs \\<and> (z,y) \\<in> S \\<and> list_all2 (fun_of S) zs ys)\"", "lemma rel_list_all2_refl:\n  \"(\\<And>x. (x,x) \\<in> S) \\<Longrightarrow> list_all2 (fun_of S) xs xs\"", "lemma rel_list_all2_antisym:\n  \"\\<lbrakk> (\\<And>x y. \\<lbrakk>(x,y) \\<in> S; (y,x) \\<in> T\\<rbrakk> \\<Longrightarrow> x = y); \n     list_all2 (fun_of S) xs ys; list_all2 (fun_of T) ys xs \\<rbrakk> \\<Longrightarrow> xs = ys\"", "lemma rel_list_all2_trans: \n  \"\\<lbrakk> \\<And>a b c. \\<lbrakk>(a,b) \\<in> R; (b,c) \\<in> S\\<rbrakk> \\<Longrightarrow> (a,c) \\<in> T;\n    list_all2 (fun_of R) as bs; list_all2 (fun_of S) bs cs\\<rbrakk> \n  \\<Longrightarrow> list_all2 (fun_of T) as cs\"", "lemma rel_list_all2_update_cong:\n  \"\\<lbrakk> i<size xs; list_all2 (fun_of S) xs ys; (x,y) \\<in> S \\<rbrakk> \n  \\<Longrightarrow> list_all2 (fun_of S) (xs[i:=x]) (ys[i:=y])\"", "lemma rel_list_all2_nthD:\n  \"\\<lbrakk> list_all2 (fun_of S) xs ys; p < size xs \\<rbrakk> \\<Longrightarrow> (xs!p,ys!p) \\<in> S\"", "lemma rel_list_all2I:\n  \"\\<lbrakk> length a = length b; \\<And>n. n < length a \\<Longrightarrow> (a!n,b!n) \\<in> S \\<rbrakk> \\<Longrightarrow> list_all2 (fun_of S) a b\"", "lemma list_all2_induct[consumes 1, case_names Nil Cons]:\n  assumes major: \"list_all2 P xs ys\"\n  and Nil: \"Q [] []\"\n  and Cons: \"\\<And>x xs y ys. \\<lbrakk> P x y; list_all2 P xs ys; Q xs ys \\<rbrakk> \\<Longrightarrow> Q (x # xs) (y # ys)\"\n  shows \"Q xs ys\"", "lemma list_all2_split:\n  assumes major: \"list_all2 P xs ys\"\n  and split: \"\\<And>x y. P x y \\<Longrightarrow> \\<exists>z. Q x z \\<and> R z y\"\n  shows \"\\<exists>zs. list_all2 Q xs zs \\<and> list_all2 R zs ys\"", "lemma list_all2_refl_conv:\n  \"list_all2 P xs xs \\<longleftrightarrow> (\\<forall>x\\<in>set xs. P x x)\"", "lemma list_all2_op_eq [simp]:\n  \"list_all2 (=) xs ys \\<longleftrightarrow> xs = ys\"", "lemmas filter_replicate_conv = filter_replicate", "lemma length_greater_Suc_0_conv: \"Suc 0 < length xs \\<longleftrightarrow> (\\<exists>x x' xs'. xs = x # x' # xs')\"", "lemmas zip_same_conv = zip_same_conv_map", "lemma nth_Cons_subtract: \"0 < n \\<Longrightarrow> (x # xs) ! n = xs ! (n - 1)\"", "lemma f_nth_set:\n  \"\\<lbrakk> f (xs ! n) = v; n < length xs \\<rbrakk> \\<Longrightarrow> v \\<in> f ` set xs\"", "lemma nth_concat_eqI:\n  \"\\<lbrakk> n = sum_list (map length (take i xss)) + k; i < length xss; k < length (xss ! i); x = xss ! i ! k \\<rbrakk>\n  \\<Longrightarrow> concat xss ! n = x\"", "lemma replicate_eq_append_conv: \n  \"(replicate n x = xs @ ys) = (\\<exists>m\\<le>n. xs = replicate m x \\<and> ys = replicate (n-m) x)\"", "lemma replicate_Suc_snoc:\n  \"replicate (Suc n) x = replicate n x @ [x]\"", "lemma map_eq_append_conv:\n  \"map f xs = ys @ zs \\<longleftrightarrow> (\\<exists>ys' zs'. map f ys' = ys \\<and> map f zs' = zs \\<and> xs = ys' @ zs')\"", "lemma append_eq_map_conv:\n  \"ys @ zs = map f xs \\<longleftrightarrow> (\\<exists>ys' zs'. map f ys' = ys \\<and> map f zs' = zs \\<and> xs = ys' @ zs')\"", "lemma map_eq_map_conv:\n  \"map f xs = map g ys \\<longleftrightarrow> list_all2 (\\<lambda>x y. f x = g y) xs ys\"", "lemma map_eq_all_nth_conv:\n  \"map f xs = ys \\<longleftrightarrow> length xs = length ys \\<and> (\\<forall>n < length xs. f (xs ! n) = ys ! n)\"", "lemma take_eq_take_le_eq:\n  \"\\<lbrakk> take n xs = take n ys; m \\<le> n \\<rbrakk> \\<Longrightarrow> take m xs = take m ys\"", "lemma take_list_update_beyond:\n  \"n \\<le> m \\<Longrightarrow> take n (xs[m := x]) = take n xs\"", "lemma hd_drop_conv_nth:\n  \"n < length xs \\<Longrightarrow> hd (drop n xs) = xs ! n\"", "lemma set_tl_subset: \"set (tl xs) \\<subseteq> set xs\"", "lemma tl_conv_drop: \"tl xs = drop 1 xs\"", "lemma takeWhile_eq_Nil_dropWhile_eq_Nil_imp_Nil:\n  \"\\<lbrakk> takeWhile P xs = []; dropWhile P xs = [] \\<rbrakk> \\<Longrightarrow> xs = []\"", "lemma takeWhile_eq_Nil_conv:\n  \"takeWhile P xs = [] \\<longleftrightarrow> (xs = [] \\<or> \\<not> P (hd xs))\"", "lemma dropWhile_append1': \"dropWhile P xs \\<noteq> [] \\<Longrightarrow> dropWhile P (xs @ ys) = dropWhile P xs @ ys\"", "lemma dropWhile_append2': \"dropWhile P xs = [] \\<Longrightarrow> dropWhile P (xs @ ys) = dropWhile P ys\"", "lemma takeWhile_append1': \"dropWhile P xs \\<noteq> [] \\<Longrightarrow> takeWhile P (xs @ ys) = takeWhile P xs\"", "lemma takeWhile_takeWhile: \"takeWhile P (takeWhile Q xs) = takeWhile (\\<lambda>x. P x \\<and> Q x) xs\"", "lemma dropWhile_eq_ConsD:\n  \"dropWhile P xs = y # ys \\<Longrightarrow> y \\<in> set xs \\<and> \\<not> P y\"", "lemma dropWhile_eq_hd_conv: \"dropWhile P xs = hd xs # rest \\<longleftrightarrow> xs \\<noteq> [] \\<and> rest = tl xs \\<and> \\<not> P (hd xs)\"", "lemma dropWhile_eq_same_conv: \"dropWhile P xs = xs \\<longleftrightarrow> (xs = [] \\<or> \\<not> P (hd xs))\"", "lemma subset_code [code_unfold]:\n  \"set xs \\<subseteq> set ys \\<longleftrightarrow> (\\<forall>x \\<in> set xs. x \\<in> set ys)\"", "lemma eval_bot [simp]:\n  \"Predicate.eval bot = (\\<lambda>_. False)\"", "lemma not_is_emptyE:\n  assumes \"\\<not> Predicate.is_empty P\"\n  obtains x where \"Predicate.eval P x\"", "lemma is_emptyD:\n  assumes \"Predicate.is_empty P\"\n  shows \"Predicate.eval P x \\<Longrightarrow> False\"", "lemma eval_bind_conv:\n  \"Predicate.eval (P \\<bind> R) y = (\\<exists>x. Predicate.eval P x \\<and> Predicate.eval (R x) y)\"", "lemma eval_single_conv: \"Predicate.eval (Predicate.single a) b \\<longleftrightarrow> a = b\"", "lemma conj_asm_conv_imp:\n  \"(A \\<and> B \\<Longrightarrow> PROP C) \\<equiv> (A \\<Longrightarrow> B \\<Longrightarrow> PROP C)\"", "lemma meta_all_eq_conv: \"(\\<And>a. a = b \\<Longrightarrow> PROP P a) \\<equiv> PROP P b\"", "lemma meta_all_eq_conv2: \"(\\<And>a. b = a \\<Longrightarrow> PROP P a) \\<equiv> PROP P b\"", "lemma disj_split:\n  \"P (a \\<or> b) \\<longleftrightarrow> (a \\<longrightarrow> P True) \\<and> (b \\<longrightarrow> P True) \\<and> (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False)\"", "lemma disj_split_asm:\n  \"P (a \\<or> b) \\<longleftrightarrow> \\<not> (a \\<and> \\<not> P True \\<or> b \\<and> \\<not> P True \\<or> \\<not> a \\<and> \\<not> b \\<and> \\<not> P False)\"", "lemma disjCE:\n  assumes \"P \\<or> Q\"\n  obtains P | \"Q\" \"\\<not> P\"", "lemma case_option_conv_if:\n  \"(case v of None \\<Rightarrow> f | Some x \\<Rightarrow> g x) = (if \\<exists>a. v = Some a then g (the v) else f)\"", "lemma LetI: \"(\\<And>x. x = t \\<Longrightarrow> P x) \\<Longrightarrow> let x = t in P x\"", "lemmas meta_onepoint = meta_all_eq_conv meta_all_eq_conv2", "lemma meta_all2_eq_conv: \"(\\<And>a b. a = c \\<Longrightarrow> PROP P a b) \\<equiv> (\\<And>b. PROP P c b)\"", "lemma meta_all3_eq_conv: \"(\\<And>a b c. a = d \\<Longrightarrow> PROP P a b c) \\<equiv> (\\<And>b c. PROP P d b c)\"", "lemma meta_all4_eq_conv: \"(\\<And>a b c d. a = e \\<Longrightarrow> PROP P a b c d) \\<equiv> (\\<And>b c d. PROP P e b c d)\"", "lemma meta_all5_eq_conv: \"(\\<And>a b c d e. a = f \\<Longrightarrow> PROP P a b c d e) \\<equiv> (\\<And>b c d e. PROP P f b c d e)\"", "lemma inj_on_image_mem_iff:\n  \"\\<lbrakk> inj_on f A; B \\<subseteq> A; a \\<in> A \\<rbrakk> \\<Longrightarrow> f a \\<in> f ` B \\<longleftrightarrow> a \\<in> B\"", "lemma sum_hom:\n  assumes hom_add [simp]: \"\\<And>a b. f (a + b) = f a + f b\"\n  and hom_0 [simp]: \"f 0 = 0\"\n  shows \"sum (f \\<circ> h) A = f (sum h A)\"", "lemma sum_upto_add_nat:\n  \"a \\<le> b \\<Longrightarrow> sum f {..<(a :: nat)} + sum f {a..<b} = sum f {..<b}\"", "lemma nat_fun_sum_eq_conv:\n  fixes f :: \"'a \\<Rightarrow> nat\"\n  shows \"(\\<lambda>a. f a + g a) = (\\<lambda>a. 0) \\<longleftrightarrow> f = (\\<lambda>a .0) \\<and> g = (\\<lambda>a. 0)\"", "lemma in_ran_conv: \"v \\<in> ran m \\<longleftrightarrow> (\\<exists>k. m k = Some v)\"", "lemma map_le_dom_eq_conv_eq:\n  \"\\<lbrakk> m \\<subseteq>\\<^sub>m m'; dom m = dom m' \\<rbrakk> \\<Longrightarrow> m = m'\"", "lemma map_leI:\n  \"(\\<And>k v. f k = Some v \\<Longrightarrow> g k = Some v) \\<Longrightarrow> f \\<subseteq>\\<^sub>m g\"", "lemma map_le_SomeD: \"\\<lbrakk> m \\<subseteq>\\<^sub>m m'; m x = \\<lfloor>y\\<rfloor> \\<rbrakk> \\<Longrightarrow> m' x = \\<lfloor>y\\<rfloor>\"", "lemma map_le_same_upd:\n  \"f x = None \\<Longrightarrow> f \\<subseteq>\\<^sub>m f(x \\<mapsto> y)\"", "lemma map_upd_map_add: \"X(V \\<mapsto> v) = (X ++ [V \\<mapsto> v])\"", "lemma foldr_filter_conv:\n  \"foldr f (filter P xs) = foldr (\\<lambda>x s. if P x then f x s else s) xs\"", "lemma foldr_insert_conv_set:\n  \"foldr insert xs A = A \\<union> set xs\"", "lemma snd_o_Pair_conv_id: \"snd o Pair a = id\"", "lemma if_intro:\n  \"\\<lbrakk> P \\<Longrightarrow> A; \\<not> P \\<Longrightarrow> B \\<rbrakk> \\<Longrightarrow> if P then A else B\"", "lemma ex_set_conv: \"(\\<exists>x. x \\<in> set xs) \\<longleftrightarrow> xs \\<noteq> []\"", "lemma subset_Un1: \"A \\<subseteq> B \\<Longrightarrow> A \\<subseteq> B \\<union> C\"", "lemma subset_Un2: \"A \\<subseteq> C \\<Longrightarrow> A \\<subseteq> B \\<union> C\"", "lemma subset_insert: \"A \\<subseteq> B \\<Longrightarrow> A \\<subseteq> insert a B\"", "lemma UNION_subsetD: \"\\<lbrakk> (\\<Union>x\\<in>A. f x) \\<subseteq> B; a \\<in> A \\<rbrakk> \\<Longrightarrow> f a \\<subseteq> B\"", "lemma Collect_eq_singleton_conv:\n  \"{a. P a} = {a} \\<longleftrightarrow> P a \\<and> (\\<forall>a'. P a' \\<longrightarrow> a = a')\"", "lemma Collect_conv_UN_singleton: \"{f x|x. x \\<in> P} = (\\<Union>x\\<in>P. {f x})\"", "lemma if_else_if_else_eq_if_else [simp]:\n  \"(if b then x else if b then y else z) = (if b then x else z)\"", "lemma rec_prod_split [simp]: \"old.rec_prod = case_prod\"", "lemma inj_Pair_snd [simp]: \"inj (Pair x)\"", "lemma rtranclp_False [simp]: \"(\\<lambda>a b. False)\\<^sup>*\\<^sup>* = (=)\"", "lemmas rtranclp_induct3 =\n  rtranclp_induct[where a=\"(ax, ay, az)\" and b=\"(bx, by, bz)\", split_rule, consumes 1, case_names refl step]", "lemmas tranclp_induct3 =\n  tranclp_induct[where a=\"(ax, ay, az)\" and b=\"(bx, by, bz)\", split_rule, consumes 1, case_names refl step]", "lemmas rtranclp_induct4 =\n  rtranclp_induct[where a=\"(ax, ay, az, aw)\" and b=\"(bx, by, bz, bw)\", split_rule, consumes 1, case_names refl step]", "lemmas tranclp_induct4 =\n  tranclp_induct[where a=\"(ax, ay, az, aw)\" and b=\"(bx, by, bz, bw)\", split_rule, consumes 1, case_names refl step]", "lemmas converse_tranclp_induct2 =\n  converse_tranclp_induct [of _ \"(ax,ay)\" \"(bx,by)\", split_rule,\n                 consumes 1, case_names base step]", "lemma wfP_induct' [consumes 1, case_names wfP]:\n  \"\\<lbrakk>wfP r; \\<And>x. (\\<And>y. r y x \\<Longrightarrow> P y) \\<Longrightarrow> P x\\<rbrakk> \\<Longrightarrow> P a\"", "lemma wfP_induct2 [consumes 1, case_names wfP]:\n  \"\\<lbrakk>wfP r; \\<And>x x'. (\\<And>y y'. r (y, y') (x, x') \\<Longrightarrow> P y y') \\<Longrightarrow> P x x' \\<rbrakk> \\<Longrightarrow> P x x'\"", "lemma wfP_minimalE:\n  assumes \"wfP r\"\n  and \"P x\"\n  obtains z where \"P z\" \"r^** z x\" \"\\<And>y. r y z \\<Longrightarrow> \\<not> P y\"", "lemma coinduct_set_wf [consumes 3, case_names coinduct, case_conclusion coinduct wait step]: \n  assumes \"mono f\" \"wf r\" \"(a, b) \\<in> X\"\n  and step: \"\\<And>x b. (x, b) \\<in> X \\<Longrightarrow> (\\<exists>b'. (b', b) \\<in> r \\<and> (x, b') \\<in> X) \\<or> (x \\<in> f (fst ` X \\<union> gfp f))\"\n  shows \"a \\<in> gfp f\"", "lemma converse3p_converse3p: \"converse3p (converse3p r) = r\"", "lemma converse3pD: \"converse3p r c b a \\<Longrightarrow> r a b c\"", "lemmas rtrancl3p_induct3 =\n  rtrancl3p.induct[of _ \"(ax,ay,az)\" _ \"(cx,cy,cz)\", split_format (complete),\n                 consumes 1, case_names refl step]", "lemmas rtrancl3p_induct4 = \n  rtrancl3p.induct[of _ \"(ax,ay,az,aw)\" _ \"(cx,cy,cz,cw)\", split_format (complete),\n                 consumes 1, case_names refl step]", "lemma rtrancl3p_induct4' [consumes 1, case_names refl step]:\n  assumes major: \"rtrancl3p r (ax, (ay, az), aw) bs (cx, (cy, cz), cw)\"\n  and refl: \"\\<And>a aa b ba. P a aa b ba [] a aa b ba\"\n  and step: \"\\<And>a aa b ba bs ab ac bb bc bd ad ae be bf.\n       \\<lbrakk> rtrancl3p r (a, (aa, b), ba) bs (ab, (ac, bb), bc);\n         P a aa b ba bs ab ac bb bc; r (ab, (ac, bb), bc) bd (ad, (ae, be), bf) \\<rbrakk>\n       \\<Longrightarrow> P a aa b ba (bs @ [bd]) ad ae be bf\"\n  shows \"P ax ay az aw bs cx cy cz cw\"", "lemma rtrancl3p_induct1:\n  \"\\<lbrakk> rtrancl3p r a bs c; P a; \\<And>bs c b d. \\<lbrakk> rtrancl3p r a bs c; r c b d; P c \\<rbrakk> \\<Longrightarrow> P d \\<rbrakk> \\<Longrightarrow> P c\"", "lemma rtrancl3p_trans [trans]:\n  assumes one: \"rtrancl3p r a bs a'\"\n  and two: \"rtrancl3p r a' bs' a''\"\n  shows \"rtrancl3p r a (bs @ bs') a''\"", "lemma rtrancl3p_step_converse:\n  assumes step: \"r a b a'\"\n  and stepify: \"rtrancl3p r a' bs a''\"\n  shows \"rtrancl3p r a (b # bs) a''\"", "lemma converse_rtrancl3p_step:\n  \"rtrancl3p r a (b # bs) a'' \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' bs a''\"", "lemma converse_rtrancl3pD:\n  \"rtrancl3p (converse3p r) a' bs a \\<Longrightarrow> rtrancl3p r a (rev bs) a'\"", "lemma rtrancl3p_converseD:\n  \"rtrancl3p r a bs a' \\<Longrightarrow> rtrancl3p (converse3p r) a' (rev bs) a\"", "lemma rtrancl3p_converse_induct [consumes 1, case_names refl step]:\n  assumes ih: \"rtrancl3p r a bs a''\"\n  and refl: \"\\<And>a. P a [] a\"\n  and step: \"\\<And>a b a' bs a''. \\<lbrakk> rtrancl3p r a' bs a''; r a b a'; P a' bs a'' \\<rbrakk> \\<Longrightarrow> P a (b # bs) a''\"\n  shows \"P a bs a''\"", "lemma rtrancl3p_converse_induct' [consumes 1, case_names refl step]:\n  assumes ih: \"rtrancl3p r a bs a''\"\n  and refl: \"P a'' []\"\n  and step: \"\\<And>a b a' bs. \\<lbrakk> rtrancl3p r a' bs a''; r a b a'; P a' bs \\<rbrakk> \\<Longrightarrow> P a (b # bs)\"\n  shows \"P a bs\"", "lemma rtrancl3p_converseE[consumes 1, case_names refl step]:\n  \"\\<lbrakk> rtrancl3p r a bs a'';\n     \\<lbrakk> a = a''; bs = [] \\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>bs' b a'. \\<lbrakk> bs = b # bs'; r a b a'; rtrancl3p r a' bs' a'' \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk>\n  \\<Longrightarrow> thesis\"", "lemma rtrancl3p_induct' [consumes 1, case_names refl step]:\n  assumes major: \"rtrancl3p r a bs c\"\n  and refl: \"P a [] a\"\n  and step: \"\\<And>bs a' b a''. \\<lbrakk> rtrancl3p r a bs a'; P a bs a'; r a' b a'' \\<rbrakk>\n             \\<Longrightarrow> P a (bs @ [b]) a''\"\n  shows \"P a bs c\"", "lemma r_into_rtrancl3p:\n  \"r a b a' \\<Longrightarrow> rtrancl3p r a [b] a'\"", "lemma rtrancl3p_appendE:\n  assumes \"rtrancl3p r a (bs @ bs') a''\"\n  obtains a' where \"rtrancl3p r a bs a'\" \"rtrancl3p r a' bs' a''\"", "lemma rtrancl3p_Cons:\n  \"rtrancl3p r a (b # bs) a' \\<longleftrightarrow> (\\<exists>a''. r a b a'' \\<and> rtrancl3p r a'' bs a')\"", "lemma rtrancl3p_Nil:\n  \"rtrancl3p r a [] a' \\<longleftrightarrow> a = a'\"", "lemma invariant3pI: \"(\\<And>s tl s'. \\<lbrakk> s \\<in> I; r s tl s' \\<rbrakk> \\<Longrightarrow> s' \\<in> I) \\<Longrightarrow> invariant3p r I\"", "lemma invariant3pD: \"\\<And>tl. \\<lbrakk> invariant3p r I; r s tl s'; s \\<in> I \\<rbrakk> \\<Longrightarrow> s' \\<in> I\"", "lemma invariant3p_rtrancl3p: \n  assumes inv: \"invariant3p r I\"\n  and rtrancl: \"rtrancl3p r a bs a'\"\n  and start: \"a \\<in> I\"\n  shows \"a' \\<in> I\"", "lemma invariant3p_UNIV [simp, intro!]:\n  \"invariant3p r UNIV\"", "lemma invarinat3p_empty [simp, intro!]:\n  \"invariant3p r {}\"", "lemma invariant3p_IntI [simp, intro]:\n  \"\\<lbrakk> invariant3p r I; invariant3p r J \\<rbrakk> \\<Longrightarrow> invariant3p r (I \\<inter> J)\"", "lemma explode_add [simp]:\n  \"String.explode (s + t) = String.explode s @ String.explode t\""], "translations": [["", "lemma nat_add_max_le[simp]:\n  \"((n::nat) + max i j \\<le> m) = (n + i \\<le> m \\<and> n + j \\<le> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n + max i j \\<le> m) = (n + i \\<le> m \\<and> n + j \\<le> m)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n + max i j \\<le> m) = (n + i \\<le> m \\<and> n + j \\<le> m)", "by arith"], ["", "(*>*)"], ["", "lemma Suc_add_max_le[simp]:\n  \"(Suc(n + max i j) \\<le> m) = (Suc(n + i) \\<le> m \\<and> Suc(n + j) \\<le> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc (n + max i j) \\<le> m) =\n    (Suc (n + i) \\<le> m \\<and> Suc (n + j) \\<le> m)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc (n + max i j) \\<le> m) =\n    (Suc (n + i) \\<le> m \\<and> Suc (n + j) \\<le> m)", "by arith"], ["", "(*>*)"], ["", "lemma less_min_eq1:\n  \"(a :: 'a :: order) < b \\<Longrightarrow> min a b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> min a b = a", "by(auto simp add: min_def order_less_imp_le)"], ["", "lemma less_min_eq2:\n  \"(a :: 'a :: order) > b \\<Longrightarrow> min a b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a \\<Longrightarrow> min a b = b", "by(auto simp add: min_def order_less_imp_le)"], ["", "no_notation floor (\"\\<lfloor>_\\<rfloor>\")"], ["", "notation Some (\"(\\<lfloor>_\\<rfloor>)\")"], ["", "(*<*)"], ["", "declare\n option.splits[split]\n Let_def[simp]\n subset_insertI2 [simp]"], ["", "(*>*)"], ["", "declare not_Cons_self [no_atp]"], ["", "lemma Option_bind_eq_None_conv:\n  \"x \\<bind> y = None \\<longleftrightarrow> x = None \\<or> (\\<exists>x'. x = Some x' \\<and> y x' = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<bind> y = None) =\n    (x = None \\<or>\n     (\\<exists>x'. x = \\<lfloor>x'\\<rfloor> \\<and> y x' = None))", "by(cases x) simp_all"], ["", "lemma Option_bind_eq_Some_conv:\n  \"x \\<bind> y = Some z \\<longleftrightarrow> (\\<exists>x'. x = Some x' \\<and> y x' = Some z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<bind> y = \\<lfloor>z\\<rfloor>) =\n    (\\<exists>x'.\n        x = \\<lfloor>x'\\<rfloor> \\<and> y x' = \\<lfloor>z\\<rfloor>)", "by(cases x) simp_all"], ["", "lemma map_upds_xchg_snd:\n  \"\\<lbrakk> length xs \\<le> length ys; length xs \\<le> length zs; \\<forall>i. i < length xs \\<longrightarrow> ys ! i = zs ! i \\<rbrakk>\n  \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>] zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> length ys; length xs \\<le> length zs;\n     \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n    \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>] zs)", "proof(induct xs arbitrary: ys zs f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys zs f.\n       \\<lbrakk>length [] \\<le> length ys; length [] \\<le> length zs;\n        \\<forall>i<length []. ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f([] [\\<mapsto>] ys) = f([] [\\<mapsto>] zs)\n 2. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "case Nil"], ["proof (state)\nthis:\n  length [] \\<le> length ys\n  length [] \\<le> length zs\n  \\<forall>i<length []. ys ! i = zs ! i\n\ngoal (2 subgoals):\n 1. \\<And>ys zs f.\n       \\<lbrakk>length [] \\<le> length ys; length [] \\<le> length zs;\n        \\<forall>i<length []. ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f([] [\\<mapsto>] ys) = f([] [\\<mapsto>] zs)\n 2. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "thus ?case"], ["proof (prove)\nusing this:\n  length [] \\<le> length ys\n  length [] \\<le> length zs\n  \\<forall>i<length []. ys ! i = zs ! i\n\ngoal (1 subgoal):\n 1. f([] [\\<mapsto>] ys) = f([] [\\<mapsto>] zs)", "by simp"], ["proof (state)\nthis:\n  f([] [\\<mapsto>] ys) = f([] [\\<mapsto>] zs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>length xs \\<le> length ?ys; length xs \\<le> length ?zs;\n   \\<forall>i<length xs. ?ys ! i = ?zs ! i\\<rbrakk>\n  \\<Longrightarrow> ?f(xs [\\<mapsto>] ?ys) = ?f(xs [\\<mapsto>] ?zs)\n  length (x # xs) \\<le> length ys\n  length (x # xs) \\<le> length zs\n  \\<forall>i<length (x # xs). ys ! i = zs ! i\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "note IH = \\<open>\\<And>f ys zs. \\<lbrakk> length xs \\<le> length ys; length xs \\<le> length zs; \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n             \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>] zs)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>length xs \\<le> length ?ys; length xs \\<le> length ?zs;\n   \\<forall>i<length xs. ?ys ! i = ?zs ! i\\<rbrakk>\n  \\<Longrightarrow> ?f(xs [\\<mapsto>] ?ys) = ?f(xs [\\<mapsto>] ?zs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "note leny = \\<open>length (x # xs) \\<le> length ys\\<close>"], ["proof (state)\nthis:\n  length (x # xs) \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "note lenz = \\<open>length (x # xs) \\<le> length zs\\<close>"], ["proof (state)\nthis:\n  length (x # xs) \\<le> length zs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "note nth = \\<open>\\<forall>i<length (x # xs). ys ! i = zs ! i\\<close>"], ["proof (state)\nthis:\n  \\<forall>i<length (x # xs). ys ! i = zs ! i\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "from lenz"], ["proof (chain)\npicking this:\n  length (x # xs) \\<le> length zs", "obtain z zs' where zs [simp]: \"zs = z # zs'\""], ["proof (prove)\nusing this:\n  length (x # xs) \\<le> length zs\n\ngoal (1 subgoal):\n 1. (\\<And>z zs'. zs = z # zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases zs, auto)"], ["proof (state)\nthis:\n  zs = z # zs'\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "from leny"], ["proof (chain)\npicking this:\n  length (x # xs) \\<le> length ys", "obtain y ys' where ys [simp]: \"ys = y # ys'\""], ["proof (prove)\nusing this:\n  length (x # xs) \\<le> length ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'. ys = y # ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ys, auto)"], ["proof (state)\nthis:\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "from lenz leny nth"], ["proof (chain)\npicking this:\n  length (x # xs) \\<le> length zs\n  length (x # xs) \\<le> length ys\n  \\<forall>i<length (x # xs). ys ! i = zs ! i", "have \"(f(x \\<mapsto> y))(xs [\\<mapsto>] ys') = (f(x \\<mapsto> y))(xs [\\<mapsto>] zs')\""], ["proof (prove)\nusing this:\n  length (x # xs) \\<le> length zs\n  length (x # xs) \\<le> length ys\n  \\<forall>i<length (x # xs). ys ! i = zs ! i\n\ngoal (1 subgoal):\n 1. f(x \\<mapsto> y, xs [\\<mapsto>] ys') = f(x \\<mapsto> y, xs [\\<mapsto>]\n    zs')", "by-(rule IH, auto)"], ["proof (state)\nthis:\n  f(x \\<mapsto> y, xs [\\<mapsto>] ys') = f(x \\<mapsto> y, xs [\\<mapsto>]\n  zs')\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "moreover"], ["proof (state)\nthis:\n  f(x \\<mapsto> y, xs [\\<mapsto>] ys') = f(x \\<mapsto> y, xs [\\<mapsto>]\n  zs')\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "from nth"], ["proof (chain)\npicking this:\n  \\<forall>i<length (x # xs). ys ! i = zs ! i", "have \"y = z\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (x # xs). ys ! i = zs ! i\n\ngoal (1 subgoal):\n 1. y = z", "by auto"], ["proof (state)\nthis:\n  y = z\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs f.\n       \\<lbrakk>\\<And>ys zs f.\n                   \\<lbrakk>length xs \\<le> length ys;\n                    length xs \\<le> length zs;\n                    \\<forall>i<length xs. ys ! i = zs ! i\\<rbrakk>\n                   \\<Longrightarrow> f(xs [\\<mapsto>] ys) = f(xs [\\<mapsto>]\n                                     zs);\n        length (a # xs) \\<le> length ys; length (a # xs) \\<le> length zs;\n        \\<forall>i<length (a # xs). ys ! i = zs ! i\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [\\<mapsto>] ys) = f(a # xs [\\<mapsto>] zs)", "ultimately"], ["proof (chain)\npicking this:\n  f(x \\<mapsto> y, xs [\\<mapsto>] ys') = f(x \\<mapsto> y, xs [\\<mapsto>]\n  zs')\n  y = z", "show ?case"], ["proof (prove)\nusing this:\n  f(x \\<mapsto> y, xs [\\<mapsto>] ys') = f(x \\<mapsto> y, xs [\\<mapsto>]\n  zs')\n  y = z\n\ngoal (1 subgoal):\n 1. f(x # xs [\\<mapsto>] ys) = f(x # xs [\\<mapsto>] zs)", "by(simp add: map_upds_def)"], ["proof (state)\nthis:\n  f(x # xs [\\<mapsto>] ys) = f(x # xs [\\<mapsto>] zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\<open>distinct_fst\\<close>\\<close>"], ["", "definition\n  distinct_fst  :: \"('a \\<times> 'b) list \\<Rightarrow> bool\"\nwhere\n  \"distinct_fst  \\<equiv>  distinct \\<circ> map fst\""], ["", "lemma distinct_fst_Nil [simp]:\n  \"distinct_fst []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst []", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst []", "apply (unfold distinct_fst_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct \\<circ> map fst) []", "apply (simp (no_asm))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma distinct_fst_Cons [simp]:\n  \"distinct_fst ((k,x)#kxs) = (distinct_fst kxs \\<and> (\\<forall>y. (k,y) \\<notin> set kxs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst ((k, x) # kxs) =\n    (distinct_fst kxs \\<and> (\\<forall>y. (k, y) \\<notin> set kxs))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst ((k, x) # kxs) =\n    (distinct_fst kxs \\<and> (\\<forall>y. (k, y) \\<notin> set kxs))", "apply (unfold distinct_fst_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct \\<circ> map fst) ((k, x) # kxs) =\n    ((distinct \\<circ> map fst) kxs \\<and>\n     (\\<forall>y. (k, y) \\<notin> set kxs))", "apply (auto simp:image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma distinct_fstD: \"\\<lbrakk> distinct_fst xs; (x, y) \\<in> set xs; (x, z) \\<in> set xs \\<rbrakk> \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_fst xs; (x, y) \\<in> set xs;\n     (x, z) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> y = z", "by(induct xs) auto"], ["", "lemma map_of_SomeI:\n  \"\\<lbrakk> distinct_fst kxs; (k,x) \\<in> set kxs \\<rbrakk> \\<Longrightarrow> map_of kxs k = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_fst kxs; (k, x) \\<in> set kxs\\<rbrakk>\n    \\<Longrightarrow> map_of kxs k = \\<lfloor>x\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_fst kxs; (k, x) \\<in> set kxs\\<rbrakk>\n    \\<Longrightarrow> map_of kxs k = \\<lfloor>x\\<rfloor>", "by (induct kxs) (auto simp:fun_upd_apply)"], ["", "(*>*)"], ["", "lemma rel_option_Some1:\n  \"rel_option R (Some x) y \\<longleftrightarrow> (\\<exists>y'. y = Some y' \\<and> R x y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option R \\<lfloor>x\\<rfloor> y =\n    (\\<exists>y'. y = \\<lfloor>y'\\<rfloor> \\<and> R x y')", "by(cases y) simp_all"], ["", "lemma rel_option_Some2:\n  \"rel_option R x (Some y) \\<longleftrightarrow> (\\<exists>x'. x = Some x' \\<and> R x' y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option R x \\<lfloor>y\\<rfloor> =\n    (\\<exists>x'. x = \\<lfloor>x'\\<rfloor> \\<and> R x' y)", "by(cases x) simp_all"], ["", "subsection \\<open>Using @{term list_all2} for relations\\<close>"], ["", "definition\n  fun_of :: \"('a \\<times> 'b) set \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> bool\"\nwhere\n  \"fun_of S \\<equiv> \\<lambda>x y. (x,y) \\<in> S\""], ["", "text \\<open>Convenience lemmas\\<close>"], ["", "(*<*)"], ["", "declare fun_of_def [simp]"], ["", "(*>*)"], ["", "lemma rel_list_all2_Cons [iff]:\n  \"list_all2 (fun_of S) (x#xs) (y#ys) = \n   ((x,y) \\<in> S \\<and> list_all2 (fun_of S) xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (fun_of S) (x # xs) (y # ys) =\n    ((x, y) \\<in> S \\<and> list_all2 (fun_of S) xs ys)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (fun_of S) (x # xs) (y # ys) =\n    ((x, y) \\<in> S \\<and> list_all2 (fun_of S) xs ys)", "by simp"], ["", "(*>*)"], ["", "lemma rel_list_all2_Cons1:\n  \"list_all2 (fun_of S) (x#xs) ys = \n  (\\<exists>z zs. ys = z#zs \\<and> (x,z) \\<in> S \\<and> list_all2 (fun_of S) xs zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (fun_of S) (x # xs) ys =\n    (\\<exists>z zs.\n        ys = z # zs \\<and> (x, z) \\<in> S \\<and> list_all2 (fun_of S) xs zs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (fun_of S) (x # xs) ys =\n    (\\<exists>z zs.\n        ys = z # zs \\<and> (x, z) \\<in> S \\<and> list_all2 (fun_of S) xs zs)", "by (cases ys) auto"], ["", "(*>*)"], ["", "lemma rel_list_all2_Cons2:\n  \"list_all2 (fun_of S) xs (y#ys) = \n  (\\<exists>z zs. xs = z#zs \\<and> (z,y) \\<in> S \\<and> list_all2 (fun_of S) zs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (fun_of S) xs (y # ys) =\n    (\\<exists>z zs.\n        xs = z # zs \\<and> (z, y) \\<in> S \\<and> list_all2 (fun_of S) zs ys)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (fun_of S) xs (y # ys) =\n    (\\<exists>z zs.\n        xs = z # zs \\<and> (z, y) \\<in> S \\<and> list_all2 (fun_of S) zs ys)", "by (cases xs) auto"], ["", "(*>*)"], ["", "lemma rel_list_all2_refl:\n  \"(\\<And>x. (x,x) \\<in> S) \\<Longrightarrow> list_all2 (fun_of S) xs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (x, x) \\<in> S) \\<Longrightarrow> list_all2 (fun_of S) xs xs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (x, x) \\<in> S) \\<Longrightarrow> list_all2 (fun_of S) xs xs", "by (simp add: list_all2_refl)"], ["", "(*>*)"], ["", "lemma rel_list_all2_antisym:\n  \"\\<lbrakk> (\\<And>x y. \\<lbrakk>(x,y) \\<in> S; (y,x) \\<in> T\\<rbrakk> \\<Longrightarrow> x = y); \n     list_all2 (fun_of S) xs ys; list_all2 (fun_of T) ys xs \\<rbrakk> \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                \\<lbrakk>(x, y) \\<in> S; (y, x) \\<in> T\\<rbrakk>\n                \\<Longrightarrow> x = y;\n     list_all2 (fun_of S) xs ys; list_all2 (fun_of T) ys xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                \\<lbrakk>(x, y) \\<in> S; (y, x) \\<in> T\\<rbrakk>\n                \\<Longrightarrow> x = y;\n     list_all2 (fun_of S) xs ys; list_all2 (fun_of T) ys xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "by (rule list_all2_antisym) auto"], ["", "(*>*)"], ["", "lemma rel_list_all2_trans: \n  \"\\<lbrakk> \\<And>a b c. \\<lbrakk>(a,b) \\<in> R; (b,c) \\<in> S\\<rbrakk> \\<Longrightarrow> (a,c) \\<in> T;\n    list_all2 (fun_of R) as bs; list_all2 (fun_of S) bs cs\\<rbrakk> \n  \\<Longrightarrow> list_all2 (fun_of T) as cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a b c.\n                \\<lbrakk>(a, b) \\<in> R; (b, c) \\<in> S\\<rbrakk>\n                \\<Longrightarrow> (a, c) \\<in> T;\n     list_all2 (fun_of R) as bs; list_all2 (fun_of S) bs cs\\<rbrakk>\n    \\<Longrightarrow> list_all2 (fun_of T) as cs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a b c.\n                \\<lbrakk>(a, b) \\<in> R; (b, c) \\<in> S\\<rbrakk>\n                \\<Longrightarrow> (a, c) \\<in> T;\n     list_all2 (fun_of R) as bs; list_all2 (fun_of S) bs cs\\<rbrakk>\n    \\<Longrightarrow> list_all2 (fun_of T) as cs", "by (rule list_all2_trans) auto"], ["", "(*>*)"], ["", "lemma rel_list_all2_update_cong:\n  \"\\<lbrakk> i<size xs; list_all2 (fun_of S) xs ys; (x,y) \\<in> S \\<rbrakk> \n  \\<Longrightarrow> list_all2 (fun_of S) (xs[i:=x]) (ys[i:=y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; list_all2 (fun_of S) xs ys;\n     (x, y) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> list_all2 (fun_of S) (xs[i := x]) (ys[i := y])", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; list_all2 (fun_of S) xs ys;\n     (x, y) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> list_all2 (fun_of S) (xs[i := x]) (ys[i := y])", "by (simp add: list_all2_update_cong)"], ["", "(*>*)"], ["", "lemma rel_list_all2_nthD:\n  \"\\<lbrakk> list_all2 (fun_of S) xs ys; p < size xs \\<rbrakk> \\<Longrightarrow> (xs!p,ys!p) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 (fun_of S) xs ys; p < length xs\\<rbrakk>\n    \\<Longrightarrow> (xs ! p, ys ! p) \\<in> S", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 (fun_of S) xs ys; p < length xs\\<rbrakk>\n    \\<Longrightarrow> (xs ! p, ys ! p) \\<in> S", "by (drule list_all2_nthD) auto"], ["", "(*>*)"], ["", "lemma rel_list_all2I:\n  \"\\<lbrakk> length a = length b; \\<And>n. n < length a \\<Longrightarrow> (a!n,b!n) \\<in> S \\<rbrakk> \\<Longrightarrow> list_all2 (fun_of S) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b;\n     \\<And>n. n < length a \\<Longrightarrow> (a ! n, b ! n) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> list_all2 (fun_of S) a b", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length a = length b;\n     \\<And>n. n < length a \\<Longrightarrow> (a ! n, b ! n) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> list_all2 (fun_of S) a b", "by (erule list_all2_all_nthI) simp"], ["", "(*>*)\n\n(*<*)"], ["", "declare fun_of_def [simp del]"], ["", "(*>*)"], ["", "lemma list_all2_induct[consumes 1, case_names Nil Cons]:\n  assumes major: \"list_all2 P xs ys\"\n  and Nil: \"Q [] []\"\n  and Cons: \"\\<And>x xs y ys. \\<lbrakk> P x y; list_all2 P xs ys; Q xs ys \\<rbrakk> \\<Longrightarrow> Q (x # xs) (y # ys)\"\n  shows \"Q xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q xs ys", "using major"], ["proof (prove)\nusing this:\n  list_all2 P xs ys\n\ngoal (1 subgoal):\n 1. Q xs ys", "by(induct xs arbitrary: ys)(auto simp add: list_all2_Cons1 Nil intro!: Cons)"], ["", "lemma list_all2_split:\n  assumes major: \"list_all2 P xs ys\"\n  and split: \"\\<And>x y. P x y \\<Longrightarrow> \\<exists>z. Q x z \\<and> R z y\"\n  shows \"\\<exists>zs. list_all2 Q xs zs \\<and> list_all2 R zs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zs. list_all2 Q xs zs \\<and> list_all2 R zs ys", "using major"], ["proof (prove)\nusing this:\n  list_all2 P xs ys\n\ngoal (1 subgoal):\n 1. \\<exists>zs. list_all2 Q xs zs \\<and> list_all2 R zs ys", "by(induct rule: list_all2_induct)(auto dest: split)"], ["", "lemma list_all2_refl_conv:\n  \"list_all2 P xs xs \\<longleftrightarrow> (\\<forall>x\\<in>set xs. P x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 P xs xs = (\\<forall>x\\<in>set xs. P x x)", "unfolding list_all2_conv_all_nth Ball_def in_set_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = length xs \\<and>\n     (\\<forall>i<length xs. P (xs ! i) (xs ! i))) =\n    (\\<forall>x. (\\<exists>i<length xs. xs ! i = x) \\<longrightarrow> P x x)", "by auto"], ["", "lemma list_all2_op_eq [simp]:\n  \"list_all2 (=) xs ys \\<longleftrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (=) xs ys = (xs = ys)", "by(induct xs arbitrary: ys)(auto simp add: list_all2_Cons1)"], ["", "lemmas filter_replicate_conv = filter_replicate"], ["", "lemma length_greater_Suc_0_conv: \"Suc 0 < length xs \\<longleftrightarrow> (\\<exists>x x' xs'. xs = x # x' # xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc 0 < length xs) = (\\<exists>x x' xs'. xs = x # x' # xs')", "by(cases xs, auto simp add: neq_Nil_conv)"], ["", "lemmas zip_same_conv = zip_same_conv_map"], ["", "lemma nth_Cons_subtract: \"0 < n \\<Longrightarrow> (x # xs) ! n = xs ! (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> (x # xs) ! n = xs ! (n - 1)", "by(auto simp add: nth_Cons split: nat.split)"], ["", "lemma f_nth_set:\n  \"\\<lbrakk> f (xs ! n) = v; n < length xs \\<rbrakk> \\<Longrightarrow> v \\<in> f ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f (xs ! n) = v; n < length xs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> f ` set xs", "unfolding set_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f (xs ! n) = v; n < length xs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> f ` {xs ! i |i. i < length xs}", "by auto"], ["", "lemma nth_concat_eqI:\n  \"\\<lbrakk> n = sum_list (map length (take i xss)) + k; i < length xss; k < length (xss ! i); x = xss ! i ! k \\<rbrakk>\n  \\<Longrightarrow> concat xss ! n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = sum_list (map length (take i xss)) + k; i < length xss;\n     k < length (xss ! i); x = xss ! i ! k\\<rbrakk>\n    \\<Longrightarrow> concat xss ! n = x", "apply(induct xss arbitrary: n i k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n i k.\n       \\<lbrakk>n = sum_list (map length (take i [])) + k; i < length [];\n        k < length ([] ! i); x = [] ! i ! k\\<rbrakk>\n       \\<Longrightarrow> concat [] ! n = x\n 2. \\<And>a xss n i k.\n       \\<lbrakk>\\<And>n i k.\n                   \\<lbrakk>n = sum_list (map length (take i xss)) + k;\n                    i < length xss; k < length (xss ! i);\n                    x = xss ! i ! k\\<rbrakk>\n                   \\<Longrightarrow> concat xss ! n = x;\n        n = sum_list (map length (take i (a # xss))) + k;\n        i < length (a # xss); k < length ((a # xss) ! i);\n        x = (a # xss) ! i ! k\\<rbrakk>\n       \\<Longrightarrow> concat (a # xss) ! n = x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss n i k.\n       \\<lbrakk>\\<And>n i k.\n                   \\<lbrakk>n = sum_list (map length (take i xss)) + k;\n                    i < length xss; k < length (xss ! i);\n                    x = xss ! i ! k\\<rbrakk>\n                   \\<Longrightarrow> concat xss ! n = x;\n        n = sum_list (map length (take i (a # xss))) + k;\n        i < length (a # xss); k < length ((a # xss) ! i);\n        x = (a # xss) ! i ! k\\<rbrakk>\n       \\<Longrightarrow> concat (a # xss) ! n = x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss n i k.\n       \\<lbrakk>\\<And>n ia ka.\n                   \\<lbrakk>n = sum_list (map length (take ia xss)) + ka;\n                    ia < length xss; ka < length (xss ! ia);\n                    (a # xss) ! i ! k = xss ! ia ! ka\\<rbrakk>\n                   \\<Longrightarrow> concat xss !\n                                     (sum_list (map length (take ia xss)) +\nka) =\n                                     xss ! ia ! ka;\n        n = sum_list (map length (take i (a # xss))) + k;\n        i < Suc (length xss); k < length ((a # xss) ! i);\n        x = (a # xss) ! i ! k\\<rbrakk>\n       \\<Longrightarrow> (a @ concat xss) !\n                         (sum_list (map length (take i (a # xss))) + k) =\n                         (a # xss) ! i ! k", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xss n i k.\n       \\<lbrakk>\\<And>n ia ka.\n                   \\<lbrakk>n = sum_list (map length (take ia xss)) + ka;\n                    ia < length xss; ka < length (xss ! ia);\n                    (a # xss) ! i ! k = xss ! ia ! ka\\<rbrakk>\n                   \\<Longrightarrow> concat xss !\n                                     (sum_list (map length (take ia xss)) +\nka) =\n                                     xss ! ia ! ka;\n        n = sum_list (map length (take i (a # xss))) + k;\n        i < Suc (length xss); k < length ((a # xss) ! i);\n        x = (a # xss) ! i ! k; i = 0\\<rbrakk>\n       \\<Longrightarrow> (a @ concat xss) !\n                         (sum_list (map length (take i (a # xss))) + k) =\n                         (a # xss) ! i ! k\n 2. \\<And>a xss n i k nat.\n       \\<lbrakk>\\<And>n ia ka.\n                   \\<lbrakk>n = sum_list (map length (take ia xss)) + ka;\n                    ia < length xss; ka < length (xss ! ia);\n                    (a # xss) ! i ! k = xss ! ia ! ka\\<rbrakk>\n                   \\<Longrightarrow> concat xss !\n                                     (sum_list (map length (take ia xss)) +\nka) =\n                                     xss ! ia ! ka;\n        n = sum_list (map length (take i (a # xss))) + k;\n        i < Suc (length xss); k < length ((a # xss) ! i);\n        x = (a # xss) ! i ! k; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (a @ concat xss) !\n                         (sum_list (map length (take i (a # xss))) + k) =\n                         (a # xss) ! i ! k", "apply(simp add: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss n i k nat.\n       \\<lbrakk>\\<And>n ia ka.\n                   \\<lbrakk>n = sum_list (map length (take ia xss)) + ka;\n                    ia < length xss; ka < length (xss ! ia);\n                    (a # xss) ! i ! k = xss ! ia ! ka\\<rbrakk>\n                   \\<Longrightarrow> concat xss !\n                                     (sum_list (map length (take ia xss)) +\nka) =\n                                     xss ! ia ! ka;\n        n = sum_list (map length (take i (a # xss))) + k;\n        i < Suc (length xss); k < length ((a # xss) ! i);\n        x = (a # xss) ! i ! k; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (a @ concat xss) !\n                         (sum_list (map length (take i (a # xss))) + k) =\n                         (a # xss) ! i ! k", "apply(simp add: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma replicate_eq_append_conv: \n  \"(replicate n x = xs @ ys) = (\\<exists>m\\<le>n. xs = replicate m x \\<and> ys = replicate (n-m) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate n x = xs @ ys) =\n    (\\<exists>m\\<le>n. xs = replicate m x \\<and> ys = replicate (n - m) x)", "proof(induct n arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       (replicate 0 x = xs @ ys) =\n       (\\<exists>m\\<le>0.\n           xs = replicate m x \\<and> ys = replicate (0 - m) x)\n 2. \\<And>n xs ys.\n       (\\<And>xs ys.\n           (replicate n x = xs @ ys) =\n           (\\<exists>m\\<le>n.\n               xs = replicate m x \\<and>\n               ys = replicate (n - m) x)) \\<Longrightarrow>\n       (replicate (Suc n) x = xs @ ys) =\n       (\\<exists>m\\<le>Suc n.\n           xs = replicate m x \\<and> ys = replicate (Suc n - m) x)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       (replicate 0 x = xs @ ys) =\n       (\\<exists>m\\<le>0.\n           xs = replicate m x \\<and> ys = replicate (0 - m) x)\n 2. \\<And>n xs ys.\n       (\\<And>xs ys.\n           (replicate n x = xs @ ys) =\n           (\\<exists>m\\<le>n.\n               xs = replicate m x \\<and>\n               ys = replicate (n - m) x)) \\<Longrightarrow>\n       (replicate (Suc n) x = xs @ ys) =\n       (\\<exists>m\\<le>Suc n.\n           xs = replicate m x \\<and> ys = replicate (Suc n - m) x)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate 0 x = xs @ ys) =\n    (\\<exists>m\\<le>0. xs = replicate m x \\<and> ys = replicate (0 - m) x)", "by simp"], ["proof (state)\nthis:\n  (replicate 0 x = xs @ ys) =\n  (\\<exists>m\\<le>0. xs = replicate m x \\<and> ys = replicate (0 - m) x)\n\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       (\\<And>xs ys.\n           (replicate n x = xs @ ys) =\n           (\\<exists>m\\<le>n.\n               xs = replicate m x \\<and>\n               ys = replicate (n - m) x)) \\<Longrightarrow>\n       (replicate (Suc n) x = xs @ ys) =\n       (\\<exists>m\\<le>Suc n.\n           xs = replicate m x \\<and> ys = replicate (Suc n - m) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       (\\<And>xs ys.\n           (replicate n x = xs @ ys) =\n           (\\<exists>m\\<le>n.\n               xs = replicate m x \\<and>\n               ys = replicate (n - m) x)) \\<Longrightarrow>\n       (replicate (Suc n) x = xs @ ys) =\n       (\\<exists>m\\<le>Suc n.\n           xs = replicate m x \\<and> ys = replicate (Suc n - m) x)", "case (Suc n xs ys)"], ["proof (state)\nthis:\n  (replicate n x = ?xs @ ?ys) =\n  (\\<exists>m\\<le>n. ?xs = replicate m x \\<and> ?ys = replicate (n - m) x)\n\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       (\\<And>xs ys.\n           (replicate n x = xs @ ys) =\n           (\\<exists>m\\<le>n.\n               xs = replicate m x \\<and>\n               ys = replicate (n - m) x)) \\<Longrightarrow>\n       (replicate (Suc n) x = xs @ ys) =\n       (\\<exists>m\\<le>Suc n.\n           xs = replicate m x \\<and> ys = replicate (Suc n - m) x)", "have IH: \"\\<And>xs ys. (replicate n x = xs @ ys) = (\\<exists>m\\<le>n. xs = replicate m x \\<and> ys = replicate (n - m) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (replicate n x = xs @ ys) =\n       (\\<exists>m\\<le>n.\n           xs = replicate m x \\<and> ys = replicate (n - m) x)", "by fact"], ["proof (state)\nthis:\n  (replicate n x = ?xs @ ?ys) =\n  (\\<exists>m\\<le>n. ?xs = replicate m x \\<and> ?ys = replicate (n - m) x)\n\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       (\\<And>xs ys.\n           (replicate n x = xs @ ys) =\n           (\\<exists>m\\<le>n.\n               xs = replicate m x \\<and>\n               ys = replicate (n - m) x)) \\<Longrightarrow>\n       (replicate (Suc n) x = xs @ ys) =\n       (\\<exists>m\\<le>Suc n.\n           xs = replicate m x \\<and> ys = replicate (Suc n - m) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate (Suc n) x = xs @ ys) =\n    (\\<exists>m\\<le>Suc n.\n        xs = replicate m x \\<and> ys = replicate (Suc n - m) x)", "proof(unfold replicate_Suc, rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x # replicate n x = xs @ ys \\<Longrightarrow>\n    \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n 2. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and>\n       ys = replicate (Suc n - m) x \\<Longrightarrow>\n    x # replicate n x = xs @ ys", "assume a: \"x # replicate n x = xs @ ys\""], ["proof (state)\nthis:\n  x # replicate n x = xs @ ys\n\ngoal (2 subgoals):\n 1. x # replicate n x = xs @ ys \\<Longrightarrow>\n    \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n 2. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and>\n       ys = replicate (Suc n - m) x \\<Longrightarrow>\n    x # replicate n x = xs @ ys", "show \"\\<exists>m\\<le>Suc n. xs = replicate m x \\<and> ys = replicate (Suc n - m) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>m\\<le>Suc n.\n          xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>m\\<le>Suc n.\n          xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "using a"], ["proof (prove)\nusing this:\n  xs = []\n  x # replicate n x = xs @ ys\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>m\\<le>Suc n.\n     xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>m\\<le>Suc n.\n          xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>m\\<le>Suc n.\n          xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "case (Cons X XS)"], ["proof (state)\nthis:\n  xs = X # XS\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>m\\<le>Suc n.\n          xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "with a"], ["proof (chain)\npicking this:\n  x # replicate n x = xs @ ys\n  xs = X # XS", "have x: \"x = X\" and \"replicate n x = XS @ ys\""], ["proof (prove)\nusing this:\n  x # replicate n x = xs @ ys\n  xs = X # XS\n\ngoal (1 subgoal):\n 1. x = X &&& replicate n x = XS @ ys", "by auto"], ["proof (state)\nthis:\n  x = X\n  replicate n x = XS @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>m\\<le>Suc n.\n          xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "hence \"\\<exists>m\\<le>n. XS = replicate m x \\<and> ys = replicate (n - m) x\""], ["proof (prove)\nusing this:\n  x = X\n  replicate n x = XS @ ys\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n. XS = replicate m x \\<and> ys = replicate (n - m) x", "by -(rule IH[THEN iffD1])"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n. XS = replicate m x \\<and> ys = replicate (n - m) x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>m\\<le>Suc n.\n          xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "then"], ["proof (chain)\npicking this:\n  \\<exists>m\\<le>n. XS = replicate m x \\<and> ys = replicate (n - m) x", "obtain m where \"m \\<le> n\" and XS: \"XS = replicate m x\" and ys: \"ys = replicate (n - m) x\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<le>n. XS = replicate m x \\<and> ys = replicate (n - m) x\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<le> n; XS = replicate m x;\n         ys = replicate (n - m) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m \\<le> n\n  XS = replicate m x\n  ys = replicate (n - m) x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>m\\<le>Suc n.\n          xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "with x Cons"], ["proof (chain)\npicking this:\n  x = X\n  xs = X # XS\n  m \\<le> n\n  XS = replicate m x\n  ys = replicate (n - m) x", "show ?thesis"], ["proof (prove)\nusing this:\n  x = X\n  xs = X # XS\n  m \\<le> n\n  XS = replicate m x\n  ys = replicate (n - m) x\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "by(fastforce)"], ["proof (state)\nthis:\n  \\<exists>m\\<le>Suc n.\n     xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m\\<le>Suc n.\n     xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and>\n       ys = replicate (Suc n - m) x \\<Longrightarrow>\n    x # replicate n x = xs @ ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and>\n       ys = replicate (Suc n - m) x \\<Longrightarrow>\n    x # replicate n x = xs @ ys", "assume \"\\<exists>m\\<le>Suc n. xs = replicate m x \\<and> ys = replicate (Suc n - m) x\""], ["proof (state)\nthis:\n  \\<exists>m\\<le>Suc n.\n     xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and>\n       ys = replicate (Suc n - m) x \\<Longrightarrow>\n    x # replicate n x = xs @ ys", "then"], ["proof (chain)\npicking this:\n  \\<exists>m\\<le>Suc n.\n     xs = replicate m x \\<and> ys = replicate (Suc n - m) x", "obtain m where m: \"m \\<le> Suc n\" and xs: \"xs = replicate m x\" and ys: \"ys = replicate (Suc n - m) x\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<le>Suc n.\n     xs = replicate m x \\<and> ys = replicate (Suc n - m) x\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<le> Suc n; xs = replicate m x;\n         ys = replicate (Suc n - m) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m \\<le> Suc n\n  xs = replicate m x\n  ys = replicate (Suc n - m) x\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>Suc n.\n       xs = replicate m x \\<and>\n       ys = replicate (Suc n - m) x \\<Longrightarrow>\n    x # replicate n x = xs @ ys", "thus \"x # replicate n x = xs @ ys\""], ["proof (prove)\nusing this:\n  m \\<le> Suc n\n  xs = replicate m x\n  ys = replicate (Suc n - m) x\n\ngoal (1 subgoal):\n 1. x # replicate n x = xs @ ys", "by(simp add: replicate_add[THEN sym])"], ["proof (state)\nthis:\n  x # replicate n x = xs @ ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (replicate (Suc n) x = xs @ ys) =\n  (\\<exists>m\\<le>Suc n.\n      xs = replicate m x \\<and> ys = replicate (Suc n - m) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replicate_Suc_snoc:\n  \"replicate (Suc n) x = replicate n x @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (Suc n) x = replicate n x @ [x]", "by (metis replicate_Suc replicate_append_same)"], ["", "lemma map_eq_append_conv:\n  \"map f xs = ys @ zs \\<longleftrightarrow> (\\<exists>ys' zs'. map f ys' = ys \\<and> map f zs' = zs \\<and> xs = ys' @ zs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = ys @ zs) =\n    (\\<exists>ys' zs'.\n        map f ys' = ys \\<and> map f zs' = zs \\<and> xs = ys' @ zs')", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map f xs = ys @ zs \\<Longrightarrow>\n    \\<exists>ys' zs'.\n       map f ys' = ys \\<and> map f zs' = zs \\<and> xs = ys' @ zs'\n 2. \\<exists>ys' zs'.\n       map f ys' = ys \\<and>\n       map f zs' = zs \\<and> xs = ys' @ zs' \\<Longrightarrow>\n    map f xs = ys @ zs", "apply(metis append_eq_conv_conj append_take_drop_id drop_map take_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys' zs'.\n       map f ys' = ys \\<and>\n       map f zs' = zs \\<and> xs = ys' @ zs' \\<Longrightarrow>\n    map f xs = ys @ zs", "by(clarsimp)"], ["", "lemma append_eq_map_conv:\n  \"ys @ zs = map f xs \\<longleftrightarrow> (\\<exists>ys' zs'. map f ys' = ys \\<and> map f zs' = zs \\<and> xs = ys' @ zs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys @ zs = map f xs) =\n    (\\<exists>ys' zs'.\n        map f ys' = ys \\<and> map f zs' = zs \\<and> xs = ys' @ zs')", "unfolding map_eq_append_conv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys @ zs = map f xs) = (map f xs = ys @ zs)", "by auto"], ["", "lemma map_eq_map_conv:\n  \"map f xs = map g ys \\<longleftrightarrow> list_all2 (\\<lambda>x y. f x = g y) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = map g ys) = list_all2 (\\<lambda>x y. f x = g y) xs ys", "apply(induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (map f [] = map g ys) = list_all2 (\\<lambda>x y. f x = g y) [] ys\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           (map f xs = map g ys) =\n           list_all2 (\\<lambda>x y. f x = g y) xs ys) \\<Longrightarrow>\n       (map f (a # xs) = map g ys) =\n       list_all2 (\\<lambda>x y. f x = g y) (a # xs) ys", "apply(auto simp add: list_all2_Cons1 Cons_eq_map_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_eq_all_nth_conv:\n  \"map f xs = ys \\<longleftrightarrow> length xs = length ys \\<and> (\\<forall>n < length xs. f (xs ! n) = ys ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = ys) =\n    (length xs = length ys \\<and>\n     (\\<forall>n<length xs. f (xs ! n) = ys ! n))", "apply(induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (map f [] = ys) =\n       (length [] = length ys \\<and>\n        (\\<forall>n<length []. f ([] ! n) = ys ! n))\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           (map f xs = ys) =\n           (length xs = length ys \\<and>\n            (\\<forall>n<length xs. f (xs ! n) = ys ! n))) \\<Longrightarrow>\n       (map f (a # xs) = ys) =\n       (length (a # xs) = length ys \\<and>\n        (\\<forall>n<length (a # xs). f ((a # xs) ! n) = ys ! n))", "apply(fastforce simp add: nth_Cons Suc_length_conv split: nat.splits)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_eq_take_le_eq:\n  \"\\<lbrakk> take n xs = take n ys; m \\<le> n \\<rbrakk> \\<Longrightarrow> take m xs = take m ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take n xs = take n ys; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> take m xs = take m ys", "by(metis min.absorb_iff1 take_take)"], ["", "lemma take_list_update_beyond:\n  \"n \\<le> m \\<Longrightarrow> take n (xs[m := x]) = take n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> take n (xs[m := x]) = take n xs", "by(cases \"n \\<le> length xs\")(rule nth_take_lemma, simp_all)"], ["", "lemma hd_drop_conv_nth:\n  \"n < length xs \\<Longrightarrow> hd (drop n xs) = xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow> hd (drop n xs) = xs ! n", "by(rule hd_drop_conv_nth) (metis list.size(3) not_less0)"], ["", "lemma set_tl_subset: \"set (tl xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (tl xs) \\<subseteq> set xs", "by(cases xs) auto"], ["", "lemma tl_conv_drop: \"tl xs = drop 1 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl xs = drop 1 xs", "by(cases xs) simp_all"], ["", "lemma takeWhile_eq_Nil_dropWhile_eq_Nil_imp_Nil:\n  \"\\<lbrakk> takeWhile P xs = []; dropWhile P xs = [] \\<rbrakk> \\<Longrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>takeWhile P xs = []; dropWhile P xs = []\\<rbrakk>\n    \\<Longrightarrow> xs = []", "by (metis dropWhile_eq_drop drop_0 list.size(3))"], ["", "lemma takeWhile_eq_Nil_conv:\n  \"takeWhile P xs = [] \\<longleftrightarrow> (xs = [] \\<or> \\<not> P (hd xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (takeWhile P xs = []) = (xs = [] \\<or> \\<not> P (hd xs))", "by(cases xs) simp_all"], ["", "lemma dropWhile_append1': \"dropWhile P xs \\<noteq> [] \\<Longrightarrow> dropWhile P (xs @ ys) = dropWhile P xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dropWhile P xs \\<noteq> [] \\<Longrightarrow>\n    dropWhile P (xs @ ys) = dropWhile P xs @ ys", "by(cases xs) auto"], ["", "lemma dropWhile_append2': \"dropWhile P xs = [] \\<Longrightarrow> dropWhile P (xs @ ys) = dropWhile P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dropWhile P xs = [] \\<Longrightarrow>\n    dropWhile P (xs @ ys) = dropWhile P ys", "by(simp)"], ["", "lemma takeWhile_append1': \"dropWhile P xs \\<noteq> [] \\<Longrightarrow> takeWhile P (xs @ ys) = takeWhile P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dropWhile P xs \\<noteq> [] \\<Longrightarrow>\n    takeWhile P (xs @ ys) = takeWhile P xs", "by auto"], ["", "lemma takeWhile_takeWhile: \"takeWhile P (takeWhile Q xs) = takeWhile (\\<lambda>x. P x \\<and> Q x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takeWhile P (takeWhile Q xs) = takeWhile (\\<lambda>x. P x \\<and> Q x) xs", "by(induct xs) simp_all"], ["", "lemma dropWhile_eq_ConsD:\n  \"dropWhile P xs = y # ys \\<Longrightarrow> y \\<in> set xs \\<and> \\<not> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dropWhile P xs = y # ys \\<Longrightarrow>\n    y \\<in> set xs \\<and> \\<not> P y", "by(induct xs)(auto split: if_split_asm)"], ["", "lemma dropWhile_eq_hd_conv: \"dropWhile P xs = hd xs # rest \\<longleftrightarrow> xs \\<noteq> [] \\<and> rest = tl xs \\<and> \\<not> P (hd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dropWhile P xs = hd xs # rest) =\n    (xs \\<noteq> [] \\<and> rest = tl xs \\<and> \\<not> P (hd xs))", "by (metis append_Nil append_is_Nil_conv dropWhile_eq_Cons_conv list.sel(1) neq_Nil_conv takeWhile_dropWhile_id takeWhile_eq_Nil_conv list.sel(3))"], ["", "lemma dropWhile_eq_same_conv: \"dropWhile P xs = xs \\<longleftrightarrow> (xs = [] \\<or> \\<not> P (hd xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dropWhile P xs = xs) = (xs = [] \\<or> \\<not> P (hd xs))", "by (metis dropWhile.simps(1) eq_Nil_appendI hd_dropWhile takeWhile_dropWhile_id takeWhile_eq_Nil_conv)"], ["", "lemma subset_code [code_unfold]:\n  \"set xs \\<subseteq> set ys \\<longleftrightarrow> (\\<forall>x \\<in> set xs. x \\<in> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs \\<subseteq> set ys) = (\\<forall>x\\<in>set xs. x \\<in> set ys)", "by(rule Set.subset_eq)"], ["", "lemma eval_bot [simp]:\n  \"Predicate.eval bot = (\\<lambda>_. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval bot = (\\<lambda>_. False)", "by(auto simp add: fun_eq_iff)"], ["", "lemma not_is_emptyE:\n  assumes \"\\<not> Predicate.is_empty P\"\n  obtains x where \"Predicate.eval P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. pred.eval P x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> Predicate.is_empty P\n\ngoal (1 subgoal):\n 1. (\\<And>x. pred.eval P x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: Predicate.is_empty_def bot_pred_def intro!: pred_iffI)"], ["", "lemma is_emptyD:\n  assumes \"Predicate.is_empty P\"\n  shows \"Predicate.eval P x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval P x \\<Longrightarrow> False", "using assms"], ["proof (prove)\nusing this:\n  Predicate.is_empty P\n\ngoal (1 subgoal):\n 1. pred.eval P x \\<Longrightarrow> False", "by(simp add: Predicate.is_empty_def bot_pred_def bot_apply Set.empty_def)"], ["", "lemma eval_bind_conv:\n  \"Predicate.eval (P \\<bind> R) y = (\\<exists>x. Predicate.eval P x \\<and> Predicate.eval (R x) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (P \\<bind> R) y =\n    (\\<exists>x. pred.eval P x \\<and> pred.eval (R x) y)", "by(blast elim: bindE intro: bindI)"], ["", "lemma eval_single_conv: \"Predicate.eval (Predicate.single a) b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (Predicate.single a) b = (a = b)", "by(blast intro: singleI elim: singleE)"], ["", "lemma conj_asm_conv_imp:\n  \"(A \\<and> B \\<Longrightarrow> PROP C) \\<equiv> (A \\<Longrightarrow> B \\<Longrightarrow> PROP C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<and> B \\<Longrightarrow> PROP C) \\<equiv>\n    (\\<lbrakk>A; B\\<rbrakk> \\<Longrightarrow> PROP C)", "apply(rule equal_intr_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<and> B \\<Longrightarrow> PROP C; A; B\\<rbrakk>\n    \\<Longrightarrow> PROP C\n 2. \\<lbrakk>\\<lbrakk>A; B\\<rbrakk> \\<Longrightarrow> PROP C;\n     A \\<and> B\\<rbrakk>\n    \\<Longrightarrow> PROP C", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A; B\\<rbrakk> \\<Longrightarrow> A \\<and> B\n 2. \\<lbrakk>\\<lbrakk>A; B\\<rbrakk> \\<Longrightarrow> PROP C;\n     A \\<and> B\\<rbrakk>\n    \\<Longrightarrow> PROP C", "apply(erule (1) conjI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>A; B\\<rbrakk> \\<Longrightarrow> PROP C;\n     A \\<and> B\\<rbrakk>\n    \\<Longrightarrow> PROP C", "apply(erule meta_impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<and> B \\<Longrightarrow> A\n 2. \\<lbrakk>A \\<and> B; B \\<Longrightarrow> PROP C\\<rbrakk>\n    \\<Longrightarrow> PROP C", "apply(erule conjunct1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<and> B; B \\<Longrightarrow> PROP C\\<rbrakk>\n    \\<Longrightarrow> PROP C", "apply(erule meta_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<and> B \\<Longrightarrow> B", "apply(erule conjunct2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meta_all_eq_conv: \"(\\<And>a. a = b \\<Longrightarrow> PROP P a) \\<equiv> PROP P b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. a = b \\<Longrightarrow> PROP P a) \\<equiv> PROP P b", "apply(rule equal_intr_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>a. a = b \\<Longrightarrow> PROP P a) \\<Longrightarrow> PROP P b\n 2. \\<And>a. \\<lbrakk>PROP P b; a = b\\<rbrakk> \\<Longrightarrow> PROP P a", "apply(erule meta_allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (?a3 = b \\<Longrightarrow> PROP P ?a3) \\<Longrightarrow> PROP P b\n 2. \\<And>a. \\<lbrakk>PROP P b; a = b\\<rbrakk> \\<Longrightarrow> PROP P a", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b = b\n 2. \\<And>a. \\<lbrakk>PROP P b; a = b\\<rbrakk> \\<Longrightarrow> PROP P a", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. \\<lbrakk>PROP P b; a = b\\<rbrakk> \\<Longrightarrow> PROP P a", "apply(hypsubst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. PROP P b \\<Longrightarrow> PROP P b", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meta_all_eq_conv2: \"(\\<And>a. b = a \\<Longrightarrow> PROP P a) \\<equiv> PROP P b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. b = a \\<Longrightarrow> PROP P a) \\<equiv> PROP P b", "apply(rule equal_intr_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>a. b = a \\<Longrightarrow> PROP P a) \\<Longrightarrow> PROP P b\n 2. \\<And>a. \\<lbrakk>PROP P b; b = a\\<rbrakk> \\<Longrightarrow> PROP P a", "apply(erule meta_allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (b = ?a3 \\<Longrightarrow> PROP P ?a3) \\<Longrightarrow> PROP P b\n 2. \\<And>a. \\<lbrakk>PROP P b; b = a\\<rbrakk> \\<Longrightarrow> PROP P a", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b = b\n 2. \\<And>a. \\<lbrakk>PROP P b; b = a\\<rbrakk> \\<Longrightarrow> PROP P a", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. \\<lbrakk>PROP P b; b = a\\<rbrakk> \\<Longrightarrow> PROP P a", "apply(hypsubst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. PROP P b \\<Longrightarrow> PROP P b", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma disj_split:\n  \"P (a \\<or> b) \\<longleftrightarrow> (a \\<longrightarrow> P True) \\<and> (b \\<longrightarrow> P True) \\<and> (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (a \\<or> b) =\n    ((a \\<longrightarrow> P True) \\<and>\n     (b \\<longrightarrow> P True) \\<and>\n     (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False))", "apply(cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<Longrightarrow>\n    P (a \\<or> b) =\n    ((a \\<longrightarrow> P True) \\<and>\n     (b \\<longrightarrow> P True) \\<and>\n     (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False))\n 2. \\<not> a \\<Longrightarrow>\n    P (a \\<or> b) =\n    ((a \\<longrightarrow> P True) \\<and>\n     (b \\<longrightarrow> P True) \\<and>\n     (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False))", "apply(case_tac [!] b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>a; b\\<rbrakk>\n    \\<Longrightarrow> P (a \\<or> b) =\n                      ((a \\<longrightarrow> P True) \\<and>\n                       (b \\<longrightarrow> P True) \\<and>\n                       (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False))\n 2. \\<lbrakk>a; \\<not> b\\<rbrakk>\n    \\<Longrightarrow> P (a \\<or> b) =\n                      ((a \\<longrightarrow> P True) \\<and>\n                       (b \\<longrightarrow> P True) \\<and>\n                       (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False))\n 3. \\<lbrakk>\\<not> a; b\\<rbrakk>\n    \\<Longrightarrow> P (a \\<or> b) =\n                      ((a \\<longrightarrow> P True) \\<and>\n                       (b \\<longrightarrow> P True) \\<and>\n                       (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False))\n 4. \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk>\n    \\<Longrightarrow> P (a \\<or> b) =\n                      ((a \\<longrightarrow> P True) \\<and>\n                       (b \\<longrightarrow> P True) \\<and>\n                       (\\<not> a \\<and> \\<not> b \\<longrightarrow> P False))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma disj_split_asm:\n  \"P (a \\<or> b) \\<longleftrightarrow> \\<not> (a \\<and> \\<not> P True \\<or> b \\<and> \\<not> P True \\<or> \\<not> a \\<and> \\<not> b \\<and> \\<not> P False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (a \\<or> b) =\n    (\\<not> (a \\<and> \\<not> P True \\<or>\n             b \\<and> \\<not> P True \\<or>\n             \\<not> a \\<and> \\<not> b \\<and> \\<not> P False))", "apply(auto simp add: disj_split[of P])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma disjCE:\n  assumes \"P \\<or> Q\"\n  obtains P | \"Q\" \"\\<not> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow> thesis;\n     \\<lbrakk>Q; \\<not> P\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  P \\<or> Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow> thesis;\n     \\<lbrakk>Q; \\<not> P\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["", "lemma case_option_conv_if:\n  \"(case v of None \\<Rightarrow> f | Some x \\<Rightarrow> g x) = (if \\<exists>a. v = Some a then g (the v) else f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case v of None \\<Rightarrow> f\n     | \\<lfloor>x\\<rfloor> \\<Rightarrow> g x) =\n    (if \\<exists>a. v = \\<lfloor>a\\<rfloor> then g (the v) else f)", "by(simp)"], ["", "lemma LetI: \"(\\<And>x. x = t \\<Longrightarrow> P x) \\<Longrightarrow> let x = t in P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x = t \\<Longrightarrow> P x) \\<Longrightarrow> Let t P", "by(simp)"], ["", "(* rearrange parameters and premises to allow application of one-point-rules *)\n(* adapted from Tools/induct.ML and Isabelle Developer Workshop 2010 *)"], ["", "simproc_setup rearrange_eqs (\"Pure.all t\") = \\<open>\nlet\n  fun swap_params_conv ctxt i j cv =\n    let\n      fun conv1 0 ctxt = Conv.forall_conv (cv o snd) ctxt\n        | conv1 k ctxt =\n            Conv.rewr_conv @{thm swap_params} then_conv\n            Conv.forall_conv (conv1 (k - 1) o snd) ctxt\n      fun conv2 0 ctxt = conv1 j ctxt\n        | conv2 k ctxt = Conv.forall_conv (conv2 (k - 1) o snd) ctxt\n    in conv2 i ctxt end;\n\n  fun swap_prems_conv 0 = Conv.all_conv\n    | swap_prems_conv i =\n        Conv.implies_concl_conv (swap_prems_conv (i - 1)) then_conv\n        Conv.rewr_conv Drule.swap_prems_eq;\n\n  fun find_eq ctxt t =\n    let\n      val l = length (Logic.strip_params t);\n      val Hs = Logic.strip_assums_hyp t;\n      fun find (i, (_ $ (Const (\"HOL.eq\", _) $ Bound j $ _))) = SOME (i, j)\n        | find (i, (_ $ (Const (\"HOL.eq\", _) $ _ $ Bound j))) = SOME (i, j)\n        | find _ = NONE\n    in\n      (case get_first find (map_index I Hs) of\n        NONE => NONE\n      | SOME (0, 0) => NONE\n      | SOME (i, j) => SOME (i, l - j - 1, j))\n    end;\n\n  fun mk_swap_rrule ctxt ct =\n    (case find_eq ctxt (Thm.term_of ct) of\n      NONE => NONE\n    | SOME (i, k, j) => SOME (swap_params_conv ctxt k j (K (swap_prems_conv i)) ct))\nin\n  fn _ => mk_swap_rrule\nend\n\\<close>"], ["", "declare [[simproc del: rearrange_eqs]]"], ["", "lemmas meta_onepoint = meta_all_eq_conv meta_all_eq_conv2"], ["", "lemma meta_all2_eq_conv: \"(\\<And>a b. a = c \\<Longrightarrow> PROP P a b) \\<equiv> (\\<And>b. PROP P c b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. a = c \\<Longrightarrow> PROP P a b) \\<equiv>\n    (\\<And>b. PROP P c b)", "apply(rule equal_intr_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       (\\<And>a b. a = c \\<Longrightarrow> PROP P a b) \\<Longrightarrow>\n       PROP P c b\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>b. PROP P c b; a = c\\<rbrakk>\n       \\<Longrightarrow> PROP P a b", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       (?a3 b = c \\<Longrightarrow>\n        PROP P (?a3 b) (?b5 b)) \\<Longrightarrow>\n       PROP P c b\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>b. PROP P c b; a = c\\<rbrakk>\n       \\<Longrightarrow> PROP P a b", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. c = c\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>b. PROP P c b; a = c\\<rbrakk>\n       \\<Longrightarrow> PROP P a b", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>b. PROP P c b; a = c\\<rbrakk>\n       \\<Longrightarrow> PROP P a b", "apply(erule meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a = c; PROP P c (?b10 a b)\\<rbrakk>\n       \\<Longrightarrow> PROP P a b", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meta_all3_eq_conv: \"(\\<And>a b c. a = d \\<Longrightarrow> PROP P a b c) \\<equiv> (\\<And>b c. PROP P d b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c. a = d \\<Longrightarrow> PROP P a b c) \\<equiv>\n    (\\<And>b c. PROP P d b c)", "apply(rule equal_intr_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       (\\<And>a b c. a = d \\<Longrightarrow> PROP P a b c) \\<Longrightarrow>\n       PROP P d b c\n 2. \\<And>a b c.\n       \\<lbrakk>\\<And>b c. PROP P d b c; a = d\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c.\n       (?a3 b c = d \\<Longrightarrow>\n        PROP P (?a3 b c) (?b5 b c) (?c7 b c)) \\<Longrightarrow>\n       PROP P d b c\n 2. \\<And>a b c.\n       \\<lbrakk>\\<And>b c. PROP P d b c; a = d\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c. d = d\n 2. \\<And>a b c.\n       \\<lbrakk>\\<And>b c. PROP P d b c; a = d\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>b c. PROP P d b c; a = d\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a = d; PROP P d (?b12 a b c) (?c14 a b c)\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meta_all4_eq_conv: \"(\\<And>a b c d. a = e \\<Longrightarrow> PROP P a b c d) \\<equiv> (\\<And>b c d. PROP P e b c d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c d. a = e \\<Longrightarrow> PROP P a b c d) \\<equiv>\n    (\\<And>b c d. PROP P e b c d)", "apply(rule equal_intr_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c d.\n       (\\<And>a b c d.\n           a = e \\<Longrightarrow> PROP P a b c d) \\<Longrightarrow>\n       PROP P e b c d\n 2. \\<And>a b c d.\n       \\<lbrakk>\\<And>b c d. PROP P e b c d; a = e\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c d.\n       (?a3 b c d = e \\<Longrightarrow>\n        PROP P (?a3 b c d) (?b5 b c d) (?c7 b c d)\n              (?d9 b c d)) \\<Longrightarrow>\n       PROP P e b c d\n 2. \\<And>a b c d.\n       \\<lbrakk>\\<And>b c d. PROP P e b c d; a = e\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c d. e = e\n 2. \\<And>a b c d.\n       \\<lbrakk>\\<And>b c d. PROP P e b c d; a = e\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<And>b c d. PROP P e b c d; a = e\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a = e;\n        PROP P e (?b14 a b c d) (?c16 a b c d) (?d18 a b c d)\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meta_all5_eq_conv: \"(\\<And>a b c d e. a = f \\<Longrightarrow> PROP P a b c d e) \\<equiv> (\\<And>b c d e. PROP P f b c d e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c d e. a = f \\<Longrightarrow> PROP P a b c d e) \\<equiv>\n    (\\<And>b c d e. PROP P f b c d e)", "apply(rule equal_intr_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c d e.\n       (\\<And>a b c d e.\n           a = f \\<Longrightarrow> PROP P a b c d e) \\<Longrightarrow>\n       PROP P f b c d e\n 2. \\<And>a b c d e.\n       \\<lbrakk>\\<And>b c d e. PROP P f b c d e; a = f\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d e", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c d e.\n       (?a3 b c d e = f \\<Longrightarrow>\n        PROP P (?a3 b c d e) (?b5 b c d e) (?c7 b c d e) (?d9 b c d e)\n              (?e11 b c d e)) \\<Longrightarrow>\n       PROP P f b c d e\n 2. \\<And>a b c d e.\n       \\<lbrakk>\\<And>b c d e. PROP P f b c d e; a = f\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d e", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c d e. f = f\n 2. \\<And>a b c d e.\n       \\<lbrakk>\\<And>b c d e. PROP P f b c d e; a = f\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d e", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d e.\n       \\<lbrakk>\\<And>b c d e. PROP P f b c d e; a = f\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d e", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d e.\n       \\<lbrakk>a = f;\n        PROP P f (?b16 a b c d e) (?c18 a b c d e) (?d20 a b c d e)\n              (?e22 a b c d e)\\<rbrakk>\n       \\<Longrightarrow> PROP P a b c d e", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_on_image_mem_iff:\n  \"\\<lbrakk> inj_on f A; B \\<subseteq> A; a \\<in> A \\<rbrakk> \\<Longrightarrow> f a \\<in> f ` B \\<longleftrightarrow> a \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; B \\<subseteq> A; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> (f a \\<in> f ` B) = (a \\<in> B)", "by(metis inv_into_f_eq inv_into_image_cancel rev_image_eqI)"], ["", "lemma sum_hom:\n  assumes hom_add [simp]: \"\\<And>a b. f (a + b) = f a + f b\"\n  and hom_0 [simp]: \"f 0 = 0\"\n  shows \"sum (f \\<circ> h) A = f (sum h A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (f \\<circ> h) A = f (sum h A)", "proof(cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> sum (f \\<circ> h) A = f (sum h A)\n 2. infinite A \\<Longrightarrow> sum (f \\<circ> h) A = f (sum h A)", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> sum (f \\<circ> h) A = f (sum h A)\n 2. infinite A \\<Longrightarrow> sum (f \\<circ> h) A = f (sum h A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. sum (f \\<circ> h) A = f (sum h A)", "by simp"], ["proof (state)\nthis:\n  sum (f \\<circ> h) A = f (sum h A)\n\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> sum (f \\<circ> h) A = f (sum h A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> sum (f \\<circ> h) A = f (sum h A)", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> sum (f \\<circ> h) A = f (sum h A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. sum (f \\<circ> h) A = f (sum h A)", "by(induct) simp_all"], ["proof (state)\nthis:\n  sum (f \\<circ> h) A = f (sum h A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_upto_add_nat:\n  \"a \\<le> b \\<Longrightarrow> sum f {..<(a :: nat)} + sum f {a..<b} = sum f {..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> sum f {..<a} + sum f {a..<b} = sum f {..<b}", "by (metis atLeast0LessThan le0 sum.atLeastLessThan_concat)"], ["", "lemma nat_fun_sum_eq_conv:\n  fixes f :: \"'a \\<Rightarrow> nat\"\n  shows \"(\\<lambda>a. f a + g a) = (\\<lambda>a. 0) \\<longleftrightarrow> f = (\\<lambda>a .0) \\<and> g = (\\<lambda>a. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a. f a + g a) = (\\<lambda>a. 0)) =\n    (f = (\\<lambda>a. 0) \\<and> g = (\\<lambda>a. 0))", "by(auto simp add: fun_eq_iff)"], ["", "lemma in_ran_conv: \"v \\<in> ran m \\<longleftrightarrow> (\\<exists>k. m k = Some v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> ran m) = (\\<exists>k. m k = \\<lfloor>v\\<rfloor>)", "by(simp add: ran_def)"], ["", "lemma map_le_dom_eq_conv_eq:\n  \"\\<lbrakk> m \\<subseteq>\\<^sub>m m'; dom m = dom m' \\<rbrakk> \\<Longrightarrow> m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<subseteq>\\<^sub>m m'; dom m = dom m'\\<rbrakk>\n    \\<Longrightarrow> m = m'", "by (metis map_le_antisym map_le_def)"], ["", "lemma map_leI:\n  \"(\\<And>k v. f k = Some v \\<Longrightarrow> g k = Some v) \\<Longrightarrow> f \\<subseteq>\\<^sub>m g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        f k = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        g k = \\<lfloor>v\\<rfloor>) \\<Longrightarrow>\n    f \\<subseteq>\\<^sub>m g", "unfolding map_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        f k = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        g k = \\<lfloor>v\\<rfloor>) \\<Longrightarrow>\n    \\<forall>a\\<in>dom f. f a = g a", "by auto"], ["", "lemma map_le_SomeD: \"\\<lbrakk> m \\<subseteq>\\<^sub>m m'; m x = \\<lfloor>y\\<rfloor> \\<rbrakk> \\<Longrightarrow> m' x = \\<lfloor>y\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<subseteq>\\<^sub>m m'; m x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> m' x = \\<lfloor>y\\<rfloor>", "by(auto simp add: map_le_def dest: bspec)"], ["", "lemma map_le_same_upd:\n  \"f x = None \\<Longrightarrow> f \\<subseteq>\\<^sub>m f(x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = None \\<Longrightarrow> f \\<subseteq>\\<^sub>m f(x \\<mapsto> y)", "by(auto simp add: map_le_def)"], ["", "lemma map_upd_map_add: \"X(V \\<mapsto> v) = (X ++ [V \\<mapsto> v])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X(V \\<mapsto> v) = X ++ [V \\<mapsto> v]", "by(simp)"], ["", "lemma foldr_filter_conv:\n  \"foldr f (filter P xs) = foldr (\\<lambda>x s. if P x then f x s else s) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr f (filter P xs) =\n    foldr (\\<lambda>x s. if P x then f x s else s) xs", "by(induct xs)(auto intro: ext)"], ["", "lemma foldr_insert_conv_set:\n  \"foldr insert xs A = A \\<union> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr insert xs A = A \\<union> set xs", "by(induct xs arbitrary: A) auto"], ["", "lemma snd_o_Pair_conv_id: \"snd o Pair a = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd \\<circ> Pair a = id", "by(simp add: o_def id_def)"], ["", "lemma if_intro:\n  \"\\<lbrakk> P \\<Longrightarrow> A; \\<not> P \\<Longrightarrow> B \\<rbrakk> \\<Longrightarrow> if P then A else B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow> A; \\<not> P \\<Longrightarrow> B\\<rbrakk>\n    \\<Longrightarrow> if P then A else B", "by(auto)"], ["", "lemma ex_set_conv: \"(\\<exists>x. x \\<in> set xs) \\<longleftrightarrow> xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<in> set xs) = (xs \\<noteq> [])", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> \\<exists>x. x \\<in> set xs", "apply(auto simp add: neq_Nil_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subset_Un1: \"A \\<subseteq> B \\<Longrightarrow> A \\<subseteq> B \\<union> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> A \\<subseteq> B \\<union> C", "by blast"], ["", "lemma subset_Un2: \"A \\<subseteq> C \\<Longrightarrow> A \\<subseteq> B \\<union> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> C \\<Longrightarrow> A \\<subseteq> B \\<union> C", "by blast"], ["", "lemma subset_insert: \"A \\<subseteq> B \\<Longrightarrow> A \\<subseteq> insert a B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> A \\<subseteq> insert a B", "by blast"], ["", "lemma UNION_subsetD: \"\\<lbrakk> (\\<Union>x\\<in>A. f x) \\<subseteq> B; a \\<in> A \\<rbrakk> \\<Longrightarrow> f a \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Union> (f ` A) \\<subseteq> B; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> f a \\<subseteq> B", "by blast"], ["", "lemma Collect_eq_singleton_conv:\n  \"{a. P a} = {a} \\<longleftrightarrow> P a \\<and> (\\<forall>a'. P a' \\<longrightarrow> a = a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a. P a} = {a}) =\n    (P a \\<and> (\\<forall>a'. P a' \\<longrightarrow> a = a'))", "by(auto)"], ["", "lemma Collect_conv_UN_singleton: \"{f x|x. x \\<in> P} = (\\<Union>x\\<in>P. {f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f x |x. x \\<in> P} = (\\<Union>x\\<in>P. {f x})", "by blast"], ["", "lemma if_else_if_else_eq_if_else [simp]:\n  \"(if b then x else if b then y else z) = (if b then x else z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then x else if b then y else z) = (if b then x else z)", "by(simp)"], ["", "lemma rec_prod_split [simp]: \"old.rec_prod = case_prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.rec_prod = case_prod", "by(simp add: fun_eq_iff)"], ["", "lemma inj_Pair_snd [simp]: \"inj (Pair x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (Pair x)", "by(rule injI) auto"], ["", "lemma rtranclp_False [simp]: \"(\\<lambda>a b. False)\\<^sup>*\\<^sup>* = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b. False)\\<^sup>*\\<^sup>* = (=)", "by(auto simp add: fun_eq_iff elim: rtranclp_induct)"], ["", "lemmas rtranclp_induct3 =\n  rtranclp_induct[where a=\"(ax, ay, az)\" and b=\"(bx, by, bz)\", split_rule, consumes 1, case_names refl step]"], ["", "lemmas tranclp_induct3 =\n  tranclp_induct[where a=\"(ax, ay, az)\" and b=\"(bx, by, bz)\", split_rule, consumes 1, case_names refl step]"], ["", "lemmas rtranclp_induct4 =\n  rtranclp_induct[where a=\"(ax, ay, az, aw)\" and b=\"(bx, by, bz, bw)\", split_rule, consumes 1, case_names refl step]"], ["", "lemmas tranclp_induct4 =\n  tranclp_induct[where a=\"(ax, ay, az, aw)\" and b=\"(bx, by, bz, bw)\", split_rule, consumes 1, case_names refl step]"], ["", "lemmas converse_tranclp_induct2 =\n  converse_tranclp_induct [of _ \"(ax,ay)\" \"(bx,by)\", split_rule,\n                 consumes 1, case_names base step]"], ["", "lemma wfP_induct' [consumes 1, case_names wfP]:\n  \"\\<lbrakk>wfP r; \\<And>x. (\\<And>y. r y x \\<Longrightarrow> P y) \\<Longrightarrow> P x\\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfP r;\n     \\<And>x.\n        (\\<And>y. r y x \\<Longrightarrow> P y) \\<Longrightarrow>\n        P x\\<rbrakk>\n    \\<Longrightarrow> P a", "by(blast intro: wfP_induct)"], ["", "lemma wfP_induct2 [consumes 1, case_names wfP]:\n  \"\\<lbrakk>wfP r; \\<And>x x'. (\\<And>y y'. r (y, y') (x, x') \\<Longrightarrow> P y y') \\<Longrightarrow> P x x' \\<rbrakk> \\<Longrightarrow> P x x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfP r;\n     \\<And>x x'.\n        (\\<And>y y'.\n            r (y, y') (x, x') \\<Longrightarrow> P y y') \\<Longrightarrow>\n        P x x'\\<rbrakk>\n    \\<Longrightarrow> P x x'", "by(drule wfP_induct'[where P=\"\\<lambda>(x, y). P x y\"]) blast+"], ["", "lemma wfP_minimalE:\n  assumes \"wfP r\"\n  and \"P x\"\n  obtains z where \"P z\" \"r^** z x\" \"\\<And>y. r y z \\<Longrightarrow> \\<not> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?Q = \"\\<lambda>x'. P x' \\<and> r^** x' x\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>P x\\<close>"], ["proof (chain)\npicking this:\n  P x", "have \"?Q x\""], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. P x \\<and> r\\<^sup>*\\<^sup>* x x", "by blast"], ["proof (state)\nthis:\n  P x \\<and> r\\<^sup>*\\<^sup>* x x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>wfP r\\<close>"], ["proof (chain)\npicking this:\n  wfP r", "have \"\\<And>Q. x \\<in> Q \\<longrightarrow> (\\<exists>z\\<in>Q. \\<forall>y. r y z \\<longrightarrow> y \\<notin> Q)\""], ["proof (prove)\nusing this:\n  wfP r\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q. \\<forall>y. r y z \\<longrightarrow> y \\<notin> Q)", "unfolding wfP_eq_minimal"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q. \\<forall>y. r y z \\<longrightarrow> y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q. \\<forall>y. r y z \\<longrightarrow> y \\<notin> Q)", "by blast"], ["proof (state)\nthis:\n  x \\<in> ?Q \\<longrightarrow>\n  (\\<exists>z\\<in>?Q. \\<forall>y. r y z \\<longrightarrow> y \\<notin> ?Q)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this[rule_format, of \"Collect ?Q\"] \\<open>?Q x\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> {x'. P x' \\<and> r\\<^sup>*\\<^sup>* x' x} \\<Longrightarrow>\n  \\<exists>z\\<in>{x'. P x' \\<and> r\\<^sup>*\\<^sup>* x' x}.\n     \\<forall>y.\n        r y z \\<longrightarrow>\n        y \\<notin> {x'. P x' \\<and> r\\<^sup>*\\<^sup>* x' x}\n  P x \\<and> r\\<^sup>*\\<^sup>* x x", "obtain z where \"?Q z\" and min: \"\\<And>y. r y z \\<Longrightarrow> \\<not> ?Q y\""], ["proof (prove)\nusing this:\n  x \\<in> {x'. P x' \\<and> r\\<^sup>*\\<^sup>* x' x} \\<Longrightarrow>\n  \\<exists>z\\<in>{x'. P x' \\<and> r\\<^sup>*\\<^sup>* x' x}.\n     \\<forall>y.\n        r y z \\<longrightarrow>\n        y \\<notin> {x'. P x' \\<and> r\\<^sup>*\\<^sup>* x' x}\n  P x \\<and> r\\<^sup>*\\<^sup>* x x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z \\<and> r\\<^sup>*\\<^sup>* z x;\n         \\<And>y.\n            r y z \\<Longrightarrow>\n            \\<not> (P y \\<and> r\\<^sup>*\\<^sup>* y x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P z \\<and> r\\<^sup>*\\<^sup>* z x\n  r ?y z \\<Longrightarrow> \\<not> (P ?y \\<and> r\\<^sup>*\\<^sup>* ?y x)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>?Q z\\<close>"], ["proof (chain)\npicking this:\n  P z \\<and> r\\<^sup>*\\<^sup>* z x", "have \"P z\" \"r^** z x\""], ["proof (prove)\nusing this:\n  P z \\<and> r\\<^sup>*\\<^sup>* z x\n\ngoal (1 subgoal):\n 1. P z &&& r\\<^sup>*\\<^sup>* z x", "by auto"], ["proof (state)\nthis:\n  P z\n  r\\<^sup>*\\<^sup>* z x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  P z\n  r\\<^sup>*\\<^sup>* z x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  P z\n  r\\<^sup>*\\<^sup>* z x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"r y z\""], ["proof (state)\nthis:\n  r y z\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<not> ?Q y\""], ["proof (prove)\nusing this:\n  r y z\n\ngoal (1 subgoal):\n 1. \\<not> (P y \\<and> r\\<^sup>*\\<^sup>* y x)", "by(rule min)"], ["proof (state)\nthis:\n  \\<not> (P y \\<and> r\\<^sup>*\\<^sup>* y x)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<not> (P y \\<and> r\\<^sup>*\\<^sup>* y x)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>r y z\\<close> \\<open>r^** z x\\<close>"], ["proof (chain)\npicking this:\n  r y z\n  r\\<^sup>*\\<^sup>* z x", "have \"r^** y x\""], ["proof (prove)\nusing this:\n  r y z\n  r\\<^sup>*\\<^sup>* z x\n\ngoal (1 subgoal):\n 1. r\\<^sup>*\\<^sup>* y x", "by(rule converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  r\\<^sup>*\\<^sup>* y x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (P y \\<and> r\\<^sup>*\\<^sup>* y x)\n  r\\<^sup>*\\<^sup>* y x", "have \"\\<not> P y\""], ["proof (prove)\nusing this:\n  \\<not> (P y \\<and> r\\<^sup>*\\<^sup>* y x)\n  r\\<^sup>*\\<^sup>* y x\n\ngoal (1 subgoal):\n 1. \\<not> P y", "by blast"], ["proof (state)\nthis:\n  \\<not> P y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  r ?y2 z \\<Longrightarrow> \\<not> P ?y2\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P z; r\\<^sup>*\\<^sup>* z x;\n         \\<And>y. r y z \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  P z\n  r\\<^sup>*\\<^sup>* z x\n  r ?y2 z \\<Longrightarrow> \\<not> P ?y2", "show thesis"], ["proof (prove)\nusing this:\n  P z\n  r\\<^sup>*\\<^sup>* z x\n  r ?y2 z \\<Longrightarrow> \\<not> P ?y2\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coinduct_set_wf [consumes 3, case_names coinduct, case_conclusion coinduct wait step]: \n  assumes \"mono f\" \"wf r\" \"(a, b) \\<in> X\"\n  and step: \"\\<And>x b. (x, b) \\<in> X \\<Longrightarrow> (\\<exists>b'. (b', b) \\<in> r \\<and> (x, b') \\<in> X) \\<or> (x \\<in> f (fst ` X \\<union> gfp f))\"\n  shows \"a \\<in> gfp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "from \\<open>(a, b) \\<in> X\\<close>"], ["proof (chain)\npicking this:\n  (a, b) \\<in> X", "have \"a \\<in> fst ` X\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> X\n\ngoal (1 subgoal):\n 1. a \\<in> fst ` X", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  a \\<in> fst ` X\n\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "moreover"], ["proof (state)\nthis:\n  a \\<in> fst ` X\n\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "{"], ["proof (state)\nthis:\n  a \\<in> fst ` X\n\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "assume \"(a, b) \\<in> X\""], ["proof (state)\nthis:\n  (a, b) \\<in> X\n\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "with \\<open>wf r\\<close>"], ["proof (chain)\npicking this:\n  wf r\n  (a, b) \\<in> X", "have \"a \\<in> f (fst ` X \\<union> gfp f)\""], ["proof (prove)\nusing this:\n  wf r\n  (a, b) \\<in> X\n\ngoal (1 subgoal):\n 1. a \\<in> f (fst ` X \\<union> gfp f)", "by(induct)(blast dest: step)"], ["proof (state)\nthis:\n  a \\<in> f (fst ` X \\<union> gfp f)\n\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "}"], ["proof (state)\nthis:\n  (?aa2, ?ba2) \\<in> X \\<Longrightarrow>\n  ?aa2 \\<in> f (fst ` X \\<union> gfp f)\n\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "hence \"fst ` X \\<subseteq> f (fst ` X \\<union> gfp f)\""], ["proof (prove)\nusing this:\n  (?aa2, ?ba2) \\<in> X \\<Longrightarrow>\n  ?aa2 \\<in> f (fst ` X \\<union> gfp f)\n\ngoal (1 subgoal):\n 1. fst ` X \\<subseteq> f (fst ` X \\<union> gfp f)", "by(auto)"], ["proof (state)\nthis:\n  fst ` X \\<subseteq> f (fst ` X \\<union> gfp f)\n\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> fst ` X\n  fst ` X \\<subseteq> f (fst ` X \\<union> gfp f)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> fst ` X\n  fst ` X \\<subseteq> f (fst ` X \\<union> gfp f)\n\ngoal (1 subgoal):\n 1. a \\<in> gfp f", "by(rule coinduct_set[OF \\<open>mono f\\<close>])"], ["proof (state)\nthis:\n  a \\<in> gfp f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>reflexive transitive closure for label relations\\<close>"], ["", "inductive converse3p :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> 'c \\<Rightarrow> 'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  for r :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> bool\"\nwhere\n  converse3pI: \"r a b c \\<Longrightarrow> converse3p r c b a\""], ["", "lemma converse3p_converse3p: \"converse3p (converse3p r) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converse3p (converse3p r) = r", "by(auto intro: converse3pI intro!: ext elim: converse3p.cases)"], ["", "lemma converse3pD: \"converse3p r c b a \\<Longrightarrow> r a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converse3p r c b a \\<Longrightarrow> r a b c", "by(auto elim: converse3p.cases)"], ["", "inductive rtrancl3p :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> 'b list \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  for r :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  where \n  rtrancl3p_refl [intro!, simp]: \"rtrancl3p r a [] a\"\n| rtrancl3p_step: \"\\<lbrakk> rtrancl3p r a bs a'; r a' b a'' \\<rbrakk> \\<Longrightarrow> rtrancl3p r a (bs @ [b]) a''\""], ["", "lemmas rtrancl3p_induct3 =\n  rtrancl3p.induct[of _ \"(ax,ay,az)\" _ \"(cx,cy,cz)\", split_format (complete),\n                 consumes 1, case_names refl step]"], ["", "lemmas rtrancl3p_induct4 = \n  rtrancl3p.induct[of _ \"(ax,ay,az,aw)\" _ \"(cx,cy,cz,cw)\", split_format (complete),\n                 consumes 1, case_names refl step]"], ["", "lemma rtrancl3p_induct4' [consumes 1, case_names refl step]:\n  assumes major: \"rtrancl3p r (ax, (ay, az), aw) bs (cx, (cy, cz), cw)\"\n  and refl: \"\\<And>a aa b ba. P a aa b ba [] a aa b ba\"\n  and step: \"\\<And>a aa b ba bs ab ac bb bc bd ad ae be bf.\n       \\<lbrakk> rtrancl3p r (a, (aa, b), ba) bs (ab, (ac, bb), bc);\n         P a aa b ba bs ab ac bb bc; r (ab, (ac, bb), bc) bd (ad, (ae, be), bf) \\<rbrakk>\n       \\<Longrightarrow> P a aa b ba (bs @ [bd]) ad ae be bf\"\n  shows \"P ax ay az aw bs cx cy cz cw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ax ay az aw bs cx cy cz cw", "using major"], ["proof (prove)\nusing this:\n  rtrancl3p r (ax, (ay, az), aw) bs (cx, (cy, cz), cw)\n\ngoal (1 subgoal):\n 1. P ax ay az aw bs cx cy cz cw", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p r (ax, (ay, az), aw) bs (cx, (cy, cz), cw) \\<Longrightarrow>\n    P ax ay az aw bs cx cy cz cw", "apply(drule_tac P=\"\\<lambda>(a, (aa, b), ba) bs (cx, (cy, cz), cw). P a aa b ba bs cx cy cz cw\" in rtrancl3p.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       (case a of\n        (a, xa, xb) \\<Rightarrow>\n          (case xa of\n           (aa, b) \\<Rightarrow>\n             \\<lambda>ba bs (cx, (cy, cz), cw). P a aa b ba bs cx cy cz cw)\n           xb)\n        [] a\n 2. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p r a bs a';\n        (case a of\n         (a, xa, xb) \\<Rightarrow>\n           (case xa of\n            (aa, b) \\<Rightarrow>\n              \\<lambda>ba bs (cx, (cy, cz), cw). P a aa b ba bs cx cy cz cw)\n            xb)\n         bs a';\n        r a' b a''\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (a, xa, xb) \\<Rightarrow>\n                            (case xa of\n                             (aa, b) \\<Rightarrow>\n                               \\<lambda>ba bs (cx, (cy, cz), cw).\n                                  P a aa b ba bs cx cy cz cw)\n                             xb)\n                          (bs @ [b]) a''\n 3. (case (ax, (ay, az), aw) of\n     (a, xa, xb) \\<Rightarrow>\n       (case xa of\n        (aa, b) \\<Rightarrow>\n          \\<lambda>ba bs (cx, (cy, cz), cw). P a aa b ba bs cx cy cz cw)\n        xb)\n     bs (cx, (cy, cz), cw) \\<Longrightarrow>\n    P ax ay az aw bs cx cy cz cw", "by(auto intro: refl step)"], ["", "lemma rtrancl3p_induct1:\n  \"\\<lbrakk> rtrancl3p r a bs c; P a; \\<And>bs c b d. \\<lbrakk> rtrancl3p r a bs c; r c b d; P c \\<rbrakk> \\<Longrightarrow> P d \\<rbrakk> \\<Longrightarrow> P c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtrancl3p r a bs c; P a;\n     \\<And>bs c b d.\n        \\<lbrakk>rtrancl3p r a bs c; r c b d; P c\\<rbrakk>\n        \\<Longrightarrow> P d\\<rbrakk>\n    \\<Longrightarrow> P c", "apply(induct rule: rtrancl3p.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P a;\n        \\<And>bs c b d.\n           \\<lbrakk>rtrancl3p r a bs c; r c b d; P c\\<rbrakk>\n           \\<Longrightarrow> P d\\<rbrakk>\n       \\<Longrightarrow> P a\n 2. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p r a bs a';\n        \\<lbrakk>P a;\n         \\<And>bs c b d.\n            \\<lbrakk>rtrancl3p r a bs c; r c b d; P c\\<rbrakk>\n            \\<Longrightarrow> P d\\<rbrakk>\n        \\<Longrightarrow> P a';\n        r a' b a''; P a;\n        \\<And>bs c b d.\n           \\<lbrakk>rtrancl3p r a bs c; r c b d; P c\\<rbrakk>\n           \\<Longrightarrow> P d\\<rbrakk>\n       \\<Longrightarrow> P a''", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "inductive_cases rtrancl3p_cases:\n  \"rtrancl3p r x [] y\"\n  \"rtrancl3p r x (b # bs) y\""], ["", "lemma rtrancl3p_trans [trans]:\n  assumes one: \"rtrancl3p r a bs a'\"\n  and two: \"rtrancl3p r a' bs' a''\"\n  shows \"rtrancl3p r a (bs @ bs') a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p r a (bs @ bs') a''", "using two one"], ["proof (prove)\nusing this:\n  rtrancl3p r a' bs' a''\n  rtrancl3p r a bs a'\n\ngoal (1 subgoal):\n 1. rtrancl3p r a (bs @ bs') a''", "proof(induct rule: rtrancl3p.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       rtrancl3p r a bs aa \\<Longrightarrow> rtrancl3p r a (bs @ []) aa\n 2. \\<And>aa bsa a' b a''.\n       \\<lbrakk>rtrancl3p r aa bsa a';\n        rtrancl3p r a bs aa \\<Longrightarrow> rtrancl3p r a (bs @ bsa) a';\n        r a' b a''; rtrancl3p r a bs aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (bs @ bsa @ [b]) a''", "case rtrancl3p_refl"], ["proof (state)\nthis:\n  rtrancl3p r a bs a_\n\ngoal (2 subgoals):\n 1. \\<And>aa.\n       rtrancl3p r a bs aa \\<Longrightarrow> rtrancl3p r a (bs @ []) aa\n 2. \\<And>aa bsa a' b a''.\n       \\<lbrakk>rtrancl3p r aa bsa a';\n        rtrancl3p r a bs aa \\<Longrightarrow> rtrancl3p r a (bs @ bsa) a';\n        r a' b a''; rtrancl3p r a bs aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (bs @ bsa @ [b]) a''", "thus ?case"], ["proof (prove)\nusing this:\n  rtrancl3p r a bs a_\n\ngoal (1 subgoal):\n 1. rtrancl3p r a (bs @ []) a_", "by simp"], ["proof (state)\nthis:\n  rtrancl3p r a (bs @ []) a_\n\ngoal (1 subgoal):\n 1. \\<And>aa bsa a' b a''.\n       \\<lbrakk>rtrancl3p r aa bsa a';\n        rtrancl3p r a bs aa \\<Longrightarrow> rtrancl3p r a (bs @ bsa) a';\n        r a' b a''; rtrancl3p r a bs aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (bs @ bsa @ [b]) a''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa bsa a' b a''.\n       \\<lbrakk>rtrancl3p r aa bsa a';\n        rtrancl3p r a bs aa \\<Longrightarrow> rtrancl3p r a (bs @ bsa) a';\n        r a' b a''; rtrancl3p r a bs aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (bs @ bsa @ [b]) a''", "case rtrancl3p_step"], ["proof (state)\nthis:\n  rtrancl3p r a_ bs_ a'_\n  rtrancl3p r a bs a_ \\<Longrightarrow> rtrancl3p r a (bs @ bs_) a'_\n  r a'_ b_ a''_\n  rtrancl3p r a bs a_\n\ngoal (1 subgoal):\n 1. \\<And>aa bsa a' b a''.\n       \\<lbrakk>rtrancl3p r aa bsa a';\n        rtrancl3p r a bs aa \\<Longrightarrow> rtrancl3p r a (bs @ bsa) a';\n        r a' b a''; rtrancl3p r a bs aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (bs @ bsa @ [b]) a''", "thus ?case"], ["proof (prove)\nusing this:\n  rtrancl3p r a_ bs_ a'_\n  rtrancl3p r a bs a_ \\<Longrightarrow> rtrancl3p r a (bs @ bs_) a'_\n  r a'_ b_ a''_\n  rtrancl3p r a bs a_\n\ngoal (1 subgoal):\n 1. rtrancl3p r a (bs @ bs_ @ [b_]) a''_", "by(auto simp only: append_assoc[symmetric] intro: rtrancl3p.rtrancl3p_step)"], ["proof (state)\nthis:\n  rtrancl3p r a (bs @ bs_ @ [b_]) a''_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rtrancl3p_step_converse:\n  assumes step: \"r a b a'\"\n  and stepify: \"rtrancl3p r a' bs a''\"\n  shows \"rtrancl3p r a (b # bs) a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p r a (b # bs) a''", "using stepify step"], ["proof (prove)\nusing this:\n  rtrancl3p r a' bs a''\n  r a b a'\n\ngoal (1 subgoal):\n 1. rtrancl3p r a (b # bs) a''", "proof(induct rule: rtrancl3p.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa. r a b aa \\<Longrightarrow> rtrancl3p r a [b] aa\n 2. \\<And>aa bs a' ba a''.\n       \\<lbrakk>rtrancl3p r aa bs a';\n        r a b aa \\<Longrightarrow> rtrancl3p r a (b # bs) a'; r a' ba a'';\n        r a b aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (b # bs @ [ba]) a''", "case rtrancl3p_refl"], ["proof (state)\nthis:\n  r a b a_\n\ngoal (2 subgoals):\n 1. \\<And>aa. r a b aa \\<Longrightarrow> rtrancl3p r a [b] aa\n 2. \\<And>aa bs a' ba a''.\n       \\<lbrakk>rtrancl3p r aa bs a';\n        r a b aa \\<Longrightarrow> rtrancl3p r a (b # bs) a'; r a' ba a'';\n        r a b aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (b # bs @ [ba]) a''", "with rtrancl3p.rtrancl3p_refl[where r=r and a=a]"], ["proof (chain)\npicking this:\n  rtrancl3p r a [] a\n  r a b a_", "show ?case"], ["proof (prove)\nusing this:\n  rtrancl3p r a [] a\n  r a b a_\n\ngoal (1 subgoal):\n 1. rtrancl3p r a [b] a_", "by(auto dest: rtrancl3p.rtrancl3p_step simp del: rtrancl3p.rtrancl3p_refl)"], ["proof (state)\nthis:\n  rtrancl3p r a [b] a_\n\ngoal (1 subgoal):\n 1. \\<And>aa bs a' ba a''.\n       \\<lbrakk>rtrancl3p r aa bs a';\n        r a b aa \\<Longrightarrow> rtrancl3p r a (b # bs) a'; r a' ba a'';\n        r a b aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (b # bs @ [ba]) a''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa bs a' ba a''.\n       \\<lbrakk>rtrancl3p r aa bs a';\n        r a b aa \\<Longrightarrow> rtrancl3p r a (b # bs) a'; r a' ba a'';\n        r a b aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (b # bs @ [ba]) a''", "case rtrancl3p_step"], ["proof (state)\nthis:\n  rtrancl3p r a_ bs_ a'_\n  r a b a_ \\<Longrightarrow> rtrancl3p r a (b # bs_) a'_\n  r a'_ b_ a''_\n  r a b a_\n\ngoal (1 subgoal):\n 1. \\<And>aa bs a' ba a''.\n       \\<lbrakk>rtrancl3p r aa bs a';\n        r a b aa \\<Longrightarrow> rtrancl3p r a (b # bs) a'; r a' ba a'';\n        r a b aa\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a (b # bs @ [ba]) a''", "thus ?case"], ["proof (prove)\nusing this:\n  rtrancl3p r a_ bs_ a'_\n  r a b a_ \\<Longrightarrow> rtrancl3p r a (b # bs_) a'_\n  r a'_ b_ a''_\n  r a b a_\n\ngoal (1 subgoal):\n 1. rtrancl3p r a (b # bs_ @ [b_]) a''_", "unfolding append_Cons[symmetric]"], ["proof (prove)\nusing this:\n  rtrancl3p r a_ bs_ a'_\n  r a b a_ \\<Longrightarrow> rtrancl3p r a (b # bs_) a'_\n  r a'_ b_ a''_\n  r a b a_\n\ngoal (1 subgoal):\n 1. rtrancl3p r a ((b # bs_) @ [b_]) a''_", "by -(rule rtrancl3p.rtrancl3p_step)"], ["proof (state)\nthis:\n  rtrancl3p r a (b # bs_ @ [b_]) a''_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma converse_rtrancl3p_step:\n  \"rtrancl3p r a (b # bs) a'' \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' bs a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p r a (b # bs) a'' \\<Longrightarrow>\n    \\<exists>a'. r a b a' \\<and> rtrancl3p r a' bs a''", "apply(induct bs arbitrary: a'' rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a''.\n       rtrancl3p r a [b] a'' \\<Longrightarrow>\n       \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''\n 2. \\<And>x xs a''.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs @ [x]) a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(erule rtrancl3p.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a'' aa.\n       \\<lbrakk>a = aa; [b] = []; a'' = aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''\n 2. \\<And>a'' aa bs a' ba a''a.\n       \\<lbrakk>a = aa; [b] = bs @ [ba]; a'' = a''a; rtrancl3p r aa bs a';\n        r a' ba a''a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''\n 3. \\<And>x xs a''.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs @ [x]) a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(clarsimp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a''a.\n       \\<lbrakk>rtrancl3p r a [] a'; r a' b a''a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''a\n 2. \\<And>x xs a''.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs @ [x]) a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(erule rtrancl3p.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a' a''a aa.\n       \\<lbrakk>r a' b a''a; a = aa; [] = []; a' = aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''a\n 2. \\<And>a' a''a aa bs a'a ba a''.\n       \\<lbrakk>r a' b a''a; a = aa; [] = bs @ [ba]; a' = a'';\n        rtrancl3p r aa bs a'a; r a'a ba a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''a\n 3. \\<And>x xs a''.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs @ [x]) a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a''a.\n       r a b a''a \\<Longrightarrow>\n       \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''a\n 2. \\<And>a' a''a aa bs a'a ba a''.\n       \\<lbrakk>r a' b a''a; a = aa; [] = bs @ [ba]; a' = a'';\n        rtrancl3p r aa bs a'a; r a'a ba a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''a\n 3. \\<And>x xs a''.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs @ [x]) a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(rule_tac x=\"a''a\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a''a.\n       r a b a''a \\<Longrightarrow>\n       r a b a''a \\<and> rtrancl3p r a''a [] a''a\n 2. \\<And>a' a''a aa bs a'a ba a''.\n       \\<lbrakk>r a' b a''a; a = aa; [] = bs @ [ba]; a' = a'';\n        rtrancl3p r aa bs a'a; r a'a ba a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''a\n 3. \\<And>x xs a''.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs @ [x]) a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a''a aa bs a'a ba a''.\n       \\<lbrakk>r a' b a''a; a = aa; [] = bs @ [ba]; a' = a'';\n        rtrancl3p r aa bs a'a; r a'a ba a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'. r a b a' \\<and> rtrancl3p r a' [] a''a\n 2. \\<And>x xs a''.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs @ [x]) a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a''.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs @ [x]) a''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(erule rtrancl3p.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs a'' aa.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        a = aa; b # xs @ [x] = []; a'' = aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''\n 2. \\<And>x xs a'' aa bs a' ba a''a.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        a = aa; b # xs @ [x] = bs @ [ba]; a'' = a''a; rtrancl3p r aa bs a';\n        r a' ba a''a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a'' aa bs a' ba a''a.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        a = aa; b # xs @ [x] = bs @ [ba]; a'' = a''a; rtrancl3p r aa bs a';\n        r a' ba a''a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a' a''a.\n       \\<lbrakk>\\<And>a''.\n                   rtrancl3p r a (b # xs) a'' \\<Longrightarrow>\n                   \\<exists>a'. r a b a' \\<and> rtrancl3p r a' xs a'';\n        rtrancl3p r a (b # xs) a'; r a' x a''a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            r a b a' \\<and> rtrancl3p r a' (xs @ [x]) a''a", "by(fastforce intro: rtrancl3p_step)"], ["", "lemma converse_rtrancl3pD:\n  \"rtrancl3p (converse3p r) a' bs a \\<Longrightarrow> rtrancl3p r a (rev bs) a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p (converse3p r) a' bs a \\<Longrightarrow>\n    rtrancl3p r a (rev bs) a'", "apply(induct rule: rtrancl3p.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. rtrancl3p r a (rev []) a\n 2. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p (converse3p r) a bs a'; rtrancl3p r a' (rev bs) a;\n        converse3p r a' b a''\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a'' (rev (bs @ [b])) a", "apply(fastforce intro: rtrancl3p.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p (converse3p r) a bs a'; rtrancl3p r a' (rev bs) a;\n        converse3p r a' b a''\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p r a'' (rev (bs @ [b])) a", "apply(auto dest: converse3pD intro: rtrancl3p_step_converse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rtrancl3p_converseD:\n  \"rtrancl3p r a bs a' \\<Longrightarrow> rtrancl3p (converse3p r) a' (rev bs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p r a bs a' \\<Longrightarrow>\n    rtrancl3p (converse3p r) a' (rev bs) a", "proof(induct rule: rtrancl3p.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. rtrancl3p (converse3p r) a (rev []) a\n 2. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p r a bs a'; rtrancl3p (converse3p r) a' (rev bs) a;\n        r a' b a''\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p (converse3p r) a'' (rev (bs @ [b])) a", "case rtrancl3p_refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a. rtrancl3p (converse3p r) a (rev []) a\n 2. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p r a bs a'; rtrancl3p (converse3p r) a' (rev bs) a;\n        r a' b a''\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p (converse3p r) a'' (rev (bs @ [b])) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p (converse3p r) a_ (rev []) a_", "by(auto intro: rtrancl3p.intros)"], ["proof (state)\nthis:\n  rtrancl3p (converse3p r) a_ (rev []) a_\n\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p r a bs a'; rtrancl3p (converse3p r) a' (rev bs) a;\n        r a' b a''\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p (converse3p r) a'' (rev (bs @ [b])) a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p r a bs a'; rtrancl3p (converse3p r) a' (rev bs) a;\n        r a' b a''\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p (converse3p r) a'' (rev (bs @ [b])) a", "case rtrancl3p_step"], ["proof (state)\nthis:\n  rtrancl3p r a_ bs_ a'_\n  rtrancl3p (converse3p r) a'_ (rev bs_) a_\n  r a'_ b_ a''_\n\ngoal (1 subgoal):\n 1. \\<And>a bs a' b a''.\n       \\<lbrakk>rtrancl3p r a bs a'; rtrancl3p (converse3p r) a' (rev bs) a;\n        r a' b a''\\<rbrakk>\n       \\<Longrightarrow> rtrancl3p (converse3p r) a'' (rev (bs @ [b])) a", "thus ?case"], ["proof (prove)\nusing this:\n  rtrancl3p r a_ bs_ a'_\n  rtrancl3p (converse3p r) a'_ (rev bs_) a_\n  r a'_ b_ a''_\n\ngoal (1 subgoal):\n 1. rtrancl3p (converse3p r) a''_ (rev (bs_ @ [b_])) a_", "by(auto intro: rtrancl3p_step_converse converse3p.intros)"], ["proof (state)\nthis:\n  rtrancl3p (converse3p r) a''_ (rev (bs_ @ [b_])) a_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rtrancl3p_converse_induct [consumes 1, case_names refl step]:\n  assumes ih: \"rtrancl3p r a bs a''\"\n  and refl: \"\\<And>a. P a [] a\"\n  and step: \"\\<And>a b a' bs a''. \\<lbrakk> rtrancl3p r a' bs a''; r a b a'; P a' bs a'' \\<rbrakk> \\<Longrightarrow> P a (b # bs) a''\"\n  shows \"P a bs a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a bs a''", "using ih"], ["proof (prove)\nusing this:\n  rtrancl3p r a bs a''\n\ngoal (1 subgoal):\n 1. P a bs a''", "proof(induct bs arbitrary: a a'')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a a''. rtrancl3p r a [] a'' \\<Longrightarrow> P a [] a''\n 2. \\<And>a bs aa a''.\n       \\<lbrakk>\\<And>a a''.\n                   rtrancl3p r a bs a'' \\<Longrightarrow> P a bs a'';\n        rtrancl3p r aa (a # bs) a''\\<rbrakk>\n       \\<Longrightarrow> P aa (a # bs) a''", "case Nil"], ["proof (state)\nthis:\n  rtrancl3p r a [] a''\n\ngoal (2 subgoals):\n 1. \\<And>a a''. rtrancl3p r a [] a'' \\<Longrightarrow> P a [] a''\n 2. \\<And>a bs aa a''.\n       \\<lbrakk>\\<And>a a''.\n                   rtrancl3p r a bs a'' \\<Longrightarrow> P a bs a'';\n        rtrancl3p r aa (a # bs) a''\\<rbrakk>\n       \\<Longrightarrow> P aa (a # bs) a''", "thus ?case"], ["proof (prove)\nusing this:\n  rtrancl3p r a [] a''\n\ngoal (1 subgoal):\n 1. P a [] a''", "by(auto elim: rtrancl3p.cases intro: refl)"], ["proof (state)\nthis:\n  P a [] a''\n\ngoal (1 subgoal):\n 1. \\<And>a bs aa a''.\n       \\<lbrakk>\\<And>a a''.\n                   rtrancl3p r a bs a'' \\<Longrightarrow> P a bs a'';\n        rtrancl3p r aa (a # bs) a''\\<rbrakk>\n       \\<Longrightarrow> P aa (a # bs) a''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bs aa a''.\n       \\<lbrakk>\\<And>a a''.\n                   rtrancl3p r a bs a'' \\<Longrightarrow> P a bs a'';\n        rtrancl3p r aa (a # bs) a''\\<rbrakk>\n       \\<Longrightarrow> P aa (a # bs) a''", "case Cons"], ["proof (state)\nthis:\n  rtrancl3p r ?a bs_ ?a'' \\<Longrightarrow> P ?a bs_ ?a''\n  rtrancl3p r a (a_ # bs_) a''\n\ngoal (1 subgoal):\n 1. \\<And>a bs aa a''.\n       \\<lbrakk>\\<And>a a''.\n                   rtrancl3p r a bs a'' \\<Longrightarrow> P a bs a'';\n        rtrancl3p r aa (a # bs) a''\\<rbrakk>\n       \\<Longrightarrow> P aa (a # bs) a''", "thus ?case"], ["proof (prove)\nusing this:\n  rtrancl3p r ?a bs_ ?a'' \\<Longrightarrow> P ?a bs_ ?a''\n  rtrancl3p r a (a_ # bs_) a''\n\ngoal (1 subgoal):\n 1. P a (a_ # bs_) a''", "by(auto dest!: converse_rtrancl3p_step intro: step)"], ["proof (state)\nthis:\n  P a (a_ # bs_) a''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rtrancl3p_converse_induct' [consumes 1, case_names refl step]:\n  assumes ih: \"rtrancl3p r a bs a''\"\n  and refl: \"P a'' []\"\n  and step: \"\\<And>a b a' bs. \\<lbrakk> rtrancl3p r a' bs a''; r a b a'; P a' bs \\<rbrakk> \\<Longrightarrow> P a (b # bs)\"\n  shows \"P a bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a bs", "using rtrancl3p_converse_induct[OF ih, where P=\"\\<lambda>a bs a'. a' = a'' \\<longrightarrow> P a bs\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a. a = a'' \\<longrightarrow> P a [];\n   \\<And>a b a' bs a''a.\n      \\<lbrakk>rtrancl3p r a' bs a''a; r a b a';\n       a''a = a'' \\<longrightarrow> P a' bs\\<rbrakk>\n      \\<Longrightarrow> a''a = a'' \\<longrightarrow> P a (b # bs)\\<rbrakk>\n  \\<Longrightarrow> a'' = a'' \\<longrightarrow> P a bs\n\ngoal (1 subgoal):\n 1. P a bs", "by(auto intro: refl step)"], ["", "lemma rtrancl3p_converseE[consumes 1, case_names refl step]:\n  \"\\<lbrakk> rtrancl3p r a bs a'';\n     \\<lbrakk> a = a''; bs = [] \\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>bs' b a'. \\<lbrakk> bs = b # bs'; r a b a'; rtrancl3p r a' bs' a'' \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk>\n  \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtrancl3p r a bs a'';\n     \\<lbrakk>a = a''; bs = []\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>bs' b a'.\n        \\<lbrakk>bs = b # bs'; r a b a'; rtrancl3p r a' bs' a''\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(induct rule: rtrancl3p_converse_induct)(auto)"], ["", "lemma rtrancl3p_induct' [consumes 1, case_names refl step]:\n  assumes major: \"rtrancl3p r a bs c\"\n  and refl: \"P a [] a\"\n  and step: \"\\<And>bs a' b a''. \\<lbrakk> rtrancl3p r a bs a'; P a bs a'; r a' b a'' \\<rbrakk>\n             \\<Longrightarrow> P a (bs @ [b]) a''\"\n  shows \"P a bs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a bs c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P a bs c", "from major"], ["proof (chain)\npicking this:\n  rtrancl3p r a bs c", "have \"(P a [] a \\<and> (\\<forall>bs a' b a''. rtrancl3p r a bs a' \\<and> P a bs a' \\<and> r a' b a'' \\<longrightarrow> P a (bs @ [b]) a'')) \\<longrightarrow> P a bs c\""], ["proof (prove)\nusing this:\n  rtrancl3p r a bs c\n\ngoal (1 subgoal):\n 1. P a [] a \\<and>\n    (\\<forall>bs a' b a''.\n        rtrancl3p r a bs a' \\<and>\n        P a bs a' \\<and> r a' b a'' \\<longrightarrow>\n        P a (bs @ [b]) a'') \\<longrightarrow>\n    P a bs c", "by-(erule rtrancl3p.induct, blast+)"], ["proof (state)\nthis:\n  P a [] a \\<and>\n  (\\<forall>bs a' b a''.\n      rtrancl3p r a bs a' \\<and>\n      P a bs a' \\<and> r a' b a'' \\<longrightarrow>\n      P a (bs @ [b]) a'') \\<longrightarrow>\n  P a bs c\n\ngoal (1 subgoal):\n 1. P a bs c", "with refl step"], ["proof (chain)\npicking this:\n  P a [] a\n  \\<lbrakk>rtrancl3p r a ?bs ?a'; P a ?bs ?a'; r ?a' ?b ?a''\\<rbrakk>\n  \\<Longrightarrow> P a (?bs @ [?b]) ?a''\n  P a [] a \\<and>\n  (\\<forall>bs a' b a''.\n      rtrancl3p r a bs a' \\<and>\n      P a bs a' \\<and> r a' b a'' \\<longrightarrow>\n      P a (bs @ [b]) a'') \\<longrightarrow>\n  P a bs c", "show ?thesis"], ["proof (prove)\nusing this:\n  P a [] a\n  \\<lbrakk>rtrancl3p r a ?bs ?a'; P a ?bs ?a'; r ?a' ?b ?a''\\<rbrakk>\n  \\<Longrightarrow> P a (?bs @ [?b]) ?a''\n  P a [] a \\<and>\n  (\\<forall>bs a' b a''.\n      rtrancl3p r a bs a' \\<and>\n      P a bs a' \\<and> r a' b a'' \\<longrightarrow>\n      P a (bs @ [b]) a'') \\<longrightarrow>\n  P a bs c\n\ngoal (1 subgoal):\n 1. P a bs c", "by blast"], ["proof (state)\nthis:\n  P a bs c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_into_rtrancl3p:\n  \"r a b a' \\<Longrightarrow> rtrancl3p r a [b] a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r a b a' \\<Longrightarrow> rtrancl3p r a [b] a'", "by(rule rtrancl3p_step_converse) auto"], ["", "lemma rtrancl3p_appendE:\n  assumes \"rtrancl3p r a (bs @ bs') a''\"\n  obtains a' where \"rtrancl3p r a bs a'\" \"rtrancl3p r a' bs' a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>rtrancl3p r a bs a'; rtrancl3p r a' bs' a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  rtrancl3p r a (bs @ bs') a''\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>rtrancl3p r a bs a'; rtrancl3p r a' bs' a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(induct a \"bs @ bs'\" arbitrary: bs rule: rtrancl3p_converse_induct')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<lbrakk>[] = bs @ bs';\n        \\<And>a'.\n           \\<lbrakk>rtrancl3p r a'' bs a'; rtrancl3p r a' bs' a''\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a b a' bs bsa.\n       \\<lbrakk>rtrancl3p r a' bs a''; r a b a';\n        \\<And>bsa.\n           \\<lbrakk>bs = bsa @ bs';\n            \\<And>a'a.\n               \\<lbrakk>rtrancl3p r a' bsa a'a;\n                rtrancl3p r a'a bs' a''\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        b # bs = bsa @ bs';\n        \\<And>a'.\n           \\<lbrakk>rtrancl3p r a bsa a'; rtrancl3p r a' bs' a''\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(fastforce intro: rtrancl3p_step_converse simp add: Cons_eq_append_conv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rtrancl3p_Cons:\n  \"rtrancl3p r a (b # bs) a' \\<longleftrightarrow> (\\<exists>a''. r a b a'' \\<and> rtrancl3p r a'' bs a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p r a (b # bs) a' =\n    (\\<exists>a''. r a b a'' \\<and> rtrancl3p r a'' bs a')", "by(auto intro: rtrancl3p_step_converse converse_rtrancl3p_step)"], ["", "lemma rtrancl3p_Nil:\n  \"rtrancl3p r a [] a' \\<longleftrightarrow> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p r a [] a' = (a = a')", "by(auto elim: rtrancl3p_cases)"], ["", "definition invariant3p :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a set \\<Rightarrow> bool\"\nwhere \"invariant3p r I \\<longleftrightarrow> (\\<forall>s tl s'. s \\<in> I \\<longrightarrow> r s tl s' \\<longrightarrow> s' \\<in> I)\""], ["", "lemma invariant3pI: \"(\\<And>s tl s'. \\<lbrakk> s \\<in> I; r s tl s' \\<rbrakk> \\<Longrightarrow> s' \\<in> I) \\<Longrightarrow> invariant3p r I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s tl s'.\n        \\<lbrakk>s \\<in> I; r s tl s'\\<rbrakk>\n        \\<Longrightarrow> s' \\<in> I) \\<Longrightarrow>\n    invariant3p r I", "unfolding invariant3p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s tl s'.\n        \\<lbrakk>s \\<in> I; r s tl s'\\<rbrakk>\n        \\<Longrightarrow> s' \\<in> I) \\<Longrightarrow>\n    \\<forall>s tl s'.\n       s \\<in> I \\<longrightarrow> r s tl s' \\<longrightarrow> s' \\<in> I", "by blast"], ["", "lemma invariant3pD: \"\\<And>tl. \\<lbrakk> invariant3p r I; r s tl s'; s \\<in> I \\<rbrakk> \\<Longrightarrow> s' \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tl.\n       \\<lbrakk>invariant3p r I; r s tl s'; s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> I", "unfolding invariant3p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tl.\n       \\<lbrakk>\\<forall>s tl s'.\n                   s \\<in> I \\<longrightarrow>\n                   r s tl s' \\<longrightarrow> s' \\<in> I;\n        r s tl s'; s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> I", "by(blast)"], ["", "lemma invariant3p_rtrancl3p: \n  assumes inv: \"invariant3p r I\"\n  and rtrancl: \"rtrancl3p r a bs a'\"\n  and start: \"a \\<in> I\"\n  shows \"a' \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<in> I", "using rtrancl start"], ["proof (prove)\nusing this:\n  rtrancl3p r a bs a'\n  a \\<in> I\n\ngoal (1 subgoal):\n 1. a' \\<in> I", "by(induct)(auto dest: invariant3pD[OF inv])"], ["", "lemma invariant3p_UNIV [simp, intro!]:\n  \"invariant3p r UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant3p r UNIV", "by(blast intro: invariant3pI)"], ["", "lemma invarinat3p_empty [simp, intro!]:\n  \"invariant3p r {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant3p r {}", "by(blast intro: invariant3pI)"], ["", "lemma invariant3p_IntI [simp, intro]:\n  \"\\<lbrakk> invariant3p r I; invariant3p r J \\<rbrakk> \\<Longrightarrow> invariant3p r (I \\<inter> J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant3p r I; invariant3p r J\\<rbrakk>\n    \\<Longrightarrow> invariant3p r (I \\<inter> J)", "by(blast dest: invariant3pD intro: invariant3pI)"], ["", "subsection \\<open>Concatenation for @{typ String.literal}\\<close>"], ["", "definition concat :: \"String.literal list \\<Rightarrow> String.literal\"\n  where [code_abbrev, code del]: \"concat = sum_list\""], ["", "lemma explode_add [simp]:\n  \"String.explode (s + t) = String.explode s @ String.explode t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal.explode (s + t) = literal.explode s @ literal.explode t", "by (fact plus_literal.rep_eq)"], ["", "code_printing\n  constant concat \\<rightharpoonup>\n    (SML) \"String.concat\"\n    and (Haskell) \"concat\"\n    and (OCaml) \"String.concat \\\"\\\"\""], ["", "hide_const (open) concat"], ["", "end"]]}