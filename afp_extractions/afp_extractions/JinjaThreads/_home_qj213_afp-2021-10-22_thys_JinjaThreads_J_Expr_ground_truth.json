{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/J/Expr.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma inj_Val [simp]: \"inj Val\"", "lemma expr_ineqs [simp]: \"Val v ;; e \\<noteq> e\" \"if (e1) e else e2 \\<noteq> e\" \"if (e1) e2 else e \\<noteq> e\"", "lemma [simp]: \"fvs(es @ es') = fvs es \\<union> fvs es'\"", "lemma [simp]: \"fvs(map Val vs) = {}\"", "lemma expr_lockss_append [simp]:\n  \"expr_lockss (es @ es') = (\\<lambda>ad. expr_lockss es ad + expr_lockss es' ad)\"", "lemma expr_lockss_map_Val [simp]: \"expr_lockss (map Val vs) = (\\<lambda>ad. 0)\"", "lemma contains_insyncs_append [simp]:\n  \"contains_insyncs (es @ es') \\<longleftrightarrow> contains_insyncs es \\<or> contains_insyncs es'\"", "lemma fixes e :: \"('a, 'b, 'addr) exp\"\n  and es :: \"('a, 'b, 'addr) exp list\"\n  shows contains_insync_conv: \"(contains_insync e \\<longleftrightarrow> (\\<exists>ad. expr_locks e ad > 0))\"\n    and contains_insyncs_conv: \"(contains_insyncs es \\<longleftrightarrow> (\\<exists>ad. expr_lockss es ad > 0))\"", "lemma contains_insyncs_map_Val [simp]: \"\\<not> contains_insyncs (map Val vs)\"", "lemma is_val_iff: \"is_val e \\<longleftrightarrow> (\\<exists>v. e = Val v)\"", "lemma is_vals_append [simp]: \"is_vals (es @ es') \\<longleftrightarrow> is_vals es \\<and> is_vals es'\"", "lemma is_vals_conv: \"is_vals es = (\\<exists>vs. es = map Val vs)\"", "lemma is_vals_map_Vals [simp]: \"is_vals (map Val vs) = True\"", "lemma [simp]: \"(is_addr e) \\<longleftrightarrow> (\\<exists>a. e = addr a)\"", "lemma is_Throws_conv: \"is_Throws es \\<longleftrightarrow> (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma [simp]:\n  \"\\<lbrakk> size vs = size Vs; size Ts = size Vs \\<rbrakk> \\<Longrightarrow> fv (blocks Vs Ts vs e) = fv e - set Vs\"", "lemma expr_locks_blocks:\n  \"\\<lbrakk> length vs = length pns; length Ts = length pns \\<rbrakk>\n  \\<Longrightarrow> expr_locks (blocks pns Ts vs e) = expr_locks e\"", "lemmas finalE[consumes 1, case_names Val Throw] = final.cases", "lemma final_iff: \"final e \\<longleftrightarrow> (\\<exists>v. e = Val v) \\<or> (\\<exists>a. e = Throw a)\"", "lemma final_locks: \"final e \\<Longrightarrow> expr_locks e l = 0\"", "lemma [iff]: \"finals []\"", "lemma [iff]: \"finals (Val v # es) = finals es\"", "lemma finals_app_map [iff]: \"finals (map Val vs @ es) = finals es\"", "lemma [iff]: \"finals (throw e # es) = (\\<exists>a. e = addr a)\"", "lemma not_finals_ConsI: \"\\<not> final e \\<Longrightarrow> \\<not> finals (e # es)\"", "lemma finals_iff: \"finals es \\<longleftrightarrow> (\\<exists>vs. es = map Val vs) \\<or> (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma fv_extRet2J [simp]: \"fv (extRet2J e va) \\<subseteq> fv e\"", "lemma calls_append [simp]:\n  \"calls (es @ es') = (if calls es = None \\<and> is_vals es then calls es' else calls es)\"", "lemma call_callE [consumes 1, case_names CallObj CallParams Call]:\n  \"\\<lbrakk> call (obj\\<bullet>M(pns)) = \\<lfloor>(a, M', vs)\\<rfloor>;\n     call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow> thesis; \n     \\<And>v. \\<lbrakk> obj = Val v; calls pns = \\<lfloor>(a, M', vs)\\<rfloor> \\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk> obj = addr a; pns = map Val vs; M = M' \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma calls_map_Val [simp]:\n  \"calls (map Val vs) = None\"", "lemma call_not_is_val [dest]: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<not> is_val e\"", "lemma is_calls_not_is_vals [dest]: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<not> is_vals es\""], "translations": [["", "lemma inj_Val [simp]: \"inj Val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj Val", "by(rule inj_onI)(simp)"], ["", "lemma expr_ineqs [simp]: \"Val v ;; e \\<noteq> e\" \"if (e1) e else e2 \\<noteq> e\" \"if (e1) e2 else e \\<noteq> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Val v;; e \\<noteq> e &&&\n    if (e1) e else e2 \\<noteq> e &&& if (e1) e2 else e \\<noteq> e", "by(induct e) auto"], ["", "subsection\\<open>Free Variables\\<close>"], ["", "primrec fv  :: \"('a,'b,'addr) exp      \\<Rightarrow> 'a set\"\n  and fvs :: \"('a,'b,'addr) exp list \\<Rightarrow> 'a set\"\nwhere\n  \"fv(new C) = {}\"\n| \"fv(newA T\\<lfloor>e\\<rceil>) = fv e\"\n| \"fv(Cast C e) = fv e\"\n| \"fv(e instanceof T) = fv e\"\n| \"fv(Val v) = {}\"\n| \"fv(e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) = fv e\\<^sub>1 \\<union> fv e\\<^sub>2\"\n| \"fv(Var V) = {V}\"\n| \"fv(a\\<lfloor>i\\<rceil>) = fv a \\<union> fv i\"\n| \"fv(AAss a i e) = fv a \\<union> fv i \\<union> fv e\"\n| \"fv(a\\<bullet>length) = fv a\"\n| \"fv(LAss V e) = {V} \\<union> fv e\"\n| \"fv(e\\<bullet>F{D}) = fv e\"\n| \"fv(FAss e\\<^sub>1 F D e\\<^sub>2) = fv e\\<^sub>1 \\<union> fv e\\<^sub>2\"\n| \"fv(e\\<^sub>1\\<bullet>compareAndSwap(D\\<bullet>F, e\\<^sub>2, e\\<^sub>3)) = fv e\\<^sub>1 \\<union> fv e\\<^sub>2 \\<union> fv e\\<^sub>3\"\n| \"fv(e\\<bullet>M(es)) = fv e \\<union> fvs es\"\n| \"fv({V:T=vo; e}) = fv e - {V}\"\n| \"fv(sync\\<^bsub>V\\<^esub> (h) e) = fv h \\<union> fv e\"\n| \"fv(insync\\<^bsub>V\\<^esub> (a) e) = fv e\"\n| \"fv(e\\<^sub>1;;e\\<^sub>2) = fv e\\<^sub>1 \\<union> fv e\\<^sub>2\"\n| \"fv(if (b) e\\<^sub>1 else e\\<^sub>2) = fv b \\<union> fv e\\<^sub>1 \\<union> fv e\\<^sub>2\"\n| \"fv(while (b) e) = fv b \\<union> fv e\"\n| \"fv(throw e) = fv e\"\n| \"fv(try e\\<^sub>1 catch(C V) e\\<^sub>2) = fv e\\<^sub>1 \\<union> (fv e\\<^sub>2 - {V})\"\n\n| \"fvs([]) = {}\"\n| \"fvs(e#es) = fv e \\<union> fvs es\""], ["", "lemma [simp]: \"fvs(es @ es') = fvs es \\<union> fvs es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fvs (es @ es') = fvs es \\<union> fvs es'", "by(induct es) auto"], ["", "lemma [simp]: \"fvs(map Val vs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fvs (map Val vs) = {}", "by (induct vs) auto"], ["", "subsection\\<open>Locks and addresses\\<close>"], ["", "primrec expr_locks :: \"('a,'b,'addr) exp \\<Rightarrow> 'addr \\<Rightarrow> nat\"\n  and expr_lockss :: \"('a,'b,'addr) exp list \\<Rightarrow> 'addr \\<Rightarrow> nat\"\nwhere\n  \"expr_locks (new C) = (\\<lambda>ad. 0)\"\n| \"expr_locks (newA T\\<lfloor>e\\<rceil>) = expr_locks e\"\n| \"expr_locks (Cast T e) = expr_locks e\"\n| \"expr_locks (e instanceof T) = expr_locks e\"\n| \"expr_locks (Val v) = (\\<lambda>ad. 0)\"\n| \"expr_locks (Var v) = (\\<lambda>ad. 0)\"\n| \"expr_locks (e \\<guillemotleft>bop\\<guillemotright> e') = (\\<lambda>ad. expr_locks e ad + expr_locks e' ad)\"\n| \"expr_locks (V := e) = expr_locks e\"\n| \"expr_locks (a\\<lfloor>i\\<rceil>) = (\\<lambda>ad. expr_locks a ad + expr_locks i ad)\"\n| \"expr_locks (AAss a i e) = (\\<lambda>ad. expr_locks a ad + expr_locks i ad + expr_locks e ad)\"\n| \"expr_locks (a\\<bullet>length) = expr_locks a\"\n| \"expr_locks (e\\<bullet>F{D}) = expr_locks e\"\n| \"expr_locks (FAss e F D e') = (\\<lambda>ad. expr_locks e ad + expr_locks e' ad)\"\n| \"expr_locks (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) = (\\<lambda>ad. expr_locks e ad + expr_locks e' ad + expr_locks e'' ad)\"\n| \"expr_locks (e\\<bullet>m(ps)) = (\\<lambda>ad. expr_locks e ad + expr_lockss ps ad)\"\n| \"expr_locks ({V : T=vo; e}) = expr_locks e\"\n| \"expr_locks (sync\\<^bsub>V\\<^esub> (o') e) = (\\<lambda>ad. expr_locks o' ad + expr_locks e ad)\"\n| \"expr_locks (insync\\<^bsub>V\\<^esub> (a) e) = (\\<lambda>ad. if (a = ad) then Suc (expr_locks e ad) else expr_locks e ad)\"\n| \"expr_locks (e;;e') = (\\<lambda>ad. expr_locks e ad + expr_locks e' ad)\"\n| \"expr_locks (if (b) e else e') = (\\<lambda>ad. expr_locks b ad + expr_locks e ad + expr_locks e' ad)\"\n| \"expr_locks (while (b) e) = (\\<lambda>ad. expr_locks b ad + expr_locks e ad)\"\n| \"expr_locks (throw e) = expr_locks e\"\n| \"expr_locks (try e catch(C v) e') = (\\<lambda>ad. expr_locks e ad + expr_locks e' ad)\"\n\n| \"expr_lockss [] = (\\<lambda>a. 0)\"\n| \"expr_lockss (x#xs) = (\\<lambda>ad. expr_locks x ad + expr_lockss xs ad)\""], ["", "lemma expr_lockss_append [simp]:\n  \"expr_lockss (es @ es') = (\\<lambda>ad. expr_lockss es ad + expr_lockss es' ad)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expr_lockss (es @ es') =\n    (\\<lambda>ad. expr_lockss es ad + expr_lockss es' ad)", "by(induct es) auto"], ["", "lemma expr_lockss_map_Val [simp]: \"expr_lockss (map Val vs) = (\\<lambda>ad. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expr_lockss (map Val vs) = (\\<lambda>ad. 0)", "by(induct vs) auto"], ["", "primrec contains_insync :: \"('a,'b,'addr) exp \\<Rightarrow> bool\"\n  and contains_insyncs :: \"('a,'b,'addr) exp list \\<Rightarrow> bool\"\nwhere\n  \"contains_insync (new C) = False\"\n| \"contains_insync (newA T\\<lfloor>i\\<rceil>) = contains_insync i\"\n| \"contains_insync (Cast T e) = contains_insync e\"\n| \"contains_insync (e instanceof T) = contains_insync e\"\n| \"contains_insync (Val v) = False\"\n| \"contains_insync (Var v) = False\"\n| \"contains_insync (e \\<guillemotleft>bop\\<guillemotright> e') = (contains_insync e \\<or> contains_insync e')\"\n| \"contains_insync (V := e) = contains_insync e\"\n| \"contains_insync (a\\<lfloor>i\\<rceil>) = (contains_insync a \\<or> contains_insync i)\"\n| \"contains_insync (AAss a i e) = (contains_insync a \\<or> contains_insync i \\<or> contains_insync e)\"\n| \"contains_insync (a\\<bullet>length) = contains_insync a\"\n| \"contains_insync (e\\<bullet>F{D}) = contains_insync e\"\n| \"contains_insync (FAss e F D e') = (contains_insync e \\<or> contains_insync e')\"\n| \"contains_insync (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) = (contains_insync e \\<or> contains_insync e' \\<or> contains_insync e'')\"\n| \"contains_insync (e\\<bullet>m(pns)) = (contains_insync e \\<or> contains_insyncs pns)\"\n| \"contains_insync ({V : T=vo; e}) = contains_insync e\"\n| \"contains_insync (sync\\<^bsub>V\\<^esub> (o') e) = (contains_insync o' \\<or> contains_insync e)\"\n| \"contains_insync (insync\\<^bsub>V\\<^esub> (a) e) = True\"\n| \"contains_insync (e;;e') = (contains_insync e \\<or> contains_insync e')\"\n| \"contains_insync (if (b) e else e') = (contains_insync b \\<or> contains_insync e \\<or> contains_insync e')\"\n| \"contains_insync (while (b) e) = (contains_insync b \\<or> contains_insync e)\"\n| \"contains_insync (throw e) = contains_insync e\"\n| \"contains_insync (try e catch(C v) e') = (contains_insync e \\<or> contains_insync e')\"\n\n| \"contains_insyncs [] = False\"\n| \"contains_insyncs (x # xs) = (contains_insync x \\<or> contains_insyncs xs)\""], ["", "lemma contains_insyncs_append [simp]:\n  \"contains_insyncs (es @ es') \\<longleftrightarrow> contains_insyncs es \\<or> contains_insyncs es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contains_insyncs (es @ es') =\n    (contains_insyncs es \\<or> contains_insyncs es')", "by(induct es, auto)"], ["", "lemma fixes e :: \"('a, 'b, 'addr) exp\"\n  and es :: \"('a, 'b, 'addr) exp list\"\n  shows contains_insync_conv: \"(contains_insync e \\<longleftrightarrow> (\\<exists>ad. expr_locks e ad > 0))\"\n    and contains_insyncs_conv: \"(contains_insyncs es \\<longleftrightarrow> (\\<exists>ad. expr_lockss es ad > 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contains_insync e = (\\<exists>ad. 0 < expr_locks e ad) &&&\n    contains_insyncs es = (\\<exists>ad. 0 < expr_lockss es ad)", "by(induct e and es rule: expr_locks.induct expr_lockss.induct)(auto)"], ["", "lemma contains_insyncs_map_Val [simp]: \"\\<not> contains_insyncs (map Val vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> contains_insyncs (map Val vs)", "by(induct vs) auto"], ["", "subsection \\<open>Value expressions\\<close>"], ["", "inductive is_val :: \"('a,'b,'addr) exp \\<Rightarrow> bool\" where\n  \"is_val (Val v)\""], ["", "declare is_val.intros [simp]"], ["", "declare is_val.cases [elim!]"], ["", "lemma is_val_iff: \"is_val e \\<longleftrightarrow> (\\<exists>v. e = Val v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_val e = (\\<exists>v. e = Val v)", "by(auto)"], ["", "code_pred is_val"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun is_vals :: \"('a,'b,'addr) exp list \\<Rightarrow> bool\" where\n  \"is_vals [] = True\"\n| \"is_vals (e#es) = (is_val e \\<and> is_vals es)\""], ["", "lemma is_vals_append [simp]: \"is_vals (es @ es') \\<longleftrightarrow> is_vals es \\<and> is_vals es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vals (es @ es') = (is_vals es \\<and> is_vals es')", "by(induct es) auto"], ["", "lemma is_vals_conv: \"is_vals es = (\\<exists>vs. es = map Val vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vals es = (\\<exists>vs. es = map Val vs)", "by(induct es)(auto simp add: Cons_eq_map_conv)"], ["", "lemma is_vals_map_Vals [simp]: \"is_vals (map Val vs) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vals (map Val vs) = True", "unfolding is_vals_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>vsa. map Val vs = map Val vsa) = True", "by auto"], ["", "inductive is_addr :: \"('a,'b,'addr) exp \\<Rightarrow> bool\"\nwhere \"is_addr (addr a)\""], ["", "declare is_addr.intros[intro!]"], ["", "declare is_addr.cases[elim!]"], ["", "lemma [simp]: \"(is_addr e) \\<longleftrightarrow> (\\<exists>a. e = addr a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_addr e = (\\<exists>a. e = addr a)", "by auto"], ["", "primrec the_Val :: \"('a, 'b, 'addr) exp \\<Rightarrow> 'addr val\"\nwhere\n  \"the_Val (Val v) = v\""], ["", "inductive is_Throws :: \"('a, 'b, 'addr) exp list \\<Rightarrow> bool\"\nwhere\n  \"is_Throws (Throw a # es)\"\n| \"is_Throws es \\<Longrightarrow> is_Throws (Val v # es)\""], ["", "inductive_simps is_Throws_simps:\n  \"is_Throws []\"\n  \"is_Throws (e # es)\""], ["", "code_pred is_Throws"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma is_Throws_conv: \"is_Throws es \\<longleftrightarrow> (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Throws es = (\\<exists>vs a es'. es = map Val vs @ Throw a # es')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_Throws es \\<Longrightarrow>\n    \\<exists>vs a es'. es = map Val vs @ Throw a # es'\n 2. \\<exists>vs a es'. es = map Val vs @ Throw a # es' \\<Longrightarrow>\n    is_Throws es", "assume ?lhs"], ["proof (state)\nthis:\n  is_Throws es\n\ngoal (2 subgoals):\n 1. is_Throws es \\<Longrightarrow>\n    \\<exists>vs a es'. es = map Val vs @ Throw a # es'\n 2. \\<exists>vs a es'. es = map Val vs @ Throw a # es' \\<Longrightarrow>\n    is_Throws es", "thus ?rhs"], ["proof (prove)\nusing this:\n  is_Throws es\n\ngoal (1 subgoal):\n 1. \\<exists>vs a es'. es = map Val vs @ Throw a # es'", "by(induct)(fastforce simp add: Cons_eq_append_conv Cons_eq_map_conv)+"], ["proof (state)\nthis:\n  \\<exists>vs a es'. es = map Val vs @ Throw a # es'\n\ngoal (1 subgoal):\n 1. \\<exists>vs a es'. es = map Val vs @ Throw a # es' \\<Longrightarrow>\n    is_Throws es", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>vs a es'. es = map Val vs @ Throw a # es' \\<Longrightarrow>\n    is_Throws es", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>vs a es'. es = map Val vs @ Throw a # es'\n\ngoal (1 subgoal):\n 1. \\<exists>vs a es'. es = map Val vs @ Throw a # es' \\<Longrightarrow>\n    is_Throws es", "thus ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>vs a es'. es = map Val vs @ Throw a # es'\n\ngoal (1 subgoal):\n 1. is_Throws es", "by(induct es)(auto simp add: is_Throws_simps Cons_eq_map_conv Cons_eq_append_conv)"], ["proof (state)\nthis:\n  is_Throws es\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\<open>blocks\\<close>\\<close>"], ["", "fun blocks :: \"'a list \\<Rightarrow> ty list \\<Rightarrow> 'addr val list \\<Rightarrow> ('a,'b,'addr) exp \\<Rightarrow> ('a,'b,'addr) exp\"\nwhere\n  \"blocks (V # Vs) (T # Ts) (v # vs) e = {V:T=\\<lfloor>v\\<rfloor>; blocks Vs Ts vs e}\"\n| \"blocks []       []       []       e = e\""], ["", "lemma [simp]:\n  \"\\<lbrakk> size vs = size Vs; size Ts = size Vs \\<rbrakk> \\<Longrightarrow> fv (blocks Vs Ts vs e) = fv e - set Vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length Vs; length Ts = length Vs\\<rbrakk>\n    \\<Longrightarrow> fv (blocks Vs Ts vs e) = fv e - set Vs", "by(induct rule:blocks.induct)(simp_all, blast)"], ["", "lemma expr_locks_blocks:\n  \"\\<lbrakk> length vs = length pns; length Ts = length pns \\<rbrakk>\n  \\<Longrightarrow> expr_locks (blocks pns Ts vs e) = expr_locks e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length pns; length Ts = length pns\\<rbrakk>\n    \\<Longrightarrow> expr_locks (blocks pns Ts vs e) = expr_locks e", "by(induct pns Ts vs e rule: blocks.induct)(auto)"], ["", "subsection \\<open>Final expressions\\<close>"], ["", "inductive final :: \"('a,'b,'addr) exp \\<Rightarrow> bool\" where\n  \"final (Val v)\"\n| \"final (Throw a)\""], ["", "declare final.cases [elim]"], ["", "declare final.intros[simp]"], ["", "lemmas finalE[consumes 1, case_names Val Throw] = final.cases"], ["", "lemma final_iff: \"final e \\<longleftrightarrow> (\\<exists>v. e = Val v) \\<or> (\\<exists>a. e = Throw a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final e = ((\\<exists>v. e = Val v) \\<or> (\\<exists>a. e = Throw a))", "by(auto)"], ["", "lemma final_locks: \"final e \\<Longrightarrow> expr_locks e l = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final e \\<Longrightarrow> expr_locks e l = 0", "by(auto elim: finalE)"], ["", "inductive finals :: \"('a,'b,'addr) exp list \\<Rightarrow> bool\"\nwhere\n  \"finals []\"\n| \"finals (Throw a # es)\"\n| \"finals es \\<Longrightarrow> finals (Val v # es)\""], ["", "inductive_simps finals_simps:\n  \"finals (e # es)\""], ["", "lemma [iff]: \"finals []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finals []", "by(rule finals.intros)"], ["", "lemma [iff]: \"finals (Val v # es) = finals es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finals (Val v # es) = finals es", "by(simp add: finals_simps)"], ["", "lemma finals_app_map [iff]: \"finals (map Val vs @ es) = finals es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finals (map Val vs @ es) = finals es", "by(induct vs) simp_all"], ["", "lemma [iff]: \"finals (throw e # es) = (\\<exists>a. e = addr a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finals (throw e # es) = (\\<exists>a. e = addr a)", "by(simp add: finals_simps)"], ["", "lemma not_finals_ConsI: \"\\<not> final e \\<Longrightarrow> \\<not> finals (e # es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> final e \\<Longrightarrow> \\<not> finals (e # es)", "by(simp add: finals_simps final_iff)"], ["", "lemma finals_iff: \"finals es \\<longleftrightarrow> (\\<exists>vs. es = map Val vs) \\<or> (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finals es =\n    ((\\<exists>vs. es = map Val vs) \\<or>\n     (\\<exists>vs a es'. es = map Val vs @ Throw a # es'))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finals es \\<Longrightarrow>\n    (\\<exists>vs. es = map Val vs) \\<or>\n    (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\n 2. (\\<exists>vs. es = map Val vs) \\<or>\n    (\\<exists>vs a es'. es = map Val vs @ Throw a # es') \\<Longrightarrow>\n    finals es", "assume ?lhs"], ["proof (state)\nthis:\n  finals es\n\ngoal (2 subgoals):\n 1. finals es \\<Longrightarrow>\n    (\\<exists>vs. es = map Val vs) \\<or>\n    (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\n 2. (\\<exists>vs. es = map Val vs) \\<or>\n    (\\<exists>vs a es'. es = map Val vs @ Throw a # es') \\<Longrightarrow>\n    finals es", "thus ?rhs"], ["proof (prove)\nusing this:\n  finals es\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. es = map Val vs) \\<or>\n    (\\<exists>vs a es'. es = map Val vs @ Throw a # es')", "by induct(auto simp add: Cons_eq_append_conv Cons_eq_map_conv, metis)"], ["proof (state)\nthis:\n  (\\<exists>vs. es = map Val vs) \\<or>\n  (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. es = map Val vs) \\<or>\n    (\\<exists>vs a es'. es = map Val vs @ Throw a # es') \\<Longrightarrow>\n    finals es", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>vs. es = map Val vs) \\<or>\n    (\\<exists>vs a es'. es = map Val vs @ Throw a # es') \\<Longrightarrow>\n    finals es", "assume ?rhs"], ["proof (state)\nthis:\n  (\\<exists>vs. es = map Val vs) \\<or>\n  (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. es = map Val vs) \\<or>\n    (\\<exists>vs a es'. es = map Val vs @ Throw a # es') \\<Longrightarrow>\n    finals es", "thus ?lhs"], ["proof (prove)\nusing this:\n  (\\<exists>vs. es = map Val vs) \\<or>\n  (\\<exists>vs a es'. es = map Val vs @ Throw a # es')\n\ngoal (1 subgoal):\n 1. finals es", "by(induct es) auto"], ["proof (state)\nthis:\n  finals es\n\ngoal:\nNo subgoals!", "qed"], ["", "code_pred final"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>converting results from external calls\\<close>"], ["", "primrec extRet2J :: \"('a, 'b, 'addr) exp \\<Rightarrow> 'addr extCallRet \\<Rightarrow> ('a, 'b, 'addr) exp\"\nwhere\n  \"extRet2J e (RetVal v) = Val v\"\n| \"extRet2J e (RetExc a) = Throw a\"\n| \"extRet2J e RetStaySame = e\""], ["", "lemma fv_extRet2J [simp]: \"fv (extRet2J e va) \\<subseteq> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (extRet2J e va) \\<subseteq> fv e", "by(cases va) simp_all"], ["", "subsection \\<open>expressions at a call\\<close>"], ["", "primrec call :: \"('a,'b,'addr) exp \\<Rightarrow> ('addr \\<times> mname \\<times> 'addr val list) option\"\n  and calls :: \"('a,'b,'addr) exp list \\<Rightarrow> ('addr \\<times> mname \\<times> 'addr val list) option\"\nwhere\n  \"call (new C) = None\"\n| \"call (newA T\\<lfloor>e\\<rceil>) = call e\"\n| \"call (Cast C e) = call e\"\n| \"call (e instanceof T) = call e\"\n| \"call (Val v) = None\"\n| \"call (Var V) = None\"\n| \"call (V:=e) = call e\"\n| \"call (e \\<guillemotleft>bop\\<guillemotright> e') = (if is_val e then call e' else call e)\"\n| \"call (a\\<lfloor>i\\<rceil>) = (if is_val a then call i else call a)\"\n| \"call (AAss a i e) = (if is_val a then (if is_val i then call e else call i) else call a)\"\n| \"call (a\\<bullet>length) = call a\"\n| \"call (e\\<bullet>F{D}) = call e\"\n| \"call (FAss e F D e') = (if is_val e then call e' else call e)\"\n| \"call (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) = (if is_val e then if is_val e' then call e'' else call e' else call e)\"\n| \"call (e\\<bullet>M(es)) = (if is_val e then\n                     (if is_vals es \\<and> is_addr e then \\<lfloor>(THE a. e = addr a, M, THE vs. es = map Val vs)\\<rfloor> else calls es) \n                     else call e)\"\n| \"call ({V:T=vo; e}) = call e\"\n| \"call (sync\\<^bsub>V\\<^esub> (o') e) = call o'\"\n| \"call (insync\\<^bsub>V\\<^esub> (a) e) = call e\"\n| \"call (e;;e') = call e\"\n| \"call (if (e) e1 else e2) = call e\"\n| \"call (while(b) e) = None\"\n| \"call (throw e) = call e\"\n| \"call (try e1 catch(C V) e2) = call e1\"\n\n| \"calls [] = None\"\n| \"calls (e#es) = (if is_val e then calls es else call e)\""], ["", "lemma calls_append [simp]:\n  \"calls (es @ es') = (if calls es = None \\<and> is_vals es then calls es' else calls es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calls (es @ es') =\n    (if calls es = None \\<and> is_vals es then calls es' else calls es)", "by(induct es) auto"], ["", "lemma call_callE [consumes 1, case_names CallObj CallParams Call]:\n  \"\\<lbrakk> call (obj\\<bullet>M(pns)) = \\<lfloor>(a, M', vs)\\<rfloor>;\n     call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow> thesis; \n     \\<And>v. \\<lbrakk> obj = Val v; calls pns = \\<lfloor>(a, M', vs)\\<rfloor> \\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk> obj = addr a; pns = map Val vs; M = M' \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>call (obj\\<bullet>M(pns)) = \\<lfloor>(a, M', vs)\\<rfloor>;\n     call obj = \\<lfloor>(a, M', vs)\\<rfloor> \\<Longrightarrow> thesis;\n     \\<And>v.\n        \\<lbrakk>obj = Val v;\n         calls pns = \\<lfloor>(a, M', vs)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>obj = addr a; pns = map Val vs; M = M'\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto split: if_split_asm simp add: is_vals_conv)"], ["", "lemma calls_map_Val [simp]:\n  \"calls (map Val vs) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calls (map Val vs) = None", "by(induct vs) auto"], ["", "lemma call_not_is_val [dest]: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<not> is_val e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<not> is_val e", "by(cases e) auto"], ["", "lemma is_calls_not_is_vals [dest]: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<not> is_vals es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<not> is_vals es", "by(induct es) auto"], ["", "end"]]}