{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/Compiler2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemmas compxE2_compxEs2_induct =\n  compxE2_compxEs2.induct[\n    unfolded meta_all5_eq_conv meta_all4_eq_conv meta_all3_eq_conv meta_all2_eq_conv meta_all_eq_conv,\n    case_names\n      new NewArray Cast InstanceOf Val BinOp Var LAss AAcc AAss ALen FAcc FAss Call Block\n      Synchronized InSynchronized Seq Cond While throw TryCatch\n      Nil Cons]", "lemma compE2_neq_Nil [simp]: \"compE2 e \\<noteq> []\"", "lemma compEs2_append [simp]: \"compEs2 (es @ es') = compEs2 es @ compEs2 es'\"", "lemma compEs2_eq_Nil_conv [simp]: \"compEs2 es = [] \\<longleftrightarrow> es = []\"", "lemma compEs2_map_Val: \"compEs2 (map Val vs) = map Push vs\"", "lemma compE2_0th_neq_Invoke [simp]:\n  \"compE2 e ! 0 \\<noteq> Invoke M n\"", "lemma compxEs2_append [simp]:\n  \"compxEs2 (es @ es') pc d = compxEs2 es pc d @ compxEs2 es' (length (compEs2 es) + pc) (length es + d)\"", "lemma compxEs2_map_Val [simp]: \"compxEs2 (map Val vs) pc d = []\"", "lemma compE2_blocks1 [simp]:\n  \"compE2 (blocks1 n Ts body) = compE2 body\"", "lemma compxE2_blocks1 [simp]:\n  \"compxE2 (blocks1 n Ts body) = compxE2 body\"", "lemma fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows compE2_not_Return: \"Return \\<notin> set (compE2 e)\"\n  and compEs2_not_Return: \"Return \\<notin> set (compEs2 es)\"", "lemma max_stack1: \"1 \\<le> max_stack e\"", "lemma max_stacks_ge_length: \"max_stacks es \\<ge> length es\"", "lemma max_stack_blocks1 [simp]:\n  \"max_stack (blocks1 n Ts body) = max_stack body\"", "lemma compMb2:\n  \"compMb2 e = (max_stack e, max_vars e, (compE2 e @ [Return]), compxE2 e 0 0)\""], "translations": [["", "lemmas compxE2_compxEs2_induct =\n  compxE2_compxEs2.induct[\n    unfolded meta_all5_eq_conv meta_all4_eq_conv meta_all3_eq_conv meta_all2_eq_conv meta_all_eq_conv,\n    case_names\n      new NewArray Cast InstanceOf Val BinOp Var LAss AAcc AAss ALen FAcc FAss Call Block\n      Synchronized InSynchronized Seq Cond While throw TryCatch\n      Nil Cons]"], ["", "lemma compE2_neq_Nil [simp]: \"compE2 e \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compE2 e \\<noteq> []", "by(induct e) auto"], ["", "declare compE2_neq_Nil[symmetric, simp]"], ["", "lemma compEs2_append [simp]: \"compEs2 (es @ es') = compEs2 es @ compEs2 es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compEs2 (es @ es') = compEs2 es @ compEs2 es'", "by(induct es) auto"], ["", "lemma compEs2_eq_Nil_conv [simp]: \"compEs2 es = [] \\<longleftrightarrow> es = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compEs2 es = []) = (es = [])", "by(cases es) auto"], ["", "lemma compEs2_map_Val: \"compEs2 (map Val vs) = map Push vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compEs2 (map Val vs) = map Push vs", "by(induct vs) auto"], ["", "lemma compE2_0th_neq_Invoke [simp]:\n  \"compE2 e ! 0 \\<noteq> Invoke M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compE2 e ! 0 \\<noteq> Invoke M n", "by(induct e)(auto simp add: nth_append)"], ["", "declare compE2_0th_neq_Invoke[symmetric, simp]"], ["", "lemma compxEs2_append [simp]:\n  \"compxEs2 (es @ es') pc d = compxEs2 es pc d @ compxEs2 es' (length (compEs2 es) + pc) (length es + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compxEs2 (es @ es') pc d =\n    compxEs2 es pc d @\n    compxEs2 es' (length (compEs2 es) + pc) (length es + d)", "by(induct es arbitrary: pc d)(auto simp add: ac_simps)"], ["", "lemma compxEs2_map_Val [simp]: \"compxEs2 (map Val vs) pc d = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compxEs2 (map Val vs) pc d = []", "by(induct vs arbitrary: d pc) auto"], ["", "lemma compE2_blocks1 [simp]:\n  \"compE2 (blocks1 n Ts body) = compE2 body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compE2 (blocks1 n Ts body) = compE2 body", "by(induct n Ts body rule: blocks1.induct)(auto)"], ["", "lemma compxE2_blocks1 [simp]:\n  \"compxE2 (blocks1 n Ts body) = compxE2 body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compxE2 (blocks1 n Ts body) = compxE2 body", "by(induct n Ts body rule: blocks1.induct)(auto intro!: ext)"], ["", "lemma fixes e :: \"'addr expr1\" and es :: \"'addr expr1 list\"\n  shows compE2_not_Return: \"Return \\<notin> set (compE2 e)\"\n  and compEs2_not_Return: \"Return \\<notin> set (compEs2 es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Return \\<notin> set (compE2 e) &&& Return \\<notin> set (compEs2 es)", "by(induct e and es rule: compE2.induct compEs2.induct)(auto)"], ["", "primrec max_stack :: \"'addr expr1 \\<Rightarrow> nat\"\n  and max_stacks :: \"'addr expr1 list \\<Rightarrow> nat\"\nwhere\n  \"max_stack (new C) = 1\"\n| \"max_stack (newA T\\<lfloor>e\\<rceil>) = max_stack e\"\n| \"max_stack (Cast C e) = max_stack e\"\n| \"max_stack (e instanceof T) = max_stack e\"\n| \"max_stack (Val v) = 1\"\n| \"max_stack (e1 \\<guillemotleft>bop\\<guillemotright> e2) = max (max_stack e1) (max_stack e2) + 1\"\n| \"max_stack (Var i) = 1\"\n| \"max_stack (i:=e) = max_stack e\"\n| \"max_stack (a\\<lfloor>i\\<rceil>) = max (max_stack a) (max_stack i + 1)\"\n| \"max_stack (a\\<lfloor>i\\<rceil> := e) = max (max (max_stack a) (max_stack i + 1)) (max_stack e + 2)\"\n| \"max_stack (a\\<bullet>length) = max_stack a\"\n| \"max_stack (e\\<bullet>F{D}) = max_stack e\"\n| \"max_stack (e1\\<bullet>F{D} := e2) = max (max_stack e1) (max_stack e2) + 1\"\n| \"max_stack (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) = max (max (max_stack e) (max_stack e' + 1)) (max_stack e'' + 2)\"\n| \"max_stack (e\\<bullet>M(es)) = max (max_stack e) (max_stacks es) + 1\"\n| \"max_stack ({i:T=vo; e}) = max_stack e\"\n| \"max_stack (sync\\<^bsub>V\\<^esub> (o') e) = max (max_stack o') (max (max_stack e) 2)\"\n| \"max_stack (insync\\<^bsub>V\\<^esub> (a) e) = 1\"\n| \"max_stack (e1;;e2) = max (max_stack e1) (max_stack e2)\"\n| \"max_stack (if (e) e\\<^sub>1 else e\\<^sub>2) =\n   max (max_stack e) (max (max_stack e\\<^sub>1) (max_stack e\\<^sub>2))\"\n| \"max_stack (while (e) c) = max (max_stack e) (max_stack c)\"\n| \"max_stack (throw e) = max_stack e\"\n| \"max_stack (try e1 catch(C i) e2) = max (max_stack e1) (max_stack e2)\"\n\n| \"max_stacks [] = 0\"\n| \"max_stacks (e#es) = max (max_stack e) (1 + max_stacks es)\""], ["", "lemma max_stack1: \"1 \\<le> max_stack e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> max_stack e", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> max_stack e", "by(induct e) (simp_all add:max_def)"], ["", "(*>*)"], ["", "lemma max_stacks_ge_length: \"max_stacks es \\<ge> length es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length es \\<le> max_stacks es", "by(induct es, auto)"], ["", "lemma max_stack_blocks1 [simp]:\n  \"max_stack (blocks1 n Ts body) = max_stack body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_stack (blocks1 n Ts body) = max_stack body", "by(induct n Ts body rule: blocks1.induct) auto"], ["", "definition compMb2 :: \"'addr expr1 \\<Rightarrow> 'addr jvm_method\"\nwhere\n  \"compMb2  \\<equiv>  \\<lambda>body.\n  let ins = compE2 body @ [Return];\n      xt = compxE2 body 0 0\n  in (max_stack body, max_vars body, ins, xt)\""], ["", "definition compP2 :: \"'addr J1_prog \\<Rightarrow> 'addr jvm_prog\"\nwhere \"compP2  \\<equiv>  compP (\\<lambda>C M Ts T. compMb2)\""], ["", "lemma compMb2:\n  \"compMb2 e = (max_stack e, max_vars e, (compE2 e @ [Return]), compxE2 e 0 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compMb2 e =\n    (max_stack e, max_vars e, compE2 e @ [Return], compxE2 e 0 0)", "by (simp add: compMb2_def)"], ["", "end"]]}