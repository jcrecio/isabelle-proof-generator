{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/SC_Completion.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma mrw_value_cases:\n  obtains ad al v where \"x = NormalAction (WriteMem ad al v)\"\n  | ad hT where \"x = NormalAction (NewHeapElem ad hT)\"\n  | ad M vs v where \"x = NormalAction (ExternalCall ad M vs v)\"\n  | ad al v where \"x = NormalAction (ReadMem ad al v)\"\n  | t where \"x = NormalAction (ThreadStart t)\"\n  | t where \"x = NormalAction (ThreadJoin t)\"\n  | ad where \"x = NormalAction (SyncLock ad)\"\n  | ad where \"x = NormalAction (SyncUnlock ad)\"\n  | t where \"x = NormalAction (ObsInterrupt t)\"\n  | t where \"x = NormalAction (ObsInterrupted t)\"\n  | \"x = InitialThreadAction\"\n  | \"x = ThreadFinishAction\"", "lemma mrw_values_eq_SomeD:\n  assumes mrw: \"mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\"\n  and \"vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow> \\<exists>wa. wa \\<in> set obs \\<and> is_write_action wa \\<and> (ad, al) \\<in> action_loc_aux P wa \\<and> (b \\<longrightarrow> \\<not> is_new_action wa)\"\n  shows \"\\<exists>obs' wa obs''. obs = obs' @ wa # obs'' \\<and> is_write_action wa \\<and> (ad, al) \\<in> action_loc_aux P wa \\<and>\n            value_written_aux P wa al = v \\<and> (is_new_action wa \\<longleftrightarrow> \\<not> b) \\<and>\n            (\\<forall>ob\\<in>set obs''. is_write_action ob \\<longrightarrow> (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow> is_new_action ob \\<and> b)\"\n  (is \"?concl obs\")", "lemma mrw_values_WriteMemD:\n  assumes \"NormalAction (WriteMem ad al v') \\<in> set obs\"\n  shows \"\\<exists>v. mrw_values P vs0 obs (ad, al) = Some (v, True)\"", "lemma mrw_values_new_actionD:\n  assumes \"w \\<in> set obs\" \"is_new_action w\" \"adal \\<in> action_loc_aux P w\"\n  shows \"\\<exists>v b. mrw_values P vs0 obs adal = Some (v, b)\"", "lemma mrw_value_dom_mono:\n  \"dom vs \\<subseteq> dom (mrw_value P vs ob)\"", "lemma mrw_values_dom_mono:\n  \"dom vs \\<subseteq> dom (mrw_values P vs obs)\"", "lemma mrw_values_eq_NoneD:\n  assumes \"mrw_values P vs0 obs adal = None\"\n  and \"w \\<in> set obs\" and \"is_write_action w\" and \"adal \\<in> action_loc_aux P w\"\n  shows False", "lemma mrw_values_mrw:\n  assumes mrw: \"mrw_values P vs0 (map snd obs) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\"\n  and initial: \"vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow> \\<exists>wa. wa \\<in> set (map snd obs) \\<and> is_write_action wa \\<and> (ad, al) \\<in> action_loc_aux P wa \\<and> (b \\<longrightarrow> \\<not> is_new_action wa)\"\n  shows \"\\<exists>i. i < length obs \\<and> P,llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and> value_written P (llist_of obs) i (ad, al) = v\"", "lemma mrw_values_no_write_unchanged:\n  assumes no_write: \"\\<And>w. \\<lbrakk> w \\<in> set obs; is_write_action w; adal \\<in> action_loc_aux P w \\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False | Some (v, b) \\<Rightarrow> b \\<and> is_new_action w\"\n  shows \"mrw_values P vs obs adal = vs adal\"", "lemma ta_seq_consist_lappend:\n  assumes \"lfinite obs\"\n  shows \"ta_seq_consist P vs (lappend obs obs') \\<longleftrightarrow>\n         ta_seq_consist P vs obs \\<and> ta_seq_consist P (mrw_values P vs (list_of obs)) obs'\"\n  (is \"?concl vs obs\")", "lemma\n  assumes \"ta_seq_consist P vs obs\"\n  shows ta_seq_consist_ltake: \"ta_seq_consist P vs (ltake n obs)\" (is ?thesis1)\n  and ta_seq_consist_ldrop: \"ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)\" (is ?thesis2)", "lemma ta_seq_consist_coinduct_append [consumes 1, case_names ta_seq_consist, case_conclusion ta_seq_consist LNil lappend]:\n  assumes major: \"X vs obs\"\n  and step: \"\\<And>vs obs. X vs obs \n    \\<Longrightarrow> obs = LNil \\<or>\n       (\\<exists>obs' obs''. obs = lappend obs' obs'' \\<and> obs' \\<noteq> LNil \\<and> ta_seq_consist P vs obs' \\<and>\n                    (lfinite obs' \\<longrightarrow> (X (mrw_values P vs (list_of obs')) obs'' \\<or> \n                                       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')))\"\n    (is \"\\<And>vs obs. _ \\<Longrightarrow> _ \\<or> ?step vs obs\")\n  shows \"ta_seq_consist P vs obs\"", "lemma ta_seq_consist_coinduct_append_wf\n  [consumes 2, case_names ta_seq_consist, case_conclusion ta_seq_consist LNil lappend]:\n  assumes major: \"X vs obs a\"\n  and wf: \"wf R\"\n  and step: \"\\<And>vs obs a. X vs obs a\n    \\<Longrightarrow> obs = LNil \\<or>\n       (\\<exists>obs' obs'' a'. obs = lappend obs' obs'' \\<and> ta_seq_consist P vs obs' \\<and> (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n                        (lfinite obs' \\<longrightarrow> X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n                                          ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\"\n    (is \"\\<And>vs obs a. _ \\<Longrightarrow> _ \\<or> ?step vs obs a\")\n  shows \"ta_seq_consist P vs obs\"", "lemma ta_seq_consist_nthI:\n  \"(\\<And>i ad al v. \\<lbrakk> enat i < llength obs; lnth obs i = NormalAction (ReadMem ad al v);\n      ta_seq_consist P vs (ltake (enat i) obs) \\<rbrakk> \n    \\<Longrightarrow> \\<exists>b. mrw_values P vs (list_of (ltake (enat i) obs)) (ad, al) = \\<lfloor>(v, b)\\<rfloor>)\n  \\<Longrightarrow> ta_seq_consist P vs obs\"", "lemma ta_seq_consist_into_non_speculative:\n  \"\\<lbrakk> ta_seq_consist P vs obs; \\<forall>adal. set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV \\<rbrakk>\n  \\<Longrightarrow> non_speculative P vs' obs\"", "lemma llist_of_list_of_append:\n  \"lfinite xs \\<Longrightarrow> llist_of (list_of xs @ ys) = lappend xs (llist_of ys)\"", "lemma ta_seq_consist_most_recent_write_for:\n  assumes sc: \"ta_seq_consist P Map.empty (lmap snd E)\"\n  and read: \"r \\<in> read_actions E\"\n  and new_actions_for_fun: \"\\<And>adal a a'. \\<lbrakk> a \\<in> new_actions_for P E adal; a' \\<in> new_actions_for P E adal \\<rbrakk> \\<Longrightarrow> a = a'\"\n  shows \"\\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r\"", "lemma ta_seq_consist_mrw_before:\n  assumes sc: \"ta_seq_consist P Map.empty (lmap snd E)\"\n  and new_actions_for_fun: \"\\<And>adal a a'. \\<lbrakk> a \\<in> new_actions_for P E adal; a' \\<in> new_actions_for P E adal \\<rbrakk> \\<Longrightarrow> a = a'\"\n  and mrw: \"P,E \\<turnstile> r \\<leadsto>mrw w\"\n  shows \"w < r\"", "lemma ta_seq_consist_imp_sequentially_consistent:\n  assumes tsa_ok: \"thread_start_actions_ok E\"\n  and new_actions_for_fun: \"\\<And>adal a a'. \\<lbrakk> a \\<in> new_actions_for P E adal; a' \\<in> new_actions_for P E adal \\<rbrakk> \\<Longrightarrow> a = a'\"\n  and seq: \"ta_seq_consist P Map.empty (lmap snd E)\"\n  shows \"\\<exists>ws. sequentially_consistent P (E, ws) \\<and> P \\<turnstile> (E, ws) \\<surd>\"", "lemma eq_upto_seq_inconsist_simps:\n  \"eq_upto_seq_inconsist P [] obs' vs \\<longleftrightarrow> obs' = []\"\n  \"eq_upto_seq_inconsist P obs [] vs \\<longleftrightarrow> obs = []\"\n  \"eq_upto_seq_inconsist P (ob # obs) (ob' # obs') vs \\<longleftrightarrow> \n   (case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \n      if (\\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>) \n      then ob = ob' \\<and> eq_upto_seq_inconsist P obs obs' (mrw_value P vs ob) \n      else ob \\<approx> ob'\n    | _ \\<Rightarrow> ob = ob' \\<and> eq_upto_seq_inconsist P obs obs' (mrw_value P vs ob))\"", "lemma eq_upto_seq_inconsist_Cons1:\n  \"eq_upto_seq_inconsist P (ob # obs) obs' vs \\<longleftrightarrow>\n   (\\<exists>ob' obs''. obs' = ob' # obs'' \\<and> \n      (case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \n         if (\\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>) \n         then ob' = ob \\<and> eq_upto_seq_inconsist P obs obs'' (mrw_value P vs ob)\n         else ob \\<approx> ob'\n       | _ \\<Rightarrow> ob' = ob \\<and> eq_upto_seq_inconsist P obs obs'' (mrw_value P vs ob)))\"", "lemma eq_upto_seq_inconsist_appendD:\n  assumes \"eq_upto_seq_inconsist P (obs @ obs') obs'' vs\"\n  and \"ta_seq_consist P vs (llist_of obs)\"\n  shows \"length obs \\<le> length obs''\" (is ?thesis1)\n  and \"take (length obs) obs'' = obs\" (is ?thesis2)\n  and \"eq_upto_seq_inconsist P obs' (drop (length obs) obs'') (mrw_values P vs obs)\" (is ?thesis3)", "lemma ta_seq_consist_imp_eq_upto_seq_inconsist_refl:\n  \"ta_seq_consist P vs (llist_of obs) \\<Longrightarrow> eq_upto_seq_inconsist P obs obs vs\"", "lemma eq_upto_seq_inconsist_appendI:\n  \"\\<lbrakk> eq_upto_seq_inconsist P obs OBS vs;\n     \\<lbrakk> ta_seq_consist P vs (llist_of obs) \\<rbrakk> \\<Longrightarrow> eq_upto_seq_inconsist P obs' OBS' (mrw_values P vs OBS) \\<rbrakk>\n  \\<Longrightarrow> eq_upto_seq_inconsist P (obs @ obs') (OBS @ OBS') vs\"", "lemma eq_upto_seq_inconsist_trans:\n  \"\\<lbrakk> eq_upto_seq_inconsist P obs obs' vs; eq_upto_seq_inconsist P obs' obs'' vs \\<rbrakk>\n  \\<Longrightarrow> eq_upto_seq_inconsist P obs obs'' vs\"", "lemma eq_upto_seq_inconsist_append2:\n  \"\\<lbrakk> eq_upto_seq_inconsist P obs obs' vs; \\<not> ta_seq_consist P vs (llist_of obs) \\<rbrakk>\n  \\<Longrightarrow> eq_upto_seq_inconsist P obs (obs' @ obs'') vs\"", "lemma ta_seq_consist_mrwI:\n  assumes E: \"E \\<in> \\<E>\"\n  and wf: \"P \\<turnstile> (E, ws) \\<surd>\"\n  and mrw: \"\\<And>a. \\<lbrakk> enat a < r; a \\<in> read_actions E \\<rbrakk> \\<Longrightarrow> P,E \\<turnstile> a \\<leadsto>mrw ws a\"\n  shows \"ta_seq_consist P Map.empty (lmap snd (ltake r E))\"", "lemma sc_completionD:\n  \"\\<lbrakk> sc_completion s vs; s -\\<triangleright>ttas\\<rightarrow>* s'; ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))); \n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m'); actions_ok s' t ta \\<rbrakk>\n  \\<Longrightarrow> \\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and>\n                   ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\"", "lemma sc_completionI:\n  \"(\\<And>ttas s' t x ta x' m'. \n     \\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))); \n       thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m'); actions_ok s' t ta \\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and>\n                   ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n  \\<Longrightarrow> sc_completion s vs\"", "lemma sc_completion_shift:\n  assumes sc_c: \"sc_completion s vs\"\n  and \\<tau>Red: \"s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and sc: \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (llist_of ttas)))\"\n  shows \"sc_completion s' (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\"", "lemma complete_sc_in_Runs:\n  assumes cau: \"sc_completion s vs\"\n  and ta_seq_consist_convert_RA: \"\\<And>vs ln. ta_seq_consist P vs (llist_of (convert_RA ln))\"\n  shows \"mthr.Runs s (complete_sc s vs)\"", "lemma complete_sc_ta_seq_consist:\n  assumes cau: \"sc_completion s vs\"\n  and ta_seq_consist_convert_RA: \"\\<And>vs ln. ta_seq_consist P vs (llist_of (convert_RA ln))\"\n  shows \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (complete_sc s vs)))\"", "lemma sequential_completion_Runs:\n  assumes \"sc_completion s vs\"\n  and \"\\<And>vs ln. ta_seq_consist P vs (llist_of (convert_RA ln))\"\n  shows \"\\<exists>ttas. mthr.Runs s ttas \\<and> ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))\"", "lemma cut_and_updateI[intro?]:\n  \"(\\<And>ttas s' t x ta x' m'. \n     \\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)));\n       thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m'); actions_ok s' t ta \\<rbrakk>\n      \\<Longrightarrow> \\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and> \n                       ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))))\n    \\<Longrightarrow> cut_and_update s vs\"", "lemma cut_and_updateD:\n  \"\\<lbrakk> cut_and_update s vs; s -\\<triangleright>ttas\\<rightarrow>* s'; ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)));\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m'); actions_ok s' t ta \\<rbrakk>\n  \\<Longrightarrow> \\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and> \n                   ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                   eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\"", "lemma cut_and_update_imp_sc_completion:\n  \"cut_and_update s vs \\<Longrightarrow> sc_completion s vs\"", "lemma sequential_completion:\n  assumes cut_and_update: \"cut_and_update s vs\"\n  and ta_seq_consist_convert_RA: \"\\<And>vs ln. ta_seq_consist P vs (llist_of (convert_RA ln))\"\n  and Red: \"s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and sc: \"ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\"\n  and red: \"s' -t\\<triangleright>ta\\<rightarrow> s''\"\n  shows\n  \"\\<exists>ta' ttas'. mthr.Runs s' (LCons (t, ta') ttas') \\<and> \n     ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and> \n     eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\""], "translations": [["", "lemma mrw_value_cases:\n  obtains ad al v where \"x = NormalAction (WriteMem ad al v)\"\n  | ad hT where \"x = NormalAction (NewHeapElem ad hT)\"\n  | ad M vs v where \"x = NormalAction (ExternalCall ad M vs v)\"\n  | ad al v where \"x = NormalAction (ReadMem ad al v)\"\n  | t where \"x = NormalAction (ThreadStart t)\"\n  | t where \"x = NormalAction (ThreadJoin t)\"\n  | ad where \"x = NormalAction (SyncLock ad)\"\n  | ad where \"x = NormalAction (SyncUnlock ad)\"\n  | t where \"x = NormalAction (ObsInterrupt t)\"\n  | t where \"x = NormalAction (ObsInterrupted t)\"\n  | \"x = InitialThreadAction\"\n  | \"x = ThreadFinishAction\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ad al v.\n                x = NormalAction (WriteMem ad al v) \\<Longrightarrow>\n                thesis;\n     \\<And>ad hT.\n        x = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> thesis;\n     \\<And>ad M vs v.\n        x = NormalAction (ExternalCall ad M vs v) \\<Longrightarrow> thesis;\n     \\<And>ad al v.\n        x = NormalAction (ReadMem ad al v) \\<Longrightarrow> thesis;\n     \\<And>t. x = NormalAction (ThreadStart t) \\<Longrightarrow> thesis;\n     \\<And>t. x = NormalAction (ThreadJoin t) \\<Longrightarrow> thesis;\n     \\<And>ad. x = NormalAction (SyncLock ad) \\<Longrightarrow> thesis;\n     \\<And>ad. x = NormalAction (SyncUnlock ad) \\<Longrightarrow> thesis;\n     \\<And>t. x = NormalAction (ObsInterrupt t) \\<Longrightarrow> thesis;\n     \\<And>t. x = NormalAction (ObsInterrupted t) \\<Longrightarrow> thesis;\n     x = InitialThreadAction \\<Longrightarrow> thesis;\n     x = ThreadFinishAction \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by pat_completeness"], ["", "abbreviation mrw_values ::\n  \"'m prog \\<Rightarrow> (('addr \\<times> addr_loc) \\<rightharpoonup> ('addr val \\<times> bool)) \\<Rightarrow> ('addr, 'thread_id) obs_event action list\n  \\<Rightarrow> (('addr \\<times> addr_loc) \\<rightharpoonup> ('addr val \\<times> bool))\"\nwhere \"mrw_values P \\<equiv> foldl (mrw_value P)\""], ["", "lemma mrw_values_eq_SomeD:\n  assumes mrw: \"mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\"\n  and \"vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow> \\<exists>wa. wa \\<in> set obs \\<and> is_write_action wa \\<and> (ad, al) \\<in> action_loc_aux P wa \\<and> (b \\<longrightarrow> \\<not> is_new_action wa)\"\n  shows \"\\<exists>obs' wa obs''. obs = obs' @ wa # obs'' \\<and> is_write_action wa \\<and> (ad, al) \\<in> action_loc_aux P wa \\<and>\n            value_written_aux P wa al = v \\<and> (is_new_action wa \\<longleftrightarrow> \\<not> b) \\<and>\n            (\\<forall>ob\\<in>set obs''. is_write_action ob \\<longrightarrow> (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow> is_new_action ob \\<and> b)\"\n  (is \"?concl obs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       obs = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "using assms"], ["proof (prove)\nusing this:\n  mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n  \\<exists>wa.\n     wa \\<in> set obs \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       obs = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "proof(induct obs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mrw_values P vs0 [] (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n     vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n     \\<exists>wa.\n        wa \\<in> set [] \\<and>\n        is_write_action wa \\<and>\n        (ad, al) \\<in> action_loc_aux P wa \\<and>\n        (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obs' wa obs''.\n                         [] = obs' @ wa # obs'' \\<and>\n                         is_write_action wa \\<and>\n                         (ad, al) \\<in> action_loc_aux P wa \\<and>\n                         value_written_aux P wa al = v \\<and>\n                         is_new_action wa = (\\<not> b) \\<and>\n                         (\\<forall>ob\\<in>set obs''.\n                             is_write_action ob \\<longrightarrow>\n                             (ad, al)\n                             \\<in> action_loc_aux P ob \\<longrightarrow>\n                             is_new_action ob \\<and> b)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>mrw_values P vs0 xs (ad, al) =\n                         \\<lfloor>(v, b)\\<rfloor>;\n                 vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n                 \\<exists>wa.\n                    wa \\<in> set xs \\<and>\n                    is_write_action wa \\<and>\n                    (ad, al) \\<in> action_loc_aux P wa \\<and>\n                    (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>obs' wa obs''.\n                                     xs = obs' @ wa # obs'' \\<and>\n                                     is_write_action wa \\<and>\n                                     (ad, al)\n                                     \\<in> action_loc_aux P wa \\<and>\n                                     value_written_aux P wa al = v \\<and>\n                                     is_new_action wa = (\\<not> b) \\<and>\n                                     (\\<forall>ob\\<in>set obs''.\n   is_write_action ob \\<longrightarrow>\n   (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n   is_new_action ob \\<and> b);\n        mrw_values P vs0 (xs @ [x]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n        vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        \\<exists>wa.\n           wa \\<in> set (xs @ [x]) \\<and>\n           is_write_action wa \\<and>\n           (ad, al) \\<in> action_loc_aux P wa \\<and>\n           (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' wa obs''.\n                            xs @ [x] = obs' @ wa # obs'' \\<and>\n                            is_write_action wa \\<and>\n                            (ad, al) \\<in> action_loc_aux P wa \\<and>\n                            value_written_aux P wa al = v \\<and>\n                            is_new_action wa = (\\<not> b) \\<and>\n                            (\\<forall>ob\\<in>set obs''.\n                                is_write_action ob \\<longrightarrow>\n                                (ad, al)\n                                \\<in> action_loc_aux P ob \\<longrightarrow>\n                                is_new_action ob \\<and> b)", "case Nil"], ["proof (state)\nthis:\n  mrw_values P vs0 [] (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n  \\<exists>wa.\n     wa \\<in> set [] \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mrw_values P vs0 [] (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n     vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n     \\<exists>wa.\n        wa \\<in> set [] \\<and>\n        is_write_action wa \\<and>\n        (ad, al) \\<in> action_loc_aux P wa \\<and>\n        (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obs' wa obs''.\n                         [] = obs' @ wa # obs'' \\<and>\n                         is_write_action wa \\<and>\n                         (ad, al) \\<in> action_loc_aux P wa \\<and>\n                         value_written_aux P wa al = v \\<and>\n                         is_new_action wa = (\\<not> b) \\<and>\n                         (\\<forall>ob\\<in>set obs''.\n                             is_write_action ob \\<longrightarrow>\n                             (ad, al)\n                             \\<in> action_loc_aux P ob \\<longrightarrow>\n                             is_new_action ob \\<and> b)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>mrw_values P vs0 xs (ad, al) =\n                         \\<lfloor>(v, b)\\<rfloor>;\n                 vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n                 \\<exists>wa.\n                    wa \\<in> set xs \\<and>\n                    is_write_action wa \\<and>\n                    (ad, al) \\<in> action_loc_aux P wa \\<and>\n                    (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>obs' wa obs''.\n                                     xs = obs' @ wa # obs'' \\<and>\n                                     is_write_action wa \\<and>\n                                     (ad, al)\n                                     \\<in> action_loc_aux P wa \\<and>\n                                     value_written_aux P wa al = v \\<and>\n                                     is_new_action wa = (\\<not> b) \\<and>\n                                     (\\<forall>ob\\<in>set obs''.\n   is_write_action ob \\<longrightarrow>\n   (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n   is_new_action ob \\<and> b);\n        mrw_values P vs0 (xs @ [x]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n        vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        \\<exists>wa.\n           wa \\<in> set (xs @ [x]) \\<and>\n           is_write_action wa \\<and>\n           (ad, al) \\<in> action_loc_aux P wa \\<and>\n           (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' wa obs''.\n                            xs @ [x] = obs' @ wa # obs'' \\<and>\n                            is_write_action wa \\<and>\n                            (ad, al) \\<in> action_loc_aux P wa \\<and>\n                            value_written_aux P wa al = v \\<and>\n                            is_new_action wa = (\\<not> b) \\<and>\n                            (\\<forall>ob\\<in>set obs''.\n                                is_write_action ob \\<longrightarrow>\n                                (ad, al)\n                                \\<in> action_loc_aux P ob \\<longrightarrow>\n                                is_new_action ob \\<and> b)", "thus ?case"], ["proof (prove)\nusing this:\n  mrw_values P vs0 [] (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n  \\<exists>wa.\n     wa \\<in> set [] \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       [] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "by simp"], ["proof (state)\nthis:\n  \\<exists>obs' wa obs''.\n     [] = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>mrw_values P vs0 xs (ad, al) =\n                         \\<lfloor>(v, b)\\<rfloor>;\n                 vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n                 \\<exists>wa.\n                    wa \\<in> set xs \\<and>\n                    is_write_action wa \\<and>\n                    (ad, al) \\<in> action_loc_aux P wa \\<and>\n                    (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>obs' wa obs''.\n                                     xs = obs' @ wa # obs'' \\<and>\n                                     is_write_action wa \\<and>\n                                     (ad, al)\n                                     \\<in> action_loc_aux P wa \\<and>\n                                     value_written_aux P wa al = v \\<and>\n                                     is_new_action wa = (\\<not> b) \\<and>\n                                     (\\<forall>ob\\<in>set obs''.\n   is_write_action ob \\<longrightarrow>\n   (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n   is_new_action ob \\<and> b);\n        mrw_values P vs0 (xs @ [x]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n        vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        \\<exists>wa.\n           wa \\<in> set (xs @ [x]) \\<and>\n           is_write_action wa \\<and>\n           (ad, al) \\<in> action_loc_aux P wa \\<and>\n           (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' wa obs''.\n                            xs @ [x] = obs' @ wa # obs'' \\<and>\n                            is_write_action wa \\<and>\n                            (ad, al) \\<in> action_loc_aux P wa \\<and>\n                            value_written_aux P wa al = v \\<and>\n                            is_new_action wa = (\\<not> b) \\<and>\n                            (\\<forall>ob\\<in>set obs''.\n                                is_write_action ob \\<longrightarrow>\n                                (ad, al)\n                                \\<in> action_loc_aux P ob \\<longrightarrow>\n                                is_new_action ob \\<and> b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>mrw_values P vs0 xs (ad, al) =\n                         \\<lfloor>(v, b)\\<rfloor>;\n                 vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n                 \\<exists>wa.\n                    wa \\<in> set xs \\<and>\n                    is_write_action wa \\<and>\n                    (ad, al) \\<in> action_loc_aux P wa \\<and>\n                    (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>obs' wa obs''.\n                                     xs = obs' @ wa # obs'' \\<and>\n                                     is_write_action wa \\<and>\n                                     (ad, al)\n                                     \\<in> action_loc_aux P wa \\<and>\n                                     value_written_aux P wa al = v \\<and>\n                                     is_new_action wa = (\\<not> b) \\<and>\n                                     (\\<forall>ob\\<in>set obs''.\n   is_write_action ob \\<longrightarrow>\n   (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n   is_new_action ob \\<and> b);\n        mrw_values P vs0 (xs @ [x]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n        vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        \\<exists>wa.\n           wa \\<in> set (xs @ [x]) \\<and>\n           is_write_action wa \\<and>\n           (ad, al) \\<in> action_loc_aux P wa \\<and>\n           (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' wa obs''.\n                            xs @ [x] = obs' @ wa # obs'' \\<and>\n                            is_write_action wa \\<and>\n                            (ad, al) \\<in> action_loc_aux P wa \\<and>\n                            value_written_aux P wa al = v \\<and>\n                            is_new_action wa = (\\<not> b) \\<and>\n                            (\\<forall>ob\\<in>set obs''.\n                                is_write_action ob \\<longrightarrow>\n                                (ad, al)\n                                \\<in> action_loc_aux P ob \\<longrightarrow>\n                                is_new_action ob \\<and> b)", "case (snoc ob obs)"], ["proof (state)\nthis:\n  \\<lbrakk>mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n   vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n   \\<exists>wa.\n      wa \\<in> set obs \\<and>\n      is_write_action wa \\<and>\n      (ad, al) \\<in> action_loc_aux P wa \\<and>\n      (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>obs' wa obs''.\n                       obs = obs' @ wa # obs'' \\<and>\n                       is_write_action wa \\<and>\n                       (ad, al) \\<in> action_loc_aux P wa \\<and>\n                       value_written_aux P wa al = v \\<and>\n                       is_new_action wa = (\\<not> b) \\<and>\n                       (\\<forall>ob\\<in>set obs''.\n                           is_write_action ob \\<longrightarrow>\n                           (ad, al)\n                           \\<in> action_loc_aux P ob \\<longrightarrow>\n                           is_new_action ob \\<and> b)\n  mrw_values P vs0 (obs @ [ob]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n  \\<exists>wa.\n     wa \\<in> set (obs @ [ob]) \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>mrw_values P vs0 xs (ad, al) =\n                         \\<lfloor>(v, b)\\<rfloor>;\n                 vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n                 \\<exists>wa.\n                    wa \\<in> set xs \\<and>\n                    is_write_action wa \\<and>\n                    (ad, al) \\<in> action_loc_aux P wa \\<and>\n                    (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>obs' wa obs''.\n                                     xs = obs' @ wa # obs'' \\<and>\n                                     is_write_action wa \\<and>\n                                     (ad, al)\n                                     \\<in> action_loc_aux P wa \\<and>\n                                     value_written_aux P wa al = v \\<and>\n                                     is_new_action wa = (\\<not> b) \\<and>\n                                     (\\<forall>ob\\<in>set obs''.\n   is_write_action ob \\<longrightarrow>\n   (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n   is_new_action ob \\<and> b);\n        mrw_values P vs0 (xs @ [x]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n        vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        \\<exists>wa.\n           wa \\<in> set (xs @ [x]) \\<and>\n           is_write_action wa \\<and>\n           (ad, al) \\<in> action_loc_aux P wa \\<and>\n           (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' wa obs''.\n                            xs @ [x] = obs' @ wa # obs'' \\<and>\n                            is_write_action wa \\<and>\n                            (ad, al) \\<in> action_loc_aux P wa \\<and>\n                            value_written_aux P wa al = v \\<and>\n                            is_new_action wa = (\\<not> b) \\<and>\n                            (\\<forall>ob\\<in>set obs''.\n                                is_write_action ob \\<longrightarrow>\n                                (ad, al)\n                                \\<in> action_loc_aux P ob \\<longrightarrow>\n                                is_new_action ob \\<and> b)", "note mrw = \\<open>mrw_values P vs0 (obs @ [ob]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  mrw_values P vs0 (obs @ [ob]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>mrw_values P vs0 xs (ad, al) =\n                         \\<lfloor>(v, b)\\<rfloor>;\n                 vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n                 \\<exists>wa.\n                    wa \\<in> set xs \\<and>\n                    is_write_action wa \\<and>\n                    (ad, al) \\<in> action_loc_aux P wa \\<and>\n                    (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>obs' wa obs''.\n                                     xs = obs' @ wa # obs'' \\<and>\n                                     is_write_action wa \\<and>\n                                     (ad, al)\n                                     \\<in> action_loc_aux P wa \\<and>\n                                     value_written_aux P wa al = v \\<and>\n                                     is_new_action wa = (\\<not> b) \\<and>\n                                     (\\<forall>ob\\<in>set obs''.\n   is_write_action ob \\<longrightarrow>\n   (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n   is_new_action ob \\<and> b);\n        mrw_values P vs0 (xs @ [x]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>;\n        vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        \\<exists>wa.\n           wa \\<in> set (xs @ [x]) \\<and>\n           is_write_action wa \\<and>\n           (ad, al) \\<in> action_loc_aux P wa \\<and>\n           (b \\<longrightarrow> \\<not> is_new_action wa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' wa obs''.\n                            xs @ [x] = obs' @ wa # obs'' \\<and>\n                            is_write_action wa \\<and>\n                            (ad, al) \\<in> action_loc_aux P wa \\<and>\n                            value_written_aux P wa al = v \\<and>\n                            is_new_action wa = (\\<not> b) \\<and>\n                            (\\<forall>ob\\<in>set obs''.\n                                is_write_action ob \\<longrightarrow>\n                                (ad, al)\n                                \\<in> action_loc_aux P ob \\<longrightarrow>\n                                is_new_action ob \\<and> b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "proof(cases \"is_write_action ob \\<and> (ad, al) \\<in> action_loc_aux P ob \\<and> (is_new_action ob \\<longrightarrow> \\<not> b)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_write_action ob \\<and>\n    (ad, al) \\<in> action_loc_aux P ob \\<and>\n    (is_new_action ob \\<longrightarrow> \\<not> b) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)\n 2. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "case True"], ["proof (state)\nthis:\n  is_write_action ob \\<and>\n  (ad, al) \\<in> action_loc_aux P ob \\<and>\n  (is_new_action ob \\<longrightarrow> \\<not> b)\n\ngoal (2 subgoals):\n 1. is_write_action ob \\<and>\n    (ad, al) \\<in> action_loc_aux P ob \\<and>\n    (is_new_action ob \\<longrightarrow> \\<not> b) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)\n 2. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_write_action ob \\<and>\n  (ad, al) \\<in> action_loc_aux P ob \\<and>\n  (is_new_action ob \\<longrightarrow> \\<not> b)\n\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "using mrw"], ["proof (prove)\nusing this:\n  is_write_action ob \\<and>\n  (ad, al) \\<in> action_loc_aux P ob \\<and>\n  (is_new_action ob \\<longrightarrow> \\<not> b)\n  mrw_values P vs0 (obs @ [ob]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "by(fastforce elim!: is_write_action.cases intro: action_loc_aux_intros split: if_split_asm)"], ["proof (state)\nthis:\n  \\<exists>obs' wa obs''.\n     obs @ [ob] = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "case False"], ["proof (state)\nthis:\n  \\<not> (is_write_action ob \\<and>\n          (ad, al) \\<in> action_loc_aux P ob \\<and>\n          (is_new_action ob \\<longrightarrow> \\<not> b))\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "with mrw"], ["proof (chain)\npicking this:\n  mrw_values P vs0 (obs @ [ob]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  \\<not> (is_write_action ob \\<and>\n          (ad, al) \\<in> action_loc_aux P ob \\<and>\n          (is_new_action ob \\<longrightarrow> \\<not> b))", "have \"mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\""], ["proof (prove)\nusing this:\n  mrw_values P vs0 (obs @ [ob]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  \\<not> (is_write_action ob \\<and>\n          (ad, al) \\<in> action_loc_aux P ob \\<and>\n          (is_new_action ob \\<longrightarrow> \\<not> b))\n\ngoal (1 subgoal):\n 1. mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>", "by(cases \"ob\" rule: mrw_value_cases)(auto split: if_split_asm simp add: addr_locs_def split: htype.split_asm)"], ["proof (state)\nthis:\n  mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "moreover"], ["proof (state)\nthis:\n  mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "{"], ["proof (state)\nthis:\n  mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "assume \"vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor>\""], ["proof (state)\nthis:\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "hence \"\\<exists>wa. wa \\<in> set (obs @ [ob]) \\<and> is_write_action wa \\<and> (ad, al) \\<in> action_loc_aux P wa \\<and> (b \\<longrightarrow> \\<not> is_new_action wa)\""], ["proof (prove)\nusing this:\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>wa.\n       wa \\<in> set (obs @ [ob]) \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       (b \\<longrightarrow> \\<not> is_new_action wa)", "by(rule snoc)"], ["proof (state)\nthis:\n  \\<exists>wa.\n     wa \\<in> set (obs @ [ob]) \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (is_write_action ob \\<and>\n          (ad, al) \\<in> action_loc_aux P ob \\<and>\n          (is_new_action ob \\<longrightarrow> \\<not> b))\n  \\<exists>wa.\n     wa \\<in> set (obs @ [ob]) \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)", "have \"\\<exists>wa. wa \\<in> set obs \\<and> is_write_action wa \\<and> (ad, al) \\<in> action_loc_aux P wa \\<and> (b \\<longrightarrow> \\<not> is_new_action wa)\""], ["proof (prove)\nusing this:\n  \\<not> (is_write_action ob \\<and>\n          (ad, al) \\<in> action_loc_aux P ob \\<and>\n          (is_new_action ob \\<longrightarrow> \\<not> b))\n  \\<exists>wa.\n     wa \\<in> set (obs @ [ob]) \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (1 subgoal):\n 1. \\<exists>wa.\n       wa \\<in> set obs \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       (b \\<longrightarrow> \\<not> is_new_action wa)", "by auto"], ["proof (state)\nthis:\n  \\<exists>wa.\n     wa \\<in> set obs \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "}"], ["proof (state)\nthis:\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n  \\<exists>wa.\n     wa \\<in> set obs \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "ultimately"], ["proof (chain)\npicking this:\n  mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n  \\<exists>wa.\n     wa \\<in> set obs \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)", "have \"?concl obs\""], ["proof (prove)\nusing this:\n  mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n  \\<exists>wa.\n     wa \\<in> set obs \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     (b \\<longrightarrow> \\<not> is_new_action wa)\n\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       obs = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "by(rule snoc)"], ["proof (state)\nthis:\n  \\<exists>obs' wa obs''.\n     obs = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)\n\ngoal (1 subgoal):\n 1. \\<not> (is_write_action ob \\<and>\n            (ad, al) \\<in> action_loc_aux P ob \\<and>\n            (is_new_action ob \\<longrightarrow> \\<not> b)) \\<Longrightarrow>\n    \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs' wa obs''.\n     obs = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)\n\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "using False mrw"], ["proof (prove)\nusing this:\n  \\<exists>obs' wa obs''.\n     obs = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)\n  \\<not> (is_write_action ob \\<and>\n          (ad, al) \\<in> action_loc_aux P ob \\<and>\n          (is_new_action ob \\<longrightarrow> \\<not> b))\n  mrw_values P vs0 (obs @ [ob]) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obs' wa obs''.\n       obs @ [ob] = obs' @ wa # obs'' \\<and>\n       is_write_action wa \\<and>\n       (ad, al) \\<in> action_loc_aux P wa \\<and>\n       value_written_aux P wa al = v \\<and>\n       is_new_action wa = (\\<not> b) \\<and>\n       (\\<forall>ob\\<in>set obs''.\n           is_write_action ob \\<longrightarrow>\n           (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n           is_new_action ob \\<and> b)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>obs' wa obs''.\n     obs @ [ob] = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>obs' wa obs''.\n     obs @ [ob] = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mrw_values_WriteMemD:\n  assumes \"NormalAction (WriteMem ad al v') \\<in> set obs\"\n  shows \"\\<exists>v. mrw_values P vs0 obs (ad, al) = Some (v, True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, True)\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  NormalAction (WriteMem ad al v') \\<in> set obs\n\ngoal (1 subgoal):\n 1. \\<exists>v. mrw_values P vs0 obs (ad, al) = \\<lfloor>(v, True)\\<rfloor>", "apply(induct obs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. NormalAction (WriteMem ad al v') \\<in> set [] \\<Longrightarrow>\n    \\<exists>v. mrw_values P vs0 [] (ad, al) = \\<lfloor>(v, True)\\<rfloor>\n 2. \\<And>x xs.\n       \\<lbrakk>NormalAction (WriteMem ad al v')\n                \\<in> set xs \\<Longrightarrow>\n                \\<exists>v.\n                   mrw_values P vs0 xs (ad, al) =\n                   \\<lfloor>(v, True)\\<rfloor>;\n        NormalAction (WriteMem ad al v') \\<in> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_values P vs0 (xs @ [x]) (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>NormalAction (WriteMem ad al v')\n                \\<in> set xs \\<Longrightarrow>\n                \\<exists>v.\n                   mrw_values P vs0 xs (ad, al) =\n                   \\<lfloor>(v, True)\\<rfloor>;\n        NormalAction (WriteMem ad al v') \\<in> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_values P vs0 (xs @ [x]) (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>NormalAction (WriteMem ad al v')\n                \\<in> set xs \\<Longrightarrow>\n                \\<exists>v.\n                   mrw_values P vs0 xs (ad, al) =\n                   \\<lfloor>(v, True)\\<rfloor>;\n        NormalAction (WriteMem ad al v') = x \\<or>\n        NormalAction (WriteMem ad al v') \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>NormalAction (WriteMem ad al v')\n                \\<in> set xs \\<Longrightarrow>\n                \\<exists>v.\n                   mrw_values P vs0 xs (ad, al) =\n                   \\<lfloor>(v, True)\\<rfloor>;\n        NormalAction (WriteMem ad al v') = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 2. \\<And>x xs.\n       \\<lbrakk>NormalAction (WriteMem ad al v')\n                \\<in> set xs \\<Longrightarrow>\n                \\<exists>v.\n                   mrw_values P vs0 xs (ad, al) =\n                   \\<lfloor>(v, True)\\<rfloor>;\n        NormalAction (WriteMem ad al v') \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>NormalAction (WriteMem ad al v')\n                \\<in> set xs \\<Longrightarrow>\n                \\<exists>v.\n                   mrw_values P vs0 xs (ad, al) =\n                   \\<lfloor>(v, True)\\<rfloor>;\n        NormalAction (WriteMem ad al v') \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs v.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>", "apply(case_tac x rule: mrw_value_cases)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xs v ada ala va.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (WriteMem ada ala va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 2. \\<And>x xs v ada hT.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (NewHeapElem ada hT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 3. \\<And>x xs v ada M vs va.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (ExternalCall ada M vs va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 4. \\<And>x xs v ada ala va.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (ReadMem ada ala va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 5. \\<And>x xs v t.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (ThreadStart t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 6. \\<And>x xs v t.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (ThreadJoin t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 7. \\<And>x xs v ada.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (SyncLock ada)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 8. \\<And>x xs v ada.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (SyncUnlock ada)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 9. \\<And>x xs v t.\n       \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n        mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n        x = NormalAction (ObsInterrupt t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                            \\<lfloor>(v, True)\\<rfloor>\n 10. \\<And>x xs v t.\n        \\<lbrakk>NormalAction (WriteMem ad al v') \\<in> set xs;\n         mrw_values P vs0 xs (ad, al) = \\<lfloor>(v, True)\\<rfloor>;\n         x = NormalAction (ObsInterrupted t)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>v.\n                             mrw_value P (mrw_values P vs0 xs) x (ad, al) =\n                             \\<lfloor>(v, True)\\<rfloor>\nA total of 12 subgoals...", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mrw_values_new_actionD:\n  assumes \"w \\<in> set obs\" \"is_new_action w\" \"adal \\<in> action_loc_aux P w\"\n  shows \"\\<exists>v b. mrw_values P vs0 obs adal = Some (v, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v b. mrw_values P vs0 obs adal = \\<lfloor>(v, b)\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> set obs\n  is_new_action w\n  adal \\<in> action_loc_aux P w\n\ngoal (1 subgoal):\n 1. \\<exists>v b. mrw_values P vs0 obs adal = \\<lfloor>(v, b)\\<rfloor>", "apply(induct obs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<in> set []; is_new_action w;\n     adal \\<in> action_loc_aux P w\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v b.\n                         mrw_values P vs0 [] adal = \\<lfloor>(v, b)\\<rfloor>\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>w \\<in> set xs; is_new_action w;\n                 adal \\<in> action_loc_aux P w\\<rbrakk>\n                \\<Longrightarrow> \\<exists>v b.\n                                     mrw_values P vs0 xs adal =\n                                     \\<lfloor>(v, b)\\<rfloor>;\n        w \\<in> set (xs @ [x]); is_new_action w;\n        adal \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_values P vs0 (xs @ [x]) adal =\n                            \\<lfloor>(v, b)\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>w \\<in> set xs; is_new_action w;\n                 adal \\<in> action_loc_aux P w\\<rbrakk>\n                \\<Longrightarrow> \\<exists>v b.\n                                     mrw_values P vs0 xs adal =\n                                     \\<lfloor>(v, b)\\<rfloor>;\n        w \\<in> set (xs @ [x]); is_new_action w;\n        adal \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_values P vs0 (xs @ [x]) adal =\n                            \\<lfloor>(v, b)\\<rfloor>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>w \\<in> set xs \\<Longrightarrow>\n                \\<exists>v b.\n                   mrw_values P vs0 xs adal = \\<lfloor>(v, b)\\<rfloor>;\n        w = x \\<or> w \\<in> set xs; is_new_action w;\n        adal \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 xs) x adal =\n                            \\<lfloor>(v, b)\\<rfloor>", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>w \\<in> set xs \\<Longrightarrow>\n                \\<exists>v b.\n                   mrw_values P vs0 xs adal = \\<lfloor>(v, b)\\<rfloor>;\n        is_new_action w; adal \\<in> action_loc_aux P w; w = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 xs) x adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 2. \\<And>x xs.\n       \\<lbrakk>w \\<in> set xs \\<Longrightarrow>\n                \\<exists>v b.\n                   mrw_values P vs0 xs adal = \\<lfloor>(v, b)\\<rfloor>;\n        is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 xs) x adal =\n                            \\<lfloor>(v, b)\\<rfloor>", "apply(fastforce simp add: split_beta elim!: action_loc_aux_cases is_new_action.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>w \\<in> set xs \\<Longrightarrow>\n                \\<exists>v b.\n                   mrw_values P vs0 xs adal = \\<lfloor>(v, b)\\<rfloor>;\n        is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 xs) x adal =\n                            \\<lfloor>(v, b)\\<rfloor>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs v b.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set xs;\n        mrw_values P vs0 xs adal = \\<lfloor>(v, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 xs) x adal =\n                            \\<lfloor>(v, b)\\<rfloor>", "apply(rename_tac w' obs' v b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w' obs' v b.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>", "apply(case_tac w' rule: mrw_value_cases)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>w' obs' v b ad al va.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (WriteMem ad al va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 2. \\<And>w' obs' v b ad hT.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (NewHeapElem ad hT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 3. \\<And>w' obs' v b ad M vs va.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (ExternalCall ad M vs va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 4. \\<And>w' obs' v b ad al va.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (ReadMem ad al va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 5. \\<And>w' obs' v b t.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (ThreadStart t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 6. \\<And>w' obs' v b t.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (ThreadJoin t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 7. \\<And>w' obs' v b ad.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (SyncLock ad)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 8. \\<And>w' obs' v b ad.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (SyncUnlock ad)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 9. \\<And>w' obs' v b t.\n       \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n        w \\<in> set obs';\n        mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n        w' = NormalAction (ObsInterrupt t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v b.\n                            mrw_value P (mrw_values P vs0 obs') w' adal =\n                            \\<lfloor>(v, b)\\<rfloor>\n 10. \\<And>w' obs' v b t.\n        \\<lbrakk>is_new_action w; adal \\<in> action_loc_aux P w;\n         w \\<in> set obs';\n         mrw_values P vs0 obs' adal = \\<lfloor>(v, b)\\<rfloor>;\n         w' = NormalAction (ObsInterrupted t)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>v b.\n                             mrw_value P (mrw_values P vs0 obs') w' adal =\n                             \\<lfloor>(v, b)\\<rfloor>\nA total of 12 subgoals...", "apply(auto simp add: split_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mrw_value_dom_mono:\n  \"dom vs \\<subseteq> dom (mrw_value P vs ob)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom vs \\<subseteq> dom (mrw_value P vs ob)", "by(cases ob rule: mrw_value_cases) auto"], ["", "lemma mrw_values_dom_mono:\n  \"dom vs \\<subseteq> dom (mrw_values P vs obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom vs \\<subseteq> dom (mrw_values P vs obs)", "by(induct obs arbitrary: vs)(auto intro: subset_trans[OF mrw_value_dom_mono] del: subsetI)"], ["", "lemma mrw_values_eq_NoneD:\n  assumes \"mrw_values P vs0 obs adal = None\"\n  and \"w \\<in> set obs\" and \"is_write_action w\" and \"adal \\<in> action_loc_aux P w\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  mrw_values P vs0 obs adal = None\n  w \\<in> set obs\n  is_write_action w\n  adal \\<in> action_loc_aux P w\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mrw_values P vs0 obs adal = None; w \\<in> set obs;\n     is_write_action w; adal \\<in> action_loc_aux P w\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule is_write_action.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ad hT.\n       \\<lbrakk>mrw_values P vs0 obs adal = None; w \\<in> set obs;\n        adal \\<in> action_loc_aux P w;\n        w = NormalAction (NewHeapElem ad hT)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ad al v.\n       \\<lbrakk>mrw_values P vs0 obs adal = None; w \\<in> set obs;\n        adal \\<in> action_loc_aux P w;\n        w = NormalAction (WriteMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(fastforce dest: mrw_values_WriteMemD[where ?vs0.0=vs0 and P=P] mrw_values_new_actionD[where ?vs0.0=vs0] elim: action_loc_aux_cases)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mrw_values_mrw:\n  assumes mrw: \"mrw_values P vs0 (map snd obs) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\"\n  and initial: \"vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow> \\<exists>wa. wa \\<in> set (map snd obs) \\<and> is_write_action wa \\<and> (ad, al) \\<in> action_loc_aux P wa \\<and> (b \\<longrightarrow> \\<not> is_new_action wa)\"\n  shows \"\\<exists>i. i < length obs \\<and> P,llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and> value_written P (llist_of obs) i (ad, al) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "from mrw_values_eq_SomeD[OF mrw initial]"], ["proof (chain)\npicking this:\n  (vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n   vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor>) \\<Longrightarrow>\n  \\<exists>obs' wa obs''.\n     map snd obs = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)", "obtain obs' wa obs'' where obs: \"map snd obs = obs' @ wa # obs''\"\n    and wa: \"is_write_action wa\"\n    and adal: \"(ad, al) \\<in> action_loc_aux P wa\"\n    and written: \"value_written_aux P wa al = v\"\n    and new: \"is_new_action wa \\<longleftrightarrow> \\<not> b\"\n    and last: \"\\<And>ob. \\<lbrakk> ob \\<in> set obs''; is_write_action ob; (ad, al) \\<in> action_loc_aux P ob \\<rbrakk> \\<Longrightarrow> is_new_action ob \\<and> b\""], ["proof (prove)\nusing this:\n  (vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n   vs0 (ad, al) = \\<lfloor>(v, b)\\<rfloor>) \\<Longrightarrow>\n  \\<exists>obs' wa obs''.\n     map snd obs = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> b) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> b)\n\ngoal (1 subgoal):\n 1. (\\<And>obs' wa obs''.\n        \\<lbrakk>map snd obs = obs' @ wa # obs''; is_write_action wa;\n         (ad, al) \\<in> action_loc_aux P wa; value_written_aux P wa al = v;\n         is_new_action wa = (\\<not> b);\n         \\<And>ob.\n            \\<lbrakk>ob \\<in> set obs''; is_write_action ob;\n             (ad, al) \\<in> action_loc_aux P ob\\<rbrakk>\n            \\<Longrightarrow> is_new_action ob \\<and> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map snd obs = obs' @ wa # obs''\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  value_written_aux P wa al = v\n  is_new_action wa = (\\<not> b)\n  \\<lbrakk>?ob \\<in> set obs''; is_write_action ?ob;\n   (ad, al) \\<in> action_loc_aux P ?ob\\<rbrakk>\n  \\<Longrightarrow> is_new_action ?ob \\<and> b\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "let ?i = \"length obs'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "let ?E = \"llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "from obs"], ["proof (chain)\npicking this:\n  map snd obs = obs' @ wa # obs''", "have len: \"length (map snd obs) = Suc (length obs') + length obs''\""], ["proof (prove)\nusing this:\n  map snd obs = obs' @ wa # obs''\n\ngoal (1 subgoal):\n 1. length (map snd obs) = Suc (length obs') + length obs''", "by simp"], ["proof (state)\nthis:\n  length (map snd obs) = Suc (length obs') + length obs''\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "hence \"?i < length obs\""], ["proof (prove)\nusing this:\n  length (map snd obs) = Suc (length obs') + length obs''\n\ngoal (1 subgoal):\n 1. length obs' < length obs", "by simp"], ["proof (state)\nthis:\n  length obs' < length obs\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "moreover"], ["proof (state)\nthis:\n  length obs' < length obs\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "hence obs_i: \"action_obs ?E ?i = wa\""], ["proof (prove)\nusing this:\n  length obs' < length obs\n\ngoal (1 subgoal):\n 1. action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n     (length obs') =\n    wa", "using len obs"], ["proof (prove)\nusing this:\n  length obs' < length obs\n  length (map snd obs) = Suc (length obs') + length obs''\n  map snd obs = obs' @ wa # obs''\n\ngoal (1 subgoal):\n 1. action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n     (length obs') =\n    wa", "by(auto simp add: action_obs_def map_eq_append_conv)"], ["proof (state)\nthis:\n  action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n   (length obs') =\n  wa\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "have \"P,?E \\<turnstile> length obs \\<leadsto>mrw ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,llist_of\n       (obs @\n        [(t, NormalAction\n              (ReadMem ad al\n                v))]) \\<turnstile> length obs \\<leadsto>mrw length obs'", "proof(rule most_recent_write_for.intros)"], ["proof (state)\ngoal (6 subgoals):\n 1. length obs\n    \\<in> read_actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n 2. ?adal\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs)\n 3. llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al v))]) \\<turnstile> length obs' \\<le>a length obs\n 4. length obs'\n    \\<in> write_actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n 5. ?adal\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs')\n 6. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        ?adal\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "show \"length obs \\<in> read_actions ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length obs\n    \\<in> read_actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "by(auto intro: read_actions.intros simp add: actions_def action_obs_def)"], ["proof (state)\nthis:\n  length obs\n  \\<in> read_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (5 subgoals):\n 1. ?adal\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs)\n 2. llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al v))]) \\<turnstile> length obs' \\<le>a length obs\n 3. length obs'\n    \\<in> write_actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n 4. ?adal\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs')\n 5. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        ?adal\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "show \"(ad, al) \\<in> action_loc P ?E (length obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ad, al)\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs)", "by(simp add: action_obs_def lnth_llist_of)"], ["proof (state)\nthis:\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n         (length obs)\n\ngoal (4 subgoals):\n 1. llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al v))]) \\<turnstile> length obs' \\<le>a length obs\n 2. length obs'\n    \\<in> write_actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n 3. (ad, al)\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs')\n 4. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        (ad, al)\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "show \"?E \\<turnstile> length obs' \\<le>a length obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al v))]) \\<turnstile> length obs' \\<le>a length obs", "using len"], ["proof (prove)\nusing this:\n  length (map snd obs) = Suc (length obs') + length obs''\n\ngoal (1 subgoal):\n 1. llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al v))]) \\<turnstile> length obs' \\<le>a length obs", "by-(rule action_orderI, auto simp add: actions_def action_obs_def nth_append)"], ["proof (state)\nthis:\n  llist_of\n   (obs @\n    [(t, NormalAction\n          (ReadMem ad al v))]) \\<turnstile> length obs' \\<le>a length obs\n\ngoal (3 subgoals):\n 1. length obs'\n    \\<in> write_actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n 2. (ad, al)\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs')\n 3. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        (ad, al)\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "show \"?i \\<in> write_actions ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length obs'\n    \\<in> write_actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "using len obs wa"], ["proof (prove)\nusing this:\n  length (map snd obs) = Suc (length obs') + length obs''\n  map snd obs = obs' @ wa # obs''\n  is_write_action wa\n\ngoal (1 subgoal):\n 1. length obs'\n    \\<in> write_actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "by-(rule write_actions.intros, auto simp add: actions_def action_obs_def nth_append map_eq_append_conv)"], ["proof (state)\nthis:\n  length obs'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (2 subgoals):\n 1. (ad, al)\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs')\n 2. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        (ad, al)\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "show \"(ad, al) \\<in> action_loc P ?E ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ad, al)\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs')", "using obs_i adal"], ["proof (prove)\nusing this:\n  action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n   (length obs') =\n  wa\n  (ad, al) \\<in> action_loc_aux P wa\n\ngoal (1 subgoal):\n 1. (ad, al)\n    \\<in> action_loc P\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n           (length obs')", "by simp"], ["proof (state)\nthis:\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n         (length obs')\n\ngoal (1 subgoal):\n 1. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        (ad, al)\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "fix wa'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        (ad, al)\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "assume wa': \"wa' \\<in> write_actions ?E\"\n      and adal': \"(ad, al) \\<in> action_loc P ?E wa'\""], ["proof (state)\nthis:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa'\n\ngoal (1 subgoal):\n 1. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        (ad, al)\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "from wa' \\<open>?i \\<in> write_actions ?E\\<close>"], ["proof (chain)\npicking this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n  length obs'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "have \"wa' \\<in> actions ?E\" \"?i \\<in> actions ?E\""], ["proof (prove)\nusing this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n  length obs'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. wa'\n    \\<in> actions\n           (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) &&&\n    length obs'\n    \\<in> actions (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "by simp_all"], ["proof (state)\nthis:\n  wa' \\<in> actions (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n  length obs'\n  \\<in> actions (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        (ad, al)\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "hence \"?E \\<turnstile> wa' \\<le>a ?i\""], ["proof (prove)\nusing this:\n  wa' \\<in> actions (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n  length obs'\n  \\<in> actions (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al v))]) \\<turnstile> wa' \\<le>a length obs'", "proof(rule action_orderI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_new_action\n              (action_obs\n                (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n                wa');\n     is_new_action\n      (action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n        (length obs'))\\<rbrakk>\n    \\<Longrightarrow> wa' \\<le> length obs'\n 2. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "assume new_wa': \"is_new_action (action_obs ?E wa')\"\n        and new_i: \"is_new_action (action_obs ?E ?i)\""], ["proof (state)\nthis:\n  is_new_action\n   (action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa')\n  is_new_action\n   (action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n     (length obs'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_new_action\n              (action_obs\n                (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n                wa');\n     is_new_action\n      (action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n        (length obs'))\\<rbrakk>\n    \\<Longrightarrow> wa' \\<le> length obs'\n 2. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "from new_i obs_i new"], ["proof (chain)\npicking this:\n  is_new_action\n   (action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n     (length obs'))\n  action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n   (length obs') =\n  wa\n  is_new_action wa = (\\<not> b)", "have b: \"\\<not> b\""], ["proof (prove)\nusing this:\n  is_new_action\n   (action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n     (length obs'))\n  action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n   (length obs') =\n  wa\n  is_new_action wa = (\\<not> b)\n\ngoal (1 subgoal):\n 1. \\<not> b", "by simp"], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_new_action\n              (action_obs\n                (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n                wa');\n     is_new_action\n      (action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n        (length obs'))\\<rbrakk>\n    \\<Longrightarrow> wa' \\<le> length obs'\n 2. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "show \"wa' \\<le> ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa' \\<le> length obs'", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> wa' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "hence \"?i < wa'\""], ["proof (prove)\nusing this:\n  \\<not> wa' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. length obs' < wa'", "by simp"], ["proof (state)\nthis:\n  length obs' < wa'\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "hence \"snd (obs ! wa') \\<in> set obs''\""], ["proof (prove)\nusing this:\n  length obs' < wa'\n\ngoal (1 subgoal):\n 1. snd (obs ! wa') \\<in> set obs''", "using obs wa'"], ["proof (prove)\nusing this:\n  length obs' < wa'\n  map snd obs = obs' @ wa # obs''\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. snd (obs ! wa') \\<in> set obs''", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  length obs' < wa'\n  map snd obs = obs' @ wa # obs''\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs''. obs'' ! i = snd (obs ! wa')", "by -(rule exI[where x=\"wa' - Suc (length obs')\"], auto elim!: write_actions.cases actionsE simp add: action_obs_def lnth_llist_of actions_def nth_append map_eq_append_conv nth_Cons' split: if_split_asm)"], ["proof (state)\nthis:\n  snd (obs ! wa') \\<in> set obs''\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  snd (obs ! wa') \\<in> set obs''\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "from wa'"], ["proof (chain)\npicking this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "have \"is_write_action (snd (obs ! wa'))\""], ["proof (prove)\nusing this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. is_write_action (snd (obs ! wa'))", "by cases(auto simp add: action_obs_def nth_append actions_def split: if_split_asm)"], ["proof (state)\nthis:\n  is_write_action (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_write_action (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "from adal' wa'"], ["proof (chain)\npicking this:\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa'\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "have \"(ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\""], ["proof (prove)\nusing this:\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa'\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))", "by(auto simp add: action_obs_def nth_append nth_Cons' actions_def split: if_split_asm elim!: write_actions.cases)"], ["proof (state)\nthis:\n  (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  snd (obs ! wa') \\<in> set obs''\n  is_write_action (snd (obs ! wa'))\n  (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))", "show False"], ["proof (prove)\nusing this:\n  snd (obs ! wa') \\<in> set obs''\n  is_write_action (snd (obs ! wa'))\n  (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. False", "using last[of \"snd (obs ! wa')\"] b"], ["proof (prove)\nusing this:\n  snd (obs ! wa') \\<in> set obs''\n  is_write_action (snd (obs ! wa'))\n  (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\n  \\<lbrakk>snd (obs ! wa') \\<in> set obs'';\n   is_write_action (snd (obs ! wa'));\n   (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\\<rbrakk>\n  \\<Longrightarrow> is_new_action (snd (obs ! wa')) \\<and> b\n  \\<not> b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wa' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "assume new_wa': \"\\<not> is_new_action (action_obs ?E wa')\""], ["proof (state)\nthis:\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa')\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "with wa' adal'"], ["proof (chain)\npicking this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa'\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa')", "obtain v' where \"NormalAction (WriteMem ad al v') \\<in> set (map snd obs)\""], ["proof (prove)\nusing this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa'\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa')\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        NormalAction (WriteMem ad al v')\n        \\<in> set (map snd obs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa'\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa')\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<exists>i<length (map snd obs).\n           map snd obs ! i =\n           NormalAction (WriteMem ad al v') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (fastforce elim!: write_actions.cases is_write_action.cases simp add: action_obs_def actions_def nth_append split: if_split_asm intro!: exI[where x=wa'])"], ["proof (state)\nthis:\n  NormalAction (WriteMem ad al v') \\<in> set (map snd obs)\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "from mrw_values_WriteMemD[OF this, of P vs0] mrw"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     mrw_values P vs0 (map snd obs) (ad, al) = \\<lfloor>(v, True)\\<rfloor>\n  mrw_values P vs0 (map snd obs) (ad, al) = \\<lfloor>(v, b)\\<rfloor>", "have b"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     mrw_values P vs0 (map snd obs) (ad, al) = \\<lfloor>(v, True)\\<rfloor>\n  mrw_values P vs0 (map snd obs) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. b", "by simp"], ["proof (state)\nthis:\n  b\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "with new obs_i"], ["proof (chain)\npicking this:\n  is_new_action wa = (\\<not> b)\n  action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n   (length obs') =\n  wa\n  b", "have \"\\<not> is_new_action (action_obs ?E ?i)\""], ["proof (prove)\nusing this:\n  is_new_action wa = (\\<not> b)\n  action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n   (length obs') =\n  wa\n  b\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs'))", "by simp"], ["proof (state)\nthis:\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n            (length obs'))\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "moreover"], ["proof (state)\nthis:\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n            (length obs'))\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "have \"wa' \\<le> ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa' \\<le> length obs'", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> wa' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "hence \"?i < wa'\""], ["proof (prove)\nusing this:\n  \\<not> wa' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. length obs' < wa'", "by simp"], ["proof (state)\nthis:\n  length obs' < wa'\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "hence \"snd (obs ! wa') \\<in> set obs''\""], ["proof (prove)\nusing this:\n  length obs' < wa'\n\ngoal (1 subgoal):\n 1. snd (obs ! wa') \\<in> set obs''", "using obs wa'"], ["proof (prove)\nusing this:\n  length obs' < wa'\n  map snd obs = obs' @ wa # obs''\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. snd (obs ! wa') \\<in> set obs''", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  length obs' < wa'\n  map snd obs = obs' @ wa # obs''\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs''. obs'' ! i = snd (obs ! wa')", "by -(rule exI[where x=\"wa' - Suc (length obs')\"], auto elim!: write_actions.cases actionsE simp add: action_obs_def lnth_llist_of actions_def nth_append map_eq_append_conv nth_Cons' split: if_split_asm)"], ["proof (state)\nthis:\n  snd (obs ! wa') \\<in> set obs''\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  snd (obs ! wa') \\<in> set obs''\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "from wa'"], ["proof (chain)\npicking this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "have \"is_write_action (snd (obs ! wa'))\""], ["proof (prove)\nusing this:\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. is_write_action (snd (obs ! wa'))", "by cases(auto simp add: action_obs_def nth_append actions_def split: if_split_asm)"], ["proof (state)\nthis:\n  is_write_action (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_write_action (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "from adal' wa'"], ["proof (chain)\npicking this:\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa'\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "have \"(ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\""], ["proof (prove)\nusing this:\n  (ad, al)\n  \\<in> action_loc P\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa'\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))", "by(auto simp add: action_obs_def nth_append nth_Cons' actions_def split: if_split_asm elim!: write_actions.cases)"], ["proof (state)\nthis:\n  (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  snd (obs ! wa') \\<in> set obs''\n  is_write_action (snd (obs ! wa'))\n  (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))", "have \"is_new_action (snd (obs ! wa'))\""], ["proof (prove)\nusing this:\n  snd (obs ! wa') \\<in> set obs''\n  is_write_action (snd (obs ! wa'))\n  (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. is_new_action (snd (obs ! wa'))", "using last[of \"snd (obs ! wa')\"]"], ["proof (prove)\nusing this:\n  snd (obs ! wa') \\<in> set obs''\n  is_write_action (snd (obs ! wa'))\n  (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\n  \\<lbrakk>snd (obs ! wa') \\<in> set obs'';\n   is_write_action (snd (obs ! wa'));\n   (ad, al) \\<in> action_loc_aux P (snd (obs ! wa'))\\<rbrakk>\n  \\<Longrightarrow> is_new_action (snd (obs ! wa')) \\<and> b\n\ngoal (1 subgoal):\n 1. is_new_action (snd (obs ! wa'))", "by simp"], ["proof (state)\nthis:\n  is_new_action (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_new_action (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "from new_wa' wa'"], ["proof (chain)\npicking this:\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa')\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))", "have \"\\<not> is_new_action (snd (obs ! wa'))\""], ["proof (prove)\nusing this:\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))])) wa')\n  wa'\n  \\<in> write_actions\n         (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action (snd (obs ! wa'))", "by(auto elim!: write_actions.cases simp add: action_obs_def nth_append actions_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<not> is_new_action (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. \\<not> wa' \\<le> length obs' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  is_new_action (snd (obs ! wa'))\n  \\<not> is_new_action (snd (obs ! wa'))", "show False"], ["proof (prove)\nusing this:\n  is_new_action (snd (obs ! wa'))\n  \\<not> is_new_action (snd (obs ! wa'))\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wa' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              wa') \\<Longrightarrow>\n    \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n            (length obs'))\n  wa' \\<le> length obs'", "show \"\\<not> is_new_action (action_obs ?E ?i) \\<and> wa' \\<le> ?i\""], ["proof (prove)\nusing this:\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n            (length obs'))\n  wa' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action\n            (action_obs\n              (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n              (length obs')) \\<and>\n    wa' \\<le> length obs'", "by blast"], ["proof (state)\nthis:\n  \\<not> is_new_action\n          (action_obs\n            (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n            (length obs')) \\<and>\n  wa' \\<le> length obs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llist_of\n   (obs @\n    [(t, NormalAction\n          (ReadMem ad al v))]) \\<turnstile> wa' \\<le>a length obs'\n\ngoal (1 subgoal):\n 1. \\<And>wa'.\n       \\<lbrakk>wa'\n                \\<in> write_actions\n                       (llist_of\n                         (obs @ [(t, NormalAction (ReadMem ad al v))]));\n        (ad, al)\n        \\<in> action_loc P\n               (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n               wa'\\<rbrakk>\n       \\<Longrightarrow> llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> wa' \\<le>a length\n                            obs' \\<or>\n                         llist_of\n                          (obs @\n                           [(t, NormalAction\n                                 (ReadMem ad al\n                                   v))]) \\<turnstile> length obs \\<le>a wa'", "thus \"?E \\<turnstile> wa' \\<le>a ?i \\<or> ?E \\<turnstile> length obs \\<le>a wa'\""], ["proof (prove)\nusing this:\n  llist_of\n   (obs @\n    [(t, NormalAction\n          (ReadMem ad al v))]) \\<turnstile> wa' \\<le>a length obs'\n\ngoal (1 subgoal):\n 1. llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al v))]) \\<turnstile> wa' \\<le>a length obs' \\<or>\n    llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al v))]) \\<turnstile> length obs \\<le>a wa'", ".."], ["proof (state)\nthis:\n  llist_of\n   (obs @\n    [(t, NormalAction\n          (ReadMem ad al v))]) \\<turnstile> wa' \\<le>a length obs' \\<or>\n  llist_of\n   (obs @\n    [(t, NormalAction\n          (ReadMem ad al v))]) \\<turnstile> length obs \\<le>a wa'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al\n              v))]) \\<turnstile> length obs \\<leadsto>mrw length obs'\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "moreover"], ["proof (state)\nthis:\n  P,llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al\n              v))]) \\<turnstile> length obs \\<leadsto>mrw length obs'\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "from written \\<open>?i < length obs\\<close> obs_i"], ["proof (chain)\npicking this:\n  value_written_aux P wa al = v\n  length obs' < length obs\n  action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n   (length obs') =\n  wa", "have \"value_written P (llist_of obs) ?i (ad, al) = v\""], ["proof (prove)\nusing this:\n  value_written_aux P wa al = v\n  length obs' < length obs\n  action_obs (llist_of (obs @ [(t, NormalAction (ReadMem ad al v))]))\n   (length obs') =\n  wa\n\ngoal (1 subgoal):\n 1. value_written P (llist_of obs) (length obs') (ad, al) = v", "by(simp add: value_written_def action_obs_def nth_append)"], ["proof (state)\nthis:\n  value_written P (llist_of obs) (length obs') (ad, al) = v\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "ultimately"], ["proof (chain)\npicking this:\n  length obs' < length obs\n  P,llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al\n              v))]) \\<turnstile> length obs \\<leadsto>mrw length obs'\n  value_written P (llist_of obs) (length obs') (ad, al) = v", "show ?thesis"], ["proof (prove)\nusing this:\n  length obs' < length obs\n  P,llist_of\n     (obs @\n      [(t, NormalAction\n            (ReadMem ad al\n              v))]) \\<turnstile> length obs \\<leadsto>mrw length obs'\n  value_written P (llist_of obs) (length obs') (ad, al) = v\n\ngoal (1 subgoal):\n 1. \\<exists>i<length obs.\n       P,llist_of\n          (obs @\n           [(t, NormalAction\n                 (ReadMem ad al\n                   v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n       value_written P (llist_of obs) i (ad, al) = v", "by blast"], ["proof (state)\nthis:\n  \\<exists>i<length obs.\n     P,llist_of\n        (obs @\n         [(t, NormalAction\n               (ReadMem ad al\n                 v))]) \\<turnstile> length obs \\<leadsto>mrw i \\<and>\n     value_written P (llist_of obs) i (ad, al) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mrw_values_no_write_unchanged:\n  assumes no_write: \"\\<And>w. \\<lbrakk> w \\<in> set obs; is_write_action w; adal \\<in> action_loc_aux P w \\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False | Some (v, b) \\<Rightarrow> b \\<and> is_new_action w\"\n  shows \"mrw_values P vs obs adal = vs adal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P vs obs adal = vs adal", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<in> set obs; is_write_action ?w;\n   adal \\<in> action_loc_aux P ?w\\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                        b \\<and> is_new_action ?w\n\ngoal (1 subgoal):\n 1. mrw_values P vs obs adal = vs adal", "proof(induct obs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       (\\<And>w.\n           \\<lbrakk>w \\<in> set []; is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w) \\<Longrightarrow>\n       mrw_values P vs [] adal = vs adal\n 2. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   (\\<And>w.\n                       \\<lbrakk>w \\<in> set obs; is_write_action w;\n                        adal \\<in> action_loc_aux P w\\<rbrakk>\n                       \\<Longrightarrow> case vs adal of\n   None \\<Rightarrow> False\n   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n       b \\<and> is_new_action w) \\<Longrightarrow>\n                   mrw_values P vs obs adal = vs adal;\n        \\<And>w.\n           \\<lbrakk>w \\<in> set (a # obs); is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w\\<rbrakk>\n       \\<Longrightarrow> mrw_values P vs (a # obs) adal = vs adal", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?w \\<in> set []; is_write_action ?w;\n   adal \\<in> action_loc_aux P ?w\\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                        b \\<and> is_new_action ?w\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       (\\<And>w.\n           \\<lbrakk>w \\<in> set []; is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w) \\<Longrightarrow>\n       mrw_values P vs [] adal = vs adal\n 2. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   (\\<And>w.\n                       \\<lbrakk>w \\<in> set obs; is_write_action w;\n                        adal \\<in> action_loc_aux P w\\<rbrakk>\n                       \\<Longrightarrow> case vs adal of\n   None \\<Rightarrow> False\n   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n       b \\<and> is_new_action w) \\<Longrightarrow>\n                   mrw_values P vs obs adal = vs adal;\n        \\<And>w.\n           \\<lbrakk>w \\<in> set (a # obs); is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w\\<rbrakk>\n       \\<Longrightarrow> mrw_values P vs (a # obs) adal = vs adal", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P vs [] adal = vs adal", "by simp"], ["proof (state)\nthis:\n  mrw_values P vs [] adal = vs adal\n\ngoal (1 subgoal):\n 1. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   (\\<And>w.\n                       \\<lbrakk>w \\<in> set obs; is_write_action w;\n                        adal \\<in> action_loc_aux P w\\<rbrakk>\n                       \\<Longrightarrow> case vs adal of\n   None \\<Rightarrow> False\n   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n       b \\<and> is_new_action w) \\<Longrightarrow>\n                   mrw_values P vs obs adal = vs adal;\n        \\<And>w.\n           \\<lbrakk>w \\<in> set (a # obs); is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w\\<rbrakk>\n       \\<Longrightarrow> mrw_values P vs (a # obs) adal = vs adal", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   (\\<And>w.\n                       \\<lbrakk>w \\<in> set obs; is_write_action w;\n                        adal \\<in> action_loc_aux P w\\<rbrakk>\n                       \\<Longrightarrow> case vs adal of\n   None \\<Rightarrow> False\n   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n       b \\<and> is_new_action w) \\<Longrightarrow>\n                   mrw_values P vs obs adal = vs adal;\n        \\<And>w.\n           \\<lbrakk>w \\<in> set (a # obs); is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w\\<rbrakk>\n       \\<Longrightarrow> mrw_values P vs (a # obs) adal = vs adal", "case (Cons ob obs)"], ["proof (state)\nthis:\n  (\\<And>w.\n      \\<lbrakk>w \\<in> set obs; is_write_action w;\n       adal \\<in> action_loc_aux P w\\<rbrakk>\n      \\<Longrightarrow> case ?vs adal of None \\<Rightarrow> False\n                        | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                            b \\<and> is_new_action w) \\<Longrightarrow>\n  mrw_values P ?vs obs adal = ?vs adal\n  \\<lbrakk>?w \\<in> set (ob # obs); is_write_action ?w;\n   adal \\<in> action_loc_aux P ?w\\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                        b \\<and> is_new_action ?w\n\ngoal (1 subgoal):\n 1. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   (\\<And>w.\n                       \\<lbrakk>w \\<in> set obs; is_write_action w;\n                        adal \\<in> action_loc_aux P w\\<rbrakk>\n                       \\<Longrightarrow> case vs adal of\n   None \\<Rightarrow> False\n   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n       b \\<and> is_new_action w) \\<Longrightarrow>\n                   mrw_values P vs obs adal = vs adal;\n        \\<And>w.\n           \\<lbrakk>w \\<in> set (a # obs); is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w\\<rbrakk>\n       \\<Longrightarrow> mrw_values P vs (a # obs) adal = vs adal", "from Cons.prems[of ob]"], ["proof (chain)\npicking this:\n  \\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n   adal \\<in> action_loc_aux P ob\\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                        b \\<and> is_new_action ob", "have \"mrw_value P vs ob adal = vs adal\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n   adal \\<in> action_loc_aux P ob\\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                        b \\<and> is_new_action ob\n\ngoal (1 subgoal):\n 1. mrw_value P vs ob adal = vs adal", "apply(cases adal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal", "apply(cases ob rule: mrw_value_cases, fastforce+)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>a b ad hT.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (NewHeapElem ad hT)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 2. \\<And>a b ad M vs v.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (ExternalCall ad M vs v)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 3. \\<And>a b ad al v.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 4. \\<And>a b t.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (ThreadStart t)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 5. \\<And>a b t.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (ThreadJoin t)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 6. \\<And>a b ad.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (SyncLock ad)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 7. \\<And>a b ad.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (SyncUnlock ad)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 8. \\<And>a b t.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (ObsInterrupt t)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 9. \\<And>a b t.\n       \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                 adal \\<in> action_loc_aux P ob\\<rbrakk>\n                \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\nb \\<and> is_new_action ob;\n        adal = (a, b); ob = NormalAction (ObsInterrupted t)\\<rbrakk>\n       \\<Longrightarrow> mrw_value P vs ob adal = vs adal\n 10. \\<And>a b.\n        \\<lbrakk>\\<lbrakk>ob \\<in> set (ob # obs); is_write_action ob;\n                  adal \\<in> action_loc_aux P ob\\<rbrakk>\n                 \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                                   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n b \\<and> is_new_action ob;\n         adal = (a, b); ob = InitialThreadAction\\<rbrakk>\n        \\<Longrightarrow> mrw_value P vs ob adal = vs adal\nA total of 11 subgoals...", "apply(auto simp add: addr_locs_def split: htype.split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a x1 D F fm T.\n       \\<lbrakk>\\<exists>T fm.\n                   P \\<turnstile> x1 has F:T (fm) in D \\<Longrightarrow>\n                False;\n        adal = (a, CField D F);\n        ob = NormalAction (NewHeapElem a (Class_type x1));\n        vs (a, CField D F) = None;\n        P \\<turnstile> x1 has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a x21 x22 F fm T.\n       \\<lbrakk>\\<exists>T fm.\n                   P \\<turnstile> Object has F:T (fm) in Object \\<Longrightarrow>\n                False;\n        adal = (a, CField Object F);\n        ob = NormalAction (NewHeapElem a (Array_type x21 x22));\n        vs (a, CField Object F) = None;\n        P \\<turnstile> Object has F:T (fm) in Object\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a aa ba x1 D F fm T.\n       \\<lbrakk>\\<not> ba;\n        \\<exists>T fm. P \\<turnstile> x1 has F:T (fm) in D \\<Longrightarrow>\n        False;\n        adal = (a, CField D F);\n        ob = NormalAction (NewHeapElem a (Class_type x1));\n        vs (a, CField D F) = \\<lfloor>(aa, False)\\<rfloor>;\n        P \\<turnstile> x1 has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> default_val T = aa\n 4. \\<And>a aa ba x21 x22 F fm T.\n       \\<lbrakk>\\<not> ba;\n        \\<exists>T fm.\n           P \\<turnstile> Object has F:T (fm) in Object \\<Longrightarrow>\n        False;\n        adal = (a, CField Object F);\n        ob = NormalAction (NewHeapElem a (Array_type x21 x22));\n        vs (a, CField Object F) = \\<lfloor>(aa, False)\\<rfloor>;\n        P \\<turnstile> Object has F:T (fm) in Object\\<rbrakk>\n       \\<Longrightarrow> default_val T = aa", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mrw_value P vs ob adal = vs adal\n\ngoal (1 subgoal):\n 1. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   (\\<And>w.\n                       \\<lbrakk>w \\<in> set obs; is_write_action w;\n                        adal \\<in> action_loc_aux P w\\<rbrakk>\n                       \\<Longrightarrow> case vs adal of\n   None \\<Rightarrow> False\n   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n       b \\<and> is_new_action w) \\<Longrightarrow>\n                   mrw_values P vs obs adal = vs adal;\n        \\<And>w.\n           \\<lbrakk>w \\<in> set (a # obs); is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w\\<rbrakk>\n       \\<Longrightarrow> mrw_values P vs (a # obs) adal = vs adal", "moreover"], ["proof (state)\nthis:\n  mrw_value P vs ob adal = vs adal\n\ngoal (1 subgoal):\n 1. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   (\\<And>w.\n                       \\<lbrakk>w \\<in> set obs; is_write_action w;\n                        adal \\<in> action_loc_aux P w\\<rbrakk>\n                       \\<Longrightarrow> case vs adal of\n   None \\<Rightarrow> False\n   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n       b \\<and> is_new_action w) \\<Longrightarrow>\n                   mrw_values P vs obs adal = vs adal;\n        \\<And>w.\n           \\<lbrakk>w \\<in> set (a # obs); is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w\\<rbrakk>\n       \\<Longrightarrow> mrw_values P vs (a # obs) adal = vs adal", "have \"mrw_values P (mrw_value P vs ob) obs adal = mrw_value P vs ob adal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P (mrw_value P vs ob) obs adal = mrw_value P vs ob adal", "proof(rule Cons.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set obs; is_write_action w;\n        adal \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P vs ob adal of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set obs; is_write_action w;\n        adal \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P vs ob adal of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "assume \"w \\<in> set obs\" \"is_write_action w\" \"adal \\<in> action_loc_aux P w\""], ["proof (state)\nthis:\n  w \\<in> set obs\n  is_write_action w\n  adal \\<in> action_loc_aux P w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set obs; is_write_action w;\n        adal \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P vs ob adal of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "with Cons.prems[of w] \\<open>mrw_value P vs ob adal = vs adal\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>w \\<in> set (ob # obs); is_write_action w;\n   adal \\<in> action_loc_aux P w\\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                        b \\<and> is_new_action w\n  mrw_value P vs ob adal = vs adal\n  w \\<in> set obs\n  is_write_action w\n  adal \\<in> action_loc_aux P w", "show \"case mrw_value P vs ob adal of None \\<Rightarrow> False | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>w \\<in> set (ob # obs); is_write_action w;\n   adal \\<in> action_loc_aux P w\\<rbrakk>\n  \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                        b \\<and> is_new_action w\n  mrw_value P vs ob adal = vs adal\n  w \\<in> set obs\n  is_write_action w\n  adal \\<in> action_loc_aux P w\n\ngoal (1 subgoal):\n 1. case mrw_value P vs ob adal of None \\<Rightarrow> False\n    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action w", "by simp"], ["proof (state)\nthis:\n  case mrw_value P vs ob adal of None \\<Rightarrow> False\n  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mrw_values P (mrw_value P vs ob) obs adal = mrw_value P vs ob adal\n\ngoal (1 subgoal):\n 1. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   (\\<And>w.\n                       \\<lbrakk>w \\<in> set obs; is_write_action w;\n                        adal \\<in> action_loc_aux P w\\<rbrakk>\n                       \\<Longrightarrow> case vs adal of\n   None \\<Rightarrow> False\n   | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n       b \\<and> is_new_action w) \\<Longrightarrow>\n                   mrw_values P vs obs adal = vs adal;\n        \\<And>w.\n           \\<lbrakk>w \\<in> set (a # obs); is_write_action w;\n            adal \\<in> action_loc_aux P w\\<rbrakk>\n           \\<Longrightarrow> case vs adal of None \\<Rightarrow> False\n                             | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                                 b \\<and> is_new_action w\\<rbrakk>\n       \\<Longrightarrow> mrw_values P vs (a # obs) adal = vs adal", "ultimately"], ["proof (chain)\npicking this:\n  mrw_value P vs ob adal = vs adal\n  mrw_values P (mrw_value P vs ob) obs adal = mrw_value P vs ob adal", "show ?case"], ["proof (prove)\nusing this:\n  mrw_value P vs ob adal = vs adal\n  mrw_values P (mrw_value P vs ob) obs adal = mrw_value P vs ob adal\n\ngoal (1 subgoal):\n 1. mrw_values P vs (ob # obs) adal = vs adal", "by simp"], ["proof (state)\nthis:\n  mrw_values P vs (ob # obs) adal = vs adal\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Coinductive version of sequentially consistent prefixes\\<close>"], ["", "coinductive ta_seq_consist :: \n  \"'m prog \\<Rightarrow> ('addr \\<times> addr_loc \\<rightharpoonup> 'addr val \\<times> bool) \\<Rightarrow> ('addr, 'thread_id) obs_event action llist \\<Rightarrow> bool\"\nfor P :: \"'m prog\" \nwhere\n  LNil: \"ta_seq_consist P vs LNil\"\n| LCons:\n  \"\\<lbrakk> case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor> | _ \\<Rightarrow> True;\n     ta_seq_consist P (mrw_value P vs ob) obs \\<rbrakk> \n  \\<Longrightarrow> ta_seq_consist P vs (LCons ob obs)\""], ["", "inductive_simps ta_seq_consist_simps [simp]:\n  \"ta_seq_consist P vs LNil\"\n  \"ta_seq_consist P vs (LCons ob obs)\""], ["", "lemma ta_seq_consist_lappend:\n  assumes \"lfinite obs\"\n  shows \"ta_seq_consist P vs (lappend obs obs') \\<longleftrightarrow>\n         ta_seq_consist P vs obs \\<and> ta_seq_consist P (mrw_values P vs (list_of obs)) obs'\"\n  (is \"?concl vs obs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (lappend obs obs') =\n    (ta_seq_consist P vs obs \\<and>\n     ta_seq_consist P (mrw_values P vs (list_of obs)) obs')", "using assms"], ["proof (prove)\nusing this:\n  lfinite obs\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (lappend obs obs') =\n    (ta_seq_consist P vs obs \\<and>\n     ta_seq_consist P (mrw_values P vs (list_of obs)) obs')", "proof(induct arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       ta_seq_consist P vs (lappend LNil obs') =\n       (ta_seq_consist P vs LNil \\<and>\n        ta_seq_consist P (mrw_values P vs (list_of LNil)) obs')\n 2. \\<And>xs x vs.\n       \\<lbrakk>lfinite xs;\n        \\<And>vs.\n           ta_seq_consist P vs (lappend xs obs') =\n           (ta_seq_consist P vs xs \\<and>\n            ta_seq_consist P (mrw_values P vs (list_of xs)) obs')\\<rbrakk>\n       \\<Longrightarrow> ta_seq_consist P vs (lappend (LCons x xs) obs') =\n                         (ta_seq_consist P vs (LCons x xs) \\<and>\n                          ta_seq_consist P\n                           (mrw_values P vs (list_of (LCons x xs))) obs')", "case lfinite_LNil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       ta_seq_consist P vs (lappend LNil obs') =\n       (ta_seq_consist P vs LNil \\<and>\n        ta_seq_consist P (mrw_values P vs (list_of LNil)) obs')\n 2. \\<And>xs x vs.\n       \\<lbrakk>lfinite xs;\n        \\<And>vs.\n           ta_seq_consist P vs (lappend xs obs') =\n           (ta_seq_consist P vs xs \\<and>\n            ta_seq_consist P (mrw_values P vs (list_of xs)) obs')\\<rbrakk>\n       \\<Longrightarrow> ta_seq_consist P vs (lappend (LCons x xs) obs') =\n                         (ta_seq_consist P vs (LCons x xs) \\<and>\n                          ta_seq_consist P\n                           (mrw_values P vs (list_of (LCons x xs))) obs')", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (lappend LNil obs') =\n    (ta_seq_consist P vs LNil \\<and>\n     ta_seq_consist P (mrw_values P vs (list_of LNil)) obs')", "by simp"], ["proof (state)\nthis:\n  ta_seq_consist P vs (lappend LNil obs') =\n  (ta_seq_consist P vs LNil \\<and>\n   ta_seq_consist P (mrw_values P vs (list_of LNil)) obs')\n\ngoal (1 subgoal):\n 1. \\<And>xs x vs.\n       \\<lbrakk>lfinite xs;\n        \\<And>vs.\n           ta_seq_consist P vs (lappend xs obs') =\n           (ta_seq_consist P vs xs \\<and>\n            ta_seq_consist P (mrw_values P vs (list_of xs)) obs')\\<rbrakk>\n       \\<Longrightarrow> ta_seq_consist P vs (lappend (LCons x xs) obs') =\n                         (ta_seq_consist P vs (LCons x xs) \\<and>\n                          ta_seq_consist P\n                           (mrw_values P vs (list_of (LCons x xs))) obs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x vs.\n       \\<lbrakk>lfinite xs;\n        \\<And>vs.\n           ta_seq_consist P vs (lappend xs obs') =\n           (ta_seq_consist P vs xs \\<and>\n            ta_seq_consist P (mrw_values P vs (list_of xs)) obs')\\<rbrakk>\n       \\<Longrightarrow> ta_seq_consist P vs (lappend (LCons x xs) obs') =\n                         (ta_seq_consist P vs (LCons x xs) \\<and>\n                          ta_seq_consist P\n                           (mrw_values P vs (list_of (LCons x xs))) obs')", "case (lfinite_LConsI obs ob)"], ["proof (state)\nthis:\n  lfinite obs\n  ta_seq_consist P ?vs (lappend obs obs') =\n  (ta_seq_consist P ?vs obs \\<and>\n   ta_seq_consist P (mrw_values P ?vs (list_of obs)) obs')\n\ngoal (1 subgoal):\n 1. \\<And>xs x vs.\n       \\<lbrakk>lfinite xs;\n        \\<And>vs.\n           ta_seq_consist P vs (lappend xs obs') =\n           (ta_seq_consist P vs xs \\<and>\n            ta_seq_consist P (mrw_values P vs (list_of xs)) obs')\\<rbrakk>\n       \\<Longrightarrow> ta_seq_consist P vs (lappend (LCons x xs) obs') =\n                         (ta_seq_consist P vs (LCons x xs) \\<and>\n                          ta_seq_consist P\n                           (mrw_values P vs (list_of (LCons x xs))) obs')", "have \"?concl (mrw_value P vs ob) obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_value P vs ob) (lappend obs obs') =\n    (ta_seq_consist P (mrw_value P vs ob) obs \\<and>\n     ta_seq_consist P (mrw_values P (mrw_value P vs ob) (list_of obs)) obs')", "by fact"], ["proof (state)\nthis:\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs obs') =\n  (ta_seq_consist P (mrw_value P vs ob) obs \\<and>\n   ta_seq_consist P (mrw_values P (mrw_value P vs ob) (list_of obs)) obs')\n\ngoal (1 subgoal):\n 1. \\<And>xs x vs.\n       \\<lbrakk>lfinite xs;\n        \\<And>vs.\n           ta_seq_consist P vs (lappend xs obs') =\n           (ta_seq_consist P vs xs \\<and>\n            ta_seq_consist P (mrw_values P vs (list_of xs)) obs')\\<rbrakk>\n       \\<Longrightarrow> ta_seq_consist P vs (lappend (LCons x xs) obs') =\n                         (ta_seq_consist P vs (LCons x xs) \\<and>\n                          ta_seq_consist P\n                           (mrw_values P vs (list_of (LCons x xs))) obs')", "thus ?case"], ["proof (prove)\nusing this:\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs obs') =\n  (ta_seq_consist P (mrw_value P vs ob) obs \\<and>\n   ta_seq_consist P (mrw_values P (mrw_value P vs ob) (list_of obs)) obs')\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (lappend (LCons ob obs) obs') =\n    (ta_seq_consist P vs (LCons ob obs) \\<and>\n     ta_seq_consist P (mrw_values P vs (list_of (LCons ob obs))) obs')", "using \\<open>lfinite obs\\<close>"], ["proof (prove)\nusing this:\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs obs') =\n  (ta_seq_consist P (mrw_value P vs ob) obs \\<and>\n   ta_seq_consist P (mrw_values P (mrw_value P vs ob) (list_of obs)) obs')\n  lfinite obs\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (lappend (LCons ob obs) obs') =\n    (ta_seq_consist P vs (LCons ob obs) \\<and>\n     ta_seq_consist P (mrw_values P vs (list_of (LCons ob obs))) obs')", "by(simp split: action.split add: list_of_LCons)"], ["proof (state)\nthis:\n  ta_seq_consist P vs (lappend (LCons ob obs) obs') =\n  (ta_seq_consist P vs (LCons ob obs) \\<and>\n   ta_seq_consist P (mrw_values P vs (list_of (LCons ob obs))) obs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes \"ta_seq_consist P vs obs\"\n  shows ta_seq_consist_ltake: \"ta_seq_consist P vs (ltake n obs)\" (is ?thesis1)\n  and ta_seq_consist_ldrop: \"ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (ltake n obs) &&&\n    ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ta_seq_consist P vs (ltake n obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)", "note assms"], ["proof (state)\nthis:\n  ta_seq_consist P vs obs\n\ngoal (2 subgoals):\n 1. ta_seq_consist P vs (ltake n obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)", "also"], ["proof (state)\nthis:\n  ta_seq_consist P vs obs\n\ngoal (2 subgoals):\n 1. ta_seq_consist P vs (ltake n obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)", "have \"obs = lappend (ltake n obs) (ldrop n obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs = lappend (ltake n obs) (ldrop n obs)", "by(simp add: lappend_ltake_ldrop)"], ["proof (state)\nthis:\n  obs = lappend (ltake n obs) (ldrop n obs)\n\ngoal (2 subgoals):\n 1. ta_seq_consist P vs (ltake n obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)", "finally"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs (lappend (ltake n obs) (ldrop n obs))", "have \"?thesis1 \\<and> ?thesis2\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs (lappend (ltake n obs) (ldrop n obs))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (ltake n obs) \\<and>\n    ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)", "by(cases n)(simp_all add: ta_seq_consist_lappend del: lappend_ltake_enat_ldropn)"], ["proof (state)\nthis:\n  ta_seq_consist P vs (ltake n obs) \\<and>\n  ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)\n\ngoal (2 subgoals):\n 1. ta_seq_consist P vs (ltake n obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  ta_seq_consist P vs (ltake n obs) \\<and>\n  ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (ltake n obs) &&&\n    ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)", "by blast+"], ["proof (state)\nthis:\n  ta_seq_consist P vs (ltake n obs)\n  ta_seq_consist P (mrw_values P vs (list_of (ltake n obs))) (ldrop n obs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ta_seq_consist_coinduct_append [consumes 1, case_names ta_seq_consist, case_conclusion ta_seq_consist LNil lappend]:\n  assumes major: \"X vs obs\"\n  and step: \"\\<And>vs obs. X vs obs \n    \\<Longrightarrow> obs = LNil \\<or>\n       (\\<exists>obs' obs''. obs = lappend obs' obs'' \\<and> obs' \\<noteq> LNil \\<and> ta_seq_consist P vs obs' \\<and>\n                    (lfinite obs' \\<longrightarrow> (X (mrw_values P vs (list_of obs')) obs'' \\<or> \n                                       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')))\"\n    (is \"\\<And>vs obs. _ \\<Longrightarrow> _ \\<or> ?step vs obs\")\n  shows \"ta_seq_consist P vs obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "from major"], ["proof (chain)\npicking this:\n  X vs obs", "have \"\\<exists>obs' obs''. obs = lappend (llist_of obs') obs'' \\<and> ta_seq_consist P vs (llist_of obs') \\<and> \n                     X (mrw_values P vs obs') obs''\""], ["proof (prove)\nusing this:\n  X vs obs\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''.\n       obs = lappend (llist_of obs') obs'' \\<and>\n       ta_seq_consist P vs (llist_of obs') \\<and>\n       X (mrw_values P vs obs') obs''", "by(auto intro: exI[where x=\"[]\"])"], ["proof (state)\nthis:\n  \\<exists>obs' obs''.\n     obs = lappend (llist_of obs') obs'' \\<and>\n     ta_seq_consist P vs (llist_of obs') \\<and>\n     X (mrw_values P vs obs') obs''\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs' obs''.\n     obs = lappend (llist_of obs') obs'' \\<and>\n     ta_seq_consist P vs (llist_of obs') \\<and>\n     X (mrw_values P vs obs') obs''\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<exists>obs' obs''.\n          x2 = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P x1 (llist_of obs') \\<and>\n          X (mrw_values P x1 obs') obs'' \\<Longrightarrow>\n       (\\<exists>vs. x1 = vs \\<and> x2 = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           x1 = vs \\<and>\n           x2 = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "case (ta_seq_consist vs obs)"], ["proof (state)\nthis:\n  \\<exists>obs' obs''.\n     obs = lappend (llist_of obs') obs'' \\<and>\n     ta_seq_consist P vs (llist_of obs') \\<and>\n     X (mrw_values P vs obs') obs''\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<exists>obs' obs''.\n          x2 = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P x1 (llist_of obs') \\<and>\n          X (mrw_values P x1 obs') obs'' \\<Longrightarrow>\n       (\\<exists>vs. x1 = vs \\<and> x2 = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           x1 = vs \\<and>\n           x2 = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "then"], ["proof (chain)\npicking this:\n  \\<exists>obs' obs''.\n     obs = lappend (llist_of obs') obs'' \\<and>\n     ta_seq_consist P vs (llist_of obs') \\<and>\n     X (mrw_values P vs obs') obs''", "obtain obs' obs'' \n      where obs: \"obs = lappend (llist_of obs') obs''\"\n      and sc_obs': \"ta_seq_consist P vs (llist_of obs')\"\n      and X: \"X (mrw_values P vs obs') obs''\""], ["proof (prove)\nusing this:\n  \\<exists>obs' obs''.\n     obs = lappend (llist_of obs') obs'' \\<and>\n     ta_seq_consist P vs (llist_of obs') \\<and>\n     X (mrw_values P vs obs') obs''\n\ngoal (1 subgoal):\n 1. (\\<And>obs' obs''.\n        \\<lbrakk>obs = lappend (llist_of obs') obs'';\n         ta_seq_consist P vs (llist_of obs');\n         X (mrw_values P vs obs') obs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  obs = lappend (llist_of obs') obs''\n  ta_seq_consist P vs (llist_of obs')\n  X (mrw_values P vs obs') obs''\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<exists>obs' obs''.\n          x2 = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P x1 (llist_of obs') \\<and>\n          X (mrw_values P x1 obs') obs'' \\<Longrightarrow>\n       (\\<exists>vs. x1 = vs \\<and> x2 = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           x1 = vs \\<and>\n           x2 = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "proof(cases obs')"], ["proof (state)\ngoal (2 subgoals):\n 1. obs' = [] \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "case Nil"], ["proof (state)\nthis:\n  obs' = []\n\ngoal (2 subgoals):\n 1. obs' = [] \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "with X"], ["proof (chain)\npicking this:\n  X (mrw_values P vs obs') obs''\n  obs' = []", "have \"X vs obs''\""], ["proof (prove)\nusing this:\n  X (mrw_values P vs obs') obs''\n  obs' = []\n\ngoal (1 subgoal):\n 1. X vs obs''", "by simp"], ["proof (state)\nthis:\n  X vs obs''\n\ngoal (2 subgoals):\n 1. obs' = [] \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "from step[OF this]"], ["proof (chain)\npicking this:\n  obs'' = LNil \\<or>\n  (\\<exists>obs' obs''a.\n      obs'' = lappend obs' obs''a \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       X (mrw_values P vs (list_of obs')) obs''a \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''a))", "show ?thesis"], ["proof (prove)\nusing this:\n  obs'' = LNil \\<or>\n  (\\<exists>obs' obs''a.\n      obs'' = lappend obs' obs''a \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       X (mrw_values P vs (list_of obs')) obs''a \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''a))\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. obs'' = LNil \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "assume \"obs'' = LNil\""], ["proof (state)\nthis:\n  obs'' = LNil\n\ngoal (2 subgoals):\n 1. obs'' = LNil \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "with Nil obs"], ["proof (chain)\npicking this:\n  obs' = []\n  obs = lappend (llist_of obs') obs''\n  obs'' = LNil", "show ?thesis"], ["proof (prove)\nusing this:\n  obs' = []\n  obs = lappend (llist_of obs') obs''\n  obs'' = LNil\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>obs' obs''.\n           obs = lappend (llist_of obs') obs'' \\<and>\n           ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n           X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "assume \"?step vs obs''\""], ["proof (state)\nthis:\n  \\<exists>obs' obs''a.\n     obs'' = lappend obs' obs''a \\<and>\n     obs' \\<noteq> LNil \\<and>\n     ta_seq_consist P vs obs' \\<and>\n     (lfinite obs' \\<longrightarrow>\n      X (mrw_values P vs (list_of obs')) obs''a \\<or>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs''a)\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "then"], ["proof (chain)\npicking this:\n  \\<exists>obs' obs''a.\n     obs'' = lappend obs' obs''a \\<and>\n     obs' \\<noteq> LNil \\<and>\n     ta_seq_consist P vs obs' \\<and>\n     (lfinite obs' \\<longrightarrow>\n      X (mrw_values P vs (list_of obs')) obs''a \\<or>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs''a)", "obtain obs''' obs'''' \n          where obs'': \"obs'' = lappend obs''' obs''''\" and \"obs''' \\<noteq> LNil\"\n          and sc_obs''': \"ta_seq_consist P vs obs'''\" \n          and fin: \"lfinite obs''' \\<Longrightarrow> X (mrw_values P vs (list_of obs''')) obs'''' \\<or>\n                                      ta_seq_consist P (mrw_values P vs (list_of obs''')) obs''''\""], ["proof (prove)\nusing this:\n  \\<exists>obs' obs''a.\n     obs'' = lappend obs' obs''a \\<and>\n     obs' \\<noteq> LNil \\<and>\n     ta_seq_consist P vs obs' \\<and>\n     (lfinite obs' \\<longrightarrow>\n      X (mrw_values P vs (list_of obs')) obs''a \\<or>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs''a)\n\ngoal (1 subgoal):\n 1. (\\<And>obs''' obs''''.\n        \\<lbrakk>obs'' = lappend obs''' obs''''; obs''' \\<noteq> LNil;\n         ta_seq_consist P vs obs''';\n         lfinite obs''' \\<Longrightarrow>\n         X (mrw_values P vs (list_of obs''')) obs'''' \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs'''))\n          obs''''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  obs'' = lappend obs''' obs''''\n  obs''' \\<noteq> LNil\n  ta_seq_consist P vs obs'''\n  lfinite obs''' \\<Longrightarrow>\n  X (mrw_values P vs (list_of obs''')) obs'''' \\<or>\n  ta_seq_consist P (mrw_values P vs (list_of obs''')) obs''''\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "from \\<open>obs''' \\<noteq> LNil\\<close>"], ["proof (chain)\npicking this:\n  obs''' \\<noteq> LNil", "obtain ob obs''''' where obs''': \"obs''' = LCons ob obs'''''\""], ["proof (prove)\nusing this:\n  obs''' \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. (\\<And>ob obs'''''.\n        obs''' = LCons ob obs''''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding neq_LNil_conv"], ["proof (prove)\nusing this:\n  \\<exists>x xs'. obs''' = LCons x xs'\n\ngoal (1 subgoal):\n 1. (\\<And>ob obs'''''.\n        obs''' = LCons ob obs''''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  obs''' = LCons ob obs'''''\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "with Nil obs'' obs"], ["proof (chain)\npicking this:\n  obs' = []\n  obs'' = lappend obs''' obs''''\n  obs = lappend (llist_of obs') obs''\n  obs''' = LCons ob obs'''''", "have concl1: \"obs = LCons ob (lappend obs''''' obs'''')\""], ["proof (prove)\nusing this:\n  obs' = []\n  obs'' = lappend obs''' obs''''\n  obs = lappend (llist_of obs') obs''\n  obs''' = LCons ob obs'''''\n\ngoal (1 subgoal):\n 1. obs = LCons ob (lappend obs''''' obs'''')", "by simp"], ["proof (state)\nthis:\n  obs = LCons ob (lappend obs''''' obs'''')\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "have concl2: \"case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor> | _ \\<Rightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case ob of\n    NormalAction (ReadMem ad al v) \\<Rightarrow>\n      \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n    | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True", "using sc_obs''' obs'''"], ["proof (prove)\nusing this:\n  ta_seq_consist P vs obs'''\n  obs''' = LCons ob obs'''''\n\ngoal (1 subgoal):\n 1. case ob of\n    NormalAction (ReadMem ad al v) \\<Rightarrow>\n      \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n    | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True", "by simp"], ["proof (state)\nthis:\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''a.\n       obs'' = lappend obs' obs''a \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs''a \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs''a) \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "proof(cases \"lfinite obs'''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<not> lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite obs'''\n\ngoal (2 subgoals):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<not> lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "hence \"lappend obs''''' obs'''' = obs'''''\""], ["proof (prove)\nusing this:\n  \\<not> lfinite obs'''\n\ngoal (1 subgoal):\n 1. lappend obs''''' obs'''' = obs'''''", "using obs'''"], ["proof (prove)\nusing this:\n  \\<not> lfinite obs'''\n  obs''' = LCons ob obs'''''\n\ngoal (1 subgoal):\n 1. lappend obs''''' obs'''' = obs'''''", "by(simp add: lappend_inf)"], ["proof (state)\nthis:\n  lappend obs''''' obs'''' = obs'''''\n\ngoal (2 subgoals):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<not> lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "hence \"ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')\""], ["proof (prove)\nusing this:\n  lappend obs''''' obs'''' = obs'''''\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')", "using sc_obs''' obs'''"], ["proof (prove)\nusing this:\n  lappend obs''''' obs'''' = obs'''''\n  ta_seq_consist P vs obs'''\n  obs''' = LCons ob obs'''''\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')", "by simp"], ["proof (state)\nthis:\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')\n\ngoal (2 subgoals):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<not> lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "with concl1 concl2"], ["proof (chain)\npicking this:\n  obs = LCons ob (lappend obs''''' obs'''')\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')", "have ?LCons"], ["proof (prove)\nusing this:\n  obs = LCons ob (lappend obs''''' obs'''')\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')\n\ngoal (1 subgoal):\n 1. \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ob vs obs.\n     vs = vs \\<and>\n     obs = LCons ob obs \\<and>\n     (case ob of\n      NormalAction (ReadMem ad al v) \\<Rightarrow>\n        \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n      | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n     ((\\<exists>obs' obs''.\n          obs = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n          X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n      ta_seq_consist P (mrw_value P vs ob) obs)\n\ngoal (2 subgoals):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<not> lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ob vs obs.\n     vs = vs \\<and>\n     obs = LCons ob obs \\<and>\n     (case ob of\n      NormalAction (ReadMem ad al v) \\<Rightarrow>\n        \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n      | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n     ((\\<exists>obs' obs''.\n          obs = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n          X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n      ta_seq_consist P (mrw_value P vs ob) obs)\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>obs' obs''.\n           obs = lappend (llist_of obs') obs'' \\<and>\n           ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n           X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal (1 subgoal):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "case True"], ["proof (state)\nthis:\n  lfinite obs'''\n\ngoal (1 subgoal):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "with obs'''"], ["proof (chain)\npicking this:\n  obs''' = LCons ob obs'''''\n  lfinite obs'''", "obtain obs'''''' where obs''''': \"obs''''' = llist_of obs''''''\""], ["proof (prove)\nusing this:\n  obs''' = LCons ob obs'''''\n  lfinite obs'''\n\ngoal (1 subgoal):\n 1. (\\<And>obs''''''.\n        obs''''' = llist_of obs'''''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp(auto simp add: lfinite_eq_range_llist_of)"], ["proof (state)\nthis:\n  obs''''' = llist_of obs''''''\n\ngoal (1 subgoal):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "from fin[OF True]"], ["proof (chain)\npicking this:\n  X (mrw_values P vs (list_of obs''')) obs'''' \\<or>\n  ta_seq_consist P (mrw_values P vs (list_of obs''')) obs''''", "have \"?LCons\""], ["proof (prove)\nusing this:\n  X (mrw_values P vs (list_of obs''')) obs'''' \\<or>\n  ta_seq_consist P (mrw_values P vs (list_of obs''')) obs''''\n\ngoal (1 subgoal):\n 1. \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs''')) obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "assume X: \"X (mrw_values P vs (list_of obs''')) obs''''\""], ["proof (state)\nthis:\n  X (mrw_values P vs (list_of obs''')) obs''''\n\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs''')) obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "hence \"X (mrw_values P (mrw_value P vs ob) obs'''''') obs''''\""], ["proof (prove)\nusing this:\n  X (mrw_values P vs (list_of obs''')) obs''''\n\ngoal (1 subgoal):\n 1. X (mrw_values P (mrw_value P vs ob) obs'''''') obs''''", "using obs''''' obs'''"], ["proof (prove)\nusing this:\n  X (mrw_values P vs (list_of obs''')) obs''''\n  obs''''' = llist_of obs''''''\n  obs''' = LCons ob obs'''''\n\ngoal (1 subgoal):\n 1. X (mrw_values P (mrw_value P vs ob) obs'''''') obs''''", "by simp"], ["proof (state)\nthis:\n  X (mrw_values P (mrw_value P vs ob) obs'''''') obs''''\n\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs''')) obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "moreover"], ["proof (state)\nthis:\n  X (mrw_values P (mrw_value P vs ob) obs'''''') obs''''\n\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs''')) obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "from obs'''''"], ["proof (chain)\npicking this:\n  obs''''' = llist_of obs''''''", "have \"lappend obs''''' obs'''' = lappend (llist_of obs'''''') obs''''\""], ["proof (prove)\nusing this:\n  obs''''' = llist_of obs''''''\n\ngoal (1 subgoal):\n 1. lappend obs''''' obs'''' = lappend (llist_of obs'''''') obs''''", "by simp"], ["proof (state)\nthis:\n  lappend obs''''' obs'''' = lappend (llist_of obs'''''') obs''''\n\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs''')) obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "moreover"], ["proof (state)\nthis:\n  lappend obs''''' obs'''' = lappend (llist_of obs'''''') obs''''\n\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs''')) obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "have \"ta_seq_consist P (mrw_value P vs ob) (llist_of obs'''''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_value P vs ob) (llist_of obs'''''')", "using sc_obs''' obs''' obs'''''"], ["proof (prove)\nusing this:\n  ta_seq_consist P vs obs'''\n  obs''' = LCons ob obs'''''\n  obs''''' = llist_of obs''''''\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_value P vs ob) (llist_of obs'''''')", "by simp"], ["proof (state)\nthis:\n  ta_seq_consist P (mrw_value P vs ob) (llist_of obs'''''')\n\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs''')) obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "ultimately"], ["proof (chain)\npicking this:\n  X (mrw_values P (mrw_value P vs ob) obs'''''') obs''''\n  lappend obs''''' obs'''' = lappend (llist_of obs'''''') obs''''\n  ta_seq_consist P (mrw_value P vs ob) (llist_of obs'''''')", "show ?thesis"], ["proof (prove)\nusing this:\n  X (mrw_values P (mrw_value P vs ob) obs'''''') obs''''\n  lappend obs''''' obs'''' = lappend (llist_of obs'''''') obs''''\n  ta_seq_consist P (mrw_value P vs ob) (llist_of obs'''''')\n\ngoal (1 subgoal):\n 1. \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "using concl1 concl2"], ["proof (prove)\nusing this:\n  X (mrw_values P (mrw_value P vs ob) obs'''''') obs''''\n  lappend obs''''' obs'''' = lappend (llist_of obs'''''') obs''''\n  ta_seq_consist P (mrw_value P vs ob) (llist_of obs'''''')\n  obs = LCons ob (lappend obs''''' obs'''')\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n\ngoal (1 subgoal):\n 1. \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ob vs obs.\n     vs = vs \\<and>\n     obs = LCons ob obs \\<and>\n     (case ob of\n      NormalAction (ReadMem ad al v) \\<Rightarrow>\n        \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n      | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n     ((\\<exists>obs' obs''.\n          obs = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n          X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n      ta_seq_consist P (mrw_value P vs ob) obs)\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "assume \"ta_seq_consist P (mrw_values P vs (list_of obs''')) obs''''\""], ["proof (state)\nthis:\n  ta_seq_consist P (mrw_values P vs (list_of obs''')) obs''''\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "with sc_obs''' obs''''' obs'''"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs obs'''\n  obs''''' = llist_of obs''''''\n  obs''' = LCons ob obs'''''\n  ta_seq_consist P (mrw_values P vs (list_of obs''')) obs''''", "have \"ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs obs'''\n  obs''''' = llist_of obs''''''\n  obs''' = LCons ob obs'''''\n  ta_seq_consist P (mrw_values P vs (list_of obs''')) obs''''\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')", "by(simp add: ta_seq_consist_lappend)"], ["proof (state)\nthis:\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_values P vs (list_of obs'''))\n     obs'''' \\<Longrightarrow>\n    \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "with concl1 concl2"], ["proof (chain)\npicking this:\n  obs = LCons ob (lappend obs''''' obs'''')\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')", "show ?thesis"], ["proof (prove)\nusing this:\n  obs = LCons ob (lappend obs''''' obs'''')\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n  ta_seq_consist P (mrw_value P vs ob) (lappend obs''''' obs'''')\n\ngoal (1 subgoal):\n 1. \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>obs' obs''.\n            obs = lappend (llist_of obs') obs'' \\<and>\n            ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n            X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ob vs obs.\n     vs = vs \\<and>\n     obs = LCons ob obs \\<and>\n     (case ob of\n      NormalAction (ReadMem ad al v) \\<Rightarrow>\n        \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n      | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n     ((\\<exists>obs' obs''.\n          obs = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n          X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n      ta_seq_consist P (mrw_value P vs ob) obs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ob vs obs.\n     vs = vs \\<and>\n     obs = LCons ob obs \\<and>\n     (case ob of\n      NormalAction (ReadMem ad al v) \\<Rightarrow>\n        \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n      | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n     ((\\<exists>obs' obs''.\n          obs = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n          X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n      ta_seq_consist P (mrw_value P vs ob) obs)\n\ngoal (1 subgoal):\n 1. lfinite obs''' \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ob vs obs.\n     vs = vs \\<and>\n     obs = LCons ob obs \\<and>\n     (case ob of\n      NormalAction (ReadMem ad al v) \\<Rightarrow>\n        \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n      | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n     ((\\<exists>obs' obs''.\n          obs = lappend (llist_of obs') obs'' \\<and>\n          ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n          X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n      ta_seq_consist P (mrw_value P vs ob) obs)\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>obs' obs''.\n           obs = lappend (llist_of obs') obs'' \\<and>\n           ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n           X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>obs' obs''.\n           obs = lappend (llist_of obs') obs'' \\<and>\n           ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n           X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>obs' obs''.\n           obs = lappend (llist_of obs') obs'' \\<and>\n           ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n           X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "case (Cons ob obs''')"], ["proof (state)\nthis:\n  obs' = ob # obs'''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "hence \"obs = LCons ob (lappend (llist_of obs''') obs'')\""], ["proof (prove)\nusing this:\n  obs' = ob # obs'''\n\ngoal (1 subgoal):\n 1. obs = LCons ob (lappend (llist_of obs''') obs'')", "using obs"], ["proof (prove)\nusing this:\n  obs' = ob # obs'''\n  obs = lappend (llist_of obs') obs''\n\ngoal (1 subgoal):\n 1. obs = LCons ob (lappend (llist_of obs''') obs'')", "by simp"], ["proof (state)\nthis:\n  obs = LCons ob (lappend (llist_of obs''') obs'')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "moreover"], ["proof (state)\nthis:\n  obs = LCons ob (lappend (llist_of obs''') obs'')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "from sc_obs' Cons"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs (llist_of obs')\n  obs' = ob # obs'''", "have \"case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor> | _ \\<Rightarrow> True\"\n        and \"ta_seq_consist P (mrw_value P vs ob) (llist_of obs''')\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs (llist_of obs')\n  obs' = ob # obs'''\n\ngoal (1 subgoal):\n 1. case ob of\n    NormalAction (ReadMem ad al v) \\<Rightarrow>\n      \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n    | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True &&&\n    ta_seq_consist P (mrw_value P vs ob) (llist_of obs''')", "by simp_all"], ["proof (state)\nthis:\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n  ta_seq_consist P (mrw_value P vs ob) (llist_of obs''')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "moreover"], ["proof (state)\nthis:\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n  ta_seq_consist P (mrw_value P vs ob) (llist_of obs''')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "from X Cons"], ["proof (chain)\npicking this:\n  X (mrw_values P vs obs') obs''\n  obs' = ob # obs'''", "have \"X (mrw_values P (mrw_value P vs ob) obs''') obs''\""], ["proof (prove)\nusing this:\n  X (mrw_values P vs obs') obs''\n  obs' = ob # obs'''\n\ngoal (1 subgoal):\n 1. X (mrw_values P (mrw_value P vs ob) obs''') obs''", "by simp"], ["proof (state)\nthis:\n  X (mrw_values P (mrw_value P vs ob) obs''') obs''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       obs' = a # list \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>obs' obs''.\n                obs = lappend (llist_of obs') obs'' \\<and>\n                ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n                X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "ultimately"], ["proof (chain)\npicking this:\n  obs = LCons ob (lappend (llist_of obs''') obs'')\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n  ta_seq_consist P (mrw_value P vs ob) (llist_of obs''')\n  X (mrw_values P (mrw_value P vs ob) obs''') obs''", "show ?thesis"], ["proof (prove)\nusing this:\n  obs = LCons ob (lappend (llist_of obs''') obs'')\n  case ob of\n  NormalAction (ReadMem ad al v) \\<Rightarrow>\n    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n  | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n  ta_seq_consist P (mrw_value P vs ob) (llist_of obs''')\n  X (mrw_values P (mrw_value P vs ob) obs''') obs''\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>obs' obs''.\n             obs = lappend (llist_of obs') obs'' \\<and>\n             ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n             X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>obs' obs''.\n           obs = lappend (llist_of obs') obs'' \\<and>\n           ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n           X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>obs' obs''.\n           obs = lappend (llist_of obs') obs'' \\<and>\n           ta_seq_consist P (mrw_value P vs ob) (llist_of obs') \\<and>\n           X (mrw_values P (mrw_value P vs ob) obs') obs'') \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ta_seq_consist P vs obs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ta_seq_consist_coinduct_append_wf\n  [consumes 2, case_names ta_seq_consist, case_conclusion ta_seq_consist LNil lappend]:\n  assumes major: \"X vs obs a\"\n  and wf: \"wf R\"\n  and step: \"\\<And>vs obs a. X vs obs a\n    \\<Longrightarrow> obs = LNil \\<or>\n       (\\<exists>obs' obs'' a'. obs = lappend obs' obs'' \\<and> ta_seq_consist P vs obs' \\<and> (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n                        (lfinite obs' \\<longrightarrow> X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n                                          ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\"\n    (is \"\\<And>vs obs a. _ \\<Longrightarrow> _ \\<or> ?step vs obs a\")\n  shows \"ta_seq_consist P vs obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "fix vs obs a"], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "assume \"X vs obs a\""], ["proof (state)\nthis:\n  X vs obs a\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "with wf"], ["proof (chain)\npicking this:\n  wf R\n  X vs obs a", "have \"obs = LNil \\<or> (\\<exists>obs' obs''. obs = lappend obs' obs'' \\<and> obs' \\<noteq> LNil \\<and> ta_seq_consist P vs obs' \\<and>\n          (lfinite obs' \\<longrightarrow> (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or> \n                            ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\"\n      (is \"_ \\<or> ?step_concl vs obs\")"], ["proof (prove)\nusing this:\n  wf R\n  X vs obs a\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "proof(induct a arbitrary: vs obs rule: wf_induct[consumes 1, case_names wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x vs obs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa.\n                       X x xa y \\<longrightarrow>\n                       xa = LNil \\<or>\n                       (\\<exists>obs' obs''.\n                           xa = lappend obs' obs'' \\<and>\n                           obs' \\<noteq> LNil \\<and>\n                           ta_seq_consist P x obs' \\<and>\n                           (lfinite obs' \\<longrightarrow>\n                            Ex (X (mrw_values P x (list_of obs'))\n                                 obs'') \\<or>\n                            ta_seq_consist P (mrw_values P x (list_of obs'))\n                             obs'')));\n        X vs obs x\\<rbrakk>\n       \\<Longrightarrow> obs = LNil \\<or>\n                         (\\<exists>obs' obs''.\n                             obs = lappend obs' obs'' \\<and>\n                             obs' \\<noteq> LNil \\<and>\n                             ta_seq_consist P vs obs' \\<and>\n                             (lfinite obs' \\<longrightarrow>\n                              Ex (X (mrw_values P vs (list_of obs'))\n                                   obs'') \\<or>\n                              ta_seq_consist P\n                               (mrw_values P vs (list_of obs')) obs''))", "case (wf a)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, a) \\<in> R \\<longrightarrow>\n     (\\<forall>x xa.\n         X x xa y \\<longrightarrow>\n         xa = LNil \\<or>\n         (\\<exists>obs' obs''.\n             xa = lappend obs' obs'' \\<and>\n             obs' \\<noteq> LNil \\<and>\n             ta_seq_consist P x obs' \\<and>\n             (lfinite obs' \\<longrightarrow>\n              (\\<exists>a. X (mrw_values P x (list_of obs')) obs'' a) \\<or>\n              ta_seq_consist P (mrw_values P x (list_of obs')) obs'')))\n  X vs obs a\n\ngoal (1 subgoal):\n 1. \\<And>x vs obs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa.\n                       X x xa y \\<longrightarrow>\n                       xa = LNil \\<or>\n                       (\\<exists>obs' obs''.\n                           xa = lappend obs' obs'' \\<and>\n                           obs' \\<noteq> LNil \\<and>\n                           ta_seq_consist P x obs' \\<and>\n                           (lfinite obs' \\<longrightarrow>\n                            Ex (X (mrw_values P x (list_of obs'))\n                                 obs'') \\<or>\n                            ta_seq_consist P (mrw_values P x (list_of obs'))\n                             obs'')));\n        X vs obs x\\<rbrakk>\n       \\<Longrightarrow> obs = LNil \\<or>\n                         (\\<exists>obs' obs''.\n                             obs = lappend obs' obs'' \\<and>\n                             obs' \\<noteq> LNil \\<and>\n                             ta_seq_consist P vs obs' \\<and>\n                             (lfinite obs' \\<longrightarrow>\n                              Ex (X (mrw_values P vs (list_of obs'))\n                                   obs'') \\<or>\n                              ta_seq_consist P\n                               (mrw_values P vs (list_of obs')) obs''))", "note IH = wf.hyps[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, a) \\<in> R; X ?x ?xa ?y\\<rbrakk>\n  \\<Longrightarrow> ?xa = LNil \\<or>\n                    (\\<exists>obs' obs''.\n                        ?xa = lappend obs' obs'' \\<and>\n                        obs' \\<noteq> LNil \\<and>\n                        ta_seq_consist P ?x obs' \\<and>\n                        (lfinite obs' \\<longrightarrow>\n                         Ex (X (mrw_values P ?x (list_of obs')) obs'') \\<or>\n                         ta_seq_consist P (mrw_values P ?x (list_of obs'))\n                          obs''))\n\ngoal (1 subgoal):\n 1. \\<And>x vs obs.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> R \\<longrightarrow>\n                   (\\<forall>x xa.\n                       X x xa y \\<longrightarrow>\n                       xa = LNil \\<or>\n                       (\\<exists>obs' obs''.\n                           xa = lappend obs' obs'' \\<and>\n                           obs' \\<noteq> LNil \\<and>\n                           ta_seq_consist P x obs' \\<and>\n                           (lfinite obs' \\<longrightarrow>\n                            Ex (X (mrw_values P x (list_of obs'))\n                                 obs'') \\<or>\n                            ta_seq_consist P (mrw_values P x (list_of obs'))\n                             obs'')));\n        X vs obs x\\<rbrakk>\n       \\<Longrightarrow> obs = LNil \\<or>\n                         (\\<exists>obs' obs''.\n                             obs = lappend obs' obs'' \\<and>\n                             obs' \\<noteq> LNil \\<and>\n                             ta_seq_consist P vs obs' \\<and>\n                             (lfinite obs' \\<longrightarrow>\n                              Ex (X (mrw_values P vs (list_of obs'))\n                                   obs'') \\<or>\n                              ta_seq_consist P\n                               (mrw_values P vs (list_of obs')) obs''))", "from step[OF \\<open>X vs obs a\\<close>]"], ["proof (chain)\npicking this:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs'' a'.\n      obs = lappend obs' obs'' \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n      (lfinite obs' \\<longrightarrow>\n       X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "show ?case"], ["proof (prove)\nusing this:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs'' a'.\n      obs = lappend obs' obs'' \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n      (lfinite obs' \\<longrightarrow>\n       X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. obs = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. \\<exists>obs' obs'' a'.\n       obs = lappend obs' obs'' \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs'') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "assume \"obs = LNil\""], ["proof (state)\nthis:\n  obs = LNil\n\ngoal (2 subgoals):\n 1. obs = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. \\<exists>obs' obs'' a'.\n       obs = lappend obs' obs'' \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs'') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs = LNil\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", ".."], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs'' a'.\n       obs = lappend obs' obs'' \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs'') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>obs' obs'' a'.\n       obs = lappend obs' obs'' \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs'') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "assume \"?step vs obs a\""], ["proof (state)\nthis:\n  \\<exists>obs' obs'' a'.\n     obs = lappend obs' obs'' \\<and>\n     ta_seq_consist P vs obs' \\<and>\n     (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n     (lfinite obs' \\<longrightarrow>\n      X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs'' a'.\n       obs = lappend obs' obs'' \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs'') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "then"], ["proof (chain)\npicking this:\n  \\<exists>obs' obs'' a'.\n     obs = lappend obs' obs'' \\<and>\n     ta_seq_consist P vs obs' \\<and>\n     (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n     (lfinite obs' \\<longrightarrow>\n      X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')", "obtain obs' obs'' a'\n          where obs: \"obs = lappend obs' obs''\"\n          and sc_obs': \"ta_seq_consist P vs obs'\"\n          and decr: \"obs' = LNil \\<Longrightarrow> (a', a) \\<in> R\"\n          and fin: \"lfinite obs' \\<Longrightarrow> \n                    X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n                    ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\""], ["proof (prove)\nusing this:\n  \\<exists>obs' obs'' a'.\n     obs = lappend obs' obs'' \\<and>\n     ta_seq_consist P vs obs' \\<and>\n     (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n     (lfinite obs' \\<longrightarrow>\n      X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')\n\ngoal (1 subgoal):\n 1. (\\<And>obs' obs'' a'.\n        \\<lbrakk>obs = lappend obs' obs''; ta_seq_consist P vs obs';\n         obs' = LNil \\<Longrightarrow> (a', a) \\<in> R;\n         lfinite obs' \\<Longrightarrow>\n         X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  obs = lappend obs' obs''\n  ta_seq_consist P vs obs'\n  obs' = LNil \\<Longrightarrow> (a', a) \\<in> R\n  lfinite obs' \\<Longrightarrow>\n  X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n  ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs'' a'.\n       obs = lappend obs' obs'' \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (obs' = LNil \\<longrightarrow> (a', a) \\<in> R) \\<and>\n       (lfinite obs' \\<longrightarrow>\n        X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs'))\n         obs'') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "proof(cases \"obs' = LNil\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs' = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. obs' \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "case True"], ["proof (state)\nthis:\n  obs' = LNil\n\ngoal (2 subgoals):\n 1. obs' = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. obs' \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "hence \"lfinite obs'\""], ["proof (prove)\nusing this:\n  obs' = LNil\n\ngoal (1 subgoal):\n 1. lfinite obs'", "by simp"], ["proof (state)\nthis:\n  lfinite obs'\n\ngoal (2 subgoals):\n 1. obs' = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. obs' \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "from fin[OF this]"], ["proof (chain)\npicking this:\n  X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n  ta_seq_consist P (mrw_values P vs (list_of obs')) obs''", "show ?thesis"], ["proof (prove)\nusing this:\n  X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n  ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs')) obs'' a' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'))\n     obs'' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "assume X: \"X (mrw_values P vs (list_of obs')) obs'' a'\""], ["proof (state)\nthis:\n  X (mrw_values P vs (list_of obs')) obs'' a'\n\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs')) obs'' a' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'))\n     obs'' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "from True"], ["proof (chain)\npicking this:\n  obs' = LNil", "have \"(a', a) \\<in> R\""], ["proof (prove)\nusing this:\n  obs' = LNil\n\ngoal (1 subgoal):\n 1. (a', a) \\<in> R", "by(rule decr)"], ["proof (state)\nthis:\n  (a', a) \\<in> R\n\ngoal (2 subgoals):\n 1. X (mrw_values P vs (list_of obs')) obs'' a' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. ta_seq_consist P (mrw_values P vs (list_of obs'))\n     obs'' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "from IH[OF this X]"], ["proof (chain)\npicking this:\n  obs'' = LNil \\<or>\n  (\\<exists>obs'a obs''a.\n      obs'' = lappend obs'a obs''a \\<and>\n      obs'a \\<noteq> LNil \\<and>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n      (lfinite obs'a \\<longrightarrow>\n       Ex (X (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n            obs''a) \\<or>\n       ta_seq_consist P\n        (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n        obs''a))", "show ?thesis"], ["proof (prove)\nusing this:\n  obs'' = LNil \\<or>\n  (\\<exists>obs'a obs''a.\n      obs'' = lappend obs'a obs''a \\<and>\n      obs'a \\<noteq> LNil \\<and>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n      (lfinite obs'a \\<longrightarrow>\n       Ex (X (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n            obs''a) \\<or>\n       ta_seq_consist P\n        (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n        obs''a))\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. obs'' = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. \\<exists>obs'a obs''a.\n       obs'' = lappend obs'a obs''a \\<and>\n       obs'a \\<noteq> LNil \\<and>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n       (lfinite obs'a \\<longrightarrow>\n        Ex (X (mrw_values P (mrw_values P vs (list_of obs'))\n                (list_of obs'a))\n             obs''a) \\<or>\n        ta_seq_consist P\n         (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n         obs''a) \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "assume \"obs'' = LNil\""], ["proof (state)\nthis:\n  obs'' = LNil\n\ngoal (2 subgoals):\n 1. obs'' = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. \\<exists>obs'a obs''a.\n       obs'' = lappend obs'a obs''a \\<and>\n       obs'a \\<noteq> LNil \\<and>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n       (lfinite obs'a \\<longrightarrow>\n        Ex (X (mrw_values P (mrw_values P vs (list_of obs'))\n                (list_of obs'a))\n             obs''a) \\<or>\n        ta_seq_consist P\n         (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n         obs''a) \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "with True obs"], ["proof (chain)\npicking this:\n  obs' = LNil\n  obs = lappend obs' obs''\n  obs'' = LNil", "have \"obs = LNil\""], ["proof (prove)\nusing this:\n  obs' = LNil\n  obs = lappend obs' obs''\n  obs'' = LNil\n\ngoal (1 subgoal):\n 1. obs = LNil", "by simp"], ["proof (state)\nthis:\n  obs = LNil\n\ngoal (2 subgoals):\n 1. obs'' = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n 2. \\<exists>obs'a obs''a.\n       obs'' = lappend obs'a obs''a \\<and>\n       obs'a \\<noteq> LNil \\<and>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n       (lfinite obs'a \\<longrightarrow>\n        Ex (X (mrw_values P (mrw_values P vs (list_of obs'))\n                (list_of obs'a))\n             obs''a) \\<or>\n        ta_seq_consist P\n         (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n         obs''a) \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs = LNil\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", ".."], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. \\<exists>obs'a obs''a.\n       obs'' = lappend obs'a obs''a \\<and>\n       obs'a \\<noteq> LNil \\<and>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n       (lfinite obs'a \\<longrightarrow>\n        Ex (X (mrw_values P (mrw_values P vs (list_of obs'))\n                (list_of obs'a))\n             obs''a) \\<or>\n        ta_seq_consist P\n         (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n         obs''a) \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>obs'a obs''a.\n       obs'' = lappend obs'a obs''a \\<and>\n       obs'a \\<noteq> LNil \\<and>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n       (lfinite obs'a \\<longrightarrow>\n        Ex (X (mrw_values P (mrw_values P vs (list_of obs'))\n                (list_of obs'a))\n             obs''a) \\<or>\n        ta_seq_consist P\n         (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n         obs''a) \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "assume \"?step_concl (mrw_values P vs (list_of obs')) obs''\""], ["proof (state)\nthis:\n  \\<exists>obs'a obs''a.\n     obs'' = lappend obs'a obs''a \\<and>\n     obs'a \\<noteq> LNil \\<and>\n     ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n     (lfinite obs'a \\<longrightarrow>\n      (\\<exists>a.\n          X (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n           obs''a a) \\<or>\n      ta_seq_consist P\n       (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n       obs''a)\n\ngoal (1 subgoal):\n 1. \\<exists>obs'a obs''a.\n       obs'' = lappend obs'a obs''a \\<and>\n       obs'a \\<noteq> LNil \\<and>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n       (lfinite obs'a \\<longrightarrow>\n        Ex (X (mrw_values P (mrw_values P vs (list_of obs'))\n                (list_of obs'a))\n             obs''a) \\<or>\n        ta_seq_consist P\n         (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n         obs''a) \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "hence \"?step_concl vs obs\""], ["proof (prove)\nusing this:\n  \\<exists>obs'a obs''a.\n     obs'' = lappend obs'a obs''a \\<and>\n     obs'a \\<noteq> LNil \\<and>\n     ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n     (lfinite obs'a \\<longrightarrow>\n      (\\<exists>a.\n          X (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n           obs''a a) \\<or>\n      ta_seq_consist P\n       (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n       obs''a)\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''.\n       obs = lappend obs' obs'' \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')", "using True obs"], ["proof (prove)\nusing this:\n  \\<exists>obs'a obs''a.\n     obs'' = lappend obs'a obs''a \\<and>\n     obs'a \\<noteq> LNil \\<and>\n     ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n     (lfinite obs'a \\<longrightarrow>\n      (\\<exists>a.\n          X (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n           obs''a a) \\<or>\n      ta_seq_consist P\n       (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n       obs''a)\n  obs' = LNil\n  obs = lappend obs' obs''\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs''.\n       obs = lappend obs' obs'' \\<and>\n       obs' \\<noteq> LNil \\<and>\n       ta_seq_consist P vs obs' \\<and>\n       (lfinite obs' \\<longrightarrow>\n        (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n        ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')", "by simp"], ["proof (state)\nthis:\n  \\<exists>obs' obs''.\n     obs = lappend obs' obs'' \\<and>\n     obs' \\<noteq> LNil \\<and>\n     ta_seq_consist P vs obs' \\<and>\n     (lfinite obs' \\<longrightarrow>\n      (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')\n\ngoal (1 subgoal):\n 1. \\<exists>obs'a obs''a.\n       obs'' = lappend obs'a obs''a \\<and>\n       obs'a \\<noteq> LNil \\<and>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs'a \\<and>\n       (lfinite obs'a \\<longrightarrow>\n        Ex (X (mrw_values P (mrw_values P vs (list_of obs'))\n                (list_of obs'a))\n             obs''a) \\<or>\n        ta_seq_consist P\n         (mrw_values P (mrw_values P vs (list_of obs')) (list_of obs'a))\n         obs''a) \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs' obs''.\n     obs = lappend obs' obs'' \\<and>\n     obs' \\<noteq> LNil \\<and>\n     ta_seq_consist P vs obs' \\<and>\n     (lfinite obs' \\<longrightarrow>\n      (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n      ta_seq_consist P (mrw_values P vs (list_of obs')) obs'')\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", ".."], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_values P vs (list_of obs'))\n     obs'' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_values P vs (list_of obs'))\n     obs'' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "assume \"ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\""], ["proof (state)\nthis:\n  ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\n\ngoal (1 subgoal):\n 1. ta_seq_consist P (mrw_values P vs (list_of obs'))\n     obs'' \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "using obs True"], ["proof (prove)\nusing this:\n  ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\n  obs = lappend obs' obs''\n  obs' = LNil\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "by cases(auto cong: action.case_cong obs_event.case_cong intro: exI[where x=\"LCons x LNil\" for x])"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. obs' \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. obs' \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "case False"], ["proof (state)\nthis:\n  obs' \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. obs' \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "with obs sc_obs' fin"], ["proof (chain)\npicking this:\n  obs = lappend obs' obs''\n  ta_seq_consist P vs obs'\n  lfinite obs' \\<Longrightarrow>\n  X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n  ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\n  obs' \\<noteq> LNil", "show ?thesis"], ["proof (prove)\nusing this:\n  obs = lappend obs' obs''\n  ta_seq_consist P vs obs'\n  lfinite obs' \\<Longrightarrow>\n  X (mrw_values P vs (list_of obs')) obs'' a' \\<or>\n  ta_seq_consist P (mrw_values P vs (list_of obs')) obs''\n  obs' \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "by auto"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P vs (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "}"], ["proof (state)\nthis:\n  X ?vsa2 ?obsa2 ?aa2 \\<Longrightarrow>\n  ?obsa2 = LNil \\<or>\n  (\\<exists>obs' obs''.\n      ?obsa2 = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P ?vsa2 obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P ?vsa2 (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P ?vsa2 (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "note step' = this"], ["proof (state)\nthis:\n  X ?vsa2 ?obsa2 ?aa2 \\<Longrightarrow>\n  ?obsa2 = LNil \\<or>\n  (\\<exists>obs' obs''.\n      ?obsa2 = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P ?vsa2 obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>a. X (mrw_values P ?vsa2 (list_of obs')) obs'' a) \\<or>\n       ta_seq_consist P (mrw_values P ?vsa2 (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "from major"], ["proof (chain)\npicking this:\n  X vs obs a", "show ?thesis"], ["proof (prove)\nusing this:\n  X vs obs a\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs obs", "proof(coinduction arbitrary: vs obs a rule: ta_seq_consist_coinduct_append)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vsa obsa a.\n       X vsa obsa a \\<Longrightarrow>\n       obsa = LNil \\<or>\n       (\\<exists>obs' obs''.\n           obsa = lappend obs' obs'' \\<and>\n           obs' \\<noteq> LNil \\<and>\n           ta_seq_consist P vsa obs' \\<and>\n           (lfinite obs' \\<longrightarrow>\n            (\\<exists>vs obs a.\n                mrw_values P vsa (list_of obs') = vs \\<and>\n                obs'' = obs \\<and> X vs obs a) \\<or>\n            ta_seq_consist P (mrw_values P vsa (list_of obs')) obs''))", "case (ta_seq_consist vs obs a)"], ["proof (state)\nthis:\n  X vs obs a\n\ngoal (1 subgoal):\n 1. \\<And>vsa obsa a.\n       X vsa obsa a \\<Longrightarrow>\n       obsa = LNil \\<or>\n       (\\<exists>obs' obs''.\n           obsa = lappend obs' obs'' \\<and>\n           obs' \\<noteq> LNil \\<and>\n           ta_seq_consist P vsa obs' \\<and>\n           (lfinite obs' \\<longrightarrow>\n            (\\<exists>vs obs a.\n                mrw_values P vsa (list_of obs') = vs \\<and>\n                obs'' = obs \\<and> X vs obs a) \\<or>\n            ta_seq_consist P (mrw_values P vsa (list_of obs')) obs''))", "thus ?case"], ["proof (prove)\nusing this:\n  X vs obs a\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs''.\n        obs = lappend obs' obs'' \\<and>\n        obs' \\<noteq> LNil \\<and>\n        ta_seq_consist P vs obs' \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>vs obs a.\n             mrw_values P vs (list_of obs') = vs \\<and>\n             obs'' = obs \\<and> X vs obs a) \\<or>\n         ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))", "by simp(rule step')"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs''.\n      obs = lappend obs' obs'' \\<and>\n      obs' \\<noteq> LNil \\<and>\n      ta_seq_consist P vs obs' \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>vs obs a.\n           mrw_values P vs (list_of obs') = vs \\<and>\n           obs'' = obs \\<and> X vs obs a) \\<or>\n       ta_seq_consist P (mrw_values P vs (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ta_seq_consist P vs obs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ta_seq_consist_nthI:\n  \"(\\<And>i ad al v. \\<lbrakk> enat i < llength obs; lnth obs i = NormalAction (ReadMem ad al v);\n      ta_seq_consist P vs (ltake (enat i) obs) \\<rbrakk> \n    \\<Longrightarrow> \\<exists>b. mrw_values P vs (list_of (ltake (enat i) obs)) (ad, al) = \\<lfloor>(v, b)\\<rfloor>)\n  \\<Longrightarrow> ta_seq_consist P vs obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i ad al v.\n        \\<lbrakk>enat i < llength obs;\n         lnth obs i = NormalAction (ReadMem ad al v);\n         ta_seq_consist P vs (ltake (enat i) obs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>b.\n                             mrw_values P vs (list_of (ltake (enat i) obs))\n                              (ad, al) =\n                             \\<lfloor>(v, b)\\<rfloor>) \\<Longrightarrow>\n    ta_seq_consist P vs obs", "proof(coinduction arbitrary: vs obs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs obs.\n       \\<forall>i ad al v.\n          enat i < llength obs \\<longrightarrow>\n          lnth obs i = NormalAction (ReadMem ad al v) \\<longrightarrow>\n          ta_seq_consist P vs (ltake (enat i) obs) \\<longrightarrow>\n          (\\<exists>b.\n              mrw_values P vs (list_of (ltake (enat i) obs)) (ad, al) =\n              \\<lfloor>(v, b)\\<rfloor>) \\<Longrightarrow>\n       (\\<exists>vsa. vs = vsa \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vsa obsa.\n           vs = vsa \\<and>\n           obs = LCons ob obsa \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vsa (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vs obs.\n                mrw_value P vsa ob = vs \\<and>\n                obsa = obs \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obs \\<longrightarrow>\n                    lnth obs i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vs\n                     (ltake (enat i) obs) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vs (list_of (ltake (enat i) obs))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vsa ob) obsa))", "case (ta_seq_consist vs obs)"], ["proof (state)\nthis:\n  \\<forall>i ad al v.\n     enat i < llength obs \\<longrightarrow>\n     lnth obs i = NormalAction (ReadMem ad al v) \\<longrightarrow>\n     ta_seq_consist P vs (ltake (enat i) obs) \\<longrightarrow>\n     (\\<exists>b.\n         mrw_values P vs (list_of (ltake (enat i) obs)) (ad, al) =\n         \\<lfloor>(v, b)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>vs obs.\n       \\<forall>i ad al v.\n          enat i < llength obs \\<longrightarrow>\n          lnth obs i = NormalAction (ReadMem ad al v) \\<longrightarrow>\n          ta_seq_consist P vs (ltake (enat i) obs) \\<longrightarrow>\n          (\\<exists>b.\n              mrw_values P vs (list_of (ltake (enat i) obs)) (ad, al) =\n              \\<lfloor>(v, b)\\<rfloor>) \\<Longrightarrow>\n       (\\<exists>vsa. vs = vsa \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vsa obsa.\n           vs = vsa \\<and>\n           obs = LCons ob obsa \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vsa (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vs obs.\n                mrw_value P vsa ob = vs \\<and>\n                obsa = obs \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obs \\<longrightarrow>\n                    lnth obs i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vs\n                     (ltake (enat i) obs) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vs (list_of (ltake (enat i) obs))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vsa ob) obsa))", "hence nth:\n    \"\\<And>i ad al v. \\<lbrakk> enat i < llength obs; lnth obs i = NormalAction (ReadMem ad al v); \n                   ta_seq_consist P vs (ltake (enat i) obs) \\<rbrakk> \n    \\<Longrightarrow> \\<exists>b. mrw_values P vs (list_of (ltake (enat i) obs)) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<forall>i ad al v.\n     enat i < llength obs \\<longrightarrow>\n     lnth obs i = NormalAction (ReadMem ad al v) \\<longrightarrow>\n     ta_seq_consist P vs (ltake (enat i) obs) \\<longrightarrow>\n     (\\<exists>b.\n         mrw_values P vs (list_of (ltake (enat i) obs)) (ad, al) =\n         \\<lfloor>(v, b)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength obs;\n        lnth obs i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P vs (ltake (enat i) obs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P vs (list_of (ltake (enat i) obs))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?i < llength obs;\n   lnth obs ?i = NormalAction (ReadMem ?ad ?al ?v);\n   ta_seq_consist P vs (ltake (enat ?i) obs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P vs (list_of (ltake (enat ?i) obs))\n                        (?ad, ?al) =\n                       \\<lfloor>(?v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>vs obs.\n       \\<forall>i ad al v.\n          enat i < llength obs \\<longrightarrow>\n          lnth obs i = NormalAction (ReadMem ad al v) \\<longrightarrow>\n          ta_seq_consist P vs (ltake (enat i) obs) \\<longrightarrow>\n          (\\<exists>b.\n              mrw_values P vs (list_of (ltake (enat i) obs)) (ad, al) =\n              \\<lfloor>(v, b)\\<rfloor>) \\<Longrightarrow>\n       (\\<exists>vsa. vs = vsa \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vsa obsa.\n           vs = vsa \\<and>\n           obs = LCons ob obsa \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vsa (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vs obs.\n                mrw_value P vsa ob = vs \\<and>\n                obsa = obs \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obs \\<longrightarrow>\n                    lnth obs i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vs\n                     (ltake (enat i) obs) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vs (list_of (ltake (enat i) obs))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vsa ob) obsa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>vsa obsa.\n             mrw_value P vs ob = vsa \\<and>\n             obs = obsa \\<and>\n             (\\<forall>i ad al v.\n                 enat i < llength obsa \\<longrightarrow>\n                 lnth obsa i =\n                 NormalAction (ReadMem ad al v) \\<longrightarrow>\n                 ta_seq_consist P vsa\n                  (ltake (enat i) obsa) \\<longrightarrow>\n                 (\\<exists>b.\n                     mrw_values P vsa (list_of (ltake (enat i) obsa))\n                      (ad, al) =\n                     \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "proof(cases obs)"], ["proof (state)\ngoal (2 subgoals):\n 1. obs = LNil \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>vsa obsa.\n             mrw_value P vs ob = vsa \\<and>\n             obs = obsa \\<and>\n             (\\<forall>i ad al v.\n                 enat i < llength obsa \\<longrightarrow>\n                 lnth obsa i =\n                 NormalAction (ReadMem ad al v) \\<longrightarrow>\n                 ta_seq_consist P vsa\n                  (ltake (enat i) obsa) \\<longrightarrow>\n                 (\\<exists>b.\n                     mrw_values P vsa (list_of (ltake (enat i) obsa))\n                      (ad, al) =\n                     \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "case LNil"], ["proof (state)\nthis:\n  obs = LNil\n\ngoal (2 subgoals):\n 1. obs = LNil \\<Longrightarrow>\n    (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>vsa obsa.\n             mrw_value P vs ob = vsa \\<and>\n             obs = obsa \\<and>\n             (\\<forall>i ad al v.\n                 enat i < llength obsa \\<longrightarrow>\n                 lnth obsa i =\n                 NormalAction (ReadMem ad al v) \\<longrightarrow>\n                 ta_seq_consist P vsa\n                  (ltake (enat i) obsa) \\<longrightarrow>\n                 (\\<exists>b.\n                     mrw_values P vsa (list_of (ltake (enat i) obsa))\n                      (ad, al) =\n                     \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))\n 2. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs = LNil\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>vsa obsa.\n             mrw_value P vs ob = vsa \\<and>\n             obs = obsa \\<and>\n             (\\<forall>i ad al v.\n                 enat i < llength obsa \\<longrightarrow>\n                 lnth obsa i =\n                 NormalAction (ReadMem ad al v) \\<longrightarrow>\n                 ta_seq_consist P vsa\n                  (ltake (enat i) obsa) \\<longrightarrow>\n                 (\\<exists>b.\n                     mrw_values P vsa (list_of (ltake (enat i) obsa))\n                      (ad, al) =\n                     \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>vsa obsa.\n           mrw_value P vs ob = vsa \\<and>\n           obs = obsa \\<and>\n           (\\<forall>i ad al v.\n               enat i < llength obsa \\<longrightarrow>\n               lnth obsa i =\n               NormalAction (ReadMem ad al v) \\<longrightarrow>\n               ta_seq_consist P vsa (ltake (enat i) obsa) \\<longrightarrow>\n               (\\<exists>b.\n                   mrw_values P vsa (list_of (ltake (enat i) obsa))\n                    (ad, al) =\n                   \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "case (LCons ob obs')"], ["proof (state)\nthis:\n  obs = LCons ob obs'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "{"], ["proof (state)\nthis:\n  obs = LCons ob obs'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "fix ad al v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "assume \"ob = NormalAction (ReadMem ad al v)\""], ["proof (state)\nthis:\n  ob = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "with nth[of 0 ad al v] LCons"], ["proof (chain)\npicking this:\n  \\<lbrakk>enat 0 < llength obs;\n   lnth obs 0 = NormalAction (ReadMem ad al v);\n   ta_seq_consist P vs (ltake (enat 0) obs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P vs (list_of (ltake (enat 0) obs))\n                        (ad, al) =\n                       \\<lfloor>(v, b)\\<rfloor>\n  obs = LCons ob obs'\n  ob = NormalAction (ReadMem ad al v)", "have \"\\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>enat 0 < llength obs;\n   lnth obs 0 = NormalAction (ReadMem ad al v);\n   ta_seq_consist P vs (ltake (enat 0) obs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P vs (list_of (ltake (enat 0) obs))\n                        (ad, al) =\n                       \\<lfloor>(v, b)\\<rfloor>\n  obs = LCons ob obs'\n  ob = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "}"], ["proof (state)\nthis:\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "note base = this"], ["proof (state)\nthis:\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "moreover"], ["proof (state)\nthis:\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "{"], ["proof (state)\nthis:\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "fix i ad al v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "assume \"enat i < llength obs'\" \"lnth obs' i = NormalAction (ReadMem ad al v)\"\n        and \"ta_seq_consist P (mrw_value P vs ob) (ltake (enat i) obs')\""], ["proof (state)\nthis:\n  enat i < llength obs'\n  lnth obs' i = NormalAction (ReadMem ad al v)\n  ta_seq_consist P (mrw_value P vs ob) (ltake (enat i) obs')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "with LCons nth[of \"Suc i\" ad al v] base"], ["proof (chain)\npicking this:\n  obs = LCons ob obs'\n  \\<lbrakk>enat (Suc i) < llength obs;\n   lnth obs (Suc i) = NormalAction (ReadMem ad al v);\n   ta_seq_consist P vs (ltake (enat (Suc i)) obs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P vs (list_of (ltake (enat (Suc i)) obs))\n                        (ad, al) =\n                       \\<lfloor>(v, b)\\<rfloor>\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n  enat i < llength obs'\n  lnth obs' i = NormalAction (ReadMem ad al v)\n  ta_seq_consist P (mrw_value P vs ob) (ltake (enat i) obs')", "have \"\\<exists>b. mrw_values P (mrw_value P vs ob) (list_of (ltake (enat i) obs')) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\""], ["proof (prove)\nusing this:\n  obs = LCons ob obs'\n  \\<lbrakk>enat (Suc i) < llength obs;\n   lnth obs (Suc i) = NormalAction (ReadMem ad al v);\n   ta_seq_consist P vs (ltake (enat (Suc i)) obs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P vs (list_of (ltake (enat (Suc i)) obs))\n                        (ad, al) =\n                       \\<lfloor>(v, b)\\<rfloor>\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n  enat i < llength obs'\n  lnth obs' i = NormalAction (ReadMem ad al v)\n  ta_seq_consist P (mrw_value P vs ob) (ltake (enat i) obs')\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       mrw_values P (mrw_value P vs ob) (list_of (ltake (enat i) obs'))\n        (ad, al) =\n       \\<lfloor>(v, b)\\<rfloor>", "by(clarsimp simp add: eSuc_enat[symmetric] split: obs_event.split action.split)"], ["proof (state)\nthis:\n  \\<exists>b.\n     mrw_values P (mrw_value P vs ob) (list_of (ltake (enat i) obs'))\n      (ad, al) =\n     \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?i2 < llength obs';\n   lnth obs' ?i2 = NormalAction (ReadMem ?ad2 ?al2 ?v2);\n   ta_seq_consist P (mrw_value P vs ob) (ltake (enat ?i2) obs')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P (mrw_value P vs ob)\n                        (list_of (ltake (enat ?i2) obs')) (?ad2, ?al2) =\n                       \\<lfloor>(?v2, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "ultimately"], ["proof (chain)\npicking this:\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n  \\<lbrakk>enat ?i2 < llength obs';\n   lnth obs' ?i2 = NormalAction (ReadMem ?ad2 ?al2 ?v2);\n   ta_seq_consist P (mrw_value P vs ob) (ltake (enat ?i2) obs')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P (mrw_value P vs ob)\n                        (list_of (ltake (enat ?i2) obs')) (?ad2, ?al2) =\n                       \\<lfloor>(?v2, b)\\<rfloor>", "have ?LCons"], ["proof (prove)\nusing this:\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n  \\<lbrakk>enat ?i2 < llength obs';\n   lnth obs' ?i2 = NormalAction (ReadMem ?ad2 ?al2 ?v2);\n   ta_seq_consist P (mrw_value P vs ob) (ltake (enat ?i2) obs')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P (mrw_value P vs ob)\n                        (list_of (ltake (enat ?i2) obs')) (?ad2, ?al2) =\n                       \\<lfloor>(?v2, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>vsa obsa.\n            mrw_value P vs ob = vsa \\<and>\n            obs = obsa \\<and>\n            (\\<forall>i ad al v.\n                enat i < llength obsa \\<longrightarrow>\n                lnth obsa i =\n                NormalAction (ReadMem ad al v) \\<longrightarrow>\n                ta_seq_consist P vsa (ltake (enat i) obsa) \\<longrightarrow>\n                (\\<exists>b.\n                    mrw_values P vsa (list_of (ltake (enat i) obsa))\n                     (ad, al) =\n                    \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "using LCons"], ["proof (prove)\nusing this:\n  ob = NormalAction (ReadMem ?ad2 ?al2 ?v2) \\<Longrightarrow>\n  \\<exists>b. vs (?ad2, ?al2) = \\<lfloor>(?v2, b)\\<rfloor>\n  \\<lbrakk>enat ?i2 < llength obs';\n   lnth obs' ?i2 = NormalAction (ReadMem ?ad2 ?al2 ?v2);\n   ta_seq_consist P (mrw_value P vs ob) (ltake (enat ?i2) obs')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       mrw_values P (mrw_value P vs ob)\n                        (list_of (ltake (enat ?i2) obs')) (?ad2, ?al2) =\n                       \\<lfloor>(?v2, b)\\<rfloor>\n  obs = LCons ob obs'\n\ngoal (1 subgoal):\n 1. \\<exists>ob vs obs.\n       vs = vs \\<and>\n       obs = LCons ob obs \\<and>\n       (case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n       ((\\<exists>vsa obsa.\n            mrw_value P vs ob = vsa \\<and>\n            obs = obsa \\<and>\n            (\\<forall>i ad al v.\n                enat i < llength obsa \\<longrightarrow>\n                lnth obsa i =\n                NormalAction (ReadMem ad al v) \\<longrightarrow>\n                ta_seq_consist P vsa (ltake (enat i) obsa) \\<longrightarrow>\n                (\\<exists>b.\n                    mrw_values P vsa (list_of (ltake (enat i) obsa))\n                     (ad, al) =\n                    \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n        ta_seq_consist P (mrw_value P vs ob) obs)", "by(simp split: action.split obs_event.split)"], ["proof (state)\nthis:\n  \\<exists>ob vs obs.\n     vs = vs \\<and>\n     obs = LCons ob obs \\<and>\n     (case ob of\n      NormalAction (ReadMem ad al v) \\<Rightarrow>\n        \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n      | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n     ((\\<exists>vsa obsa.\n          mrw_value P vs ob = vsa \\<and>\n          obs = obsa \\<and>\n          (\\<forall>i ad al v.\n              enat i < llength obsa \\<longrightarrow>\n              lnth obsa i = NormalAction (ReadMem ad al v) \\<longrightarrow>\n              ta_seq_consist P vsa (ltake (enat i) obsa) \\<longrightarrow>\n              (\\<exists>b.\n                  mrw_values P vsa (list_of (ltake (enat i) obsa))\n                   (ad, al) =\n                  \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n      ta_seq_consist P (mrw_value P vs ob) obs)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       obs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n       (\\<exists>ob vs obs.\n           vs = vs \\<and>\n           obs = LCons ob obs \\<and>\n           (case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True\n            | _ \\<Rightarrow> True) \\<and>\n           ((\\<exists>vsa obsa.\n                mrw_value P vs ob = vsa \\<and>\n                obs = obsa \\<and>\n                (\\<forall>i ad al v.\n                    enat i < llength obsa \\<longrightarrow>\n                    lnth obsa i =\n                    NormalAction (ReadMem ad al v) \\<longrightarrow>\n                    ta_seq_consist P vsa\n                     (ltake (enat i) obsa) \\<longrightarrow>\n                    (\\<exists>b.\n                        mrw_values P vsa (list_of (ltake (enat i) obsa))\n                         (ad, al) =\n                        \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n            ta_seq_consist P (mrw_value P vs ob) obs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ob vs obs.\n     vs = vs \\<and>\n     obs = LCons ob obs \\<and>\n     (case ob of\n      NormalAction (ReadMem ad al v) \\<Rightarrow>\n        \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n      | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n     ((\\<exists>vsa obsa.\n          mrw_value P vs ob = vsa \\<and>\n          obs = obsa \\<and>\n          (\\<forall>i ad al v.\n              enat i < llength obsa \\<longrightarrow>\n              lnth obsa i = NormalAction (ReadMem ad al v) \\<longrightarrow>\n              ta_seq_consist P vsa (ltake (enat i) obsa) \\<longrightarrow>\n              (\\<exists>b.\n                  mrw_values P vsa (list_of (ltake (enat i) obsa))\n                   (ad, al) =\n                  \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n      ta_seq_consist P (mrw_value P vs ob) obs)\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>vsa obsa.\n             mrw_value P vs ob = vsa \\<and>\n             obs = obsa \\<and>\n             (\\<forall>i ad al v.\n                 enat i < llength obsa \\<longrightarrow>\n                 lnth obsa i =\n                 NormalAction (ReadMem ad al v) \\<longrightarrow>\n                 ta_seq_consist P vsa\n                  (ltake (enat i) obsa) \\<longrightarrow>\n                 (\\<exists>b.\n                     mrw_values P vsa (list_of (ltake (enat i) obsa))\n                      (ad, al) =\n                     \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n         ta_seq_consist P (mrw_value P vs ob) obs))", ".."], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>vsa obsa.\n           mrw_value P vs ob = vsa \\<and>\n           obs = obsa \\<and>\n           (\\<forall>i ad al v.\n               enat i < llength obsa \\<longrightarrow>\n               lnth obsa i =\n               NormalAction (ReadMem ad al v) \\<longrightarrow>\n               ta_seq_consist P vsa (ltake (enat i) obsa) \\<longrightarrow>\n               (\\<exists>b.\n                   mrw_values P vsa (list_of (ltake (enat i) obsa))\n                    (ad, al) =\n                   \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>vs. vs = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow>\n         \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>vsa obsa.\n           mrw_value P vs ob = vsa \\<and>\n           obs = obsa \\<and>\n           (\\<forall>i ad al v.\n               enat i < llength obsa \\<longrightarrow>\n               lnth obsa i =\n               NormalAction (ReadMem ad al v) \\<longrightarrow>\n               ta_seq_consist P vsa (ltake (enat i) obsa) \\<longrightarrow>\n               (\\<exists>b.\n                   mrw_values P vsa (list_of (ltake (enat i) obsa))\n                    (ad, al) =\n                   \\<lfloor>(v, b)\\<rfloor>))) \\<or>\n       ta_seq_consist P (mrw_value P vs ob) obs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ta_seq_consist_into_non_speculative:\n  \"\\<lbrakk> ta_seq_consist P vs obs; \\<forall>adal. set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV \\<rbrakk>\n  \\<Longrightarrow> non_speculative P vs' obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ta_seq_consist P vs obs;\n     \\<forall>adal.\n        set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV\\<rbrakk>\n    \\<Longrightarrow> non_speculative P vs' obs", "proof(coinduction arbitrary: vs' obs vs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs' obs vs.\n       \\<lbrakk>ta_seq_consist P vs obs;\n        \\<forall>adal.\n           set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>vs. vs' = vs \\<and> obs = LNil) \\<or>\n                         (\\<exists>ob vs obsa.\n                             vs' = vs \\<and>\n                             obs = LCons ob obsa \\<and>\n                             (case ob of\n                              NormalAction (ReadMem ad al v) \\<Rightarrow>\n                                v \\<in> vs (ad, al)\n                              | NormalAction _ \\<Rightarrow> True\n                              | _ \\<Rightarrow> True) \\<and>\n                             ((\\<exists>vs' obs vsa.\n                                  w_value P vs ob = vs' \\<and>\n                                  obsa = obs \\<and>\n                                  ta_seq_consist P vsa obs \\<and>\n                                  (\\<forall>adal.\nset_option (vsa adal) \\<subseteq> vs' adal \\<times> UNIV)) \\<or>\n                              non_speculative P (w_value P vs ob) obsa))", "case (non_speculative vs' obs vs)"], ["proof (state)\nthis:\n  ta_seq_consist P vs obs\n  \\<forall>adal. set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>vs' obs vs.\n       \\<lbrakk>ta_seq_consist P vs obs;\n        \\<forall>adal.\n           set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>vs. vs' = vs \\<and> obs = LNil) \\<or>\n                         (\\<exists>ob vs obsa.\n                             vs' = vs \\<and>\n                             obs = LCons ob obsa \\<and>\n                             (case ob of\n                              NormalAction (ReadMem ad al v) \\<Rightarrow>\n                                v \\<in> vs (ad, al)\n                              | NormalAction _ \\<Rightarrow> True\n                              | _ \\<Rightarrow> True) \\<and>\n                             ((\\<exists>vs' obs vsa.\n                                  w_value P vs ob = vs' \\<and>\n                                  obsa = obs \\<and>\n                                  ta_seq_consist P vsa obs \\<and>\n                                  (\\<forall>adal.\nset_option (vsa adal) \\<subseteq> vs' adal \\<times> UNIV)) \\<or>\n                              non_speculative P (w_value P vs ob) obsa))", "thus ?case"], ["proof (prove)\nusing this:\n  ta_seq_consist P vs obs\n  \\<forall>adal. set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (\\<exists>vs. vs' = vs \\<and> obs = LNil) \\<or>\n    (\\<exists>ob vs obs.\n        vs' = vs \\<and>\n        obs = LCons ob obs \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow> v \\<in> vs (ad, al)\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ((\\<exists>vs' obsa vsa.\n             w_value P vs ob = vs' \\<and>\n             obs = obsa \\<and>\n             ta_seq_consist P vsa obsa \\<and>\n             (\\<forall>adal.\n                 set_option (vsa adal)\n                 \\<subseteq> vs' adal \\<times> UNIV)) \\<or>\n         non_speculative P (w_value P vs ob) obs))", "apply cases"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>adal.\n                set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV;\n     obs = LNil\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>vs. vs' = vs \\<and> obs = LNil) \\<or>\n                      (\\<exists>ob vs obs.\n                          vs' = vs \\<and>\n                          obs = LCons ob obs \\<and>\n                          (case ob of\n                           NormalAction (ReadMem ad al v) \\<Rightarrow>\n                             v \\<in> vs (ad, al)\n                           | NormalAction _ \\<Rightarrow> True\n                           | _ \\<Rightarrow> True) \\<and>\n                          ((\\<exists>vs' obsa vsa.\n                               w_value P vs ob = vs' \\<and>\n                               obs = obsa \\<and>\n                               ta_seq_consist P vsa obsa \\<and>\n                               (\\<forall>adal.\n                                   set_option (vsa adal)\n                                   \\<subseteq> vs' adal \\<times>\n         UNIV)) \\<or>\n                           non_speculative P (w_value P vs ob) obs))\n 2. \\<And>ob obs.\n       \\<lbrakk>\\<forall>adal.\n                   set_option (vs adal) \\<subseteq> vs' adal \\<times> UNIV;\n        obs = LCons ob obs;\n        case ob of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n        | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True;\n        ta_seq_consist P (mrw_value P vs ob) obs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>vs. vs' = vs \\<and> obs = LNil) \\<or>\n                         (\\<exists>ob vs obs.\n                             vs' = vs \\<and>\n                             obs = LCons ob obs \\<and>\n                             (case ob of\n                              NormalAction (ReadMem ad al v) \\<Rightarrow>\n                                v \\<in> vs (ad, al)\n                              | NormalAction _ \\<Rightarrow> True\n                              | _ \\<Rightarrow> True) \\<and>\n                             ((\\<exists>vs' obsa vsa.\n                                  w_value P vs ob = vs' \\<and>\n                                  obs = obsa \\<and>\n                                  ta_seq_consist P vsa obsa \\<and>\n                                  (\\<forall>adal.\nset_option (vsa adal) \\<subseteq> vs' adal \\<times> UNIV)) \\<or>\n                              non_speculative P (w_value P vs ob) obs))", "apply(auto split: action.split_asm obs_event.split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>obs x31 x32 x33.\n       \\<lbrakk>ta_seq_consist P (vs((x31, x32) \\<mapsto> (x33, True))) obs;\n        \\<forall>a b.\n           set_option (vs (a, b)) \\<subseteq> vs' (a, b) \\<times> UNIV;\n        obs = LCons (NormalAction (WriteMem x31 x32 x33)) obs;\n        \\<not> non_speculative P\n                (vs'((x31, x32) := insert x33 (vs' (x31, x32))))\n                obs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs.\n                            ta_seq_consist P vs obs \\<and>\n                            (\\<forall>a b.\n                                (a = x31 \\<and> b = x32 \\<longrightarrow>\n                                 set_option (vs (x31, x32))\n                                 \\<subseteq> insert x33\n        (vs' (x31, x32)) \\<times>\n       UNIV) \\<and>\n                                ((a = x31 \\<longrightarrow>\n                                  b \\<noteq> x32) \\<longrightarrow>\n                                 set_option (vs (a, b))\n                                 \\<subseteq> vs' (a, b) \\<times> UNIV))\n 2. \\<And>obs x41 x42.\n       \\<lbrakk>ta_seq_consist P\n                 (\\<lambda>(ad', al).\n                     if x41 = ad' \\<and>\n                        al \\<in> addr_locs P x42 \\<and>\n                        (case vs (x41, al) of None \\<Rightarrow> True\n                         | \\<lfloor>(v, xa)\\<rfloor> \\<Rightarrow>\n                             \\<not> xa)\n                     then \\<lfloor>(addr_loc_default P x42 al,\n                                    False)\\<rfloor>\n                     else vs (ad', al))\n                 obs;\n        \\<forall>a b.\n           set_option (vs (a, b)) \\<subseteq> vs' (a, b) \\<times> UNIV;\n        obs = LCons (NormalAction (NewHeapElem x41 x42)) obs;\n        \\<not> non_speculative P\n                (\\<lambda>(ad', al).\n                    if x41 = ad' \\<and> al \\<in> addr_locs P x42\n                    then insert (addr_loc_default P x42 al) (vs' (x41, al))\n                    else vs' (ad', al))\n                obs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs.\n                            ta_seq_consist P vs obs \\<and>\n                            (\\<forall>a b.\n                                (x41 = a \\<and>\n                                 b \\<in> addr_locs P x42 \\<longrightarrow>\n                                 set_option (vs (a, b))\n                                 \\<subseteq> insert\n        (addr_loc_default P x42 b) (vs' (a, b)) \\<times>\n       UNIV) \\<and>\n                                ((x41 = a \\<longrightarrow>\n                                  b \\<notin> addr_locs P\n        x42) \\<longrightarrow>\n                                 set_option (vs (a, b))\n                                 \\<subseteq> vs' (a, b) \\<times> UNIV))", "apply(rule exI, erule conjI, auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>vs. vs' = vs \\<and> obs = LNil) \\<or>\n  (\\<exists>ob vs obs.\n      vs' = vs \\<and>\n      obs = LCons ob obs \\<and>\n      (case ob of\n       NormalAction (ReadMem ad al v) \\<Rightarrow> v \\<in> vs (ad, al)\n       | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n      ((\\<exists>vs' obsa vsa.\n           w_value P vs ob = vs' \\<and>\n           obs = obsa \\<and>\n           ta_seq_consist P vsa obsa \\<and>\n           (\\<forall>adal.\n               set_option (vsa adal)\n               \\<subseteq> vs' adal \\<times> UNIV)) \\<or>\n       non_speculative P (w_value P vs ob) obs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_of_list_of_append:\n  \"lfinite xs \\<Longrightarrow> llist_of (list_of xs @ ys) = lappend xs (llist_of ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    llist_of (list_of xs @ ys) = lappend xs (llist_of ys)", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> range llist_of \\<Longrightarrow>\n    llist_of (list_of xs @ ys) = lappend xs (llist_of ys)", "by(clarsimp simp add: lappend_llist_of_llist_of)"], ["", "lemma ta_seq_consist_most_recent_write_for:\n  assumes sc: \"ta_seq_consist P Map.empty (lmap snd E)\"\n  and read: \"r \\<in> read_actions E\"\n  and new_actions_for_fun: \"\\<And>adal a a'. \\<lbrakk> a \\<in> new_actions_for P E adal; a' \\<in> new_actions_for P E adal \\<rbrakk> \\<Longrightarrow> a = a'\"\n  shows \"\\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "from read"], ["proof (chain)\npicking this:\n  r \\<in> read_actions E", "obtain t v ad al \n    where nth_r: \"lnth E r = (t, NormalAction (ReadMem ad al v))\"\n    and r: \"enat r < llength E\""], ["proof (prove)\nusing this:\n  r \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. (\\<And>t ad al v.\n        \\<lbrakk>lnth E r = (t, NormalAction (ReadMem ad al v));\n         enat r < llength E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases)(cases \"lnth E r\", auto simp add: action_obs_def actions_def)"], ["proof (state)\nthis:\n  lnth E r = (t, NormalAction (ReadMem ad al v))\n  enat r < llength E\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "from nth_r r"], ["proof (chain)\npicking this:\n  lnth E r = (t, NormalAction (ReadMem ad al v))\n  enat r < llength E", "have E_unfold: \"E = lappend (ltake (enat r) E) (LCons (t, NormalAction (ReadMem ad al v)) (ldropn (Suc r) E))\""], ["proof (prove)\nusing this:\n  lnth E r = (t, NormalAction (ReadMem ad al v))\n  enat r < llength E\n\ngoal (1 subgoal):\n 1. E =\n    lappend (ltake (enat r) E)\n     (LCons (t, NormalAction (ReadMem ad al v)) (ldropn (Suc r) E))", "by (metis lappend_ltake_enat_ldropn ldropn_Suc_conv_ldropn)"], ["proof (state)\nthis:\n  E =\n  lappend (ltake (enat r) E)\n   (LCons (t, NormalAction (ReadMem ad al v)) (ldropn (Suc r) E))\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "from sc"], ["proof (chain)\npicking this:\n  ta_seq_consist P Map.empty (lmap snd E)", "obtain b where sc': \"ta_seq_consist P Map.empty (ltake (enat r) (lmap snd E))\"\n    and mrw': \"mrw_values P Map.empty (map snd (list_of (ltake (enat r) E))) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\""], ["proof (prove)\nusing this:\n  ta_seq_consist P Map.empty (lmap snd E)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>ta_seq_consist P Map.empty (ltake (enat r) (lmap snd E));\n         mrw_values P Map.empty (map snd (list_of (ltake (enat r) E)))\n          (ad, al) =\n         \\<lfloor>(v, b)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(subst (asm) (3) E_unfold)(auto simp add: ta_seq_consist_lappend lmap_lappend_distrib)"], ["proof (state)\nthis:\n  ta_seq_consist P Map.empty (ltake (enat r) (lmap snd E))\n  mrw_values P Map.empty (map snd (list_of (ltake (enat r) E))) (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "from mrw_values_mrw[OF mrw', of t] r"], ["proof (chain)\npicking this:\n  (None = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n   \\<exists>wa.\n      wa \\<in> set (map snd (list_of (ltake (enat r) E))) \\<and>\n      is_write_action wa \\<and>\n      (ad, al) \\<in> action_loc_aux P wa \\<and>\n      (b \\<longrightarrow> \\<not> is_new_action wa)) \\<Longrightarrow>\n  \\<exists>i<length (list_of (ltake (enat r) E)).\n     P,llist_of\n        (list_of (ltake (enat r) E) @\n         [(t, NormalAction\n               (ReadMem ad al\n                 v))]) \\<turnstile> length\n                                     (list_of\n (ltake (enat r) E)) \\<leadsto>mrw i \\<and>\n     value_written P (llist_of (list_of (ltake (enat r) E))) i (ad, al) = v\n  enat r < llength E", "obtain E' w' \n    where E': \"E' = llist_of (list_of (ltake (enat r) E) @ [(t, NormalAction (ReadMem ad al v))])\"\n    and v: \"v = value_written P (ltake (enat r) E) w' (ad, al)\"\n    and mrw'': \"P,E' \\<turnstile> r \\<leadsto>mrw w'\"\n    and w': \"w' < r\""], ["proof (prove)\nusing this:\n  (None = \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n   \\<exists>wa.\n      wa \\<in> set (map snd (list_of (ltake (enat r) E))) \\<and>\n      is_write_action wa \\<and>\n      (ad, al) \\<in> action_loc_aux P wa \\<and>\n      (b \\<longrightarrow> \\<not> is_new_action wa)) \\<Longrightarrow>\n  \\<exists>i<length (list_of (ltake (enat r) E)).\n     P,llist_of\n        (list_of (ltake (enat r) E) @\n         [(t, NormalAction\n               (ReadMem ad al\n                 v))]) \\<turnstile> length\n                                     (list_of\n (ltake (enat r) E)) \\<leadsto>mrw i \\<and>\n     value_written P (llist_of (list_of (ltake (enat r) E))) i (ad, al) = v\n  enat r < llength E\n\ngoal (1 subgoal):\n 1. (\\<And>E' w'.\n        \\<lbrakk>E' =\n                 llist_of\n                  (list_of (ltake (enat r) E) @\n                   [(t, NormalAction (ReadMem ad al v))]);\n         v = value_written P (ltake (enat r) E) w' (ad, al);\n         P,E' \\<turnstile> r \\<leadsto>mrw w'; w' < r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: length_list_of_conv_the_enat min_def split: if_split_asm)"], ["proof (state)\nthis:\n  E' =\n  llist_of\n   (list_of (ltake (enat r) E) @ [(t, NormalAction (ReadMem ad al v))])\n  v = value_written P (ltake (enat r) E) w' (ad, al)\n  P,E' \\<turnstile> r \\<leadsto>mrw w'\n  w' < r\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "from E' r"], ["proof (chain)\npicking this:\n  E' =\n  llist_of\n   (list_of (ltake (enat r) E) @ [(t, NormalAction (ReadMem ad al v))])\n  enat r < llength E", "have sim: \"ltake (enat (Suc r)) E' [\\<approx>] ltake (enat (Suc r)) E\""], ["proof (prove)\nusing this:\n  E' =\n  llist_of\n   (list_of (ltake (enat r) E) @ [(t, NormalAction (ReadMem ad al v))])\n  enat r < llength E\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc r)) E' [\\<approx>] ltake (enat (Suc r)) E", "by(subst E_unfold)(simp add: ltake_lappend llist_of_list_of_append min_def, auto simp add: eSuc_enat[symmetric] zero_enat_def[symmetric] eq_into_sim_actions)"], ["proof (state)\nthis:\n  ltake (enat (Suc r)) E' [\\<approx>] ltake (enat (Suc r)) E\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "from nth_r"], ["proof (chain)\npicking this:\n  lnth E r = (t, NormalAction (ReadMem ad al v))", "have adal_r: \"(ad, al) \\<in> action_loc P E r\""], ["proof (prove)\nusing this:\n  lnth E r = (t, NormalAction (ReadMem ad al v))\n\ngoal (1 subgoal):\n 1. (ad, al) \\<in> action_loc P E r", "by(simp add: action_obs_def)"], ["proof (state)\nthis:\n  (ad, al) \\<in> action_loc P E r\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "from E' r"], ["proof (chain)\npicking this:\n  E' =\n  llist_of\n   (list_of (ltake (enat r) E) @ [(t, NormalAction (ReadMem ad al v))])\n  enat r < llength E", "have nth_r': \"lnth E' r = (t, NormalAction (ReadMem ad al v))\""], ["proof (prove)\nusing this:\n  E' =\n  llist_of\n   (list_of (ltake (enat r) E) @ [(t, NormalAction (ReadMem ad al v))])\n  enat r < llength E\n\ngoal (1 subgoal):\n 1. lnth E' r = (t, NormalAction (ReadMem ad al v))", "by(auto simp add: nth_append length_list_of_conv_the_enat min_def)"], ["proof (state)\nthis:\n  lnth E' r = (t, NormalAction (ReadMem ad al v))\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "with mrw'' w' r adal_r"], ["proof (chain)\npicking this:\n  P,E' \\<turnstile> r \\<leadsto>mrw w'\n  w' < r\n  enat r < llength E\n  (ad, al) \\<in> action_loc P E r\n  lnth E' r = (t, NormalAction (ReadMem ad al v))", "obtain \"E \\<turnstile> w' \\<le>a r\" \"w' \\<in> write_actions E\" \"(ad, al) \\<in> action_loc P E w'\""], ["proof (prove)\nusing this:\n  P,E' \\<turnstile> r \\<leadsto>mrw w'\n  w' < r\n  enat r < llength E\n  (ad, al) \\<in> action_loc P E r\n  lnth E' r = (t, NormalAction (ReadMem ad al v))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>E \\<turnstile> w' \\<le>a r; w' \\<in> write_actions E;\n      (ad, al) \\<in> action_loc P E w'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases(fastforce simp add: action_obs_def action_loc_change_prefix[OF sim[symmetric], simplified action_obs_def] intro: action_order_change_prefix[OF _ sim] write_actions_change_prefix[OF _ sim])"], ["proof (state)\nthis:\n  E \\<turnstile> w' \\<le>a r\n  w' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E w'\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "with read adal_r"], ["proof (chain)\npicking this:\n  r \\<in> read_actions E\n  (ad, al) \\<in> action_loc P E r\n  E \\<turnstile> w' \\<le>a r\n  w' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E w'", "have \"P,E \\<turnstile> r \\<leadsto>mrw w'\""], ["proof (prove)\nusing this:\n  r \\<in> read_actions E\n  (ad, al) \\<in> action_loc P E r\n  E \\<turnstile> w' \\<le>a r\n  w' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E w'\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> r \\<leadsto>mrw w'", "proof(rule most_recent_write_for.intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa'.\n       \\<lbrakk>wa' \\<in> write_actions E;\n        (ad, al) \\<in> action_loc P E wa'\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> wa' \\<le>a w' \\<or>\n                         E \\<turnstile> r \\<le>a wa'", "fix wa'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa'.\n       \\<lbrakk>wa' \\<in> write_actions E;\n        (ad, al) \\<in> action_loc P E wa'\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> wa' \\<le>a w' \\<or>\n                         E \\<turnstile> r \\<le>a wa'", "assume write': \"wa' \\<in> write_actions E\"\n      and adal_wa': \"(ad, al) \\<in> action_loc P E wa'\""], ["proof (state)\nthis:\n  wa' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E wa'\n\ngoal (1 subgoal):\n 1. \\<And>wa'.\n       \\<lbrakk>wa' \\<in> write_actions E;\n        (ad, al) \\<in> action_loc P E wa'\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> wa' \\<le>a w' \\<or>\n                         E \\<turnstile> r \\<le>a wa'", "show \"E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "proof(cases \"r \\<le> wa'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n 2. \\<not> r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "assume \"r \\<le> wa'\""], ["proof (state)\nthis:\n  r \\<le> wa'\n\ngoal (2 subgoals):\n 1. r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n 2. \\<not> r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "proof(cases \"is_new_action (action_obs E wa')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n 2. \\<not> is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "case False"], ["proof (state)\nthis:\n  \\<not> is_new_action (action_obs E wa')\n\ngoal (2 subgoals):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n 2. \\<not> is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "with \\<open>r \\<le> wa'\\<close>"], ["proof (chain)\npicking this:\n  r \\<le> wa'\n  \\<not> is_new_action (action_obs E wa')", "have \"E \\<turnstile> r \\<le>a wa'\""], ["proof (prove)\nusing this:\n  r \\<le> wa'\n  \\<not> is_new_action (action_obs E wa')\n\ngoal (1 subgoal):\n 1. E \\<turnstile> r \\<le>a wa'", "using read write'"], ["proof (prove)\nusing this:\n  r \\<le> wa'\n  \\<not> is_new_action (action_obs E wa')\n  r \\<in> read_actions E\n  wa' \\<in> write_actions E\n\ngoal (1 subgoal):\n 1. E \\<turnstile> r \\<le>a wa'", "by(auto simp add: action_order_def elim!: read_actions.cases)"], ["proof (state)\nthis:\n  E \\<turnstile> r \\<le>a wa'\n\ngoal (2 subgoals):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n 2. \\<not> is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "thus ?thesis"], ["proof (prove)\nusing this:\n  E \\<turnstile> r \\<le>a wa'\n\ngoal (1 subgoal):\n 1. E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", ".."], ["proof (state)\nthis:\n  E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n\ngoal (1 subgoal):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "case True"], ["proof (state)\nthis:\n  is_new_action (action_obs E wa')\n\ngoal (1 subgoal):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "with write' adal_wa'"], ["proof (chain)\npicking this:\n  wa' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E wa'\n  is_new_action (action_obs E wa')", "have \"wa' \\<in> new_actions_for P E (ad, al)\""], ["proof (prove)\nusing this:\n  wa' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E wa'\n  is_new_action (action_obs E wa')\n\ngoal (1 subgoal):\n 1. wa' \\<in> new_actions_for P E (ad, al)", "by(simp add: new_actions_for_def)"], ["proof (state)\nthis:\n  wa' \\<in> new_actions_for P E (ad, al)\n\ngoal (1 subgoal):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "hence \"w' \\<notin> new_actions_for P E (ad, al)\""], ["proof (prove)\nusing this:\n  wa' \\<in> new_actions_for P E (ad, al)\n\ngoal (1 subgoal):\n 1. w' \\<notin> new_actions_for P E (ad, al)", "using r w' \\<open>r \\<le> wa'\\<close>"], ["proof (prove)\nusing this:\n  wa' \\<in> new_actions_for P E (ad, al)\n  enat r < llength E\n  w' < r\n  r \\<le> wa'\n\ngoal (1 subgoal):\n 1. w' \\<notin> new_actions_for P E (ad, al)", "by(auto dest: new_actions_for_fun)"], ["proof (state)\nthis:\n  w' \\<notin> new_actions_for P E (ad, al)\n\ngoal (1 subgoal):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "with \\<open>w' \\<in> write_actions E\\<close> \\<open>(ad, al) \\<in> action_loc P E w'\\<close>"], ["proof (chain)\npicking this:\n  w' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E w'\n  w' \\<notin> new_actions_for P E (ad, al)", "have \"\\<not> is_new_action (action_obs E w')\""], ["proof (prove)\nusing this:\n  w' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E w'\n  w' \\<notin> new_actions_for P E (ad, al)\n\ngoal (1 subgoal):\n 1. \\<not> is_new_action (action_obs E w')", "by(simp add: new_actions_for_def)"], ["proof (state)\nthis:\n  \\<not> is_new_action (action_obs E w')\n\ngoal (1 subgoal):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "with write' True \\<open>w' \\<in> write_actions E\\<close>"], ["proof (chain)\npicking this:\n  wa' \\<in> write_actions E\n  is_new_action (action_obs E wa')\n  w' \\<in> write_actions E\n  \\<not> is_new_action (action_obs E w')", "have \"E \\<turnstile> wa' \\<le>a w'\""], ["proof (prove)\nusing this:\n  wa' \\<in> write_actions E\n  is_new_action (action_obs E wa')\n  w' \\<in> write_actions E\n  \\<not> is_new_action (action_obs E w')\n\ngoal (1 subgoal):\n 1. E \\<turnstile> wa' \\<le>a w'", "by(simp add: action_order_def)"], ["proof (state)\nthis:\n  E \\<turnstile> wa' \\<le>a w'\n\ngoal (1 subgoal):\n 1. is_new_action (action_obs E wa') \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "thus ?thesis"], ["proof (prove)\nusing this:\n  E \\<turnstile> wa' \\<le>a w'\n\ngoal (1 subgoal):\n 1. E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", ".."], ["proof (state)\nthis:\n  E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n\ngoal (1 subgoal):\n 1. \\<not> r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "assume \"\\<not> r \\<le> wa'\""], ["proof (state)\nthis:\n  \\<not> r \\<le> wa'\n\ngoal (1 subgoal):\n 1. \\<not> r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "hence \"wa' < r\""], ["proof (prove)\nusing this:\n  \\<not> r \\<le> wa'\n\ngoal (1 subgoal):\n 1. wa' < r", "by simp"], ["proof (state)\nthis:\n  wa' < r\n\ngoal (1 subgoal):\n 1. \\<not> r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "with write' adal_wa'"], ["proof (chain)\npicking this:\n  wa' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E wa'\n  wa' < r", "have \"wa' \\<in> write_actions E'\" \"(ad, al) \\<in> action_loc P E' wa'\""], ["proof (prove)\nusing this:\n  wa' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E wa'\n  wa' < r\n\ngoal (1 subgoal):\n 1. wa' \\<in> write_actions E' &&& (ad, al) \\<in> action_loc P E' wa'", "by(auto intro: write_actions_change_prefix[OF _ sim[symmetric]] simp add: action_loc_change_prefix[OF sim])"], ["proof (state)\nthis:\n  wa' \\<in> write_actions E'\n  (ad, al) \\<in> action_loc P E' wa'\n\ngoal (1 subgoal):\n 1. \\<not> r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "from most_recent_write_recent[OF mrw'' _ this] nth_r'"], ["proof (chain)\npicking this:\n  (ad, al) \\<in> action_loc P E' r \\<Longrightarrow>\n  E' \\<turnstile> wa' \\<le>a w' \\<or> E' \\<turnstile> r \\<le>a wa'\n  lnth E' r = (t, NormalAction (ReadMem ad al v))", "have \"E' \\<turnstile> wa' \\<le>a w' \\<or> E' \\<turnstile> r \\<le>a wa'\""], ["proof (prove)\nusing this:\n  (ad, al) \\<in> action_loc P E' r \\<Longrightarrow>\n  E' \\<turnstile> wa' \\<le>a w' \\<or> E' \\<turnstile> r \\<le>a wa'\n  lnth E' r = (t, NormalAction (ReadMem ad al v))\n\ngoal (1 subgoal):\n 1. E' \\<turnstile> wa' \\<le>a w' \\<or> E' \\<turnstile> r \\<le>a wa'", "by(simp add: action_obs_def)"], ["proof (state)\nthis:\n  E' \\<turnstile> wa' \\<le>a w' \\<or> E' \\<turnstile> r \\<le>a wa'\n\ngoal (1 subgoal):\n 1. \\<not> r \\<le> wa' \\<Longrightarrow>\n    E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "thus ?thesis"], ["proof (prove)\nusing this:\n  E' \\<turnstile> wa' \\<le>a w' \\<or> E' \\<turnstile> r \\<le>a wa'\n\ngoal (1 subgoal):\n 1. E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "using \\<open>wa' < r\\<close> w'"], ["proof (prove)\nusing this:\n  E' \\<turnstile> wa' \\<le>a w' \\<or> E' \\<turnstile> r \\<le>a wa'\n  wa' < r\n  w' < r\n\ngoal (1 subgoal):\n 1. E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'", "by(auto 4 3 del: disjCI intro: disjI1 disjI2 action_order_change_prefix[OF _ sim])"], ["proof (state)\nthis:\n  E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E \\<turnstile> wa' \\<le>a w' \\<or> E \\<turnstile> r \\<le>a wa'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,E \\<turnstile> r \\<leadsto>mrw w'\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "with w'"], ["proof (chain)\npicking this:\n  w' < r\n  P,E \\<turnstile> r \\<leadsto>mrw w'", "show ?thesis"], ["proof (prove)\nusing this:\n  w' < r\n  P,E \\<turnstile> r \\<leadsto>mrw w'\n\ngoal (1 subgoal):\n 1. \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. P,E \\<turnstile> r \\<leadsto>mrw i \\<and> i < r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ta_seq_consist_mrw_before:\n  assumes sc: \"ta_seq_consist P Map.empty (lmap snd E)\"\n  and new_actions_for_fun: \"\\<And>adal a a'. \\<lbrakk> a \\<in> new_actions_for P E adal; a' \\<in> new_actions_for P E adal \\<rbrakk> \\<Longrightarrow> a = a'\"\n  and mrw: \"P,E \\<turnstile> r \\<leadsto>mrw w\"\n  shows \"w < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w < r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w < r", "from mrw"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> r \\<leadsto>mrw w", "have \"r \\<in> read_actions E\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> r \\<leadsto>mrw w\n\ngoal (1 subgoal):\n 1. r \\<in> read_actions E", "by cases"], ["proof (state)\nthis:\n  r \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. w < r", "with sc new_actions_for_fun"], ["proof (chain)\npicking this:\n  ta_seq_consist P Map.empty (lmap snd E)\n  \\<lbrakk>?a \\<in> new_actions_for P E ?adal;\n   ?a' \\<in> new_actions_for P E ?adal\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  r \\<in> read_actions E", "obtain w' where \"P,E \\<turnstile> r \\<leadsto>mrw w'\" \"w' < r\""], ["proof (prove)\nusing this:\n  ta_seq_consist P Map.empty (lmap snd E)\n  \\<lbrakk>?a \\<in> new_actions_for P E ?adal;\n   ?a' \\<in> new_actions_for P E ?adal\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  r \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        \\<lbrakk>P,E \\<turnstile> r \\<leadsto>mrw w'; w' < r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: ta_seq_consist_most_recent_write_for)"], ["proof (state)\nthis:\n  P,E \\<turnstile> r \\<leadsto>mrw w'\n  w' < r\n\ngoal (1 subgoal):\n 1. w < r", "with mrw"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> r \\<leadsto>mrw w\n  P,E \\<turnstile> r \\<leadsto>mrw w'\n  w' < r", "show ?thesis"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> r \\<leadsto>mrw w\n  P,E \\<turnstile> r \\<leadsto>mrw w'\n  w' < r\n\ngoal (1 subgoal):\n 1. w < r", "by(auto dest: most_recent_write_for_fun)"], ["proof (state)\nthis:\n  w < r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ta_seq_consist_imp_sequentially_consistent:\n  assumes tsa_ok: \"thread_start_actions_ok E\"\n  and new_actions_for_fun: \"\\<And>adal a a'. \\<lbrakk> a \\<in> new_actions_for P E adal; a' \\<in> new_actions_for P E adal \\<rbrakk> \\<Longrightarrow> a = a'\"\n  and seq: \"ta_seq_consist P Map.empty (lmap snd E)\"\n  shows \"\\<exists>ws. sequentially_consistent P (E, ws) \\<and> P \\<turnstile> (E, ws) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ws.\n       sequentially_consistent P (E, ws) \\<and>\n       P \\<turnstile> (E, ws) \\<surd>", "proof(intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. sequentially_consistent P (E, ?ws)\n 2. P \\<turnstile> (E, ?ws) \\<surd>", "define ws where \"ws i = (THE w. P,E \\<turnstile> i \\<leadsto>mrw w)\" for i"], ["proof (state)\nthis:\n  ws ?i = (THE w. P,E \\<turnstile> ?i \\<leadsto>mrw w)\n\ngoal (2 subgoals):\n 1. sequentially_consistent P (E, ?ws)\n 2. P \\<turnstile> (E, ?ws) \\<surd>", "from seq"], ["proof (chain)\npicking this:\n  ta_seq_consist P Map.empty (lmap snd E)", "have ns: \"non_speculative P (\\<lambda>_. {}) (lmap snd E)\""], ["proof (prove)\nusing this:\n  ta_seq_consist P Map.empty (lmap snd E)\n\ngoal (1 subgoal):\n 1. non_speculative P (\\<lambda>_. {}) (lmap snd E)", "by(rule ta_seq_consist_into_non_speculative) simp"], ["proof (state)\nthis:\n  non_speculative P (\\<lambda>_. {}) (lmap snd E)\n\ngoal (2 subgoals):\n 1. sequentially_consistent P (E, ?ws)\n 2. P \\<turnstile> (E, ?ws) \\<surd>", "show \"sequentially_consistent P (E, ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequentially_consistent P (E, ws)", "unfolding ws_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sequentially_consistent P\n     (E, \\<lambda>i. The (most_recent_write_for P E i))", "proof(rule sequentially_consistentI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> read_actions E \\<Longrightarrow>\n       P,E \\<turnstile> r \\<leadsto>mrw The (most_recent_write_for P E r)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> read_actions E \\<Longrightarrow>\n       P,E \\<turnstile> r \\<leadsto>mrw The (most_recent_write_for P E r)", "assume \"r \\<in> read_actions E\""], ["proof (state)\nthis:\n  r \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> read_actions E \\<Longrightarrow>\n       P,E \\<turnstile> r \\<leadsto>mrw The (most_recent_write_for P E r)", "with seq new_actions_for_fun"], ["proof (chain)\npicking this:\n  ta_seq_consist P Map.empty (lmap snd E)\n  \\<lbrakk>?a \\<in> new_actions_for P E ?adal;\n   ?a' \\<in> new_actions_for P E ?adal\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  r \\<in> read_actions E", "obtain w where \"P,E \\<turnstile> r \\<leadsto>mrw w\""], ["proof (prove)\nusing this:\n  ta_seq_consist P Map.empty (lmap snd E)\n  \\<lbrakk>?a \\<in> new_actions_for P E ?adal;\n   ?a' \\<in> new_actions_for P E ?adal\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  r \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        P,E \\<turnstile> r \\<leadsto>mrw w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: ta_seq_consist_most_recent_write_for)"], ["proof (state)\nthis:\n  P,E \\<turnstile> r \\<leadsto>mrw w\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> read_actions E \\<Longrightarrow>\n       P,E \\<turnstile> r \\<leadsto>mrw The (most_recent_write_for P E r)", "thus \"P,E \\<turnstile> r \\<leadsto>mrw THE w. P,E \\<turnstile> r \\<leadsto>mrw w\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> r \\<leadsto>mrw w\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> r \\<leadsto>mrw THE w.\n  P,E \\<turnstile> r \\<leadsto>mrw w", "by(simp add: THE_most_recent_writeI)"], ["proof (state)\nthis:\n  P,E \\<turnstile> r \\<leadsto>mrw THE w. P,E \\<turnstile> r \\<leadsto>mrw w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sequentially_consistent P (E, ws)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (E, \\<lambda>i.\n                          The (most_recent_write_for P E i)) \\<surd>", "show \"P \\<turnstile> (E, ws) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (E, ws) \\<surd>", "proof(rule wf_execI)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_write_seen P E ws\n 2. thread_start_actions_ok E", "show \"is_write_seen P E ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_write_seen P E ws", "proof(rule is_write_seenI)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> ws a \\<in> write_actions E\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> (ad, al) \\<in> action_loc P E (ws a)\n 3. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 4. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>hb ws a\n 5. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 6. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 7. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "fix a ad al v"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> ws a \\<in> write_actions E\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> (ad, al) \\<in> action_loc P E (ws a)\n 3. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 4. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>hb ws a\n 5. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 6. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 7. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "assume a: \"a \\<in> read_actions E\"\n        and adal: \"action_obs E a = NormalAction (ReadMem ad al v)\""], ["proof (state)\nthis:\n  a \\<in> read_actions E\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (7 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> ws a \\<in> write_actions E\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> (ad, al) \\<in> action_loc P E (ws a)\n 3. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 4. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>hb ws a\n 5. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 6. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 7. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "from ns"], ["proof (chain)\npicking this:\n  non_speculative P (\\<lambda>_. {}) (lmap snd E)", "have seq': \"non_speculative P (\\<lambda>_. {}) (ltake (enat a) (lmap snd E))\""], ["proof (prove)\nusing this:\n  non_speculative P (\\<lambda>_. {}) (lmap snd E)\n\ngoal (1 subgoal):\n 1. non_speculative P (\\<lambda>_. {}) (ltake (enat a) (lmap snd E))", "by(rule non_speculative_ltake)"], ["proof (state)\nthis:\n  non_speculative P (\\<lambda>_. {}) (ltake (enat a) (lmap snd E))\n\ngoal (7 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> ws a \\<in> write_actions E\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> (ad, al) \\<in> action_loc P E (ws a)\n 3. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 4. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>hb ws a\n 5. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 6. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 7. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "from seq a seq new_actions_for_fun"], ["proof (chain)\npicking this:\n  ta_seq_consist P Map.empty (lmap snd E)\n  a \\<in> read_actions E\n  ta_seq_consist P Map.empty (lmap snd E)\n  \\<lbrakk>?a \\<in> new_actions_for P E ?adal;\n   ?a' \\<in> new_actions_for P E ?adal\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'", "obtain w where mrw: \"P,E \\<turnstile> a \\<leadsto>mrw w\" \n        and \"w < a\""], ["proof (prove)\nusing this:\n  ta_seq_consist P Map.empty (lmap snd E)\n  a \\<in> read_actions E\n  ta_seq_consist P Map.empty (lmap snd E)\n  \\<lbrakk>?a \\<in> new_actions_for P E ?adal;\n   ?a' \\<in> new_actions_for P E ?adal\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>P,E \\<turnstile> a \\<leadsto>mrw w; w < a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: ta_seq_consist_most_recent_write_for)"], ["proof (state)\nthis:\n  P,E \\<turnstile> a \\<leadsto>mrw w\n  w < a\n\ngoal (7 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> ws a \\<in> write_actions E\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> (ad, al) \\<in> action_loc P E (ws a)\n 3. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 4. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>hb ws a\n 5. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 6. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 7. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence w: \"ws a = w\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> a \\<leadsto>mrw w\n  w < a\n\ngoal (1 subgoal):\n 1. ws a = w", "by(simp add: ws_def THE_most_recent_writeI)"], ["proof (state)\nthis:\n  ws a = w\n\ngoal (7 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> ws a \\<in> write_actions E\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> (ad, al) \\<in> action_loc P E (ws a)\n 3. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 4. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>hb ws a\n 5. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 6. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 7. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "with mrw adal"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> a \\<leadsto>mrw w\n  action_obs E a = NormalAction (ReadMem ad al v)\n  ws a = w", "show \"ws a \\<in> write_actions E\"\n        and \"(ad, al) \\<in> action_loc P E (ws a)\"\n        and \"\\<not> P,E \\<turnstile> a \\<le>hb ws a\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> a \\<leadsto>mrw w\n  action_obs E a = NormalAction (ReadMem ad al v)\n  ws a = w\n\ngoal (1 subgoal):\n 1. ws a \\<in> write_actions E &&&\n    (ad, al) \\<in> action_loc P E (ws a) &&&\n    \\<not> P,E \\<turnstile> a \\<le>hb ws a", "by(fastforce elim!: most_recent_write_for.cases dest: happens_before_into_action_order antisymPD[OF antisym_action_order] read_actions_not_write_actions)+"], ["proof (state)\nthis:\n  ws a \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws a)\n  \\<not> P,E \\<turnstile> a \\<le>hb ws a\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "let ?between = \"ltake (enat (a - Suc w)) (ldropn (Suc w) E)\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "let ?prefix = \"ltake (enat w) E\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "let ?vs_prefix = \"mrw_values P Map.empty (map snd (list_of ?prefix))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "fix v'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "assume new: \"is_new_action (action_obs E w)\"\n          and vs': \"?vs_prefix (ad, al) = \\<lfloor>(v', True)\\<rfloor>\""], ["proof (state)\nthis:\n  is_new_action (action_obs E w)\n  mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))) (ad, al) =\n  \\<lfloor>(v', True)\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "from mrw_values_eq_SomeD[OF vs']"], ["proof (chain)\npicking this:\n  (None = \\<lfloor>(v', True)\\<rfloor> \\<Longrightarrow>\n   \\<exists>wa.\n      wa \\<in> set (map snd (list_of (ltake (enat w) E))) \\<and>\n      is_write_action wa \\<and>\n      (ad, al) \\<in> action_loc_aux P wa \\<and>\n      (True \\<longrightarrow> \\<not> is_new_action wa)) \\<Longrightarrow>\n  \\<exists>obs' wa obs''.\n     map snd (list_of (ltake (enat w) E)) = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v' \\<and>\n     is_new_action wa = (\\<not> True) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> True)", "obtain obs' wa obs'' where split: \"map snd (list_of ?prefix) = obs' @ wa # obs''\"\n          and wa: \"is_write_action wa\"\n          and adal': \"(ad, al) \\<in> action_loc_aux P wa\"\n          and new_wa: \"\\<not> is_new_action wa\""], ["proof (prove)\nusing this:\n  (None = \\<lfloor>(v', True)\\<rfloor> \\<Longrightarrow>\n   \\<exists>wa.\n      wa \\<in> set (map snd (list_of (ltake (enat w) E))) \\<and>\n      is_write_action wa \\<and>\n      (ad, al) \\<in> action_loc_aux P wa \\<and>\n      (True \\<longrightarrow> \\<not> is_new_action wa)) \\<Longrightarrow>\n  \\<exists>obs' wa obs''.\n     map snd (list_of (ltake (enat w) E)) = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v' \\<and>\n     is_new_action wa = (\\<not> True) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> True)\n\ngoal (1 subgoal):\n 1. (\\<And>obs' wa obs''.\n        \\<lbrakk>map snd (list_of (ltake (enat w) E)) = obs' @ wa # obs'';\n         is_write_action wa; (ad, al) \\<in> action_loc_aux P wa;\n         \\<not> is_new_action wa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map snd (list_of (ltake (enat w) E)) = obs' @ wa # obs''\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "from split"], ["proof (chain)\npicking this:\n  map snd (list_of (ltake (enat w) E)) = obs' @ wa # obs''", "have \"length (map snd (list_of ?prefix)) = Suc (length obs' + length obs'')\""], ["proof (prove)\nusing this:\n  map snd (list_of (ltake (enat w) E)) = obs' @ wa # obs''\n\ngoal (1 subgoal):\n 1. length (map snd (list_of (ltake (enat w) E))) =\n    Suc (length obs' + length obs'')", "by simp"], ["proof (state)\nthis:\n  length (map snd (list_of (ltake (enat w) E))) =\n  Suc (length obs' + length obs'')\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence len_prefix: \"llength ?prefix = enat \\<dots>\""], ["proof (prove)\nusing this:\n  length (map snd (list_of (ltake (enat w) E))) =\n  Suc (length obs' + length obs'')\n\ngoal (1 subgoal):\n 1. llength (ltake (enat w) E) = enat (Suc (length obs' + length obs''))", "by(simp add: length_list_of_conv_the_enat min_enat1_conv_enat)"], ["proof (state)\nthis:\n  llength (ltake (enat w) E) = enat (Suc (length obs' + length obs''))\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "with split"], ["proof (chain)\npicking this:\n  map snd (list_of (ltake (enat w) E)) = obs' @ wa # obs''\n  llength (ltake (enat w) E) = enat (Suc (length obs' + length obs''))", "have \"nth (map snd (list_of ?prefix)) (length obs') = wa\"\n          and \"enat (length obs') < llength ?prefix\""], ["proof (prove)\nusing this:\n  map snd (list_of (ltake (enat w) E)) = obs' @ wa # obs''\n  llength (ltake (enat w) E) = enat (Suc (length obs' + length obs''))\n\ngoal (1 subgoal):\n 1. map snd (list_of (ltake (enat w) E)) ! length obs' = wa &&&\n    enat (length obs') < llength (ltake (enat w) E)", "by simp_all"], ["proof (state)\nthis:\n  map snd (list_of (ltake (enat w) E)) ! length obs' = wa\n  enat (length obs') < llength (ltake (enat w) E)\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence \"snd (lnth ?prefix (length obs')) = wa\""], ["proof (prove)\nusing this:\n  map snd (list_of (ltake (enat w) E)) ! length obs' = wa\n  enat (length obs') < llength (ltake (enat w) E)\n\ngoal (1 subgoal):\n 1. snd (lnth (ltake (enat w) E) (length obs')) = wa", "by(simp add: list_of_lmap[symmetric] del: list_of_lmap)"], ["proof (state)\nthis:\n  snd (lnth (ltake (enat w) E) (length obs')) = wa\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence wa': \"action_obs E (length obs') = wa\" and \"enat (length obs') < llength E\""], ["proof (prove)\nusing this:\n  snd (lnth (ltake (enat w) E) (length obs')) = wa\n\ngoal (1 subgoal):\n 1. action_obs E (length obs') = wa &&& enat (length obs') < llength E", "using \\<open>enat (length obs') < llength ?prefix\\<close>"], ["proof (prove)\nusing this:\n  snd (lnth (ltake (enat w) E) (length obs')) = wa\n  enat (length obs') < llength (ltake (enat w) E)\n\ngoal (1 subgoal):\n 1. action_obs E (length obs') = wa &&& enat (length obs') < llength E", "by(auto simp add: action_obs_def lnth_ltake)"], ["proof (state)\nthis:\n  action_obs E (length obs') = wa\n  enat (length obs') < llength E\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "with wa"], ["proof (chain)\npicking this:\n  is_write_action wa\n  action_obs E (length obs') = wa\n  enat (length obs') < llength E", "have \"length obs' \\<in> write_actions E\""], ["proof (prove)\nusing this:\n  is_write_action wa\n  action_obs E (length obs') = wa\n  enat (length obs') < llength E\n\ngoal (1 subgoal):\n 1. length obs' \\<in> write_actions E", "by(auto intro: write_actions.intros simp add: actions_def)"], ["proof (state)\nthis:\n  length obs' \\<in> write_actions E\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "from most_recent_write_recent[OF mrw _ this, of \"(ad, al)\"] adal adal' wa'"], ["proof (chain)\npicking this:\n  \\<lbrakk>(ad, al) \\<in> action_loc P E a;\n   (ad, al) \\<in> action_loc P E (length obs')\\<rbrakk>\n  \\<Longrightarrow> E \\<turnstile> length obs' \\<le>a w \\<or>\n                    E \\<turnstile> a \\<le>a length obs'\n  action_obs E a = NormalAction (ReadMem ad al v)\n  (ad, al) \\<in> action_loc_aux P wa\n  action_obs E (length obs') = wa", "have \"E \\<turnstile> length obs' \\<le>a w \\<or> E \\<turnstile> a \\<le>a length obs'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(ad, al) \\<in> action_loc P E a;\n   (ad, al) \\<in> action_loc P E (length obs')\\<rbrakk>\n  \\<Longrightarrow> E \\<turnstile> length obs' \\<le>a w \\<or>\n                    E \\<turnstile> a \\<le>a length obs'\n  action_obs E a = NormalAction (ReadMem ad al v)\n  (ad, al) \\<in> action_loc_aux P wa\n  action_obs E (length obs') = wa\n\ngoal (1 subgoal):\n 1. E \\<turnstile> length obs' \\<le>a w \\<or>\n    E \\<turnstile> a \\<le>a length obs'", "by simp"], ["proof (state)\nthis:\n  E \\<turnstile> length obs' \\<le>a w \\<or>\n  E \\<turnstile> a \\<le>a length obs'\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence False"], ["proof (prove)\nusing this:\n  E \\<turnstile> length obs' \\<le>a w \\<or>\n  E \\<turnstile> a \\<le>a length obs'\n\ngoal (1 subgoal):\n 1. False", "using new_wa new wa' adal len_prefix \\<open>w < a\\<close>"], ["proof (prove)\nusing this:\n  E \\<turnstile> length obs' \\<le>a w \\<or>\n  E \\<turnstile> a \\<le>a length obs'\n  \\<not> is_new_action wa\n  is_new_action (action_obs E w)\n  action_obs E (length obs') = wa\n  action_obs E a = NormalAction (ReadMem ad al v)\n  llength (ltake (enat w) E) = enat (Suc (length obs' + length obs''))\n  w < a\n\ngoal (1 subgoal):\n 1. False", "by(auto elim!: action_orderE simp add: min_enat1_conv_enat split: enat.split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_new_action (action_obs E w);\n   mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))) (ad, al) =\n   \\<lfloor>(?v'2, True)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence mrw_value_w: \"mrw_value P ?vs_prefix (snd (lnth E w)) (ad, al) =\n                          \\<lfloor>(value_written P E w (ad, al), \\<not> is_new_action (action_obs E w))\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_new_action (action_obs E w);\n   mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))) (ad, al) =\n   \\<lfloor>(?v'2, True)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "using \\<open>ws a \\<in> write_actions E\\<close> \\<open>(ad, al) \\<in> action_loc P E (ws a)\\<close> w"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_new_action (action_obs E w);\n   mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))) (ad, al) =\n   \\<lfloor>(?v'2, True)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> False\n  ws a \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws a)\n  ws a = w\n\ngoal (1 subgoal):\n 1. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "by(cases \"snd (lnth E w)\" rule: mrw_value_cases)(fastforce elim: write_actions.cases simp add: value_written_def action_obs_def)+"], ["proof (state)\nthis:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n   (snd (lnth E w)) (ad, al) =\n  \\<lfloor>(value_written P E w (ad, al),\n            \\<not> is_new_action (action_obs E w))\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "have \"mrw_values P (mrw_value P ?vs_prefix (snd (lnth E w))) (list_of (lmap snd ?between)) (ad, al) = \\<lfloor>(value_written P E w (ad, al), \\<not> is_new_action (action_obs E w))\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P\n     (mrw_value P\n       (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n       (snd (lnth E w)))\n     (list_of (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n     (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "proof(subst mrw_values_no_write_unchanged)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "fix wa"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "assume \"wa \\<in> set (list_of (lmap snd ?between))\"\n          and write_wa: \"is_write_action wa\"\n          and adal_wa: \"(ad, al) \\<in> action_loc_aux P wa\""], ["proof (state)\nthis:\n  wa \\<in> set (list_of\n                 (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "hence wa: \"wa \\<in> lset (lmap snd ?between)\""], ["proof (prove)\nusing this:\n  wa \\<in> set (list_of\n                 (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n\ngoal (1 subgoal):\n 1. wa \\<in> lset (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))", "by simp"], ["proof (state)\nthis:\n  wa \\<in> lset (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "from wa"], ["proof (chain)\npicking this:\n  wa \\<in> lset (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))", "obtain i_wa where \"wa = lnth (lmap snd ?between) i_wa\"\n          and i_wa: \"enat i_wa < llength (lmap snd ?between)\""], ["proof (prove)\nusing this:\n  wa \\<in> lset (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n\ngoal (1 subgoal):\n 1. (\\<And>i_wa.\n        \\<lbrakk>wa =\n                 lnth\n                  (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n                  i_wa;\n         enat i_wa\n         < llength\n            (lmap snd\n              (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lset_conv_lnth"], ["proof (prove)\nusing this:\n  wa \\<in> {lnth (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n             n |\n            n. enat n\n               < llength\n                  (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))}\n\ngoal (1 subgoal):\n 1. (\\<And>i_wa.\n        \\<lbrakk>wa =\n                 lnth\n                  (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n                  i_wa;\n         enat i_wa\n         < llength\n            (lmap snd\n              (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  wa = lnth (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))) i_wa\n  enat i_wa\n  < llength (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  wa = lnth (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))) i_wa\n  enat i_wa\n  < llength (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "hence i_wa_len: \"enat (Suc (w + i_wa)) < llength E\""], ["proof (prove)\nusing this:\n  wa = lnth (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))) i_wa\n  enat i_wa\n  < llength (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n\ngoal (1 subgoal):\n 1. enat (Suc (w + i_wa)) < llength E", "by(cases \"llength E\") auto"], ["proof (state)\nthis:\n  enat (Suc (w + i_wa)) < llength E\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  wa = lnth (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))) i_wa\n  enat i_wa\n  < llength (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n  enat (Suc (w + i_wa)) < llength E", "have wa': \"wa = action_obs E (Suc (w + i_wa))\""], ["proof (prove)\nusing this:\n  wa = lnth (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))) i_wa\n  enat i_wa\n  < llength (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n  enat (Suc (w + i_wa)) < llength E\n\ngoal (1 subgoal):\n 1. wa = action_obs E (Suc (w + i_wa))", "by(simp_all add: lnth_ltake action_obs_def ac_simps)"], ["proof (state)\nthis:\n  wa = action_obs E (Suc (w + i_wa))\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "with write_wa i_wa_len"], ["proof (chain)\npicking this:\n  is_write_action wa\n  enat (Suc (w + i_wa)) < llength E\n  wa = action_obs E (Suc (w + i_wa))", "have \"Suc (w + i_wa) \\<in> write_actions E\""], ["proof (prove)\nusing this:\n  is_write_action wa\n  enat (Suc (w + i_wa)) < llength E\n  wa = action_obs E (Suc (w + i_wa))\n\ngoal (1 subgoal):\n 1. Suc (w + i_wa) \\<in> write_actions E", "by(auto intro: write_actions.intros simp add: actions_def)"], ["proof (state)\nthis:\n  Suc (w + i_wa) \\<in> write_actions E\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "from most_recent_write_recent[OF mrw _ this, of \"(ad, al)\"] adal adal_wa wa'"], ["proof (chain)\npicking this:\n  \\<lbrakk>(ad, al) \\<in> action_loc P E a;\n   (ad, al) \\<in> action_loc P E (Suc (w + i_wa))\\<rbrakk>\n  \\<Longrightarrow> E \\<turnstile> Suc (w + i_wa) \\<le>a w \\<or>\n                    E \\<turnstile> a \\<le>a Suc (w + i_wa)\n  action_obs E a = NormalAction (ReadMem ad al v)\n  (ad, al) \\<in> action_loc_aux P wa\n  wa = action_obs E (Suc (w + i_wa))", "have \"E \\<turnstile> Suc (w + i_wa) \\<le>a w \\<or> E \\<turnstile> a \\<le>a Suc (w + i_wa)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(ad, al) \\<in> action_loc P E a;\n   (ad, al) \\<in> action_loc P E (Suc (w + i_wa))\\<rbrakk>\n  \\<Longrightarrow> E \\<turnstile> Suc (w + i_wa) \\<le>a w \\<or>\n                    E \\<turnstile> a \\<le>a Suc (w + i_wa)\n  action_obs E a = NormalAction (ReadMem ad al v)\n  (ad, al) \\<in> action_loc_aux P wa\n  wa = action_obs E (Suc (w + i_wa))\n\ngoal (1 subgoal):\n 1. E \\<turnstile> Suc (w + i_wa) \\<le>a w \\<or>\n    E \\<turnstile> a \\<le>a Suc (w + i_wa)", "by(simp)"], ["proof (state)\nthis:\n  E \\<turnstile> Suc (w + i_wa) \\<le>a w \\<or>\n  E \\<turnstile> a \\<le>a Suc (w + i_wa)\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "hence \"is_new_action wa \\<and> \\<not> is_new_action (action_obs E w)\""], ["proof (prove)\nusing this:\n  E \\<turnstile> Suc (w + i_wa) \\<le>a w \\<or>\n  E \\<turnstile> a \\<le>a Suc (w + i_wa)\n\ngoal (1 subgoal):\n 1. is_new_action wa \\<and> \\<not> is_new_action (action_obs E w)", "using adal i_wa wa'"], ["proof (prove)\nusing this:\n  E \\<turnstile> Suc (w + i_wa) \\<le>a w \\<or>\n  E \\<turnstile> a \\<le>a Suc (w + i_wa)\n  action_obs E a = NormalAction (ReadMem ad al v)\n  enat i_wa\n  < llength (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))\n  wa = action_obs E (Suc (w + i_wa))\n\ngoal (1 subgoal):\n 1. is_new_action wa \\<and> \\<not> is_new_action (action_obs E w)", "by(auto elim: action_orderE)"], ["proof (state)\nthis:\n  is_new_action wa \\<and> \\<not> is_new_action (action_obs E w)\n\ngoal (2 subgoals):\n 1. \\<And>wa.\n       \\<lbrakk>wa \\<in> set (list_of\n                               (lmap snd\n                                 (ltake (enat (a - Suc w))\n                                   (ldropn (Suc w) E))));\n        is_write_action wa; (ad, al) \\<in> action_loc_aux P wa\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd (list_of (ltake (enat w) E))))\n                               (snd (lnth E w)) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action wa\n 2. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "thus \"case (mrw_value P ?vs_prefix (snd (lnth E w)) (ad, al)) of None \\<Rightarrow> False | Some (v, b) \\<Rightarrow> b \\<and> is_new_action wa\""], ["proof (prove)\nusing this:\n  is_new_action wa \\<and> \\<not> is_new_action (action_obs E w)\n\ngoal (1 subgoal):\n 1. case mrw_value P\n          (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n          (snd (lnth E w)) (ad, al) of\n    None \\<Rightarrow> False\n    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action wa", "unfolding mrw_value_w"], ["proof (prove)\nusing this:\n  is_new_action wa \\<and> \\<not> is_new_action (action_obs E w)\n\ngoal (1 subgoal):\n 1. case \\<lfloor>(value_written P E w (ad, al),\n                   \\<not> is_new_action (action_obs E w))\\<rfloor> of\n    None \\<Rightarrow> False\n    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action wa", "by simp"], ["proof (state)\nthis:\n  case mrw_value P\n        (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n        (snd (lnth E w)) (ad, al) of\n  None \\<Rightarrow> False\n  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action wa\n\ngoal (1 subgoal):\n 1. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)) (ad, al) =\n    \\<lfloor>(value_written P E w (ad, al),\n              \\<not> is_new_action (action_obs E w))\\<rfloor>", "qed(simp add: mrw_value_w)"], ["proof (state)\nthis:\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)))\n   (list_of (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (ad, al) =\n  \\<lfloor>(value_written P E w (ad, al),\n            \\<not> is_new_action (action_obs E w))\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "moreover"], ["proof (state)\nthis:\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)))\n   (list_of (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (ad, al) =\n  \\<lfloor>(value_written P E w (ad, al),\n            \\<not> is_new_action (action_obs E w))\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "from a"], ["proof (chain)\npicking this:\n  a \\<in> read_actions E", "have \"a \\<in> actions E\""], ["proof (prove)\nusing this:\n  a \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. a \\<in> actions E", "by simp"], ["proof (state)\nthis:\n  a \\<in> actions E\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence \"enat a < llength E\""], ["proof (prove)\nusing this:\n  a \\<in> actions E\n\ngoal (1 subgoal):\n 1. enat a < llength E", "by(rule actionsE)"], ["proof (state)\nthis:\n  enat a < llength E\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "with \\<open>w < a\\<close>"], ["proof (chain)\npicking this:\n  w < a\n  enat a < llength E", "have \"enat (a - Suc w) < llength E - enat (Suc w)\""], ["proof (prove)\nusing this:\n  w < a\n  enat a < llength E\n\ngoal (1 subgoal):\n 1. enat (a - Suc w) < llength E - enat (Suc w)", "by(cases \"llength E\") simp_all"], ["proof (state)\nthis:\n  enat (a - Suc w) < llength E - enat (Suc w)\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence \"E = lappend (lappend ?prefix (LCons (lnth E w) ?between)) (LCons (lnth (ldropn (Suc w) E) (a - Suc w)) (ldropn (Suc (a - Suc w)) (ldropn (Suc w) E)))\""], ["proof (prove)\nusing this:\n  enat (a - Suc w) < llength E - enat (Suc w)\n\ngoal (1 subgoal):\n 1. E =\n    lappend\n     (lappend (ltake (enat w) E)\n       (LCons (lnth E w) (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n     (LCons (lnth (ldropn (Suc w) E) (a - Suc w))\n       (ldropn (Suc (a - Suc w)) (ldropn (Suc w) E)))", "using \\<open>w < a\\<close> \\<open>enat a < llength E\\<close>"], ["proof (prove)\nusing this:\n  enat (a - Suc w) < llength E - enat (Suc w)\n  w < a\n  enat a < llength E\n\ngoal (1 subgoal):\n 1. E =\n    lappend\n     (lappend (ltake (enat w) E)\n       (LCons (lnth E w) (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n     (LCons (lnth (ldropn (Suc w) E) (a - Suc w))\n       (ldropn (Suc (a - Suc w)) (ldropn (Suc w) E)))", "unfolding lappend_assoc lappend_code"], ["proof (prove)\nusing this:\n  enat (a - Suc w) < llength E - enat (Suc w)\n  w < a\n  enat a < llength E\n\ngoal (1 subgoal):\n 1. E =\n    lappend (ltake (enat w) E)\n     (LCons (lnth E w)\n       (lappend (ltake (enat (a - Suc w)) (ldropn (Suc w) E))\n         (LCons (lnth (ldropn (Suc w) E) (a - Suc w))\n           (ldropn (Suc (a - Suc w)) (ldropn (Suc w) E)))))", "apply(subst ldropn_Suc_conv_ldropn, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat (a - Suc w) < llength E - enat (Suc w); w < a;\n     enat a < llength E\\<rbrakk>\n    \\<Longrightarrow> E =\n                      lappend (ltake (enat w) E)\n                       (LCons (lnth E w)\n                         (lappend\n                           (ltake (enat (a - Suc w)) (ldropn (Suc w) E))\n                           (ldropn (a - Suc w) (ldropn (Suc w) E))))", "apply(subst lappend_ltake_enat_ldropn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat (a - Suc w) < llength E - enat (Suc w); w < a;\n     enat a < llength E\\<rbrakk>\n    \\<Longrightarrow> E =\n                      lappend (ltake (enat w) E)\n                       (LCons (lnth E w) (ldropn (Suc w) E))", "apply(subst ldropn_Suc_conv_ldropn, simp add: less_trans[where y=\"enat a\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat (a - Suc w) < llength E - enat (Suc w); w < a;\n     enat a < llength E\\<rbrakk>\n    \\<Longrightarrow> E = lappend (ltake (enat w) E) (ldropn w E)", "by simp"], ["proof (state)\nthis:\n  E =\n  lappend\n   (lappend (ltake (enat w) E)\n     (LCons (lnth E w) (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (LCons (lnth (ldropn (Suc w) E) (a - Suc w))\n     (ldropn (Suc (a - Suc w)) (ldropn (Suc w) E)))\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "hence E': \"E = lappend (lappend ?prefix (LCons (lnth E w) ?between)) (LCons (lnth E a) (ldropn (Suc a) E))\""], ["proof (prove)\nusing this:\n  E =\n  lappend\n   (lappend (ltake (enat w) E)\n     (LCons (lnth E w) (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (LCons (lnth (ldropn (Suc w) E) (a - Suc w))\n     (ldropn (Suc (a - Suc w)) (ldropn (Suc w) E)))\n\ngoal (1 subgoal):\n 1. E =\n    lappend\n     (lappend (ltake (enat w) E)\n       (LCons (lnth E w) (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n     (LCons (lnth E a) (ldropn (Suc a) E))", "using \\<open>w < a\\<close> \\<open>enat a < llength E\\<close>"], ["proof (prove)\nusing this:\n  E =\n  lappend\n   (lappend (ltake (enat w) E)\n     (LCons (lnth E w) (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (LCons (lnth (ldropn (Suc w) E) (a - Suc w))\n     (ldropn (Suc (a - Suc w)) (ldropn (Suc w) E)))\n  w < a\n  enat a < llength E\n\ngoal (1 subgoal):\n 1. E =\n    lappend\n     (lappend (ltake (enat w) E)\n       (LCons (lnth E w) (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n     (LCons (lnth E a) (ldropn (Suc a) E))", "by simp"], ["proof (state)\nthis:\n  E =\n  lappend\n   (lappend (ltake (enat w) E)\n     (LCons (lnth E w) (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (LCons (lnth E a) (ldropn (Suc a) E))\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "from seq"], ["proof (chain)\npicking this:\n  ta_seq_consist P Map.empty (lmap snd E)", "have \"ta_seq_consist P (mrw_values P Map.empty (list_of (lappend (lmap snd ?prefix) (LCons (snd (lnth E w)) (lmap snd ?between))))) (lmap snd (LCons (lnth E a) (ldropn (Suc a) E)))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P Map.empty (lmap snd E)\n\ngoal (1 subgoal):\n 1. ta_seq_consist P\n     (mrw_values P Map.empty\n       (list_of\n         (lappend (lmap snd (ltake (enat w) E))\n           (LCons (snd (lnth E w))\n             (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))))))\n     (lmap snd (LCons (lnth E a) (ldropn (Suc a) E)))", "by(subst (asm) E')(simp add: lmap_lappend_distrib ta_seq_consist_lappend)"], ["proof (state)\nthis:\n  ta_seq_consist P\n   (mrw_values P Map.empty\n     (list_of\n       (lappend (lmap snd (ltake (enat w) E))\n         (LCons (snd (lnth E w))\n           (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))))))\n   (lmap snd (LCons (lnth E a) (ldropn (Suc a) E)))\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> value_written P E (ws a) (ad, al) = v\n 2. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "ultimately"], ["proof (chain)\npicking this:\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)))\n   (list_of (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (ad, al) =\n  \\<lfloor>(value_written P E w (ad, al),\n            \\<not> is_new_action (action_obs E w))\\<rfloor>\n  ta_seq_consist P\n   (mrw_values P Map.empty\n     (list_of\n       (lappend (lmap snd (ltake (enat w) E))\n         (LCons (snd (lnth E w))\n           (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))))))\n   (lmap snd (LCons (lnth E a) (ldropn (Suc a) E)))", "show \"value_written P E (ws a) (ad, al) = v\""], ["proof (prove)\nusing this:\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)))\n   (list_of (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (ad, al) =\n  \\<lfloor>(value_written P E w (ad, al),\n            \\<not> is_new_action (action_obs E w))\\<rfloor>\n  ta_seq_consist P\n   (mrw_values P Map.empty\n     (list_of\n       (lappend (lmap snd (ltake (enat w) E))\n         (LCons (snd (lnth E w))\n           (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))))))\n   (lmap snd (LCons (lnth E a) (ldropn (Suc a) E)))\n\ngoal (1 subgoal):\n 1. value_written P E (ws a) (ad, al) = v", "using adal w"], ["proof (prove)\nusing this:\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat w) E))))\n     (snd (lnth E w)))\n   (list_of (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E))))\n   (ad, al) =\n  \\<lfloor>(value_written P E w (ad, al),\n            \\<not> is_new_action (action_obs E w))\\<rfloor>\n  ta_seq_consist P\n   (mrw_values P Map.empty\n     (list_of\n       (lappend (lmap snd (ltake (enat w) E))\n         (LCons (snd (lnth E w))\n           (lmap snd (ltake (enat (a - Suc w)) (ldropn (Suc w) E)))))))\n   (lmap snd (LCons (lnth E a) (ldropn (Suc a) E)))\n  action_obs E a = NormalAction (ReadMem ad al v)\n  ws a = w\n\ngoal (1 subgoal):\n 1. value_written P E (ws a) (ad, al) = v", "by(clarsimp simp add: action_obs_def list_of_lappend list_of_LCons)"], ["proof (state)\nthis:\n  value_written P E (ws a) (ad, al) = v\n\ngoal (3 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "(* assume \"is_volatile P al\" *)"], ["proof (state)\nthis:\n  value_written P E (ws a) (ad, al) = v\n\ngoal (3 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        is_volatile P al\\<rbrakk>\n       \\<Longrightarrow> \\<not> P,E \\<turnstile> a \\<le>so ws a\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "show \"\\<not> P,E \\<turnstile> a \\<le>so ws a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P,E \\<turnstile> a \\<le>so ws a", "using \\<open>w < a\\<close> w adal"], ["proof (prove)\nusing this:\n  w < a\n  ws a = w\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<not> P,E \\<turnstile> a \\<le>so ws a", "by(auto elim!: action_orderE sync_orderE)"], ["proof (state)\nthis:\n  \\<not> P,E \\<turnstile> a \\<le>so ws a\n\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "fix a'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "assume a': \"a' \\<in> write_actions E\" \"(ad, al) \\<in> action_loc P E a'\""], ["proof (state)\nthis:\n  a' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E a'\n\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "{"], ["proof (state)\nthis:\n  a' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E a'\n\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "presume \"E \\<turnstile> ws a \\<le>a a'\" \"E \\<turnstile> a' \\<le>a a\""], ["proof (state)\nthis:\n  E \\<turnstile> ws a \\<le>a a'\n  E \\<turnstile> a' \\<le>a a\n\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "with mrw adal a'"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> a \\<leadsto>mrw w\n  action_obs E a = NormalAction (ReadMem ad al v)\n  a' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E a'\n  E \\<turnstile> ws a \\<le>a a'\n  E \\<turnstile> a' \\<le>a a", "have \"a' = ws a\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> a \\<leadsto>mrw w\n  action_obs E a = NormalAction (ReadMem ad al v)\n  a' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E a'\n  E \\<turnstile> ws a \\<le>a a'\n  E \\<turnstile> a' \\<le>a a\n\ngoal (1 subgoal):\n 1. a' = ws a", "unfolding w"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> a \\<leadsto>mrw w\n  action_obs E a = NormalAction (ReadMem ad al v)\n  a' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E a'\n  E \\<turnstile> w \\<le>a a'\n  E \\<turnstile> a' \\<le>a a\n\ngoal (1 subgoal):\n 1. a' = w", "by cases(fastforce dest: antisymPD[OF antisym_action_order] read_actions_not_write_actions elim!: meta_allE[where x=a'])"], ["proof (state)\nthis:\n  a' = ws a\n\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> a' = ws a", "thus \"a' = ws a\" \"a' = ws a\""], ["proof (prove)\nusing this:\n  a' = ws a\n\ngoal (1 subgoal):\n 1. a' = ws a &&& a' = ws a", "by -"], ["proof (state)\nthis:\n  a' = ws a\n  a' = ws a\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a", "assume \"P,E \\<turnstile> ws a \\<le>hb a'\" \"P,E \\<turnstile> a' \\<le>hb a\""], ["proof (state)\nthis:\n  P,E \\<turnstile> ws a \\<le>hb a'\n  P,E \\<turnstile> a' \\<le>hb a\n\ngoal (4 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        P,E \\<turnstile> ws a \\<le>hb a';\n        P,E \\<turnstile> a' \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a\n 3. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 4. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a", "thus \"E \\<turnstile> ws a \\<le>a a'\" \"E \\<turnstile> a' \\<le>a a\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> ws a \\<le>hb a'\n  P,E \\<turnstile> a' \\<le>hb a\n\ngoal (1 subgoal):\n 1. E \\<turnstile> ws a \\<le>a a' &&& E \\<turnstile> a' \\<le>a a", "using a'"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> ws a \\<le>hb a'\n  P,E \\<turnstile> a' \\<le>hb a\n  a' \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E a'\n\ngoal (1 subgoal):\n 1. E \\<turnstile> ws a \\<le>a a' &&& E \\<turnstile> a' \\<le>a a", "by(blast intro: happens_before_into_action_order)+"], ["proof (state)\nthis:\n  E \\<turnstile> ws a \\<le>a a'\n  E \\<turnstile> a' \\<le>a a\n\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a", "assume \"is_volatile P al\" \"P,E \\<turnstile> ws a \\<le>so a'\" \"P,E \\<turnstile> a' \\<le>so a\""], ["proof (state)\nthis:\n  is_volatile P al\n  P,E \\<turnstile> ws a \\<le>so a'\n  P,E \\<turnstile> a' \\<le>so a\n\ngoal (2 subgoals):\n 1. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n 2. \\<And>a ad al v a'.\n       \\<lbrakk>a \\<in> read_actions E;\n        action_obs E a = NormalAction (ReadMem ad al v);\n        a' \\<in> write_actions E; (ad, al) \\<in> action_loc P E a';\n        is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n        P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n       \\<Longrightarrow> E \\<turnstile> a' \\<le>a a", "thus \"E \\<turnstile> ws a \\<le>a a'\" \"E \\<turnstile> a' \\<le>a a\""], ["proof (prove)\nusing this:\n  is_volatile P al\n  P,E \\<turnstile> ws a \\<le>so a'\n  P,E \\<turnstile> a' \\<le>so a\n\ngoal (1 subgoal):\n 1. E \\<turnstile> ws a \\<le>a a' &&& E \\<turnstile> a' \\<le>a a", "by(auto elim: sync_orderE)"], ["proof (state)\nthis:\n  E \\<turnstile> ws a \\<le>a a'\n  E \\<turnstile> a' \\<le>a a\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n   P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n  \\<Longrightarrow> E \\<turnstile> ws a \\<le>a a'\n  \\<lbrakk>is_volatile P al; P,E \\<turnstile> ws a \\<le>so a';\n   P,E \\<turnstile> a' \\<le>so a\\<rbrakk>\n  \\<Longrightarrow> E \\<turnstile> a' \\<le>a a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_write_seen P E ws\n\ngoal (1 subgoal):\n 1. thread_start_actions_ok E", "qed(rule tsa_ok)"], ["proof (state)\nthis:\n  P \\<turnstile> (E, ws) \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cut-and-update and sequentially consistent completion\\<close>"], ["", "inductive foldl_list_all2 ::\n  \"('b \\<Rightarrow> 'c \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> ('b \\<Rightarrow> 'c \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'c \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'b list \\<Rightarrow> 'c list \\<Rightarrow> 'a \\<Rightarrow> bool\"\nfor f and P and Q\nwhere\n  \"foldl_list_all2 f P Q [] [] s\"\n| \"\\<lbrakk> Q x y s; P x y s \\<Longrightarrow> foldl_list_all2 f P Q xs ys (f x y s) \\<rbrakk> \\<Longrightarrow> foldl_list_all2 f P Q (x # xs) (y # ys) s\""], ["", "inductive_simps foldl_list_all2_simps [simp]:\n  \"foldl_list_all2 f P Q [] ys s\"\n  \"foldl_list_all2 f P Q xs [] s\"\n  \"foldl_list_all2 f P Q (x # xs) (y # ys) s\""], ["", "inductive_simps foldl_list_all2_Cons1:\n  \"foldl_list_all2 f P Q (x # xs) ys s\""], ["", "inductive_simps foldl_list_all2_Cons2:\n  \"foldl_list_all2 f P Q xs (y # ys) s\""], ["", "definition eq_upto_seq_inconsist ::\n  \"'m prog \\<Rightarrow> ('addr, 'thread_id) obs_event action list \\<Rightarrow> ('addr, 'thread_id) obs_event action list\n  \\<Rightarrow> ('addr \\<times> addr_loc \\<rightharpoonup> 'addr val \\<times> bool) \\<Rightarrow> bool\"\nwhere\n  \"eq_upto_seq_inconsist P =\n   foldl_list_all2 (\\<lambda>ob ob' vs. mrw_value P vs ob) \n                   (\\<lambda>ob ob' vs. case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \\<exists>b. vs (ad, al) = Some (v, b) | _ \\<Rightarrow> True)\n                   (\\<lambda>ob ob' vs. if (case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \\<exists>b. vs (ad, al) = Some (v, b) | _ \\<Rightarrow> True) then ob = ob' else ob \\<approx> ob')\""], ["", "lemma eq_upto_seq_inconsist_simps:\n  \"eq_upto_seq_inconsist P [] obs' vs \\<longleftrightarrow> obs' = []\"\n  \"eq_upto_seq_inconsist P obs [] vs \\<longleftrightarrow> obs = []\"\n  \"eq_upto_seq_inconsist P (ob # obs) (ob' # obs') vs \\<longleftrightarrow> \n   (case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \n      if (\\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>) \n      then ob = ob' \\<and> eq_upto_seq_inconsist P obs obs' (mrw_value P vs ob) \n      else ob \\<approx> ob'\n    | _ \\<Rightarrow> ob = ob' \\<and> eq_upto_seq_inconsist P obs obs' (mrw_value P vs ob))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_upto_seq_inconsist P [] obs' vs = (obs' = []) &&&\n    eq_upto_seq_inconsist P obs [] vs = (obs = []) &&&\n    eq_upto_seq_inconsist P (ob # obs) (ob' # obs') vs =\n    (case ob of\n     NormalAction (ReadMem ad al v) \\<Rightarrow>\n       if \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n       then ob = ob' \\<and>\n            eq_upto_seq_inconsist P obs obs' (mrw_value P vs ob)\n       else ob \\<approx> ob'\n     | NormalAction _ \\<Rightarrow>\n         ob = ob' \\<and>\n         eq_upto_seq_inconsist P obs obs' (mrw_value P vs ob)\n     | _ \\<Rightarrow>\n         ob = ob' \\<and>\n         eq_upto_seq_inconsist P obs obs' (mrw_value P vs ob))", "by(auto simp add: eq_upto_seq_inconsist_def split: action.split obs_event.split)"], ["", "lemma eq_upto_seq_inconsist_Cons1:\n  \"eq_upto_seq_inconsist P (ob # obs) obs' vs \\<longleftrightarrow>\n   (\\<exists>ob' obs''. obs' = ob' # obs'' \\<and> \n      (case ob of NormalAction (ReadMem ad al v) \\<Rightarrow> \n         if (\\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>) \n         then ob' = ob \\<and> eq_upto_seq_inconsist P obs obs'' (mrw_value P vs ob)\n         else ob \\<approx> ob'\n       | _ \\<Rightarrow> ob' = ob \\<and> eq_upto_seq_inconsist P obs obs'' (mrw_value P vs ob)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_upto_seq_inconsist P (ob # obs) obs' vs =\n    (\\<exists>ob' obs''.\n        obs' = ob' # obs'' \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           if \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n           then ob' = ob \\<and>\n                eq_upto_seq_inconsist P obs obs'' (mrw_value P vs ob)\n           else ob \\<approx> ob'\n         | NormalAction _ \\<Rightarrow>\n             ob' = ob \\<and>\n             eq_upto_seq_inconsist P obs obs'' (mrw_value P vs ob)\n         | _ \\<Rightarrow>\n             ob' = ob \\<and>\n             eq_upto_seq_inconsist P obs obs'' (mrw_value P vs ob)))", "unfolding eq_upto_seq_inconsist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_list_all2 (\\<lambda>ob ob' vs. mrw_value P vs ob)\n     (\\<lambda>ob ob' vs.\n         case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True)\n     (\\<lambda>ob ob' vs.\n         if case ob of\n            NormalAction (ReadMem ad al v) \\<Rightarrow>\n              \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n            | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True\n         then ob = ob' else ob \\<approx> ob')\n     (ob # obs) obs' vs =\n    (\\<exists>ob' obs''.\n        obs' = ob' # obs'' \\<and>\n        (case ob of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           if \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n           then ob' = ob \\<and>\n                foldl_list_all2 (\\<lambda>ob ob' vs. mrw_value P vs ob)\n                 (\\<lambda>ob ob' vs.\n                     case ob of\n                     NormalAction (ReadMem ad al v) \\<Rightarrow>\n                       \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n                     | NormalAction _ \\<Rightarrow> True\n                     | _ \\<Rightarrow> True)\n                 (\\<lambda>ob ob' vs.\n                     if case ob of\n                        NormalAction (ReadMem ad al v) \\<Rightarrow>\n                          \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n                        | NormalAction _ \\<Rightarrow> True\n                        | _ \\<Rightarrow> True\n                     then ob = ob' else ob \\<approx> ob')\n                 obs obs'' (mrw_value P vs ob)\n           else ob \\<approx> ob'\n         | NormalAction _ \\<Rightarrow>\n             ob' = ob \\<and>\n             foldl_list_all2 (\\<lambda>ob ob' vs. mrw_value P vs ob)\n              (\\<lambda>ob ob' vs.\n                  case ob of\n                  NormalAction (ReadMem ad al v) \\<Rightarrow>\n                    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n                  | NormalAction _ \\<Rightarrow> True\n                  | _ \\<Rightarrow> True)\n              (\\<lambda>ob ob' vs.\n                  if case ob of\n                     NormalAction (ReadMem ad al v) \\<Rightarrow>\n                       \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n                     | NormalAction _ \\<Rightarrow> True\n                     | _ \\<Rightarrow> True\n                  then ob = ob' else ob \\<approx> ob')\n              obs obs'' (mrw_value P vs ob)\n         | _ \\<Rightarrow>\n             ob' = ob \\<and>\n             foldl_list_all2 (\\<lambda>ob ob' vs. mrw_value P vs ob)\n              (\\<lambda>ob ob' vs.\n                  case ob of\n                  NormalAction (ReadMem ad al v) \\<Rightarrow>\n                    \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n                  | NormalAction _ \\<Rightarrow> True\n                  | _ \\<Rightarrow> True)\n              (\\<lambda>ob ob' vs.\n                  if case ob of\n                     NormalAction (ReadMem ad al v) \\<Rightarrow>\n                       \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n                     | NormalAction _ \\<Rightarrow> True\n                     | _ \\<Rightarrow> True\n                  then ob = ob' else ob \\<approx> ob')\n              obs obs'' (mrw_value P vs ob)))", "by(auto split: obs_event.split action.split simp add: foldl_list_all2_Cons1)"], ["", "lemma eq_upto_seq_inconsist_appendD:\n  assumes \"eq_upto_seq_inconsist P (obs @ obs') obs'' vs\"\n  and \"ta_seq_consist P vs (llist_of obs)\"\n  shows \"length obs \\<le> length obs''\" (is ?thesis1)\n  and \"take (length obs) obs'' = obs\" (is ?thesis2)\n  and \"eq_upto_seq_inconsist P obs' (drop (length obs) obs'') (mrw_values P vs obs)\" (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length obs \\<le> length obs'' &&&\n    take (length obs) obs'' = obs &&&\n    eq_upto_seq_inconsist P obs' (drop (length obs) obs'')\n     (mrw_values P vs obs)", "using assms"], ["proof (prove)\nusing this:\n  eq_upto_seq_inconsist P (obs @ obs') obs'' vs\n  ta_seq_consist P vs (llist_of obs)\n\ngoal (1 subgoal):\n 1. length obs \\<le> length obs'' &&&\n    take (length obs) obs'' = obs &&&\n    eq_upto_seq_inconsist P obs' (drop (length obs) obs'')\n     (mrw_values P vs obs)", "by(induct obs arbitrary: obs'' vs)(auto split: action.split_asm obs_event.split_asm simp add: eq_upto_seq_inconsist_Cons1)"], ["", "lemma ta_seq_consist_imp_eq_upto_seq_inconsist_refl:\n  \"ta_seq_consist P vs (llist_of obs) \\<Longrightarrow> eq_upto_seq_inconsist P obs obs vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs (llist_of obs) \\<Longrightarrow>\n    eq_upto_seq_inconsist P obs obs vs", "apply(induct obs arbitrary: vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       ta_seq_consist P vs (llist_of []) \\<Longrightarrow>\n       eq_upto_seq_inconsist P [] [] vs\n 2. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   ta_seq_consist P vs (llist_of obs) \\<Longrightarrow>\n                   eq_upto_seq_inconsist P obs obs vs;\n        ta_seq_consist P vs (llist_of (a # obs))\\<rbrakk>\n       \\<Longrightarrow> eq_upto_seq_inconsist P (a # obs) (a # obs) vs", "apply(auto simp add: eq_upto_seq_inconsist_simps split: action.split obs_event.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context notes split_paired_Ex [simp del] eq_upto_seq_inconsist_simps [simp] begin"], ["", "lemma eq_upto_seq_inconsist_appendI:\n  \"\\<lbrakk> eq_upto_seq_inconsist P obs OBS vs;\n     \\<lbrakk> ta_seq_consist P vs (llist_of obs) \\<rbrakk> \\<Longrightarrow> eq_upto_seq_inconsist P obs' OBS' (mrw_values P vs OBS) \\<rbrakk>\n  \\<Longrightarrow> eq_upto_seq_inconsist P (obs @ obs') (OBS @ OBS') vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_upto_seq_inconsist P obs OBS vs;\n     ta_seq_consist P vs (llist_of obs) \\<Longrightarrow>\n     eq_upto_seq_inconsist P obs' OBS' (mrw_values P vs OBS)\\<rbrakk>\n    \\<Longrightarrow> eq_upto_seq_inconsist P (obs @ obs') (OBS @ OBS') vs", "apply(induct obs arbitrary: vs OBS)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs OBS.\n       \\<lbrakk>eq_upto_seq_inconsist P [] OBS vs;\n        ta_seq_consist P vs (llist_of []) \\<Longrightarrow>\n        eq_upto_seq_inconsist P obs' OBS' (mrw_values P vs OBS)\\<rbrakk>\n       \\<Longrightarrow> eq_upto_seq_inconsist P ([] @ obs') (OBS @ OBS') vs\n 2. \\<And>a obs vs OBS.\n       \\<lbrakk>\\<And>vs OBS.\n                   \\<lbrakk>eq_upto_seq_inconsist P obs OBS vs;\n                    ta_seq_consist P vs (llist_of obs) \\<Longrightarrow>\n                    eq_upto_seq_inconsist P obs' OBS'\n                     (mrw_values P vs OBS)\\<rbrakk>\n                   \\<Longrightarrow> eq_upto_seq_inconsist P (obs @ obs')\n(OBS @ OBS') vs;\n        eq_upto_seq_inconsist P (a # obs) OBS vs;\n        ta_seq_consist P vs (llist_of (a # obs)) \\<Longrightarrow>\n        eq_upto_seq_inconsist P obs' OBS' (mrw_values P vs OBS)\\<rbrakk>\n       \\<Longrightarrow> eq_upto_seq_inconsist P ((a # obs) @ obs')\n                          (OBS @ OBS') vs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a obs vs OBS.\n       \\<lbrakk>\\<And>vs OBS.\n                   \\<lbrakk>eq_upto_seq_inconsist P obs OBS vs;\n                    ta_seq_consist P vs (llist_of obs) \\<Longrightarrow>\n                    eq_upto_seq_inconsist P obs' OBS'\n                     (mrw_values P vs OBS)\\<rbrakk>\n                   \\<Longrightarrow> eq_upto_seq_inconsist P (obs @ obs')\n(OBS @ OBS') vs;\n        eq_upto_seq_inconsist P (a # obs) OBS vs;\n        ta_seq_consist P vs (llist_of (a # obs)) \\<Longrightarrow>\n        eq_upto_seq_inconsist P obs' OBS' (mrw_values P vs OBS)\\<rbrakk>\n       \\<Longrightarrow> eq_upto_seq_inconsist P ((a # obs) @ obs')\n                          (OBS @ OBS') vs", "apply(auto simp add: eq_upto_seq_inconsist_Cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a obs vs ob' obs''.\n       \\<lbrakk>\\<And>vs OBS.\n                   \\<lbrakk>eq_upto_seq_inconsist P obs OBS vs;\n                    ta_seq_consist P vs (llist_of obs) \\<Longrightarrow>\n                    eq_upto_seq_inconsist P obs' OBS'\n                     (mrw_values P vs OBS)\\<rbrakk>\n                   \\<Longrightarrow> eq_upto_seq_inconsist P (obs @ obs')\n(OBS @ OBS') vs;\n        (case a of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ta_seq_consist P (mrw_value P vs a) (llist_of obs) \\<Longrightarrow>\n        eq_upto_seq_inconsist P obs' OBS'\n         (mrw_values P (mrw_value P vs ob') obs'');\n        case a of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          if \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n          then ob' = a \\<and>\n               eq_upto_seq_inconsist P obs obs'' (mrw_value P vs a)\n          else a \\<approx> ob'\n        | NormalAction _ \\<Rightarrow>\n            ob' = a \\<and>\n            eq_upto_seq_inconsist P obs obs'' (mrw_value P vs a)\n        | _ \\<Rightarrow>\n            ob' = a \\<and>\n            eq_upto_seq_inconsist P obs obs'' (mrw_value P vs a)\\<rbrakk>\n       \\<Longrightarrow> case a of\n                         NormalAction (ReadMem ad al v) \\<Rightarrow>\n                           ((\\<exists>b.\n                                vs (ad, al) =\n                                \\<lfloor>(v, b)\\<rfloor>) \\<longrightarrow>\n                            ob' = a \\<and>\n                            eq_upto_seq_inconsist P (obs @ obs')\n                             (obs'' @ OBS') (mrw_value P vs a)) \\<and>\n                           ((\\<nexists>b.\n                                vs (ad, al) =\n                                \\<lfloor>(v, b)\\<rfloor>) \\<longrightarrow>\n                            a \\<approx> ob')\n                         | NormalAction _ \\<Rightarrow>\n                             ob' = a \\<and>\n                             eq_upto_seq_inconsist P (obs @ obs')\n                              (obs'' @ OBS') (mrw_value P vs a)\n                         | _ \\<Rightarrow>\n                             ob' = a \\<and>\n                             eq_upto_seq_inconsist P (obs @ obs')\n                              (obs'' @ OBS') (mrw_value P vs a)", "apply(simp split: action.split obs_event.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a obs vs ob' obs''.\n       \\<lbrakk>\\<And>vs OBS.\n                   \\<lbrakk>eq_upto_seq_inconsist P obs OBS vs;\n                    ta_seq_consist P vs (llist_of obs) \\<Longrightarrow>\n                    eq_upto_seq_inconsist P obs' OBS'\n                     (mrw_values P vs OBS)\\<rbrakk>\n                   \\<Longrightarrow> eq_upto_seq_inconsist P (obs @ obs')\n(OBS @ OBS') vs;\n        (case a of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True | _ \\<Rightarrow> True) \\<and>\n        ta_seq_consist P (mrw_value P vs a) (llist_of obs) \\<Longrightarrow>\n        eq_upto_seq_inconsist P obs' OBS'\n         (mrw_values P (mrw_value P vs ob') obs'');\n        case a of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          if \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n          then ob' = a \\<and>\n               eq_upto_seq_inconsist P obs obs'' (mrw_value P vs a)\n          else a \\<approx> ob'\n        | NormalAction _ \\<Rightarrow>\n            ob' = a \\<and>\n            eq_upto_seq_inconsist P obs obs'' (mrw_value P vs a)\n        | _ \\<Rightarrow>\n            ob' = a \\<and>\n            eq_upto_seq_inconsist P obs obs'' (mrw_value P vs a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1.\n                             (\\<forall>x11 x12 x13 x14.\n                                 x1 =\n                                 ExternalCall x11 x12 x13\n                                  x14 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (ExternalCall x11 x12 x13\n                                    x14) \\<longrightarrow>\n                                 ob' =\n                                 NormalAction\n                                  (ExternalCall x11 x12 x13 x14) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS') vs) \\<and>\n                             (\\<forall>x21 x22 x23.\n                                 x1 = ReadMem x21 x22 x23 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (ReadMem x21 x22 x23) \\<longrightarrow>\n                                 ((\\<exists>b.\nvs (x21, x22) = \\<lfloor>(x23, b)\\<rfloor>) \\<longrightarrow>\n                                  ob' =\n                                  NormalAction (ReadMem x21 x22 x23) \\<and>\n                                  eq_upto_seq_inconsist P (obs @ obs')\n                                   (obs'' @ OBS') vs) \\<and>\n                                 ((\\<forall>b.\nvs (x21, x22) \\<noteq> \\<lfloor>(x23, b)\\<rfloor>) \\<longrightarrow>\n                                  (\\<exists>v'.\nob' = NormalAction (ReadMem x21 x22 v')))) \\<and>\n                             (\\<forall>x31 x32 x33.\n                                 x1 = WriteMem x31 x32 x33 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (WriteMem x31 x32 x33) \\<longrightarrow>\n                                 ob' =\n                                 NormalAction (WriteMem x31 x32 x33) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS')\n                                  (vs((x31, x32) \\<mapsto>\n                                   (x33, True)))) \\<and>\n                             (\\<forall>x41 x42.\n                                 x1 = NewHeapElem x41 x42 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (NewHeapElem x41 x42) \\<longrightarrow>\n                                 ob' =\n                                 NormalAction (NewHeapElem x41 x42) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS')\n                                  (\\<lambda>(ad', al).\nif x41 = ad' \\<and>\n   al \\<in> addr_locs P x42 \\<and>\n   (case vs (x41, al) of None \\<Rightarrow> True\n    | \\<lfloor>(v, xa)\\<rfloor> \\<Rightarrow> \\<not> xa)\nthen \\<lfloor>(addr_loc_default P x42 al, False)\\<rfloor>\nelse vs (ad', al))) \\<and>\n                             (\\<forall>x5.\n                                 x1 = ThreadStart x5 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (ThreadStart x5) \\<longrightarrow>\n                                 ob' = NormalAction (ThreadStart x5) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS') vs) \\<and>\n                             (\\<forall>x6.\n                                 x1 = ThreadJoin x6 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (ThreadJoin x6) \\<longrightarrow>\n                                 ob' = NormalAction (ThreadJoin x6) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS') vs) \\<and>\n                             (\\<forall>x7.\n                                 x1 = SyncLock x7 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (SyncLock x7) \\<longrightarrow>\n                                 ob' = NormalAction (SyncLock x7) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS') vs) \\<and>\n                             (\\<forall>x8.\n                                 x1 = SyncUnlock x8 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (SyncUnlock x8) \\<longrightarrow>\n                                 ob' = NormalAction (SyncUnlock x8) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS') vs) \\<and>\n                             (\\<forall>x9.\n                                 x1 = ObsInterrupt x9 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (ObsInterrupt x9) \\<longrightarrow>\n                                 ob' = NormalAction (ObsInterrupt x9) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS') vs) \\<and>\n                             (\\<forall>x10.\n                                 x1 = ObsInterrupted x10 \\<longrightarrow>\n                                 a =\n                                 NormalAction\n                                  (ObsInterrupted x10) \\<longrightarrow>\n                                 ob' =\n                                 NormalAction (ObsInterrupted x10) \\<and>\n                                 eq_upto_seq_inconsist P (obs @ obs')\n                                  (obs'' @ OBS') vs)) \\<and>\n                         (a = InitialThreadAction \\<longrightarrow>\n                          ob' = InitialThreadAction \\<and>\n                          eq_upto_seq_inconsist P (obs @ obs')\n                           (obs'' @ OBS') vs) \\<and>\n                         (a = ThreadFinishAction \\<longrightarrow>\n                          ob' = ThreadFinishAction \\<and>\n                          eq_upto_seq_inconsist P (obs @ obs')\n                           (obs'' @ OBS') vs)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eq_upto_seq_inconsist_trans:\n  \"\\<lbrakk> eq_upto_seq_inconsist P obs obs' vs; eq_upto_seq_inconsist P obs' obs'' vs \\<rbrakk>\n  \\<Longrightarrow> eq_upto_seq_inconsist P obs obs'' vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_upto_seq_inconsist P obs obs' vs;\n     eq_upto_seq_inconsist P obs' obs'' vs\\<rbrakk>\n    \\<Longrightarrow> eq_upto_seq_inconsist P obs obs'' vs", "apply(induction obs arbitrary: obs' obs'' vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>obs' obs'' vs.\n       \\<lbrakk>eq_upto_seq_inconsist P [] obs' vs;\n        eq_upto_seq_inconsist P obs' obs'' vs\\<rbrakk>\n       \\<Longrightarrow> eq_upto_seq_inconsist P [] obs'' vs\n 2. \\<And>a obs obs' obs'' vs.\n       \\<lbrakk>\\<And>obs' obs'' vs.\n                   \\<lbrakk>eq_upto_seq_inconsist P obs obs' vs;\n                    eq_upto_seq_inconsist P obs' obs'' vs\\<rbrakk>\n                   \\<Longrightarrow> eq_upto_seq_inconsist P obs obs'' vs;\n        eq_upto_seq_inconsist P (a # obs) obs' vs;\n        eq_upto_seq_inconsist P obs' obs'' vs\\<rbrakk>\n       \\<Longrightarrow> eq_upto_seq_inconsist P (a # obs) obs'' vs", "apply(clarsimp simp add: eq_upto_seq_inconsist_Cons1)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a obs vs ob' obs''a ob'a obs''b.\n       \\<lbrakk>\\<And>obs' obs'' vs.\n                   \\<lbrakk>eq_upto_seq_inconsist P obs obs' vs;\n                    eq_upto_seq_inconsist P obs' obs'' vs\\<rbrakk>\n                   \\<Longrightarrow> eq_upto_seq_inconsist P obs obs'' vs;\n        case a of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          if \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n          then ob' = a \\<and>\n               eq_upto_seq_inconsist P obs obs''a (mrw_value P vs a)\n          else a \\<approx> ob'\n        | NormalAction _ \\<Rightarrow>\n            ob' = a \\<and>\n            eq_upto_seq_inconsist P obs obs''a (mrw_value P vs a)\n        | _ \\<Rightarrow>\n            ob' = a \\<and>\n            eq_upto_seq_inconsist P obs obs''a (mrw_value P vs a);\n        case ob' of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          if \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n          then ob'a = ob' \\<and>\n               eq_upto_seq_inconsist P obs''a obs''b (mrw_value P vs ob')\n          else ob' \\<approx> ob'a\n        | NormalAction _ \\<Rightarrow>\n            ob'a = ob' \\<and>\n            eq_upto_seq_inconsist P obs''a obs''b (mrw_value P vs ob')\n        | _ \\<Rightarrow>\n            ob'a = ob' \\<and>\n            eq_upto_seq_inconsist P obs''a obs''b\n             (mrw_value P vs ob')\\<rbrakk>\n       \\<Longrightarrow> case a of\n                         NormalAction (ReadMem ad al v) \\<Rightarrow>\n                           ((\\<exists>b.\n                                vs (ad, al) =\n                                \\<lfloor>(v, b)\\<rfloor>) \\<longrightarrow>\n                            ob'a = a \\<and>\n                            eq_upto_seq_inconsist P obs obs''b\n                             (mrw_value P vs a)) \\<and>\n                           ((\\<nexists>b.\n                                vs (ad, al) =\n                                \\<lfloor>(v, b)\\<rfloor>) \\<longrightarrow>\n                            a \\<approx> ob'a)\n                         | NormalAction _ \\<Rightarrow>\n                             ob'a = a \\<and>\n                             eq_upto_seq_inconsist P obs obs''b\n                              (mrw_value P vs a)\n                         | _ \\<Rightarrow>\n                             ob'a = a \\<and>\n                             eq_upto_seq_inconsist P obs obs''b\n                              (mrw_value P vs a)", "apply(auto split!: action.split obs_event.split if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eq_upto_seq_inconsist_append2:\n  \"\\<lbrakk> eq_upto_seq_inconsist P obs obs' vs; \\<not> ta_seq_consist P vs (llist_of obs) \\<rbrakk>\n  \\<Longrightarrow> eq_upto_seq_inconsist P obs (obs' @ obs'') vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_upto_seq_inconsist P obs obs' vs;\n     \\<not> ta_seq_consist P vs (llist_of obs)\\<rbrakk>\n    \\<Longrightarrow> eq_upto_seq_inconsist P obs (obs' @ obs'') vs", "apply(induction obs arbitrary: obs' vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>obs' vs.\n       \\<lbrakk>eq_upto_seq_inconsist P [] obs' vs;\n        \\<not> ta_seq_consist P vs (llist_of [])\\<rbrakk>\n       \\<Longrightarrow> eq_upto_seq_inconsist P [] (obs' @ obs'') vs\n 2. \\<And>a obs obs' vs.\n       \\<lbrakk>\\<And>obs' vs.\n                   \\<lbrakk>eq_upto_seq_inconsist P obs obs' vs;\n                    \\<not> ta_seq_consist P vs (llist_of obs)\\<rbrakk>\n                   \\<Longrightarrow> eq_upto_seq_inconsist P obs\n(obs' @ obs'') vs;\n        eq_upto_seq_inconsist P (a # obs) obs' vs;\n        \\<not> ta_seq_consist P vs (llist_of (a # obs))\\<rbrakk>\n       \\<Longrightarrow> eq_upto_seq_inconsist P (a # obs) (obs' @ obs'') vs", "apply(clarsimp simp add: eq_upto_seq_inconsist_Cons1)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a obs vs ob' obs''a.\n       \\<lbrakk>\\<And>obs' vs.\n                   \\<lbrakk>eq_upto_seq_inconsist P obs obs' vs;\n                    \\<not> ta_seq_consist P vs (llist_of obs)\\<rbrakk>\n                   \\<Longrightarrow> eq_upto_seq_inconsist P obs\n(obs' @ obs'') vs;\n        (case a of\n         NormalAction (ReadMem ad al v) \\<Rightarrow>\n           \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n         | NormalAction _ \\<Rightarrow> True\n         | _ \\<Rightarrow> True) \\<longrightarrow>\n        \\<not> ta_seq_consist P (mrw_value P vs a) (llist_of obs);\n        case a of\n        NormalAction (ReadMem ad al v) \\<Rightarrow>\n          if \\<exists>b. vs (ad, al) = \\<lfloor>(v, b)\\<rfloor>\n          then ob' = a \\<and>\n               eq_upto_seq_inconsist P obs obs''a (mrw_value P vs a)\n          else a \\<approx> ob'\n        | NormalAction _ \\<Rightarrow>\n            ob' = a \\<and>\n            eq_upto_seq_inconsist P obs obs''a (mrw_value P vs a)\n        | _ \\<Rightarrow>\n            ob' = a \\<and>\n            eq_upto_seq_inconsist P obs obs''a (mrw_value P vs a)\\<rbrakk>\n       \\<Longrightarrow> case a of\n                         NormalAction (ReadMem ad al v) \\<Rightarrow>\n                           ((\\<exists>b.\n                                vs (ad, al) =\n                                \\<lfloor>(v, b)\\<rfloor>) \\<longrightarrow>\n                            ob' = a \\<and>\n                            eq_upto_seq_inconsist P obs (obs''a @ obs'')\n                             (mrw_value P vs a)) \\<and>\n                           ((\\<nexists>b.\n                                vs (ad, al) =\n                                \\<lfloor>(v, b)\\<rfloor>) \\<longrightarrow>\n                            a \\<approx> ob')\n                         | NormalAction _ \\<Rightarrow>\n                             ob' = a \\<and>\n                             eq_upto_seq_inconsist P obs (obs''a @ obs'')\n                              (mrw_value P vs a)\n                         | _ \\<Rightarrow>\n                             ob' = a \\<and>\n                             eq_upto_seq_inconsist P obs (obs''a @ obs'')\n                              (mrw_value P vs a)", "apply(auto split!: action.split obs_event.split if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context executions_sc_hb begin"], ["", "lemma ta_seq_consist_mrwI:\n  assumes E: \"E \\<in> \\<E>\"\n  and wf: \"P \\<turnstile> (E, ws) \\<surd>\"\n  and mrw: \"\\<And>a. \\<lbrakk> enat a < r; a \\<in> read_actions E \\<rbrakk> \\<Longrightarrow> P,E \\<turnstile> a \\<leadsto>mrw ws a\"\n  shows \"ta_seq_consist P Map.empty (lmap snd (ltake r E))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P Map.empty (lmap snd (ltake r E))", "proof(rule ta_seq_consist_nthI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "fix i ad al v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "assume i_len: \"enat i < llength (lmap snd (ltake r E))\"\n    and E_i: \"lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v)\"\n    and sc: \"ta_seq_consist P Map.empty (ltake (enat i) (lmap snd (ltake r E)))\""], ["proof (state)\nthis:\n  enat i < llength (lmap snd (ltake r E))\n  lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v)\n  ta_seq_consist P Map.empty (ltake (enat i) (lmap snd (ltake r E)))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "from i_len"], ["proof (chain)\npicking this:\n  enat i < llength (lmap snd (ltake r E))", "have \"enat i < r\""], ["proof (prove)\nusing this:\n  enat i < llength (lmap snd (ltake r E))\n\ngoal (1 subgoal):\n 1. enat i < r", "by simp"], ["proof (state)\nthis:\n  enat i < r\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "with sc"], ["proof (chain)\npicking this:\n  ta_seq_consist P Map.empty (ltake (enat i) (lmap snd (ltake r E)))\n  enat i < r", "have \"ta_seq_consist P Map.empty (ltake (enat i) (lmap snd E))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P Map.empty (ltake (enat i) (lmap snd (ltake r E)))\n  enat i < r\n\ngoal (1 subgoal):\n 1. ta_seq_consist P Map.empty (ltake (enat i) (lmap snd E))", "by(simp add: min_def split: if_split_asm)"], ["proof (state)\nthis:\n  ta_seq_consist P Map.empty (ltake (enat i) (lmap snd E))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "hence ns: \"non_speculative P (\\<lambda>_. {}) (ltake (enat i) (lmap snd E))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P Map.empty (ltake (enat i) (lmap snd E))\n\ngoal (1 subgoal):\n 1. non_speculative P (\\<lambda>_. {}) (ltake (enat i) (lmap snd E))", "by(rule ta_seq_consist_into_non_speculative) simp"], ["proof (state)\nthis:\n  non_speculative P (\\<lambda>_. {}) (ltake (enat i) (lmap snd E))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "from i_len"], ["proof (chain)\npicking this:\n  enat i < llength (lmap snd (ltake r E))", "have \"i \\<in> actions E\""], ["proof (prove)\nusing this:\n  enat i < llength (lmap snd (ltake r E))\n\ngoal (1 subgoal):\n 1. i \\<in> actions E", "by(simp add: actions_def)"], ["proof (state)\nthis:\n  i \\<in> actions E\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  i \\<in> actions E\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "from E_i i_len"], ["proof (chain)\npicking this:\n  lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v)\n  enat i < llength (lmap snd (ltake r E))", "have obs_i: \"action_obs E i = NormalAction (ReadMem ad al v)\""], ["proof (prove)\nusing this:\n  lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v)\n  enat i < llength (lmap snd (ltake r E))\n\ngoal (1 subgoal):\n 1. action_obs E i = NormalAction (ReadMem ad al v)", "by(simp add: action_obs_def lnth_ltake)"], ["proof (state)\nthis:\n  action_obs E i = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  i \\<in> actions E\n  action_obs E i = NormalAction (ReadMem ad al v)", "have read: \"i \\<in> read_actions E\""], ["proof (prove)\nusing this:\n  i \\<in> actions E\n  action_obs E i = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. i \\<in> read_actions E", ".."], ["proof (state)\nthis:\n  i \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "with i_len"], ["proof (chain)\npicking this:\n  enat i < llength (lmap snd (ltake r E))\n  i \\<in> read_actions E", "have mrw_i: \"P,E \\<turnstile> i \\<leadsto>mrw ws i\""], ["proof (prove)\nusing this:\n  enat i < llength (lmap snd (ltake r E))\n  i \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> i \\<leadsto>mrw ws i", "by(auto intro: mrw)"], ["proof (state)\nthis:\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "with E"], ["proof (chain)\npicking this:\n  E \\<in> \\<E>\n  P,E \\<turnstile> i \\<leadsto>mrw ws i", "have \"ws i < i\""], ["proof (prove)\nusing this:\n  E \\<in> \\<E>\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n\ngoal (1 subgoal):\n 1. ws i < i", "using ns"], ["proof (prove)\nusing this:\n  E \\<in> \\<E>\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n  non_speculative P (\\<lambda>_. {}) (ltake (enat i) (lmap snd E))\n\ngoal (1 subgoal):\n 1. ws i < i", "by(rule mrw_before)"], ["proof (state)\nthis:\n  ws i < i\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "from mrw_i obs_i"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n  action_obs E i = NormalAction (ReadMem ad al v)", "obtain adal_w: \"(ad, al) \\<in> action_loc P E (ws i)\"\n    and adal_r: \"(ad, al) \\<in> action_loc P E i\"\n    and \"write\": \"ws i \\<in> write_actions E\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n  action_obs E i = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>(ad, al) \\<in> action_loc P E (ws i);\n      (ad, al) \\<in> action_loc P E i; ws i \\<in> write_actions E\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  (ad, al) \\<in> action_loc P E (ws i)\n  (ad, al) \\<in> action_loc P E i\n  ws i \\<in> write_actions E\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "from wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) \\<surd>", "have \"is_write_seen P E ws\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) \\<surd>\n\ngoal (1 subgoal):\n 1. is_write_seen P E ws", "by(rule wf_exec_is_write_seenD)"], ["proof (state)\nthis:\n  is_write_seen P E ws\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "from is_write_seenD[OF this read obs_i]"], ["proof (chain)\npicking this:\n  ws i \\<in> write_actions E \\<and>\n  (ad, al) \\<in> action_loc P E (ws i) \\<and>\n  value_written P E (ws i) (ad, al) = v \\<and>\n  \\<not> P,E \\<turnstile> i \\<le>hb ws i \\<and>\n  (is_volatile P al \\<longrightarrow>\n   \\<not> P,E \\<turnstile> i \\<le>so ws i) \\<and>\n  (\\<forall>a'\\<in>write_actions E.\n      (ad, al) \\<in> action_loc P E a' \\<and>\n      (P,E \\<turnstile> ws i \\<le>hb a' \\<and>\n       P,E \\<turnstile> a' \\<le>hb i \\<or>\n       is_volatile P al \\<and>\n       P,E \\<turnstile> ws i \\<le>so a' \\<and>\n       P,E \\<turnstile> a' \\<le>so i) \\<longrightarrow>\n      a' = ws i)", "have vw_v: \"value_written P E (ws i) (ad, al) = v\""], ["proof (prove)\nusing this:\n  ws i \\<in> write_actions E \\<and>\n  (ad, al) \\<in> action_loc P E (ws i) \\<and>\n  value_written P E (ws i) (ad, al) = v \\<and>\n  \\<not> P,E \\<turnstile> i \\<le>hb ws i \\<and>\n  (is_volatile P al \\<longrightarrow>\n   \\<not> P,E \\<turnstile> i \\<le>so ws i) \\<and>\n  (\\<forall>a'\\<in>write_actions E.\n      (ad, al) \\<in> action_loc P E a' \\<and>\n      (P,E \\<turnstile> ws i \\<le>hb a' \\<and>\n       P,E \\<turnstile> a' \\<le>hb i \\<or>\n       is_volatile P al \\<and>\n       P,E \\<turnstile> ws i \\<le>so a' \\<and>\n       P,E \\<turnstile> a' \\<le>so i) \\<longrightarrow>\n      a' = ws i)\n\ngoal (1 subgoal):\n 1. value_written P E (ws i) (ad, al) = v", "by simp"], ["proof (state)\nthis:\n  value_written P E (ws i) (ad, al) = v\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "let ?vs = \"mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "from \\<open>ws i < i\\<close> i_len"], ["proof (chain)\npicking this:\n  ws i < i\n  enat i < llength (lmap snd (ltake r E))", "have \"enat (ws i) < llength (ltake (enat i) E)\""], ["proof (prove)\nusing this:\n  ws i < i\n  enat i < llength (lmap snd (ltake r E))\n\ngoal (1 subgoal):\n 1. enat (ws i) < llength (ltake (enat i) E)", "by(simp add: less_trans[where y=\"enat i\"])"], ["proof (state)\nthis:\n  enat (ws i) < llength (ltake (enat i) E)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "hence \"ltake (enat i) E = lappend (ltake (enat (ws i)) (ltake (enat i) E)) (LCons (lnth (ltake (enat i) E) (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))\""], ["proof (prove)\nusing this:\n  enat (ws i) < llength (ltake (enat i) E)\n\ngoal (1 subgoal):\n 1. ltake (enat i) E =\n    lappend (ltake (enat (ws i)) (ltake (enat i) E))\n     (LCons (lnth (ltake (enat i) E) (ws i))\n       (ldropn (Suc (ws i)) (ltake (enat i) E)))", "by(simp only: ldropn_Suc_conv_ldropn lappend_ltake_enat_ldropn)"], ["proof (state)\nthis:\n  ltake (enat i) E =\n  lappend (ltake (enat (ws i)) (ltake (enat i) E))\n   (LCons (lnth (ltake (enat i) E) (ws i))\n     (ldropn (Suc (ws i)) (ltake (enat i) E)))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "also"], ["proof (state)\nthis:\n  ltake (enat i) E =\n  lappend (ltake (enat (ws i)) (ltake (enat i) E))\n   (LCons (lnth (ltake (enat i) E) (ws i))\n     (ldropn (Suc (ws i)) (ltake (enat i) E)))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "have \"\\<dots> = lappend (ltake (enat (ws i)) E) (LCons (lnth E (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (ltake (enat (ws i)) (ltake (enat i) E))\n     (LCons (lnth (ltake (enat i) E) (ws i))\n       (ldropn (Suc (ws i)) (ltake (enat i) E))) =\n    lappend (ltake (enat (ws i)) E)\n     (LCons (lnth E (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))", "using \\<open>ws i < i\\<close> i_len \\<open>enat (ws i) < llength (ltake (enat i) E)\\<close>"], ["proof (prove)\nusing this:\n  ws i < i\n  enat i < llength (lmap snd (ltake r E))\n  enat (ws i) < llength (ltake (enat i) E)\n\ngoal (1 subgoal):\n 1. lappend (ltake (enat (ws i)) (ltake (enat i) E))\n     (LCons (lnth (ltake (enat i) E) (ws i))\n       (ldropn (Suc (ws i)) (ltake (enat i) E))) =\n    lappend (ltake (enat (ws i)) E)\n     (LCons (lnth E (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))", "by(simp add: lnth_ltake)(simp add: min_def)"], ["proof (state)\nthis:\n  lappend (ltake (enat (ws i)) (ltake (enat i) E))\n   (LCons (lnth (ltake (enat i) E) (ws i))\n     (ldropn (Suc (ws i)) (ltake (enat i) E))) =\n  lappend (ltake (enat (ws i)) E)\n   (LCons (lnth E (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  ltake (enat i) E =\n  lappend (ltake (enat (ws i)) E)\n   (LCons (lnth E (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))", "have r_E: \"ltake (enat i) E = \\<dots>\""], ["proof (prove)\nusing this:\n  ltake (enat i) E =\n  lappend (ltake (enat (ws i)) E)\n   (LCons (lnth E (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))\n\ngoal (1 subgoal):\n 1. ltake (enat i) E =\n    lappend (ltake (enat (ws i)) E)\n     (LCons (lnth E (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))", "."], ["proof (state)\nthis:\n  ltake (enat i) E =\n  lappend (ltake (enat (ws i)) E)\n   (LCons (lnth E (ws i)) (ldropn (Suc (ws i)) (ltake (enat i) E)))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "have \"mrw_values P Map.empty (list_of (ltake (enat i) (lmap snd (ltake r E)))) (ad, al)\n    = mrw_values P Map.empty (map snd (list_of (ltake (enat i) E))) (ad, al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P Map.empty (list_of (ltake (enat i) (lmap snd (ltake r E))))\n     (ad, al) =\n    mrw_values P Map.empty (map snd (list_of (ltake (enat i) E))) (ad, al)", "using \\<open>enat i < r\\<close>"], ["proof (prove)\nusing this:\n  enat i < r\n\ngoal (1 subgoal):\n 1. mrw_values P Map.empty (list_of (ltake (enat i) (lmap snd (ltake r E))))\n     (ad, al) =\n    mrw_values P Map.empty (map snd (list_of (ltake (enat i) E))) (ad, al)", "by(auto simp add: min_def)"], ["proof (state)\nthis:\n  mrw_values P Map.empty (list_of (ltake (enat i) (lmap snd (ltake r E))))\n   (ad, al) =\n  mrw_values P Map.empty (map snd (list_of (ltake (enat i) E))) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "also"], ["proof (state)\nthis:\n  mrw_values P Map.empty (list_of (ltake (enat i) (lmap snd (ltake r E))))\n   (ad, al) =\n  mrw_values P Map.empty (map snd (list_of (ltake (enat i) E))) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "have \"\\<dots> = mrw_values P (mrw_value P ?vs (snd (lnth E (ws i)))) (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))) (ad, al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P Map.empty (map snd (list_of (ltake (enat i) E))) (ad, al) =\n    mrw_values P\n     (mrw_value P\n       (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n       (snd (lnth E (ws i))))\n     (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))) (ad, al)", "by(subst r_E)(simp add: list_of_lappend)"], ["proof (state)\nthis:\n  mrw_values P Map.empty (map snd (list_of (ltake (enat i) E))) (ad, al) =\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n     (snd (lnth E (ws i))))\n   (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "also"], ["proof (state)\nthis:\n  mrw_values P Map.empty (map snd (list_of (ltake (enat i) E))) (ad, al) =\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n     (snd (lnth E (ws i))))\n   (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "have \"\\<dots> = mrw_value P ?vs (snd (lnth E (ws i))) (ad, al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P\n     (mrw_value P\n       (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n       (snd (lnth E (ws i))))\n     (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))) (ad, al) =\n    mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n     (snd (lnth E (ws i))) (ad, al)", "proof(rule mrw_values_no_write_unchanged)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "fix wa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "assume wa: \"wa \\<in> set (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\"\n      and \"is_write_action wa\" \"(ad, al) \\<in> action_loc_aux P wa\""], ["proof (state)\nthis:\n  wa \\<in> set (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "from wa"], ["proof (chain)\npicking this:\n  wa \\<in> set (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))", "obtain w where \"w < length (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\"\n      and \"map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w = wa\""], ["proof (prove)\nusing this:\n  wa \\<in> set (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w < length\n                      (map snd\n                        (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))));\n         map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w =\n         wa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  \\<exists>ia<length\n               (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))).\n     map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! ia = wa\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w < length\n                      (map snd\n                        (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))));\n         map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w =\n         wa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w < length (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n  map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w = wa\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "moreover"], ["proof (state)\nthis:\n  w < length (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n  map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w = wa\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "hence \"Suc (ws i + w) < i\" (is \"?w < _\")"], ["proof (prove)\nusing this:\n  w < length (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n  map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w = wa\n\ngoal (1 subgoal):\n 1. Suc (ws i + w) < i", "using i_len"], ["proof (prove)\nusing this:\n  w < length (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n  map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w = wa\n  enat i < llength (lmap snd (ltake r E))\n\ngoal (1 subgoal):\n 1. Suc (ws i + w) < i", "by(cases \"llength E\")(simp_all add: length_list_of_conv_the_enat)"], ["proof (state)\nthis:\n  Suc (ws i + w) < i\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "ultimately"], ["proof (chain)\npicking this:\n  w < length (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n  map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w = wa\n  Suc (ws i + w) < i", "have obs_w': \"action_obs E ?w = wa\""], ["proof (prove)\nusing this:\n  w < length (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n  map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w = wa\n  Suc (ws i + w) < i\n\ngoal (1 subgoal):\n 1. action_obs E (Suc (ws i + w)) = wa", "using i_len"], ["proof (prove)\nusing this:\n  w < length (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))))\n  map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E))) ! w = wa\n  Suc (ws i + w) < i\n  enat i < llength (lmap snd (ltake r E))\n\ngoal (1 subgoal):\n 1. action_obs E (Suc (ws i + w)) = wa", "by(simp add: action_obs_def lnth_ltake less_trans[where y=\"enat i\"] ac_simps)"], ["proof (state)\nthis:\n  action_obs E (Suc (ws i + w)) = wa\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "from \\<open>?w < i\\<close> i_len"], ["proof (chain)\npicking this:\n  Suc (ws i + w) < i\n  enat i < llength (lmap snd (ltake r E))", "have \"?w \\<in> actions E\""], ["proof (prove)\nusing this:\n  Suc (ws i + w) < i\n  enat i < llength (lmap snd (ltake r E))\n\ngoal (1 subgoal):\n 1. Suc (ws i + w) \\<in> actions E", "by(simp add: actions_def less_trans[where y=\"enat i\"])"], ["proof (state)\nthis:\n  Suc (ws i + w) \\<in> actions E\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "with \\<open>is_write_action wa\\<close> obs_w' \\<open>(ad, al) \\<in> action_loc_aux P wa\\<close>"], ["proof (chain)\npicking this:\n  is_write_action wa\n  action_obs E (Suc (ws i + w)) = wa\n  (ad, al) \\<in> action_loc_aux P wa\n  Suc (ws i + w) \\<in> actions E", "have write': \"?w \\<in> write_actions E\" \n      and adal': \"(ad, al) \\<in> action_loc P E ?w\""], ["proof (prove)\nusing this:\n  is_write_action wa\n  action_obs E (Suc (ws i + w)) = wa\n  (ad, al) \\<in> action_loc_aux P wa\n  Suc (ws i + w) \\<in> actions E\n\ngoal (1 subgoal):\n 1. Suc (ws i + w) \\<in> write_actions E &&&\n    (ad, al) \\<in> action_loc P E (Suc (ws i + w))", "by(auto intro: write_actions.intros)"], ["proof (state)\nthis:\n  Suc (ws i + w) \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (Suc (ws i + w))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "from \\<open>?w < i\\<close> \\<open>i \\<in> read_actions E\\<close> \\<open>?w \\<in> actions E\\<close>"], ["proof (chain)\npicking this:\n  Suc (ws i + w) < i\n  i \\<in> read_actions E\n  Suc (ws i + w) \\<in> actions E", "have \"E \\<turnstile> ?w \\<le>a i\""], ["proof (prove)\nusing this:\n  Suc (ws i + w) < i\n  i \\<in> read_actions E\n  Suc (ws i + w) \\<in> actions E\n\ngoal (1 subgoal):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a i", "by(auto simp add: action_order_def elim: read_actions.cases)"], ["proof (state)\nthis:\n  E \\<turnstile> Suc (ws i + w) \\<le>a i\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "from mrw_i adal_r write' adal'"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n  (ad, al) \\<in> action_loc P E i\n  Suc (ws i + w) \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (Suc (ws i + w))", "have \"E \\<turnstile> ?w \\<le>a ws i \\<or> E \\<turnstile> i \\<le>a ?w\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n  (ad, al) \\<in> action_loc P E i\n  Suc (ws i + w) \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (Suc (ws i + w))\n\ngoal (1 subgoal):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a ws i \\<or>\n    E \\<turnstile> i \\<le>a Suc (ws i + w)", "by(rule most_recent_write_recent)"], ["proof (state)\nthis:\n  E \\<turnstile> Suc (ws i + w) \\<le>a ws i \\<or>\n  E \\<turnstile> i \\<le>a Suc (ws i + w)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "hence \"E \\<turnstile> ?w \\<le>a ws i\""], ["proof (prove)\nusing this:\n  E \\<turnstile> Suc (ws i + w) \\<le>a ws i \\<or>\n  E \\<turnstile> i \\<le>a Suc (ws i + w)\n\ngoal (1 subgoal):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a ws i", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a ws i \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i\n 2. E \\<turnstile> i \\<le>a Suc (ws i + w) \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i", "assume \"E \\<turnstile> i \\<le>a ?w\""], ["proof (state)\nthis:\n  E \\<turnstile> i \\<le>a Suc (ws i + w)\n\ngoal (2 subgoals):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a ws i \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i\n 2. E \\<turnstile> i \\<le>a Suc (ws i + w) \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i", "with \\<open>E \\<turnstile> ?w \\<le>a i\\<close>"], ["proof (chain)\npicking this:\n  E \\<turnstile> Suc (ws i + w) \\<le>a i\n  E \\<turnstile> i \\<le>a Suc (ws i + w)", "have \"?w = i\""], ["proof (prove)\nusing this:\n  E \\<turnstile> Suc (ws i + w) \\<le>a i\n  E \\<turnstile> i \\<le>a Suc (ws i + w)\n\ngoal (1 subgoal):\n 1. Suc (ws i + w) = i", "by(rule antisymPD[OF antisym_action_order])"], ["proof (state)\nthis:\n  Suc (ws i + w) = i\n\ngoal (2 subgoals):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a ws i \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i\n 2. E \\<turnstile> i \\<le>a Suc (ws i + w) \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i", "with write' read"], ["proof (chain)\npicking this:\n  Suc (ws i + w) \\<in> write_actions E\n  i \\<in> read_actions E\n  Suc (ws i + w) = i", "have False"], ["proof (prove)\nusing this:\n  Suc (ws i + w) \\<in> write_actions E\n  i \\<in> read_actions E\n  Suc (ws i + w) = i\n\ngoal (1 subgoal):\n 1. False", "by(auto dest: read_actions_not_write_actions)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a ws i \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i\n 2. E \\<turnstile> i \\<le>a Suc (ws i + w) \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a ws i", ".."], ["proof (state)\nthis:\n  E \\<turnstile> Suc (ws i + w) \\<le>a ws i\n\ngoal (1 subgoal):\n 1. E \\<turnstile> Suc (ws i + w) \\<le>a ws i \\<Longrightarrow>\n    E \\<turnstile> Suc (ws i + w) \\<le>a ws i", "qed"], ["proof (state)\nthis:\n  E \\<turnstile> Suc (ws i + w) \\<le>a ws i\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "from adal_w \"write\""], ["proof (chain)\npicking this:\n  (ad, al) \\<in> action_loc P E (ws i)\n  ws i \\<in> write_actions E", "have \"mrw_value P ?vs (snd (lnth E (ws i))) (ad, al) \\<noteq> None\""], ["proof (prove)\nusing this:\n  (ad, al) \\<in> action_loc P E (ws i)\n  ws i \\<in> write_actions E\n\ngoal (1 subgoal):\n 1. mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n     (snd (lnth E (ws i))) (ad, al) \\<noteq>\n    None", "by(cases \"snd (lnth E (ws i))\" rule: mrw_value_cases)\n        (auto simp add: action_obs_def split: if_split_asm elim: write_actions.cases)"], ["proof (state)\nthis:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "then"], ["proof (chain)\npicking this:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) \\<noteq>\n  None", "obtain b v where vb: \"mrw_value P ?vs (snd (lnth E (ws i))) (ad, al) = Some (v, b)\""], ["proof (prove)\nusing this:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (\\<And>v b.\n        mrw_value P\n         (mrw_values P Map.empty\n           (map snd (list_of (ltake (enat (ws i)) E))))\n         (snd (lnth E (ws i))) (ad, al) =\n        \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "moreover"], ["proof (state)\nthis:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "from \\<open>E \\<turnstile> ?w \\<le>a ws i\\<close> obs_w'"], ["proof (chain)\npicking this:\n  E \\<turnstile> Suc (ws i + w) \\<le>a ws i\n  action_obs E (Suc (ws i + w)) = wa", "have \"is_new_action wa\" \"\\<not> is_new_action (action_obs E (ws i))\""], ["proof (prove)\nusing this:\n  E \\<turnstile> Suc (ws i + w) \\<le>a ws i\n  action_obs E (Suc (ws i + w)) = wa\n\ngoal (1 subgoal):\n 1. is_new_action wa &&& \\<not> is_new_action (action_obs E (ws i))", "by(auto elim!: action_orderE)"], ["proof (state)\nthis:\n  is_new_action wa\n  \\<not> is_new_action (action_obs E (ws i))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "from \\<open>\\<not> is_new_action (action_obs E (ws i))\\<close> \"write\" adal_w"], ["proof (chain)\npicking this:\n  \\<not> is_new_action (action_obs E (ws i))\n  ws i \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws i)", "obtain v' where \"action_obs E (ws i) = NormalAction (WriteMem ad al v')\""], ["proof (prove)\nusing this:\n  \\<not> is_new_action (action_obs E (ws i))\n  ws i \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws i)\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        action_obs E (ws i) =\n        NormalAction (WriteMem ad al v') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: write_actions.cases is_write_action.cases)"], ["proof (state)\nthis:\n  action_obs E (ws i) = NormalAction (WriteMem ad al v')\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "with vb"], ["proof (chain)\npicking this:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n  action_obs E (ws i) = NormalAction (WriteMem ad al v')", "have b"], ["proof (prove)\nusing this:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n  action_obs E (ws i) = NormalAction (WriteMem ad al v')\n\ngoal (1 subgoal):\n 1. b", "by(simp add: action_obs_def)"], ["proof (state)\nthis:\n  b\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>w \\<in> set (map snd\n                              (list_of\n                                (ldropn (Suc (ws i)) (ltake (enat i) E))));\n        is_write_action w; (ad, al) \\<in> action_loc_aux P w\\<rbrakk>\n       \\<Longrightarrow> case mrw_value P\n                               (mrw_values P Map.empty\n                                 (map snd\n                                   (list_of (ltake (enat (ws i)) E))))\n                               (snd (lnth E (ws i))) (ad, al) of\n                         None \\<Rightarrow> False\n                         | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow>\n                             b \\<and> is_new_action w", "with \\<open>is_new_action wa\\<close> vb"], ["proof (chain)\npicking this:\n  is_new_action wa\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n  b", "show \"case mrw_value P ?vs (snd (lnth E (ws i))) (ad, al) of None \\<Rightarrow> False | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action wa\""], ["proof (prove)\nusing this:\n  is_new_action wa\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n  b\n\ngoal (1 subgoal):\n 1. case mrw_value P\n          (mrw_values P Map.empty\n            (map snd (list_of (ltake (enat (ws i)) E))))\n          (snd (lnth E (ws i))) (ad, al) of\n    None \\<Rightarrow> False\n    | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action wa", "by simp"], ["proof (state)\nthis:\n  case mrw_value P\n        (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n        (snd (lnth E (ws i))) (ad, al) of\n  None \\<Rightarrow> False\n  | \\<lfloor>(v, b)\\<rfloor> \\<Rightarrow> b \\<and> is_new_action wa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n     (snd (lnth E (ws i))))\n   (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))) (ad, al) =\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "also"], ["proof (state)\nthis:\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n     (snd (lnth E (ws i))))\n   (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))) (ad, al) =\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "{"], ["proof (state)\nthis:\n  mrw_values P\n   (mrw_value P\n     (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n     (snd (lnth E (ws i))))\n   (map snd (list_of (ldropn (Suc (ws i)) (ltake (enat i) E)))) (ad, al) =\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "assume \"?vs (ad, al) = Some (v, True)\"\n      and \"is_new_action (action_obs E (ws i))\""], ["proof (state)\nthis:\n  mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E)))\n   (ad, al) =\n  \\<lfloor>(v, True)\\<rfloor>\n  is_new_action (action_obs E (ws i))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "from mrw_values_eq_SomeD[OF this(1)]"], ["proof (chain)\npicking this:\n  (None = \\<lfloor>(v, True)\\<rfloor> \\<Longrightarrow>\n   \\<exists>wa.\n      wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E))) \\<and>\n      is_write_action wa \\<and>\n      (ad, al) \\<in> action_loc_aux P wa \\<and>\n      (True \\<longrightarrow> \\<not> is_new_action wa)) \\<Longrightarrow>\n  \\<exists>obs' wa obs''.\n     map snd (list_of (ltake (enat (ws i)) E)) = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> True) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> True)", "obtain wa where \"wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)))\"\n      and \"is_write_action wa\"\n      and \"(ad, al) \\<in> action_loc_aux P wa\"\n      and \"\\<not> is_new_action wa\""], ["proof (prove)\nusing this:\n  (None = \\<lfloor>(v, True)\\<rfloor> \\<Longrightarrow>\n   \\<exists>wa.\n      wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E))) \\<and>\n      is_write_action wa \\<and>\n      (ad, al) \\<in> action_loc_aux P wa \\<and>\n      (True \\<longrightarrow> \\<not> is_new_action wa)) \\<Longrightarrow>\n  \\<exists>obs' wa obs''.\n     map snd (list_of (ltake (enat (ws i)) E)) = obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and>\n     value_written_aux P wa al = v \\<and>\n     is_new_action wa = (\\<not> True) \\<and>\n     (\\<forall>ob\\<in>set obs''.\n         is_write_action ob \\<longrightarrow>\n         (ad, al) \\<in> action_loc_aux P ob \\<longrightarrow>\n         is_new_action ob \\<and> True)\n\ngoal (1 subgoal):\n 1. (\\<And>wa.\n        \\<lbrakk>wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)));\n         is_write_action wa; (ad, al) \\<in> action_loc_aux P wa;\n         \\<not> is_new_action wa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp del: set_map)"], ["proof (state)\nthis:\n  wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa", "obtain w where w: \"w < ws i\"  and wa: \"wa = snd (lnth E w)\""], ["proof (prove)\nusing this:\n  wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w < ws i; wa = snd (lnth E w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  \\<exists>ia<length (map snd (list_of (ltake (enat (ws i)) E))).\n     map snd (list_of (ltake (enat (ws i)) E)) ! ia = wa\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w < ws i; wa = snd (lnth E w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"llength E\")(auto simp add: lnth_ltake length_list_of_conv_the_enat)"], ["proof (state)\nthis:\n  w < ws i\n  wa = snd (lnth E w)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa\n  w < ws i\n  wa = snd (lnth E w)", "have \"w \\<in> write_actions E\" \"action_obs E w = wa\" \"(ad, al) \\<in> action_loc P E w\""], ["proof (prove)\nusing this:\n  wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa\n  w < ws i\n  wa = snd (lnth E w)\n\ngoal (1 subgoal):\n 1. w \\<in> write_actions E &&&\n    action_obs E w = wa &&& (ad, al) \\<in> action_loc P E w", "using \\<open>ws i \\<in> write_actions E\\<close>"], ["proof (prove)\nusing this:\n  wa \\<in> set (map snd (list_of (ltake (enat (ws i)) E)))\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  \\<not> is_new_action wa\n  w < ws i\n  wa = snd (lnth E w)\n  ws i \\<in> write_actions E\n\ngoal (1 subgoal):\n 1. w \\<in> write_actions E &&&\n    action_obs E w = wa &&& (ad, al) \\<in> action_loc P E w", "by(auto intro!: write_actions.intros simp add: actions_def less_trans[where y=\"enat (ws i)\"] action_obs_def elim!: write_actions.cases)"], ["proof (state)\nthis:\n  w \\<in> write_actions E\n  action_obs E w = wa\n  (ad, al) \\<in> action_loc P E w\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "with mrw_i adal_r"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n  (ad, al) \\<in> action_loc P E i\n  w \\<in> write_actions E\n  action_obs E w = wa\n  (ad, al) \\<in> action_loc P E w", "have \"E \\<turnstile> w \\<le>a ws i \\<or> E \\<turnstile> i \\<le>a w\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> i \\<leadsto>mrw ws i\n  (ad, al) \\<in> action_loc P E i\n  w \\<in> write_actions E\n  action_obs E w = wa\n  (ad, al) \\<in> action_loc P E w\n\ngoal (1 subgoal):\n 1. E \\<turnstile> w \\<le>a ws i \\<or> E \\<turnstile> i \\<le>a w", "by -(rule most_recent_write_recent)"], ["proof (state)\nthis:\n  E \\<turnstile> w \\<le>a ws i \\<or> E \\<turnstile> i \\<le>a w\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "hence False"], ["proof (prove)\nusing this:\n  E \\<turnstile> w \\<le>a ws i \\<or> E \\<turnstile> i \\<le>a w\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. E \\<turnstile> w \\<le>a ws i \\<Longrightarrow> False\n 2. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "assume \"E \\<turnstile> w \\<le>a ws i\""], ["proof (state)\nthis:\n  E \\<turnstile> w \\<le>a ws i\n\ngoal (2 subgoals):\n 1. E \\<turnstile> w \\<le>a ws i \\<Longrightarrow> False\n 2. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  E \\<turnstile> w \\<le>a ws i\n\ngoal (2 subgoals):\n 1. E \\<turnstile> w \\<le>a ws i \\<Longrightarrow> False\n 2. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "from \\<open>\\<not> is_new_action wa\\<close> \\<open>is_new_action (action_obs E (ws i))\\<close> \"write\" w wa \\<open>w \\<in> write_actions E\\<close>"], ["proof (chain)\npicking this:\n  \\<not> is_new_action wa\n  is_new_action (action_obs E (ws i))\n  ws i \\<in> write_actions E\n  w < ws i\n  wa = snd (lnth E w)\n  w \\<in> write_actions E", "have \"E \\<turnstile> ws i \\<le>a w\""], ["proof (prove)\nusing this:\n  \\<not> is_new_action wa\n  is_new_action (action_obs E (ws i))\n  ws i \\<in> write_actions E\n  w < ws i\n  wa = snd (lnth E w)\n  w \\<in> write_actions E\n\ngoal (1 subgoal):\n 1. E \\<turnstile> ws i \\<le>a w", "by(auto simp add: action_order_def action_obs_def)"], ["proof (state)\nthis:\n  E \\<turnstile> ws i \\<le>a w\n\ngoal (2 subgoals):\n 1. E \\<turnstile> w \\<le>a ws i \\<Longrightarrow> False\n 2. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  E \\<turnstile> w \\<le>a ws i\n  E \\<turnstile> ws i \\<le>a w", "have \"w = ws i\""], ["proof (prove)\nusing this:\n  E \\<turnstile> w \\<le>a ws i\n  E \\<turnstile> ws i \\<le>a w\n\ngoal (1 subgoal):\n 1. w = ws i", "by(rule antisymPD[OF antisym_action_order])"], ["proof (state)\nthis:\n  w = ws i\n\ngoal (2 subgoals):\n 1. E \\<turnstile> w \\<le>a ws i \\<Longrightarrow> False\n 2. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "with \\<open>w < ws i\\<close>"], ["proof (chain)\npicking this:\n  w < ws i\n  w = ws i", "show False"], ["proof (prove)\nusing this:\n  w < ws i\n  w = ws i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "assume \"E \\<turnstile> i \\<le>a w\""], ["proof (state)\nthis:\n  E \\<turnstile> i \\<le>a w\n\ngoal (1 subgoal):\n 1. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  E \\<turnstile> i \\<le>a w\n\ngoal (1 subgoal):\n 1. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "from \\<open>w \\<in> write_actions E\\<close> \\<open>w < ws i\\<close> \\<open>ws i < i\\<close> read"], ["proof (chain)\npicking this:\n  w \\<in> write_actions E\n  w < ws i\n  ws i < i\n  i \\<in> read_actions E", "have \"E \\<turnstile> w \\<le>a i\""], ["proof (prove)\nusing this:\n  w \\<in> write_actions E\n  w < ws i\n  ws i < i\n  i \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. E \\<turnstile> w \\<le>a i", "by(auto simp add: action_order_def elim: read_actions.cases)"], ["proof (state)\nthis:\n  E \\<turnstile> w \\<le>a i\n\ngoal (1 subgoal):\n 1. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  E \\<turnstile> i \\<le>a w\n  E \\<turnstile> w \\<le>a i", "have \"i = w\""], ["proof (prove)\nusing this:\n  E \\<turnstile> i \\<le>a w\n  E \\<turnstile> w \\<le>a i\n\ngoal (1 subgoal):\n 1. i = w", "by(rule antisymPD[OF antisym_action_order])"], ["proof (state)\nthis:\n  i = w\n\ngoal (1 subgoal):\n 1. E \\<turnstile> i \\<le>a w \\<Longrightarrow> False", "with \\<open>w < ws i\\<close> \\<open>ws i < i\\<close>"], ["proof (chain)\npicking this:\n  w < ws i\n  ws i < i\n  i = w", "show False"], ["proof (prove)\nusing this:\n  w < ws i\n  ws i < i\n  i = w\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>mrw_values P Map.empty\n            (map snd (list_of (ltake (enat (ws i)) E))) (ad, al) =\n           \\<lfloor>(?va2, True)\\<rfloor>;\n   is_new_action (action_obs E (ws i))\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>mrw_values P Map.empty\n            (map snd (list_of (ltake (enat (ws i)) E))) (ad, al) =\n           \\<lfloor>(?va2, True)\\<rfloor>;\n   is_new_action (action_obs E (ws i))\\<rbrakk>\n  \\<Longrightarrow> False", "obtain b where \"\\<dots> = Some (v, b)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mrw_values P Map.empty\n            (map snd (list_of (ltake (enat (ws i)) E))) (ad, al) =\n           \\<lfloor>(?va2, True)\\<rfloor>;\n   is_new_action (action_obs E (ws i))\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        mrw_value P\n         (mrw_values P Map.empty\n           (map snd (list_of (ltake (enat (ws i)) E))))\n         (snd (lnth E (ws i))) (ad, al) =\n        \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using vw_v \"write\" adal_w"], ["proof (prove)\nusing this:\n  \\<lbrakk>mrw_values P Map.empty\n            (map snd (list_of (ltake (enat (ws i)) E))) (ad, al) =\n           \\<lfloor>(?va2, True)\\<rfloor>;\n   is_new_action (action_obs E (ws i))\\<rbrakk>\n  \\<Longrightarrow> False\n  value_written P E (ws i) (ad, al) = v\n  ws i \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws i)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        mrw_value P\n         (mrw_values P Map.empty\n           (map snd (list_of (ltake (enat (ws i)) E))))\n         (snd (lnth E (ws i))) (ad, al) =\n        \\<lfloor>(v, b)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(atomize_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>va.\n                \\<lbrakk>mrw_values P Map.empty\n                          (map snd (list_of (ltake (enat (ws i)) E)))\n                          (ad, al) =\n                         \\<lfloor>(va, True)\\<rfloor>;\n                 is_new_action (action_obs E (ws i))\\<rbrakk>\n                \\<Longrightarrow> False;\n     value_written P E (ws i) (ad, al) = v; ws i \\<in> write_actions E;\n     (ad, al) \\<in> action_loc P E (ws i)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b.\n                         mrw_value P\n                          (mrw_values P Map.empty\n                            (map snd (list_of (ltake (enat (ws i)) E))))\n                          (snd (lnth E (ws i))) (ad, al) =\n                         \\<lfloor>(v, b)\\<rfloor>", "apply(auto simp add: action_obs_def value_written_def write_actions_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>va.\n                \\<lbrakk>mrw_values P Map.empty\n                          (map snd (list_of (ltake (enat (ws i)) E)))\n                          (ad, al) =\n                         \\<lfloor>(va, True)\\<rfloor>;\n                 is_new_action (snd (lnth E (ws i)))\\<rbrakk>\n                \\<Longrightarrow> False;\n     (ad, al) \\<in> action_loc_aux P (snd (lnth E (ws i)));\n     v = value_written_aux P (snd (lnth E (ws i))) al; ws i \\<in> actions E;\n     is_write_action (snd (lnth E (ws i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b.\n                         mrw_value P\n                          (mrw_values P Map.empty\n                            (map snd (list_of (ltake (enat (ws i)) E))))\n                          (snd (lnth E (ws i))) (ad, al) =\n                         \\<lfloor>(value_written_aux P (snd (lnth E (ws i)))\n                                    al,\n                                   b)\\<rfloor>", "apply(erule is_write_action.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ada hT.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>mrw_values P Map.empty\n                             (map snd (list_of (ltake (enat (ws i)) E)))\n                             (ad, al) =\n                            \\<lfloor>(va, True)\\<rfloor>;\n                    is_new_action (snd (lnth E (ws i)))\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (ad, al) \\<in> action_loc_aux P (snd (lnth E (ws i)));\n        v = value_written_aux P (snd (lnth E (ws i))) al;\n        ws i \\<in> actions E;\n        snd (lnth E (ws i)) = NormalAction (NewHeapElem ada hT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_value P\n                             (mrw_values P Map.empty\n                               (map snd (list_of (ltake (enat (ws i)) E))))\n                             (snd (lnth E (ws i))) (ad, al) =\n                            \\<lfloor>(value_written_aux P\n (snd (lnth E (ws i))) al,\nb)\\<rfloor>\n 2. \\<And>ada ala va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>mrw_values P Map.empty\n                             (map snd (list_of (ltake (enat (ws i)) E)))\n                             (ad, al) =\n                            \\<lfloor>(va, True)\\<rfloor>;\n                    is_new_action (snd (lnth E (ws i)))\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (ad, al) \\<in> action_loc_aux P (snd (lnth E (ws i)));\n        v = value_written_aux P (snd (lnth E (ws i))) al;\n        ws i \\<in> actions E;\n        snd (lnth E (ws i)) = NormalAction (WriteMem ada ala va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_value P\n                             (mrw_values P Map.empty\n                               (map snd (list_of (ltake (enat (ws i)) E))))\n                             (snd (lnth E (ws i))) (ad, al) =\n                            \\<lfloor>(value_written_aux P\n (snd (lnth E (ws i))) al,\nb)\\<rfloor>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mrw_value P\n   (mrw_values P Map.empty (map snd (list_of (ltake (enat (ws i)) E))))\n   (snd (lnth E (ws i))) (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake r E));\n        lnth (lmap snd (ltake r E)) i = NormalAction (ReadMem ad al v);\n        ta_seq_consist P Map.empty\n         (ltake (enat i) (lmap snd (ltake r E)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            mrw_values P Map.empty\n                             (list_of\n                               (ltake (enat i) (lmap snd (ltake r E))))\n                             (ad, al) =\n                            \\<lfloor>(v, b)\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  mrw_values P Map.empty (list_of (ltake (enat i) (lmap snd (ltake r E))))\n   (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>", "show \"\\<exists>b. mrw_values P Map.empty (list_of (ltake (enat i) (lmap snd (ltake r E)))) (ad, al) = \\<lfloor>(v, b)\\<rfloor>\""], ["proof (prove)\nusing this:\n  mrw_values P Map.empty (list_of (ltake (enat i) (lmap snd (ltake r E))))\n   (ad, al) =\n  \\<lfloor>(v, b)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       mrw_values P Map.empty\n        (list_of (ltake (enat i) (lmap snd (ltake r E)))) (ad, al) =\n       \\<lfloor>(v, b)\\<rfloor>", "by blast"], ["proof (state)\nthis:\n  \\<exists>b.\n     mrw_values P Map.empty\n      (list_of (ltake (enat i) (lmap snd (ltake r E)))) (ad, al) =\n     \\<lfloor>(v, b)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context jmm_multithreaded begin"], ["", "definition complete_sc :: \"('l,'thread_id,'x,'m,'w) state \\<Rightarrow> ('addr \\<times> addr_loc \\<rightharpoonup> 'addr val \\<times> bool) \\<Rightarrow> \n  ('thread_id \\<times> ('l, 'thread_id, 'x, 'm, 'w, ('addr, 'thread_id) obs_event action) thread_action) llist\"\nwhere\n  \"complete_sc s vs = unfold_llist\n     (\\<lambda>(s, vs). \\<forall>t ta s'. \\<not> s -t\\<triangleright>ta\\<rightarrow> s')\n     (\\<lambda>(s, vs). fst (SOME ((t, ta), s'). s -t\\<triangleright>ta\\<rightarrow> s' \\<and> ta_seq_consist P vs (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (\\<lambda>(s, vs). let ((t, ta), s') = SOME ((t, ta), s'). s -t\\<triangleright>ta\\<rightarrow> s' \\<and> ta_seq_consist P vs (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         in (s', mrw_values P vs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (s, vs)\""], ["", "definition sc_completion :: \"('l, 'thread_id, 'x, 'm, 'w) state \\<Rightarrow> ('addr \\<times> addr_loc \\<rightharpoonup> 'addr val \\<times> bool) \\<Rightarrow> bool\"\nwhere\n  \"sc_completion s vs \\<longleftrightarrow>\n   (\\<forall>ttas s' t x ta x' m'.\n       s -\\<triangleright>ttas\\<rightarrow>* s' \\<longrightarrow> ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) \\<longrightarrow>\n       thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow> t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m') \\<longrightarrow> actions_ok s' t ta \\<longrightarrow>\n       (\\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and>\n                      ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\""], ["", "lemma sc_completionD:\n  \"\\<lbrakk> sc_completion s vs; s -\\<triangleright>ttas\\<rightarrow>* s'; ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))); \n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m'); actions_ok s' t ta \\<rbrakk>\n  \\<Longrightarrow> \\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and>\n                   ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sc_completion s vs; s -\\<triangleright>ttas\\<rightarrow>* s';\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)));\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n     t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n     actions_ok s' t ta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' x'' m''.\n                         t \\<turnstile> \\<langle>x, shr\n               s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                         actions_ok s' t ta' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas)))\n                          (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "unfolding sc_completion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ttas s' t x ta x' m'.\n                s -\\<triangleright>ttas\\<rightarrow>* s' \\<longrightarrow>\n                ta_seq_consist P vs\n                 (llist_of\n                   (concat\n                     (map (\\<lambda>(t, y).\n                              \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas))) \\<longrightarrow>\n                thr s' t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                t \\<turnstile> \\<langle>x, shr\n      s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<longrightarrow>\n                actions_ok s' t ta \\<longrightarrow>\n                (\\<exists>ta' x'' m''.\n                    t \\<turnstile> \\<langle>x, shr\n          s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                    actions_ok s' t ta' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, y).\n                                  \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\n                     (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>));\n     s -\\<triangleright>ttas\\<rightarrow>* s';\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)));\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n     t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n     actions_ok s' t ta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' x'' m''.\n                         t \\<turnstile> \\<langle>x, shr\n               s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                         actions_ok s' t ta' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas)))\n                          (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "by blast"], ["", "lemma sc_completionI:\n  \"(\\<And>ttas s' t x ta x' m'. \n     \\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))); \n       thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m'); actions_ok s' t ta \\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and>\n                   ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n  \\<Longrightarrow> sc_completion s vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ttas s' t x ta x' m'.\n        \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n         ta_seq_consist P vs\n          (llist_of\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)));\n         thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n         t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n         actions_ok s' t ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' x'' m''.\n                             t \\<turnstile> \\<langle>x, shr\n                   s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                             actions_ok s' t ta' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas)))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)) \\<Longrightarrow>\n    sc_completion s vs", "unfolding sc_completion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ttas s' t x ta x' m'.\n        \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n         ta_seq_consist P vs\n          (llist_of\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)));\n         thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n         t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n         actions_ok s' t ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' x'' m''.\n                             t \\<turnstile> \\<langle>x, shr\n                   s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                             actions_ok s' t ta' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas)))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)) \\<Longrightarrow>\n    \\<forall>ttas s' t x ta x' m'.\n       s -\\<triangleright>ttas\\<rightarrow>* s' \\<longrightarrow>\n       ta_seq_consist P vs\n        (llist_of\n          (concat\n            (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas))) \\<longrightarrow>\n       thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n       t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<longrightarrow>\n       actions_ok s' t ta \\<longrightarrow>\n       (\\<exists>ta' x'' m''.\n           t \\<turnstile> \\<langle>x, shr\n s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n           actions_ok s' t ta' \\<and>\n           ta_seq_consist P\n            (mrw_values P vs\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas)))\n            (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))", "by blast"], ["", "lemma sc_completion_shift:\n  assumes sc_c: \"sc_completion s vs\"\n  and \\<tau>Red: \"s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and sc: \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (llist_of ttas)))\"\n  shows \"sc_completion s' (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_completion s'\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas)))", "proof(rule sc_completionI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ttasa s'a t x ta x' m'.\n       \\<lbrakk>s' -\\<triangleright>ttasa\\<rightarrow>* s'a;\n        ta_seq_consist P\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttasa)));\n        thr s'a t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s'a\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s'a t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x'' m''.\n                            t \\<turnstile> \\<langle>x, shr\n                  s'a\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                            actions_ok s'a t ta' \\<and>\n                            ta_seq_consist P\n                             (mrw_values P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas)))\n                               (concat\n                                 (map (\\<lambda>(t, ta).\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                   ttasa)))\n                             (llist_of\n                               \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "fix ttas' s'' t x ta x' m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ttasa s'a t x ta x' m'.\n       \\<lbrakk>s' -\\<triangleright>ttasa\\<rightarrow>* s'a;\n        ta_seq_consist P\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttasa)));\n        thr s'a t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s'a\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s'a t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x'' m''.\n                            t \\<turnstile> \\<langle>x, shr\n                  s'a\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                            actions_ok s'a t ta' \\<and>\n                            ta_seq_consist P\n                             (mrw_values P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas)))\n                               (concat\n                                 (map (\\<lambda>(t, ta).\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                   ttasa)))\n                             (llist_of\n                               \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "assume \\<tau>Red': \"s' -\\<triangleright>ttas'\\<rightarrow>* s''\"\n    and sc': \"ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\"\n    and red: \"thr s'' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\" \"actions_ok s'' t ta\""], ["proof (state)\nthis:\n  s' -\\<triangleright>ttas'\\<rightarrow>* s''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n  thr s'' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  actions_ok s'' t ta\n\ngoal (1 subgoal):\n 1. \\<And>ttasa s'a t x ta x' m'.\n       \\<lbrakk>s' -\\<triangleright>ttasa\\<rightarrow>* s'a;\n        ta_seq_consist P\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttasa)));\n        thr s'a t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s'a\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s'a t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x'' m''.\n                            t \\<turnstile> \\<langle>x, shr\n                  s'a\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                            actions_ok s'a t ta' \\<and>\n                            ta_seq_consist P\n                             (mrw_values P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas)))\n                               (concat\n                                 (map (\\<lambda>(t, ta).\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                   ttasa)))\n                             (llist_of\n                               \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "from \\<tau>Red \\<tau>Red'"], ["proof (chain)\npicking this:\n  s -\\<triangleright>ttas\\<rightarrow>* s'\n  s' -\\<triangleright>ttas'\\<rightarrow>* s''", "have \"s -\\<triangleright>ttas @ ttas'\\<rightarrow>* s''\""], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas\\<rightarrow>* s'\n  s' -\\<triangleright>ttas'\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. s -\\<triangleright>ttas @ ttas'\\<rightarrow>* s''", "unfolding RedT_def"], ["proof (prove)\nusing this:\n  mthr.Trsys s ttas s'\n  mthr.Trsys s' ttas' s''\n\ngoal (1 subgoal):\n 1. mthr.Trsys s (ttas @ ttas') s''", "by(rule rtrancl3p_trans)"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas @ ttas'\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<And>ttasa s'a t x ta x' m'.\n       \\<lbrakk>s' -\\<triangleright>ttasa\\<rightarrow>* s'a;\n        ta_seq_consist P\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttasa)));\n        thr s'a t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s'a\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s'a t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x'' m''.\n                            t \\<turnstile> \\<langle>x, shr\n                  s'a\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                            actions_ok s'a t ta' \\<and>\n                            ta_seq_consist P\n                             (mrw_values P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas)))\n                               (concat\n                                 (map (\\<lambda>(t, ta).\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                   ttasa)))\n                             (llist_of\n                               \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "moreover"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas @ ttas'\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<And>ttasa s'a t x ta x' m'.\n       \\<lbrakk>s' -\\<triangleright>ttasa\\<rightarrow>* s'a;\n        ta_seq_consist P\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttasa)));\n        thr s'a t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s'a\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s'a t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x'' m''.\n                            t \\<turnstile> \\<langle>x, shr\n                  s'a\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                            actions_ok s'a t ta' \\<and>\n                            ta_seq_consist P\n                             (mrw_values P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas)))\n                               (concat\n                                 (map (\\<lambda>(t, ta).\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                   ttasa)))\n                             (llist_of\n                               \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "from sc sc'"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (llist_of ttas)))\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))", "have \"ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (ttas @ ttas'))))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (llist_of ttas)))\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas @ ttas'))))", "apply(simp add: lappend_llist_of_llist_of[symmetric] ta_seq_consist_lappend del: lappend_llist_of_llist_of)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ta_seq_consist P vs\n              (lconcat\n                (llist_of\n                  (map (\\<lambda>(t, ta).\n                           llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)));\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)))\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas')))\\<rbrakk>\n    \\<Longrightarrow> ta_seq_consist P vs\n                       (llist_of\n                         (concat\n                           (map (\\<lambda>(t, y).\n                                    \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                             ttas)))", "apply(simp add: lconcat_llist_of[symmetric] lmap_llist_of[symmetric] llist.map_comp o_def split_def del: lmap_llist_of)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ ttas'))))\n\ngoal (1 subgoal):\n 1. \\<And>ttasa s'a t x ta x' m'.\n       \\<lbrakk>s' -\\<triangleright>ttasa\\<rightarrow>* s'a;\n        ta_seq_consist P\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttasa)));\n        thr s'a t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s'a\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s'a t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x'' m''.\n                            t \\<turnstile> \\<langle>x, shr\n                  s'a\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                            actions_ok s'a t ta' \\<and>\n                            ta_seq_consist P\n                             (mrw_values P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas)))\n                               (concat\n                                 (map (\\<lambda>(t, ta).\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                   ttasa)))\n                             (llist_of\n                               \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "ultimately"], ["proof (chain)\npicking this:\n  s -\\<triangleright>ttas @ ttas'\\<rightarrow>* s''\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ ttas'))))", "show \"\\<exists>ta' x'' m''. t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and> actions_ok s'' t ta' \\<and>\n         ta_seq_consist P (mrw_values P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas'))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas @ ttas'\\<rightarrow>* s''\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ ttas'))))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' x'' m''.\n       t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n       actions_ok s'' t ta' \\<and>\n       ta_seq_consist P\n        (mrw_values P\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)))\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas')))\n        (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "using red"], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas @ ttas'\\<rightarrow>* s''\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ ttas'))))\n  thr s'' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  actions_ok s'' t ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta' x'' m''.\n       t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n       actions_ok s'' t ta' \\<and>\n       ta_seq_consist P\n        (mrw_values P\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)))\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas')))\n        (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "unfolding foldl_append[symmetric] concat_append[symmetric] map_append[symmetric]"], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas @ ttas'\\<rightarrow>* s''\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ ttas'))))\n  thr s'' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  actions_ok s'' t ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta' x'' m''.\n       t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n       actions_ok s'' t ta' \\<and>\n       ta_seq_consist P\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ttas @ ttas'))))\n        (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "by(rule sc_completionD[OF sc_c])"], ["proof (state)\nthis:\n  \\<exists>ta' x'' m''.\n     t \\<turnstile> \\<langle>x, shr s''\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n     actions_ok s'' t ta' \\<and>\n     ta_seq_consist P\n      (mrw_values P\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas')))\n      (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_sc_in_Runs:\n  assumes cau: \"sc_completion s vs\"\n  and ta_seq_consist_convert_RA: \"\\<And>vs ln. ta_seq_consist P vs (llist_of (convert_RA ln))\"\n  shows \"mthr.Runs s (complete_sc s vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mthr.Runs s (complete_sc s vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mthr.Runs s (complete_sc s vs)", "let ?ttas' = \"\\<lambda>ttas' :: ('thread_id \\<times> ('l,'thread_id,'x,'m,'w, ('addr, 'thread_id) obs_event action) thread_action) list.\n               concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')\""], ["proof (state)\ngoal (1 subgoal):\n 1. mthr.Runs s (complete_sc s vs)", "let \"?vs ttas'\" = \"mrw_values P vs (?ttas' ttas')\""], ["proof (state)\ngoal (1 subgoal):\n 1. mthr.Runs s (complete_sc s vs)", "define s' vs'\n    and ttas :: \"('thread_id \\<times> ('l,'thread_id,'x,'m,'w, ('addr, 'thread_id) obs_event action) thread_action) list\"\n    where \"s' = s\" and \"vs' = vs\" and \"ttas = []\""], ["proof (state)\nthis:\n  s' = s\n  vs' = vs\n  ttas = []\n\ngoal (1 subgoal):\n 1. mthr.Runs s (complete_sc s vs)", "hence \"s -\\<triangleright>ttas\\<rightarrow>* s'\" \"ta_seq_consist P vs (llist_of (?ttas' ttas))\""], ["proof (prove)\nusing this:\n  s' = s\n  vs' = vs\n  ttas = []\n\ngoal (1 subgoal):\n 1. s -\\<triangleright>ttas\\<rightarrow>* s' &&&\n    ta_seq_consist P vs\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas)))", "by auto"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas\\<rightarrow>* s'\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. mthr.Runs s (complete_sc s vs)", "hence \"mthr.Runs s' (complete_sc s' (?vs ttas))\""], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas\\<rightarrow>* s'\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. mthr.Runs s'\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas))))", "proof(coinduction arbitrary: s' ttas rule: mthr.Runs.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' ttas.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        ta_seq_consist P vs\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             complete_sc s'\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, y).\n     \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas))) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n                         (\\<exists>sa s'a tls tl.\n                             s' = sa \\<and>\n                             complete_sc s'\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, y).\n     \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas))) =\n                             LCons tl tls \\<and>\n                             redT sa tl s'a \\<and>\n                             ((\\<exists>s' ttas.\n                                  s'a = s' \\<and>\n                                  tls =\n                                  complete_sc s'\n                                   (mrw_values P vs\n                                     (concat\n (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) \\<and>\n                                  s -\\<triangleright>ttas\\<rightarrow>* s' \\<and>\n                                  ta_seq_consist P vs\n                                   (llist_of\n                                     (concat\n (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))) \\<or>\n                              mthr.Runs s'a tls))", "case (Runs s' ttas')"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas'\\<rightarrow>* s'\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n\ngoal (1 subgoal):\n 1. \\<And>s' ttas.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        ta_seq_consist P vs\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             complete_sc s'\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, y).\n     \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas))) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n                         (\\<exists>sa s'a tls tl.\n                             s' = sa \\<and>\n                             complete_sc s'\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, y).\n     \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas))) =\n                             LCons tl tls \\<and>\n                             redT sa tl s'a \\<and>\n                             ((\\<exists>s' ttas.\n                                  s'a = s' \\<and>\n                                  tls =\n                                  complete_sc s'\n                                   (mrw_values P vs\n                                     (concat\n (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) \\<and>\n                                  s -\\<triangleright>ttas\\<rightarrow>* s' \\<and>\n                                  ta_seq_consist P vs\n                                   (llist_of\n                                     (concat\n (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))) \\<or>\n                              mthr.Runs s'a tls))", "note Red = \\<open>s -\\<triangleright>ttas'\\<rightarrow>* s'\\<close>\n      and sc = \\<open>ta_seq_consist P vs (llist_of (?ttas' ttas'))\\<close>"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas'\\<rightarrow>* s'\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n\ngoal (1 subgoal):\n 1. \\<And>s' ttas.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        ta_seq_consist P vs\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s' = s \\<and>\n                             complete_sc s'\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, y).\n     \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas))) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n                         (\\<exists>sa s'a tls tl.\n                             s' = sa \\<and>\n                             complete_sc s'\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, y).\n     \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas))) =\n                             LCons tl tls \\<and>\n                             redT sa tl s'a \\<and>\n                             ((\\<exists>s' ttas.\n                                  s'a = s' \\<and>\n                                  tls =\n                                  complete_sc s'\n                                   (mrw_values P vs\n                                     (concat\n (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) \\<and>\n                                  s -\\<triangleright>ttas\\<rightarrow>* s' \\<and>\n                                  ta_seq_consist P vs\n                                   (llist_of\n                                     (concat\n (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))) \\<or>\n                              mthr.Runs s'a tls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "proof(cases \"\\<exists>t' ta' s''. s' -t'\\<triangleright>ta'\\<rightarrow> s''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))\n 2. \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "case False"], ["proof (state)\nthis:\n  \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (2 subgoals):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))\n 2. \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "hence ?Stuck"], ["proof (prove)\nusing this:\n  \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s' = s \\<and>\n       complete_sc s'\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas'))) =\n       LNil \\<and>\n       (\\<forall>x xa. \\<not> redT s x xa)", "by(simp add: complete_sc_def)"], ["proof (state)\nthis:\n  \\<exists>s.\n     s' = s \\<and>\n     complete_sc s'\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) =\n     LNil \\<and>\n     (\\<forall>x xa. \\<not> redT s x xa)\n\ngoal (2 subgoals):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))\n 2. \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s' = s \\<and>\n     complete_sc s'\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) =\n     LNil \\<and>\n     (\\<forall>x xa. \\<not> redT s x xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      s' = s \\<and>\n      complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas'))) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n  (\\<exists>sa s' tls tl.\n      s' = sa \\<and>\n      complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas'))) =\n      LCons tl tls \\<and>\n      redT sa tl s' \\<and>\n      ((\\<exists>s'a ttas.\n           s' = s'a \\<and>\n           tls =\n           complete_sc s'a\n            (mrw_values P vs\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas))) \\<and>\n           s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n           ta_seq_consist P vs\n            (llist_of\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas)))) \\<or>\n       mthr.Runs s' tls))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "case True"], ["proof (state)\nthis:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "let ?proceed = \"\\<lambda>((t', ta'), s''). s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and> ta_seq_consist P (?vs ttas') (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "from True"], ["proof (chain)\npicking this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')", "obtain t' ta' s'' where red: \"s' -t'\\<triangleright>ta'\\<rightarrow> s''\""], ["proof (prove)\nusing this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. (\\<And>t' ta' s''.\n        s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  s' -t'\\<triangleright>ta'\\<rightarrow> s''\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "then"], ["proof (chain)\npicking this:\n  s' -t'\\<triangleright>ta'\\<rightarrow> s''", "obtain ta'' s''' where \"s' -t'\\<triangleright>ta''\\<rightarrow> s'''\"\n        and \"ta_seq_consist P (?vs ttas') (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta'\\<rightarrow> s''\n\ngoal (1 subgoal):\n 1. (\\<And>ta'' s'''.\n        \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n         ta_seq_consist P\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')))\n          (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (redT_normal x x' m')"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t' ta'\n  redT_upd s' t' ta' x' m' s''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "note red = \\<open>t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>\\<close>\n          and ts''t' = \\<open>thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>\n          and aok = \\<open>actions_ok s' t' ta'\\<close>\n          and s'' = \\<open>redT_upd s' t' ta' x' m' s''\\<close>"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t' ta'\n  redT_upd s' t' ta' x' m' s''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "from sc_completionD[OF cau Red sc ts''t' red aok]"], ["proof (chain)\npicking this:\n  \\<exists>ta' x'' m''.\n     t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n     actions_ok s' t' ta' \\<and>\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas')))\n      (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "obtain ta'' x'' m'' where red': \"t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>\"\n          and aok': \"actions_ok s' t' ta''\"\n          and sc': \"ta_seq_consist P (?vs ttas') (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\nusing this:\n  \\<exists>ta' x'' m''.\n     t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n     actions_ok s' t' ta' \\<and>\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas')))\n      (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. (\\<And>ta'' x'' m''.\n        \\<lbrakk>t' \\<turnstile> \\<langle>x, shr\n        s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n         actions_ok s' t' ta'';\n         ta_seq_consist P\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')))\n          (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  actions_ok s' t' ta''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "from redT_updWs_total"], ["proof (chain)\npicking this:\n  \\<exists>ws'. redT_updWs ?t ?ws ?was ws'", "obtain ws' where \"redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> ws'\""], ["proof (prove)\nusing this:\n  \\<exists>ws'. redT_updWs ?t ?ws ?was ws'\n\ngoal (1 subgoal):\n 1. (\\<And>ws'.\n        redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub>\n         ws' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> ws'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> ws'", "obtain s''' where \"redT_upd s' t' ta'' x'' m'' s'''\""], ["proof (prove)\nusing this:\n  redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> ws'\n\ngoal (1 subgoal):\n 1. (\\<And>s'''.\n        redT_upd s' t' ta'' x'' m'' s''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  redT_upd s' t' ta'' x'' m'' s'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "with red' ts''t' aok'"], ["proof (chain)\npicking this:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t' ta''\n  redT_upd s' t' ta'' x'' m'' s'''", "have \"s' -t'\\<triangleright>ta''\\<rightarrow> s'''\""], ["proof (prove)\nusing this:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t' ta''\n  redT_upd s' t' ta'' x'' m'' s'''\n\ngoal (1 subgoal):\n 1. s' -t'\\<triangleright>ta''\\<rightarrow> s'''", ".."], ["proof (state)\nthis:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n\ngoal (1 subgoal):\n 1. thesis", "using sc'"], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case redT_acquire"], ["proof (state)\nthis:\n  ta' = (K$ [], [], [], [], [], convert_RA ln_)\n  thr s' t' = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset s' t')\n  may_acquire_all (locks s') t' ln_\n  0 < ln_ $ n_\n  s'' =\n  (acquire_all (locks s') t' ln_,\n   (thr s'(t' \\<mapsto> (x_, no_wait_locks)), shr s'), wset s',\n   interrupts s')\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  ta' = (K$ [], [], [], [], [], convert_RA ln_)\n  thr s' t' = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset s' t')\n  may_acquire_all (locks s') t' ln_\n  0 < ln_ $ n_\n  s'' =\n  (acquire_all (locks s') t' ln_,\n   (thr s'(t' \\<mapsto> (x_, no_wait_locks)), shr s'), wset s',\n   interrupts s')\n\ngoal (1 subgoal):\n 1. thesis", "by(simp add: that[OF red] ta_seq_consist_convert_RA)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "hence \"?proceed ((t', ta''), s''')\""], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. case ((t', ta''), s''') of\n    (x, xa) \\<Rightarrow>\n      (case x of\n       (t', ta') \\<Rightarrow>\n         \\<lambda>s''.\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n       xa", "using Red"], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n  s -\\<triangleright>ttas'\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. case ((t', ta''), s''') of\n    (x, xa) \\<Rightarrow>\n      (case x of\n       (t', ta') \\<Rightarrow>\n         \\<lambda>s''.\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n       xa", "by(auto)"], ["proof (state)\nthis:\n  case ((t', ta''), s''') of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "hence *: \"?proceed (Eps ?proceed)\""], ["proof (prove)\nusing this:\n  case ((t', ta''), s''') of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. case SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n    (x, xa) \\<Rightarrow>\n      (case x of\n       (t', ta') \\<Rightarrow>\n         \\<lambda>s''.\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n       xa", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "moreover"], ["proof (state)\nthis:\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "from Red *"], ["proof (chain)\npicking this:\n  s -\\<triangleright>ttas'\\<rightarrow>* s'\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa", "have \"s -\\<triangleright>ttas' @ [fst (Eps ?proceed)]\\<rightarrow>* snd (Eps ?proceed)\""], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas'\\<rightarrow>* s'\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. s -\\<triangleright>ttas' @\n                       [fst (SOME ((t', ta'), s'').\n                                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                ta_seq_consist P\n                                 (mrw_values P vs\n                                   (concat\n                                     (map\n (\\<lambda>a.\n     case a of (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n ttas')))\n                                 (llist_of\n                                   \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n                (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>a.\n                                  case a of\n                                  (t, ta) \\<Rightarrow>\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))", "by(auto simp add: split_beta RedT_def intro: rtrancl3p_step)"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas' @\n                     [fst (SOME ((t', ta'), s'').\n                              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                              ta_seq_consist P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>a.\n      case a of (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas')))\n                               (llist_of\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n              (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>a.\n                                case a of\n                                (t, ta) \\<Rightarrow>\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "moreover"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas' @\n                     [fst (SOME ((t', ta'), s'').\n                              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                              ta_seq_consist P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>a.\n      case a of (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas')))\n                               (llist_of\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n              (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>a.\n                                case a of\n                                (t, ta) \\<Rightarrow>\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "from True"], ["proof (chain)\npicking this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')", "have \"complete_sc s' (?vs ttas') = LCons (fst (Eps ?proceed)) (complete_sc (snd (Eps ?proceed)) (?vs (ttas' @ [fst (Eps ?proceed)])))\""], ["proof (prove)\nusing this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. complete_sc s'\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas'))) =\n    LCons\n     (fst (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>a.\n                              case a of\n                              (t, ta) \\<Rightarrow>\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (ttas' @\n              [fst (SOME ((t', ta'), s'').\n                       s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                       ta_seq_consist P\n                        (mrw_values P vs\n                          (concat\n                            (map (\\<lambda>a.\n                                     case a of\n                                     (t, ta) \\<Rightarrow>\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                              ttas')))\n                        (llist_of\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))", "unfolding complete_sc_def"], ["proof (prove)\nusing this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. unfold_llist\n     (\\<lambda>(s, vs).\n         \\<forall>t ta s'. \\<not> s -t\\<triangleright>ta\\<rightarrow> s')\n     (\\<lambda>(s, vs).\n         fst (SOME ((t, ta), s').\n                 s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                 ta_seq_consist P vs\n                  (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (\\<lambda>(s, vs).\n         let ((t, ta), s') =\n               SOME ((t, ta), s').\n                  s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                  ta_seq_consist P vs\n                   (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         in (s', mrw_values P vs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (s',\n      mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas'))) =\n    LCons\n     (fst (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (unfold_llist\n       (\\<lambda>(s, vs).\n           \\<forall>t ta s'. \\<not> s -t\\<triangleright>ta\\<rightarrow> s')\n       (\\<lambda>(s, vs).\n           fst (SOME ((t, ta), s').\n                   s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                   ta_seq_consist P vs\n                    (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (\\<lambda>(s, vs).\n           let ((t, ta), s') =\n                 SOME ((t, ta), s').\n                    s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                    ta_seq_consist P vs\n                     (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           in (s', mrw_values P vs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, y).\n                              \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)),\n        mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             (ttas' @\n              [fst (SOME ((t', ta'), s'').\n                       s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                       ta_seq_consist P\n                        (mrw_values P vs\n                          (concat\n                            (map (\\<lambda>(t, y).\n                                     \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                              ttas')))\n                        (llist_of\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))", "by(simp add: split_def)"], ["proof (state)\nthis:\n  complete_sc s'\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas'))) =\n  LCons\n   (fst (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (t, ta) \\<Rightarrow>\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "moreover"], ["proof (state)\nthis:\n  complete_sc s'\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas'))) =\n  LCons\n   (fst (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (t, ta) \\<Rightarrow>\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "from sc \\<open>?proceed (Eps ?proceed)\\<close>"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa", "have \"ta_seq_consist P vs (llist_of (?ttas' (ttas' @ [fst (Eps ?proceed)])))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (t, ta) \\<Rightarrow>\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))", "unfolding map_append concat_append lappend_llist_of_llist_of[symmetric]"], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lappend\n       (llist_of\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))\n       (llist_of\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             [fst (SOME ((t', ta'), s'').\n                      s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                      ta_seq_consist P\n                       (mrw_values P vs\n                         (concat\n                           (map (\\<lambda>(t, y).\n                                    \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                             ttas')))\n                       (llist_of\n                         \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))", "by(subst ta_seq_consist_lappend)(auto simp add: split_def)"], ["proof (state)\nthis:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>a.\n                                 case a of\n                                 (t, ta) \\<Rightarrow>\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "ultimately"], ["proof (chain)\npicking this:\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n  s -\\<triangleright>ttas' @\n                     [fst (SOME ((t', ta'), s'').\n                              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                              ta_seq_consist P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>a.\n      case a of (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas')))\n                               (llist_of\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n              (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>a.\n                                case a of\n                                (t, ta) \\<Rightarrow>\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n  complete_sc s'\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas'))) =\n  LCons\n   (fst (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (t, ta) \\<Rightarrow>\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>a.\n                                 case a of\n                                 (t, ta) \\<Rightarrow>\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))", "have ?Step"], ["proof (prove)\nusing this:\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n  s -\\<triangleright>ttas' @\n                     [fst (SOME ((t', ta'), s'').\n                              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                              ta_seq_consist P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>a.\n      case a of (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas')))\n                               (llist_of\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n              (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>a.\n                                case a of\n                                (t, ta) \\<Rightarrow>\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n  complete_sc s'\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>a.\n                case a of\n                (t, ta) \\<Rightarrow> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas'))) =\n  LCons\n   (fst (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (t, ta) \\<Rightarrow>\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>a.\n                                 case a of\n                                 (t, ta) \\<Rightarrow>\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))\n\ngoal (1 subgoal):\n 1. \\<exists>sa s' tls tl.\n       s' = sa \\<and>\n       complete_sc s'\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas'))) =\n       LCons tl tls \\<and>\n       redT sa tl s' \\<and>\n       ((\\<exists>s'a ttas.\n            s' = s'a \\<and>\n            tls =\n            complete_sc s'a\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, y).\n                          \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas))) \\<and>\n            s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n            ta_seq_consist P vs\n             (llist_of\n               (concat\n                 (map (\\<lambda>(t, y).\n                          \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas)))) \\<or>\n        mthr.Runs s' tls)", "by(fastforce intro: exI[where x=\"ttas' @ [fst (Eps ?proceed)]\"] simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>sa s' tls tl.\n     s' = sa \\<and>\n     complete_sc s'\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) =\n     LCons tl tls \\<and>\n     redT sa tl s' \\<and>\n     ((\\<exists>s'a ttas.\n          s' = s'a \\<and>\n          tls =\n          complete_sc s'a\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas))) \\<and>\n          s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n          ta_seq_consist P vs\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas)))) \\<or>\n      mthr.Runs s' tls)\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>sa s' tls tl.\n     s' = sa \\<and>\n     complete_sc s'\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) =\n     LCons tl tls \\<and>\n     redT sa tl s' \\<and>\n     ((\\<exists>s'a ttas.\n          s' = s'a \\<and>\n          tls =\n          complete_sc s'a\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas))) \\<and>\n          s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n          ta_seq_consist P vs\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas)))) \\<or>\n      mthr.Runs s' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s' = s \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n    (\\<exists>sa s' tls tl.\n        s' = sa \\<and>\n        complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))) =\n        LCons tl tls \\<and>\n        redT sa tl s' \\<and>\n        ((\\<exists>s'a ttas.\n             s' = s'a \\<and>\n             tls =\n             complete_sc s'a\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas))) \\<and>\n             s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>(t, y).\n                           \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas)))) \\<or>\n         mthr.Runs s' tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s' = s \\<and>\n      complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas'))) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n  (\\<exists>sa s' tls tl.\n      s' = sa \\<and>\n      complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas'))) =\n      LCons tl tls \\<and>\n      redT sa tl s' \\<and>\n      ((\\<exists>s'a ttas.\n           s' = s'a \\<and>\n           tls =\n           complete_sc s'a\n            (mrw_values P vs\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas))) \\<and>\n           s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n           ta_seq_consist P vs\n            (llist_of\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas)))) \\<or>\n       mthr.Runs s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s' = s \\<and>\n      complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas'))) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> redT s x xa)) \\<or>\n  (\\<exists>sa s' tls tl.\n      s' = sa \\<and>\n      complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas'))) =\n      LCons tl tls \\<and>\n      redT sa tl s' \\<and>\n      ((\\<exists>s'a ttas.\n           s' = s'a \\<and>\n           tls =\n           complete_sc s'a\n            (mrw_values P vs\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas))) \\<and>\n           s -\\<triangleright>ttas\\<rightarrow>* s'a \\<and>\n           ta_seq_consist P vs\n            (llist_of\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas)))) \\<or>\n       mthr.Runs s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mthr.Runs s'\n   (complete_sc s'\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas))))\n\ngoal (1 subgoal):\n 1. mthr.Runs s (complete_sc s vs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mthr.Runs s'\n   (complete_sc s'\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas))))\n\ngoal (1 subgoal):\n 1. mthr.Runs s (complete_sc s vs)", "by(simp add: s'_def ttas_def)"], ["proof (state)\nthis:\n  mthr.Runs s (complete_sc s vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_sc_ta_seq_consist:\n  assumes cau: \"sc_completion s vs\"\n  and ta_seq_consist_convert_RA: \"\\<And>vs ln. ta_seq_consist P vs (llist_of (convert_RA ln))\"\n  shows \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (complete_sc s vs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "define vs' where \"vs' = vs\""], ["proof (state)\nthis:\n  vs' = vs\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "let ?obs = \"\\<lambda>ttas. lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "define obs where \"obs = ?obs (complete_sc s vs)\""], ["proof (state)\nthis:\n  obs =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s vs))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "define a where \"a = complete_sc s vs'\""], ["proof (state)\nthis:\n  a = complete_sc s vs'\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "let ?ttas' = \"\\<lambda>ttas' :: ('thread_id \\<times> ('l,'thread_id,'x,'m,'w,('addr, 'thread_id) obs_event action) thread_action) list.\n               concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')\""], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "let ?vs = \"\\<lambda>ttas'. mrw_values P vs (?ttas' ttas')\""], ["proof (state)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "from vs'_def obs_def"], ["proof (chain)\npicking this:\n  vs' = vs\n  obs =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s vs))", "have \"s -\\<triangleright>[]\\<rightarrow>* s\" \"ta_seq_consist P vs (llist_of (?ttas' []))\" \"vs' = ?vs []\""], ["proof (prove)\nusing this:\n  vs' = vs\n  obs =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s vs))\n\ngoal (1 subgoal):\n 1. s -\\<triangleright>[]\\<rightarrow>* s &&&\n    ta_seq_consist P vs\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           []))) &&&\n    vs' =\n    mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) []))", "by(auto)"], ["proof (state)\nthis:\n  s -\\<triangleright>[]\\<rightarrow>* s\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) [])))\n  vs' =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) []))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "hence \"\\<exists>s' ttas'. obs = ?obs (complete_sc s' vs') \\<and> s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and> \n                    ta_seq_consist P vs (llist_of (?ttas' ttas')) \\<and> vs' = ?vs ttas' \\<and> \n                    a = complete_sc s' vs'\""], ["proof (prove)\nusing this:\n  s -\\<triangleright>[]\\<rightarrow>* s\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) [])))\n  vs' =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) []))\n\ngoal (1 subgoal):\n 1. \\<exists>s' ttas'.\n       obs =\n       lconcat\n        (lmap\n          (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (complete_sc s' vs')) \\<and>\n       s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n       ta_seq_consist P vs\n        (llist_of\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas'))) \\<and>\n       vs' =\n       mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas')) \\<and>\n       a = complete_sc s' vs'", "unfolding obs_def vs'_def a_def"], ["proof (prove)\nusing this:\n  s -\\<triangleright>[]\\<rightarrow>* s\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) [])))\n  vs =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) []))\n\ngoal (1 subgoal):\n 1. \\<exists>s' ttas'.\n       lconcat\n        (lmap\n          (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (complete_sc s vs)) =\n       lconcat\n        (lmap\n          (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (complete_sc s' vs)) \\<and>\n       s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n       ta_seq_consist P vs\n        (llist_of\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas'))) \\<and>\n       vs =\n       mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas')) \\<and>\n       complete_sc s vs = complete_sc s' vs", "by metis"], ["proof (state)\nthis:\n  \\<exists>s' ttas'.\n     obs =\n     lconcat\n      (lmap\n        (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n        (complete_sc s' vs')) \\<and>\n     s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) \\<and>\n     vs' =\n     mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttas')) \\<and>\n     a = complete_sc s' vs'\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "moreover"], ["proof (state)\nthis:\n  \\<exists>s' ttas'.\n     obs =\n     lconcat\n      (lmap\n        (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n        (complete_sc s' vs')) \\<and>\n     s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) \\<and>\n     vs' =\n     mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttas')) \\<and>\n     a = complete_sc s' vs'\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "have \"wf (inv_image {(m, n). m < n} (llength \\<circ> ltakeWhile (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])))\"\n    (is \"wf ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image {(m, n). m < n}\n         (llength \\<circ>\n          ltakeWhile\n           (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])))", "by(rule wf_inv_image)(rule wellorder_class.wf)"], ["proof (state)\nthis:\n  wf (inv_image {(m, n). m < n}\n       (llength \\<circ>\n        ltakeWhile\n         (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc s vs)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>s' ttas'.\n     obs =\n     lconcat\n      (lmap\n        (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n        (complete_sc s' vs')) \\<and>\n     s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) \\<and>\n     vs' =\n     mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttas')) \\<and>\n     a = complete_sc s' vs'\n  wf (inv_image {(m, n). m < n}\n       (llength \\<circ>\n        ltakeWhile\n         (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])))", "show \"ta_seq_consist P vs' obs\""], ["proof (prove)\nusing this:\n  \\<exists>s' ttas'.\n     obs =\n     lconcat\n      (lmap\n        (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n        (complete_sc s' vs')) \\<and>\n     s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) \\<and>\n     vs' =\n     mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttas')) \\<and>\n     a = complete_sc s' vs'\n  wf (inv_image {(m, n). m < n}\n       (llength \\<circ>\n        ltakeWhile\n         (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs' obs", "proof(coinduct vs' obs a rule: ta_seq_consist_coinduct_append_wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vsa obs a.\n       \\<exists>s' ttas'.\n          obs =\n          lconcat\n           (lmap\n             (\\<lambda>a.\n                 case a of\n                 (t, ta) \\<Rightarrow>\n                   llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (complete_sc s' vsa)) \\<and>\n          s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n          ta_seq_consist P vs\n           (llist_of\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas'))) \\<and>\n          vsa =\n          mrw_values P vs\n           (concat\n             (map (\\<lambda>a.\n                      case a of\n                      (t, ta) \\<Rightarrow>\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas')) \\<and>\n          a = complete_sc s' vsa \\<Longrightarrow>\n       obs = LNil \\<or>\n       (\\<exists>obs' obs'' a'.\n           obs = lappend obs' obs'' \\<and>\n           ta_seq_consist P vsa obs' \\<and>\n           (obs' = LNil \\<longrightarrow>\n            (a', a)\n            \\<in> inv_image {(m, n). m < n}\n                   (llength \\<circ>\n                    ltakeWhile\n                     (\\<lambda>(t, ta).\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> =\n                         []))) \\<and>\n           (lfinite obs' \\<longrightarrow>\n            (\\<exists>s' ttas'.\n                obs'' =\n                lconcat\n                 (lmap\n                   (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   (complete_sc s'\n                     (mrw_values P vsa (list_of obs')))) \\<and>\n                s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n                ta_seq_consist P vs\n                 (llist_of\n                   (concat\n                     (map (\\<lambda>a.\n                              case a of\n                              (t, ta) \\<Rightarrow>\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas'))) \\<and>\n                mrw_values P vsa (list_of obs') =\n                mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')) \\<and>\n                a' = complete_sc s' (mrw_values P vsa (list_of obs'))) \\<or>\n            ta_seq_consist P (mrw_values P vsa (list_of obs')) obs''))", "case (ta_seq_consist vs' obs a)"], ["proof (state)\nthis:\n  \\<exists>s' ttas'.\n     obs =\n     lconcat\n      (lmap\n        (\\<lambda>a.\n            case a of\n            (t, ta) \\<Rightarrow>\n              llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n        (complete_sc s' vs')) \\<and>\n     s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>a.\n                   case a of\n                   (t, ta) \\<Rightarrow>\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) \\<and>\n     vs' =\n     mrw_values P vs\n      (concat\n        (map (\\<lambda>a.\n                 case a of\n                 (t, ta) \\<Rightarrow>\n                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttas')) \\<and>\n     a = complete_sc s' vs'\n\ngoal (1 subgoal):\n 1. \\<And>vsa obs a.\n       \\<exists>s' ttas'.\n          obs =\n          lconcat\n           (lmap\n             (\\<lambda>a.\n                 case a of\n                 (t, ta) \\<Rightarrow>\n                   llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (complete_sc s' vsa)) \\<and>\n          s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n          ta_seq_consist P vs\n           (llist_of\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas'))) \\<and>\n          vsa =\n          mrw_values P vs\n           (concat\n             (map (\\<lambda>a.\n                      case a of\n                      (t, ta) \\<Rightarrow>\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas')) \\<and>\n          a = complete_sc s' vsa \\<Longrightarrow>\n       obs = LNil \\<or>\n       (\\<exists>obs' obs'' a'.\n           obs = lappend obs' obs'' \\<and>\n           ta_seq_consist P vsa obs' \\<and>\n           (obs' = LNil \\<longrightarrow>\n            (a', a)\n            \\<in> inv_image {(m, n). m < n}\n                   (llength \\<circ>\n                    ltakeWhile\n                     (\\<lambda>(t, ta).\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> =\n                         []))) \\<and>\n           (lfinite obs' \\<longrightarrow>\n            (\\<exists>s' ttas'.\n                obs'' =\n                lconcat\n                 (lmap\n                   (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   (complete_sc s'\n                     (mrw_values P vsa (list_of obs')))) \\<and>\n                s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n                ta_seq_consist P vs\n                 (llist_of\n                   (concat\n                     (map (\\<lambda>a.\n                              case a of\n                              (t, ta) \\<Rightarrow>\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas'))) \\<and>\n                mrw_values P vsa (list_of obs') =\n                mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')) \\<and>\n                a' = complete_sc s' (mrw_values P vsa (list_of obs'))) \\<or>\n            ta_seq_consist P (mrw_values P vsa (list_of obs')) obs''))", "then"], ["proof (chain)\npicking this:\n  \\<exists>s' ttas'.\n     obs =\n     lconcat\n      (lmap\n        (\\<lambda>a.\n            case a of\n            (t, ta) \\<Rightarrow>\n              llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n        (complete_sc s' vs')) \\<and>\n     s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>a.\n                   case a of\n                   (t, ta) \\<Rightarrow>\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) \\<and>\n     vs' =\n     mrw_values P vs\n      (concat\n        (map (\\<lambda>a.\n                 case a of\n                 (t, ta) \\<Rightarrow>\n                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttas')) \\<and>\n     a = complete_sc s' vs'", "obtain s' ttas' where obs_def: \"obs = ?obs (complete_sc s' (?vs ttas'))\"\n      and Red: \"s -\\<triangleright>ttas'\\<rightarrow>* s'\"\n      and sc: \"ta_seq_consist P vs (llist_of (?ttas' ttas'))\"\n      and vs'_def: \"vs' = ?vs ttas'\" \n      and a_def: \"a = complete_sc s' vs'\""], ["proof (prove)\nusing this:\n  \\<exists>s' ttas'.\n     obs =\n     lconcat\n      (lmap\n        (\\<lambda>a.\n            case a of\n            (t, ta) \\<Rightarrow>\n              llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n        (complete_sc s' vs')) \\<and>\n     s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>a.\n                   case a of\n                   (t, ta) \\<Rightarrow>\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas'))) \\<and>\n     vs' =\n     mrw_values P vs\n      (concat\n        (map (\\<lambda>a.\n                 case a of\n                 (t, ta) \\<Rightarrow>\n                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttas')) \\<and>\n     a = complete_sc s' vs'\n\ngoal (1 subgoal):\n 1. (\\<And>s' ttas'.\n        \\<lbrakk>obs =\n                 lconcat\n                  (lmap\n                    (\\<lambda>(t, ta).\n                        llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    (complete_sc s'\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>(t, ta).\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))));\n         s -\\<triangleright>ttas'\\<rightarrow>* s';\n         ta_seq_consist P vs\n          (llist_of\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')));\n         vs' =\n         mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas'));\n         a = complete_sc s' vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  obs =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))))\n  s -\\<triangleright>ttas'\\<rightarrow>* s'\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n  vs' =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas'))\n  a = complete_sc s' vs'\n\ngoal (1 subgoal):\n 1. \\<And>vsa obs a.\n       \\<exists>s' ttas'.\n          obs =\n          lconcat\n           (lmap\n             (\\<lambda>a.\n                 case a of\n                 (t, ta) \\<Rightarrow>\n                   llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (complete_sc s' vsa)) \\<and>\n          s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n          ta_seq_consist P vs\n           (llist_of\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas'))) \\<and>\n          vsa =\n          mrw_values P vs\n           (concat\n             (map (\\<lambda>a.\n                      case a of\n                      (t, ta) \\<Rightarrow>\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas')) \\<and>\n          a = complete_sc s' vsa \\<Longrightarrow>\n       obs = LNil \\<or>\n       (\\<exists>obs' obs'' a'.\n           obs = lappend obs' obs'' \\<and>\n           ta_seq_consist P vsa obs' \\<and>\n           (obs' = LNil \\<longrightarrow>\n            (a', a)\n            \\<in> inv_image {(m, n). m < n}\n                   (llength \\<circ>\n                    ltakeWhile\n                     (\\<lambda>(t, ta).\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> =\n                         []))) \\<and>\n           (lfinite obs' \\<longrightarrow>\n            (\\<exists>s' ttas'.\n                obs'' =\n                lconcat\n                 (lmap\n                   (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   (complete_sc s'\n                     (mrw_values P vsa (list_of obs')))) \\<and>\n                s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n                ta_seq_consist P vs\n                 (llist_of\n                   (concat\n                     (map (\\<lambda>a.\n                              case a of\n                              (t, ta) \\<Rightarrow>\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas'))) \\<and>\n                mrw_values P vsa (list_of obs') =\n                mrw_values P vs\n                 (concat\n                   (map (\\<lambda>a.\n                            case a of\n                            (t, ta) \\<Rightarrow>\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')) \\<and>\n                a' = complete_sc s' (mrw_values P vsa (list_of obs'))) \\<or>\n            ta_seq_consist P (mrw_values P vsa (list_of obs')) obs''))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "proof(cases \"\\<exists>t' ta' s''. s' -t'\\<triangleright>ta'\\<rightarrow> s''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n 2. \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "case False"], ["proof (state)\nthis:\n  \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (2 subgoals):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n 2. \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "hence \"obs = LNil\""], ["proof (prove)\nusing this:\n  \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. obs = LNil", "unfolding obs_def complete_sc_def"], ["proof (prove)\nusing this:\n  \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (unfold_llist\n         (\\<lambda>(s, vs).\n             \\<forall>t ta s'.\n                \\<not> s -t\\<triangleright>ta\\<rightarrow> s')\n         (\\<lambda>(s, vs).\n             fst (SOME ((t, ta), s').\n                     s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                     ta_seq_consist P vs\n                      (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (\\<lambda>(s, vs).\n             let ((t, ta), s') =\n                   SOME ((t, ta), s').\n                      s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                      ta_seq_consist P vs\n                       (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             in (s', mrw_values P vs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         (s',\n          mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))))) =\n    LNil", "by simp"], ["proof (state)\nthis:\n  obs = LNil\n\ngoal (2 subgoals):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n 2. \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "hence ?LNil"], ["proof (prove)\nusing this:\n  obs = LNil\n\ngoal (1 subgoal):\n 1. obs = LNil", "unfolding obs_def"], ["proof (prove)\nusing this:\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas'))))) =\n  LNil\n\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas'))))) =\n    LNil", "by auto"], ["proof (state)\nthis:\n  obs = LNil\n\ngoal (2 subgoals):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n 2. \\<nexists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs = LNil\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", ".."], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs'' a'.\n      obs = lappend obs' obs'' \\<and>\n      ta_seq_consist P vs' obs' \\<and>\n      (obs' = LNil \\<longrightarrow>\n       (a', a)\n       \\<in> inv_image {(m, n). m < n}\n              (llength \\<circ>\n               ltakeWhile\n                (\\<lambda>(t, ta).\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>s' ttas'.\n           obs'' =\n           lconcat\n            (lmap\n              (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n           s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n           ta_seq_consist P vs\n            (llist_of\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas'))) \\<and>\n           mrw_values P vs' (list_of obs') =\n           mrw_values P vs\n            (concat\n              (map (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')) \\<and>\n           a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n       ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "case True"], ["proof (state)\nthis:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "let ?proceed = \"\\<lambda>((t', ta'), s''). s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and> ta_seq_consist P (?vs ttas') (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "let ?tta = \"fst (Eps ?proceed)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "let ?s' = \"snd (Eps ?proceed)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "from True"], ["proof (chain)\npicking this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')", "obtain t' ta' s'' where red: \"s' -t'\\<triangleright>ta'\\<rightarrow> s''\""], ["proof (prove)\nusing this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. (\\<And>t' ta' s''.\n        s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s' -t'\\<triangleright>ta'\\<rightarrow> s''\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "then"], ["proof (chain)\npicking this:\n  s' -t'\\<triangleright>ta'\\<rightarrow> s''", "obtain ta'' s''' where \"s' -t'\\<triangleright>ta''\\<rightarrow> s'''\"\n        and \"ta_seq_consist P (?vs ttas') (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta'\\<rightarrow> s''\n\ngoal (1 subgoal):\n 1. (\\<And>ta'' s'''.\n        \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n         ta_seq_consist P\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')))\n          (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (redT_normal x x' m')"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t' ta'\n  redT_upd s' t' ta' x' m' s''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "note red = \\<open>t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>\\<close>\n          and ts''t' = \\<open>thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>\n          and aok = \\<open>actions_ok s' t' ta'\\<close>\n          and s''' = \\<open>redT_upd s' t' ta' x' m' s''\\<close>"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t' ta'\n  redT_upd s' t' ta' x' m' s''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "from sc_completionD[OF cau Red sc ts''t' red aok]"], ["proof (chain)\npicking this:\n  \\<exists>ta' x'' m''.\n     t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n     actions_ok s' t' ta' \\<and>\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas')))\n      (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "obtain ta'' x'' m'' where red': \"t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>\"\n          and aok': \"actions_ok s' t' ta''\"\n          and sc': \"ta_seq_consist P (?vs ttas') (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\nusing this:\n  \\<exists>ta' x'' m''.\n     t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n     actions_ok s' t' ta' \\<and>\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas')))\n      (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. (\\<And>ta'' x'' m''.\n        \\<lbrakk>t' \\<turnstile> \\<langle>x, shr\n        s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n         actions_ok s' t' ta'';\n         ta_seq_consist P\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')))\n          (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  actions_ok s' t' ta''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "from redT_updWs_total"], ["proof (chain)\npicking this:\n  \\<exists>ws'. redT_updWs ?t ?ws ?was ws'", "obtain ws' where \"redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> ws'\""], ["proof (prove)\nusing this:\n  \\<exists>ws'. redT_updWs ?t ?ws ?was ws'\n\ngoal (1 subgoal):\n 1. (\\<And>ws'.\n        redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub>\n         ws' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> ws'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> ws'", "obtain s''' where \"redT_upd s' t' ta'' x'' m'' s'''\""], ["proof (prove)\nusing this:\n  redT_updWs t' (wset s') \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> ws'\n\ngoal (1 subgoal):\n 1. (\\<And>s'''.\n        redT_upd s' t' ta'' x'' m'' s''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  redT_upd s' t' ta'' x'' m'' s'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "with red' ts''t' aok'"], ["proof (chain)\npicking this:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t' ta''\n  redT_upd s' t' ta'' x'' m'' s'''", "have \"s' -t'\\<triangleright>ta''\\<rightarrow> s'''\""], ["proof (prove)\nusing this:\n  t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t' ta''\n  redT_upd s' t' ta'' x'' m'' s'''\n\ngoal (1 subgoal):\n 1. s' -t'\\<triangleright>ta''\\<rightarrow> s'''", ".."], ["proof (state)\nthis:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t' \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        actions_ok s' t' ta'; redT_upd s' t' ta' x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n\ngoal (1 subgoal):\n 1. thesis", "using sc'"], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case redT_acquire"], ["proof (state)\nthis:\n  ta' = (K$ [], [], [], [], [], convert_RA ln_)\n  thr s' t' = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset s' t')\n  may_acquire_all (locks s') t' ln_\n  0 < ln_ $ n_\n  s'' =\n  (acquire_all (locks s') t' ln_,\n   (thr s'(t' \\<mapsto> (x_, no_wait_locks)), shr s'), wset s',\n   interrupts s')\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta'' s'''.\n                   \\<lbrakk>s' -t'\\<triangleright>ta''\\<rightarrow> s''';\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t' = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t');\n        may_acquire_all (locks s') t' ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t' ln,\n         (thr s'(t' \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  ta' = (K$ [], [], [], [], [], convert_RA ln_)\n  thr s' t' = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset s' t')\n  may_acquire_all (locks s') t' ln_\n  0 < ln_ $ n_\n  s'' =\n  (acquire_all (locks s') t' ln_,\n   (thr s'(t' \\<mapsto> (x_, no_wait_locks)), shr s'), wset s',\n   interrupts s')\n\ngoal (1 subgoal):\n 1. thesis", "by(simp add: that[OF red] ta_seq_consist_convert_RA)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "hence \"?proceed ((t', ta''), s''')\""], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>ta''\\<rightarrow> s'''\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n   (llist_of \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. case ((t', ta''), s''') of\n    (x, xa) \\<Rightarrow>\n      (case x of\n       (t', ta') \\<Rightarrow>\n         \\<lambda>s''.\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n       xa", "by auto"], ["proof (state)\nthis:\n  case ((t', ta''), s''') of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "hence \"?proceed (Eps ?proceed)\""], ["proof (prove)\nusing this:\n  case ((t', ta''), s''') of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. case SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n    (x, xa) \\<Rightarrow>\n      (case x of\n       (t', ta') \\<Rightarrow>\n         \\<lambda>s''.\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n       xa", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta') \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "proof(cases \"obs = LNil\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n 2. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "case True"], ["proof (state)\nthis:\n  obs = LNil\n\ngoal (2 subgoals):\n 1. obs = LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n 2. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs = LNil\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", ".."], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs'' a'.\n      obs = lappend obs' obs'' \\<and>\n      ta_seq_consist P vs' obs' \\<and>\n      (obs' = LNil \\<longrightarrow>\n       (a', a)\n       \\<in> inv_image {(m, n). m < n}\n              (llength \\<circ>\n               ltakeWhile\n                (\\<lambda>(t, ta).\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>s' ttas'.\n           obs'' =\n           lconcat\n            (lmap\n              (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n           s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n           ta_seq_consist P vs\n            (llist_of\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas'))) \\<and>\n           mrw_values P vs' (list_of obs') =\n           mrw_values P vs\n            (concat\n              (map (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')) \\<and>\n           a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n       ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "case False"], ["proof (state)\nthis:\n  obs \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "from True"], ["proof (chain)\npicking this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')", "have csc_unfold: \"complete_sc s' (?vs ttas') = LCons ?tta (complete_sc ?s' (?vs (ttas' @ [?tta])))\""], ["proof (prove)\nusing this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. complete_sc s'\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas'))) =\n    LCons\n     (fst (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (ttas' @\n              [fst (SOME ((t', ta'), s'').\n                       s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                       ta_seq_consist P\n                        (mrw_values P vs\n                          (concat\n                            (map (\\<lambda>(t, ta).\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                              ttas')))\n                        (llist_of\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))", "unfolding complete_sc_def"], ["proof (prove)\nusing this:\n  \\<exists>t' ta'. Ex (redT_syntax1 s' t' ta')\n\ngoal (1 subgoal):\n 1. unfold_llist\n     (\\<lambda>(s, vs).\n         \\<forall>t ta s'. \\<not> s -t\\<triangleright>ta\\<rightarrow> s')\n     (\\<lambda>(s, vs).\n         fst (SOME ((t, ta), s').\n                 s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                 ta_seq_consist P vs\n                  (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (\\<lambda>(s, vs).\n         let ((t, ta), s') =\n               SOME ((t, ta), s').\n                  s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                  ta_seq_consist P vs\n                   (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         in (s', mrw_values P vs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     (s',\n      mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas'))) =\n    LCons\n     (fst (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (unfold_llist\n       (\\<lambda>(s, vs).\n           \\<forall>t ta s'. \\<not> s -t\\<triangleright>ta\\<rightarrow> s')\n       (\\<lambda>(s, vs).\n           fst (SOME ((t, ta), s').\n                   s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                   ta_seq_consist P vs\n                    (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (\\<lambda>(s, vs).\n           let ((t, ta), s') =\n                 SOME ((t, ta), s').\n                    s -t\\<triangleright>ta\\<rightarrow> s' \\<and>\n                    ta_seq_consist P vs\n                     (llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           in (s', mrw_values P vs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, y).\n                              \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)),\n        mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             (ttas' @\n              [fst (SOME ((t', ta'), s'').\n                       s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                       ta_seq_consist P\n                        (mrw_values P vs\n                          (concat\n                            (map (\\<lambda>(t, y).\n                                     \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                              ttas')))\n                        (llist_of\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))", "by(simp add: split_def)"], ["proof (state)\nthis:\n  complete_sc s'\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas'))) =\n  LCons\n   (fst (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>(t, ta).\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "hence \"obs = lappend (llist_of \\<lbrace>snd ?tta\\<rbrace>\\<^bsub>o\\<^esub>) (?obs (complete_sc ?s' (?vs (ttas' @ [?tta]))))\""], ["proof (prove)\nusing this:\n  complete_sc s'\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas'))) =\n  LCons\n   (fst (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>(t, ta).\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))\n\ngoal (1 subgoal):\n 1. obs =\n    lappend\n     (llist_of\n       \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas')))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc\n           (snd (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (ttas' @\n                  [fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))))", "using obs_def"], ["proof (prove)\nusing this:\n  complete_sc s'\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas'))) =\n  LCons\n   (fst (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>(t, ta).\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))\n  obs =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))))\n\ngoal (1 subgoal):\n 1. obs =\n    lappend\n     (llist_of\n       \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas')))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (complete_sc\n           (snd (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (ttas' @\n                  [fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))))", "by(simp add: split_beta)"], ["proof (state)\nthis:\n  obs =\n  lappend\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (ttas' @\n                [fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "moreover"], ["proof (state)\nthis:\n  obs =\n  lappend\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (ttas' @\n                [fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "have \"ta_seq_consist P vs' (llist_of \\<lbrace>snd ?tta\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_seq_consist P vs'\n     (llist_of\n       \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas')))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)", "using \\<open>?proceed (Eps ?proceed)\\<close> vs'_def"], ["proof (prove)\nusing this:\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n  vs' =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas'))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs'\n     (llist_of\n       \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas')))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)", "by(clarsimp simp add: split_beta)"], ["proof (state)\nthis:\n  ta_seq_consist P vs'\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "moreover"], ["proof (state)\nthis:\n  ta_seq_consist P vs'\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "{"], ["proof (state)\nthis:\n  ta_seq_consist P vs'\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "assume \"llist_of \\<lbrace>snd ?tta\\<rbrace>\\<^bsub>o\\<^esub> = LNil\""], ["proof (state)\nthis:\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "moreover"], ["proof (state)\nthis:\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "from obs_def \\<open>obs \\<noteq> LNil\\<close>"], ["proof (chain)\npicking this:\n  obs =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))))\n  obs \\<noteq> LNil", "have \"lfinite (ltakeWhile (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []) (complete_sc s' (?vs ttas')))\""], ["proof (prove)\nusing this:\n  obs =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))))\n  obs \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. lfinite\n     (ltakeWhile\n       (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])\n       (complete_sc s'\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas')))))", "unfolding lfinite_ltakeWhile"], ["proof (prove)\nusing this:\n  obs =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))))\n  obs \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. lfinite\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))) \\<or>\n    (\\<exists>x\\<in>lset\n                     (complete_sc s'\n                       (mrw_values P vs\n                         (concat\n                           (map (\\<lambda>(t, y).\n                                    \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                             ttas')))).\n        \\<not> (case x of\n                (t, ta) \\<Rightarrow>\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))", "by(fastforce simp add: split_def lconcat_eq_LNil)"], ["proof (state)\nthis:\n  lfinite\n   (ltakeWhile\n     (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "ultimately"], ["proof (chain)\npicking this:\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil\n  lfinite\n   (ltakeWhile\n     (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))))", "have \"(complete_sc ?s' (?vs (ttas' @ [?tta])), a) \\<in> ?R\""], ["proof (prove)\nusing this:\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil\n  lfinite\n   (ltakeWhile\n     (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])\n     (complete_sc s'\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))))\n\ngoal (1 subgoal):\n 1. (complete_sc\n      (snd (SOME ((t', ta'), s'').\n               s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n               ta_seq_consist P\n                (mrw_values P vs\n                  (concat\n                    (map (\\<lambda>(t, ta).\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                      ttas')))\n                (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (ttas' @\n             [fst (SOME ((t', ta'), s'').\n                      s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                      ta_seq_consist P\n                       (mrw_values P vs\n                         (concat\n                           (map (\\<lambda>(t, ta).\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                             ttas')))\n                       (llist_of\n                         \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))),\n     a)\n    \\<in> inv_image {(m, n). m < n}\n           (llength \\<circ>\n            ltakeWhile\n             (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))", "unfolding a_def vs'_def csc_unfold"], ["proof (prove)\nusing this:\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil\n  lfinite\n   (ltakeWhile\n     (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = [])\n     (LCons\n       (fst (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, y).\n                              \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, y).\n                                \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n               (ttas' @\n                [fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, y).\n \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))))\n\ngoal (1 subgoal):\n 1. (complete_sc\n      (snd (SOME ((t', ta'), s'').\n               s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n               ta_seq_consist P\n                (mrw_values P vs\n                  (concat\n                    (map (\\<lambda>(t, ta).\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                      ttas')))\n                (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (ttas' @\n             [fst (SOME ((t', ta'), s'').\n                      s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                      ta_seq_consist P\n                       (mrw_values P vs\n                         (concat\n                           (map (\\<lambda>(t, ta).\n                                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                             ttas')))\n                       (llist_of\n                         \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))),\n     LCons\n      (fst (SOME ((t', ta'), s'').\n               s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n               ta_seq_consist P\n                (mrw_values P vs\n                  (concat\n                    (map (\\<lambda>(t, y).\n                             \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                      ttas')))\n                (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n      (complete_sc\n        (snd (SOME ((t', ta'), s'').\n                 s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                 ta_seq_consist P\n                  (mrw_values P vs\n                    (concat\n                      (map (\\<lambda>(t, y).\n                               \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                        ttas')))\n                  (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ttas' @\n               [fst (SOME ((t', ta'), s'').\n                        s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                        ta_seq_consist P\n                         (mrw_values P vs\n                           (concat\n                             (map (\\<lambda>(t, y).\n\\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                               ttas')))\n                         (llist_of\n                           \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))))\n    \\<in> inv_image {(m, n). m < n}\n           (llength \\<circ>\n            ltakeWhile\n             (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))", "by(clarsimp simp add: split_def llist_of_eq_LNil_conv)(auto simp add: lfinite_eq_range_llist_of)"], ["proof (state)\nthis:\n  (complete_sc\n    (snd (SOME ((t', ta'), s'').\n             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n             ta_seq_consist P\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, ta).\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas')))\n              (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n    (mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (ttas' @\n           [fst (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))),\n   a)\n  \\<in> inv_image {(m, n). m < n}\n         (llength \\<circ>\n          ltakeWhile\n           (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "}"], ["proof (state)\nthis:\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil \\<Longrightarrow>\n  (complete_sc\n    (snd (SOME ((t', ta'), s'').\n             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n             ta_seq_consist P\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, ta).\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas')))\n              (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n    (mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (ttas' @\n           [fst (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))),\n   a)\n  \\<in> inv_image {(m, n). m < n}\n         (llength \\<circ>\n          ltakeWhile\n           (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "moreover"], ["proof (state)\nthis:\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil \\<Longrightarrow>\n  (complete_sc\n    (snd (SOME ((t', ta'), s'').\n             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n             ta_seq_consist P\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, ta).\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas')))\n              (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n    (mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (ttas' @\n           [fst (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))),\n   a)\n  \\<in> inv_image {(m, n). m < n}\n         (llength \\<circ>\n          ltakeWhile\n           (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "have \"?obs (complete_sc ?s' (?vs (ttas' @ [?tta]))) = ?obs (complete_sc ?s' (mrw_values P vs' (list_of (llist_of \\<lbrace>snd ?tta\\<rbrace>\\<^bsub>o\\<^esub>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (ttas' @\n                [fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))) =\n    lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P vs'\n           (list_of\n             (llist_of\n               \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                     ta_seq_consist P\n(mrw_values P vs\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n(llist_of\n  \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))))", "unfolding vs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (ttas' @\n                [fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))) =\n    lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (list_of\n             (llist_of\n               \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                     ta_seq_consist P\n(mrw_values P vs\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n(llist_of\n  \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))))", "by(simp add: split_def)"], ["proof (state)\nthis:\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (ttas' @\n              [fst (SOME ((t', ta'), s'').\n                       s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                       ta_seq_consist P\n                        (mrw_values P vs\n                          (concat\n                            (map (\\<lambda>(t, ta).\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                              ttas')))\n                        (llist_of\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))) =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs'\n         (list_of\n           (llist_of\n             \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                   ta_seq_consist P\n                                    (mrw_values P vs\n(concat\n  (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                    (llist_of\n\\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "moreover"], ["proof (state)\nthis:\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (ttas' @\n              [fst (SOME ((t', ta'), s'').\n                       s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                       ta_seq_consist P\n                        (mrw_values P vs\n                          (concat\n                            (map (\\<lambda>(t, ta).\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                              ttas')))\n                        (llist_of\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))) =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs'\n         (list_of\n           (llist_of\n             \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                   ta_seq_consist P\n                                    (mrw_values P vs\n(concat\n  (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                    (llist_of\n\\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "from \\<open>?proceed (Eps ?proceed)\\<close> Red"], ["proof (chain)\npicking this:\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n  s -\\<triangleright>ttas'\\<rightarrow>* s'", "have \"s -\\<triangleright>ttas' @ [?tta]\\<rightarrow>* ?s'\""], ["proof (prove)\nusing this:\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n  s -\\<triangleright>ttas'\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. s -\\<triangleright>ttas' @\n                       [fst (SOME ((t', ta'), s'').\n                                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                ta_seq_consist P\n                                 (mrw_values P vs\n                                   (concat\n                                     (map\n (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                 (llist_of\n                                   \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n                (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))", "by(auto simp add: RedT_def split_def intro: rtrancl3p_step)"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas' @\n                     [fst (SOME ((t', ta'), s'').\n                              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                              ta_seq_consist P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas')))\n                               (llist_of\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n              (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "moreover"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas' @\n                     [fst (SOME ((t', ta'), s'').\n                              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                              ta_seq_consist P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas')))\n                               (llist_of\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n              (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "from sc \\<open>?proceed (Eps ?proceed)\\<close>"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa", "have \"ta_seq_consist P vs (llist_of (?ttas' (ttas' @ [?tta])))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas')))\n  case SOME ((t', ta'), s'').\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) of\n  (x, xa) \\<Rightarrow>\n    (case x of\n     (t', ta') \\<Rightarrow>\n       \\<lambda>s''.\n          s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n          ta_seq_consist P\n           (mrw_values P vs\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')))\n           (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n     xa\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>(t, ta).\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))", "by(clarsimp simp add: split_def ta_seq_consist_lappend lappend_llist_of_llist_of[symmetric] simp del: lappend_llist_of_llist_of)"], ["proof (state)\nthis:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "moreover"], ["proof (state)\nthis:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "have \"mrw_values P vs' (list_of (llist_of \\<lbrace>snd ?tta\\<rbrace>\\<^bsub>o\\<^esub>)) = ?vs (ttas' @ [?tta])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P vs'\n     (list_of\n       (llist_of\n         \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                               s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                               ta_seq_consist P\n                                (mrw_values P vs\n                                  (concat\n                                    (map\n(\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                (llist_of\n                                  \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)) =\n    mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))", "unfolding vs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mrw_values P\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas')))\n     (list_of\n       (llist_of\n         \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                               s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                               ta_seq_consist P\n                                (mrw_values P vs\n                                  (concat\n                                    (map\n(\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                (llist_of\n                                  \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)) =\n    mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))", "by(simp add: split_def)"], ["proof (state)\nthis:\n  mrw_values P vs'\n   (list_of\n     (llist_of\n       \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas')))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)) =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (ttas' @\n        [fst (SOME ((t', ta'), s'').\n                 s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                 ta_seq_consist P\n                  (mrw_values P vs\n                    (concat\n                      (map (\\<lambda>(t, ta).\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                        ttas')))\n                  (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "moreover"], ["proof (state)\nthis:\n  mrw_values P vs'\n   (list_of\n     (llist_of\n       \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas')))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)) =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (ttas' @\n        [fst (SOME ((t', ta'), s'').\n                 s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                 ta_seq_consist P\n                  (mrw_values P vs\n                    (concat\n                      (map (\\<lambda>(t, ta).\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                        ttas')))\n                  (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "have \"complete_sc ?s' (?vs (ttas' @ [?tta])) = complete_sc ?s' (mrw_values P vs' (list_of (llist_of \\<lbrace>snd ?tta\\<rbrace>\\<^bsub>o\\<^esub>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>(t, ta).\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))) =\n    complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs'\n       (list_of\n         (llist_of\n           \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                                 s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                 ta_seq_consist P\n                                  (mrw_values P vs\n                                    (concat\n(map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                  (llist_of\n                                    \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))", "unfolding vs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas' @\n            [fst (SOME ((t', ta'), s'').\n                     s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                     ta_seq_consist P\n                      (mrw_values P vs\n                        (concat\n                          (map (\\<lambda>(t, ta).\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                            ttas')))\n                      (llist_of\n                        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))) =\n    complete_sc\n     (snd (SOME ((t', ta'), s'').\n              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n              ta_seq_consist P\n               (mrw_values P vs\n                 (concat\n                   (map (\\<lambda>(t, ta).\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                     ttas')))\n               (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n     (mrw_values P\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n             ttas')))\n       (list_of\n         (llist_of\n           \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                                 s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                 ta_seq_consist P\n                                  (mrw_values P vs\n                                    (concat\n(map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                  (llist_of\n                                    \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))", "by(simp add: split_def)"], ["proof (state)\nthis:\n  complete_sc\n   (snd (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of\n                      \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))) =\n  complete_sc\n   (snd (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (mrw_values P vs'\n     (list_of\n       (llist_of\n         \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                               s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                               ta_seq_consist P\n                                (mrw_values P vs\n                                  (concat\n                                    (map\n(\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                (llist_of\n                                  \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "ultimately"], ["proof (chain)\npicking this:\n  obs =\n  lappend\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (ttas' @\n                [fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))))\n  ta_seq_consist P vs'\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil \\<Longrightarrow>\n  (complete_sc\n    (snd (SOME ((t', ta'), s'').\n             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n             ta_seq_consist P\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, ta).\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas')))\n              (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n    (mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (ttas' @\n           [fst (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))),\n   a)\n  \\<in> inv_image {(m, n). m < n}\n         (llength \\<circ>\n          ltakeWhile\n           (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (ttas' @\n              [fst (SOME ((t', ta'), s'').\n                       s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                       ta_seq_consist P\n                        (mrw_values P vs\n                          (concat\n                            (map (\\<lambda>(t, ta).\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                              ttas')))\n                        (llist_of\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))) =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs'\n         (list_of\n           (llist_of\n             \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                   ta_seq_consist P\n                                    (mrw_values P vs\n(concat\n  (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                    (llist_of\n\\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))))\n  s -\\<triangleright>ttas' @\n                     [fst (SOME ((t', ta'), s'').\n                              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                              ta_seq_consist P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas')))\n                               (llist_of\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n              (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))\n  mrw_values P vs'\n   (list_of\n     (llist_of\n       \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas')))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)) =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (ttas' @\n        [fst (SOME ((t', ta'), s'').\n                 s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                 ta_seq_consist P\n                  (mrw_values P vs\n                    (concat\n                      (map (\\<lambda>(t, ta).\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                        ttas')))\n                  (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))\n  complete_sc\n   (snd (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of\n                      \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))) =\n  complete_sc\n   (snd (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (mrw_values P vs'\n     (list_of\n       (llist_of\n         \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                               s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                               ta_seq_consist P\n                                (mrw_values P vs\n                                  (concat\n                                    (map\n(\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                (llist_of\n                                  \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))", "have \"?lappend\""], ["proof (prove)\nusing this:\n  obs =\n  lappend\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc\n         (snd (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n         (mrw_values P vs\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (ttas' @\n                [fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))))\n  ta_seq_consist P vs'\n   (llist_of\n     \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                           s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                           ta_seq_consist P\n                            (mrw_values P vs\n                              (concat\n                                (map (\\<lambda>(t, ta).\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                  ttas')))\n                            (llist_of\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)\n  llist_of\n   \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                         s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas')))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub> =\n  LNil \\<Longrightarrow>\n  (complete_sc\n    (snd (SOME ((t', ta'), s'').\n             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n             ta_seq_consist P\n              (mrw_values P vs\n                (concat\n                  (map (\\<lambda>(t, ta).\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas')))\n              (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n    (mrw_values P vs\n      (concat\n        (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (ttas' @\n           [fst (SOME ((t', ta'), s'').\n                    s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas')))\n                     (llist_of\n                       \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))),\n   a)\n  \\<in> inv_image {(m, n). m < n}\n         (llength \\<circ>\n          ltakeWhile\n           (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs\n         (concat\n           (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (ttas' @\n              [fst (SOME ((t', ta'), s'').\n                       s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                       ta_seq_consist P\n                        (mrw_values P vs\n                          (concat\n                            (map (\\<lambda>(t, ta).\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                              ttas')))\n                        (llist_of\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))))) =\n  lconcat\n   (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (complete_sc\n       (snd (SOME ((t', ta'), s'').\n                s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                ta_seq_consist P\n                 (mrw_values P vs\n                   (concat\n                     (map (\\<lambda>(t, ta).\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas')))\n                 (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n       (mrw_values P vs'\n         (list_of\n           (llist_of\n             \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                                   ta_seq_consist P\n                                    (mrw_values P vs\n(concat\n  (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                    (llist_of\n\\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))))\n  s -\\<triangleright>ttas' @\n                     [fst (SOME ((t', ta'), s'').\n                              s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                              ta_seq_consist P\n                               (mrw_values P vs\n                                 (concat\n                                   (map (\\<lambda>(t, ta).\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                     ttas')))\n                               (llist_of\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]\\<rightarrow>* snd\n              (SOME ((t', ta'), s'').\n                  s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                  ta_seq_consist P\n                   (mrw_values P vs\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         ttas')))\n                   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))]))))\n  mrw_values P vs'\n   (list_of\n     (llist_of\n       \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                             s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas')))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)) =\n  mrw_values P vs\n   (concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (ttas' @\n        [fst (SOME ((t', ta'), s'').\n                 s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                 ta_seq_consist P\n                  (mrw_values P vs\n                    (concat\n                      (map (\\<lambda>(t, ta).\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                        ttas')))\n                  (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))\n  complete_sc\n   (snd (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas' @\n          [fst (SOME ((t', ta'), s'').\n                   s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                   ta_seq_consist P\n                    (mrw_values P vs\n                      (concat\n                        (map (\\<lambda>(t, ta).\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                          ttas')))\n                    (llist_of\n                      \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>))])))) =\n  complete_sc\n   (snd (SOME ((t', ta'), s'').\n            s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n            ta_seq_consist P\n             (mrw_values P vs\n               (concat\n                 (map (\\<lambda>(t, ta).\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas')))\n             (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\n   (mrw_values P vs'\n     (list_of\n       (llist_of\n         \\<lbrace>snd (fst (SOME ((t', ta'), s'').\n                               s' -t'\\<triangleright>ta'\\<rightarrow> s'' \\<and>\n                               ta_seq_consist P\n                                (mrw_values P vs\n                                  (concat\n                                    (map\n(\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas')))\n                                (llist_of\n                                  \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)))\\<rbrace>\\<^bsub>o\\<^esub>)))\n\ngoal (1 subgoal):\n 1. \\<exists>obs' obs'' a'.\n       obs = lappend obs' obs'' \\<and>\n       ta_seq_consist P vs' obs' \\<and>\n       (obs' = LNil \\<longrightarrow>\n        (a', a)\n        \\<in> inv_image {(m, n). m < n}\n               (llength \\<circ>\n                ltakeWhile\n                 (\\<lambda>(t, ta).\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n       (lfinite obs' \\<longrightarrow>\n        (\\<exists>s' ttas'.\n            obs'' =\n            lconcat\n             (lmap\n               (\\<lambda>a.\n                   case a of\n                   (t, ta) \\<Rightarrow>\n                     llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n            s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n            ta_seq_consist P vs\n             (llist_of\n               (concat\n                 (map (\\<lambda>a.\n                          case a of\n                          (t, ta) \\<Rightarrow>\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                   ttas'))) \\<and>\n            mrw_values P vs' (list_of obs') =\n            mrw_values P vs\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas')) \\<and>\n            a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n        ta_seq_consist P (mrw_values P vs' (list_of obs')) obs'')", "by blast"], ["proof (state)\nthis:\n  \\<exists>obs' obs'' a'.\n     obs = lappend obs' obs'' \\<and>\n     ta_seq_consist P vs' obs' \\<and>\n     (obs' = LNil \\<longrightarrow>\n      (a', a)\n      \\<in> inv_image {(m, n). m < n}\n             (llength \\<circ>\n              ltakeWhile\n               (\\<lambda>(t, ta).\n                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n     (lfinite obs' \\<longrightarrow>\n      (\\<exists>s' ttas'.\n          obs'' =\n          lconcat\n           (lmap\n             (\\<lambda>a.\n                 case a of\n                 (t, ta) \\<Rightarrow>\n                   llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n          s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n          ta_seq_consist P vs\n           (llist_of\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas'))) \\<and>\n          mrw_values P vs' (list_of obs') =\n          mrw_values P vs\n           (concat\n             (map (\\<lambda>a.\n                      case a of\n                      (t, ta) \\<Rightarrow>\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas')) \\<and>\n          a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n      ta_seq_consist P (mrw_values P vs' (list_of obs')) obs'')\n\ngoal (1 subgoal):\n 1. obs \\<noteq> LNil \\<Longrightarrow>\n    obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs' obs'' a'.\n     obs = lappend obs' obs'' \\<and>\n     ta_seq_consist P vs' obs' \\<and>\n     (obs' = LNil \\<longrightarrow>\n      (a', a)\n      \\<in> inv_image {(m, n). m < n}\n             (llength \\<circ>\n              ltakeWhile\n               (\\<lambda>(t, ta).\n                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n     (lfinite obs' \\<longrightarrow>\n      (\\<exists>s' ttas'.\n          obs'' =\n          lconcat\n           (lmap\n             (\\<lambda>a.\n                 case a of\n                 (t, ta) \\<Rightarrow>\n                   llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n             (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n          s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n          ta_seq_consist P vs\n           (llist_of\n             (concat\n               (map (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 ttas'))) \\<and>\n          mrw_values P vs' (list_of obs') =\n          mrw_values P vs\n           (concat\n             (map (\\<lambda>a.\n                      case a of\n                      (t, ta) \\<Rightarrow>\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas')) \\<and>\n          a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n      ta_seq_consist P (mrw_values P vs' (list_of obs')) obs'')\n\ngoal (1 subgoal):\n 1. obs = LNil \\<or>\n    (\\<exists>obs' obs'' a'.\n        obs = lappend obs' obs'' \\<and>\n        ta_seq_consist P vs' obs' \\<and>\n        (obs' = LNil \\<longrightarrow>\n         (a', a)\n         \\<in> inv_image {(m, n). m < n}\n                (llength \\<circ>\n                 ltakeWhile\n                  (\\<lambda>(t, ta).\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n        (lfinite obs' \\<longrightarrow>\n         (\\<exists>s' ttas'.\n             obs'' =\n             lconcat\n              (lmap\n                (\\<lambda>a.\n                    case a of\n                    (t, ta) \\<Rightarrow>\n                      llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n             s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n             ta_seq_consist P vs\n              (llist_of\n                (concat\n                  (map (\\<lambda>a.\n                           case a of\n                           (t, ta) \\<Rightarrow>\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                    ttas'))) \\<and>\n             mrw_values P vs' (list_of obs') =\n             mrw_values P vs\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas')) \\<and>\n             a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n         ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))", ".."], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs'' a'.\n      obs = lappend obs' obs'' \\<and>\n      ta_seq_consist P vs' obs' \\<and>\n      (obs' = LNil \\<longrightarrow>\n       (a', a)\n       \\<in> inv_image {(m, n). m < n}\n              (llength \\<circ>\n               ltakeWhile\n                (\\<lambda>(t, ta).\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>s' ttas'.\n           obs'' =\n           lconcat\n            (lmap\n              (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n           s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n           ta_seq_consist P vs\n            (llist_of\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas'))) \\<and>\n           mrw_values P vs' (list_of obs') =\n           mrw_values P vs\n            (concat\n              (map (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')) \\<and>\n           a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n       ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs'' a'.\n      obs = lappend obs' obs'' \\<and>\n      ta_seq_consist P vs' obs' \\<and>\n      (obs' = LNil \\<longrightarrow>\n       (a', a)\n       \\<in> inv_image {(m, n). m < n}\n              (llength \\<circ>\n               ltakeWhile\n                (\\<lambda>(t, ta).\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>s' ttas'.\n           obs'' =\n           lconcat\n            (lmap\n              (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n           s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n           ta_seq_consist P vs\n            (llist_of\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas'))) \\<and>\n           mrw_values P vs' (list_of obs') =\n           mrw_values P vs\n            (concat\n              (map (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')) \\<and>\n           a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n       ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs = LNil \\<or>\n  (\\<exists>obs' obs'' a'.\n      obs = lappend obs' obs'' \\<and>\n      ta_seq_consist P vs' obs' \\<and>\n      (obs' = LNil \\<longrightarrow>\n       (a', a)\n       \\<in> inv_image {(m, n). m < n}\n              (llength \\<circ>\n               ltakeWhile\n                (\\<lambda>(t, ta).\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> = []))) \\<and>\n      (lfinite obs' \\<longrightarrow>\n       (\\<exists>s' ttas'.\n           obs'' =\n           lconcat\n            (lmap\n              (\\<lambda>a.\n                  case a of\n                  (t, ta) \\<Rightarrow>\n                    llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              (complete_sc s' (mrw_values P vs' (list_of obs')))) \\<and>\n           s -\\<triangleright>ttas'\\<rightarrow>* s' \\<and>\n           ta_seq_consist P vs\n            (llist_of\n              (concat\n                (map (\\<lambda>a.\n                         case a of\n                         (t, ta) \\<Rightarrow>\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas'))) \\<and>\n           mrw_values P vs' (list_of obs') =\n           mrw_values P vs\n            (concat\n              (map (\\<lambda>a.\n                       case a of\n                       (t, ta) \\<Rightarrow>\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas')) \\<and>\n           a' = complete_sc s' (mrw_values P vs' (list_of obs'))) \\<or>\n       ta_seq_consist P (mrw_values P vs' (list_of obs')) obs''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ta_seq_consist P vs' obs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sequential_completion_Runs:\n  assumes \"sc_completion s vs\"\n  and \"\\<And>vs ln. ta_seq_consist P vs (llist_of (convert_RA ln))\"\n  shows \"\\<exists>ttas. mthr.Runs s ttas \\<and> ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ttas.\n       mthr.Runs s ttas \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas))", "using complete_sc_ta_seq_consist[OF assms] complete_sc_in_Runs[OF assms]"], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (complete_sc s vs)))\n  mthr.Runs s (complete_sc s vs)\n\ngoal (1 subgoal):\n 1. \\<exists>ttas.\n       mthr.Runs s ttas \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas))", "by blast"], ["", "definition cut_and_update :: \"('l, 'thread_id, 'x, 'm, 'w) state \\<Rightarrow> ('addr \\<times> addr_loc \\<rightharpoonup> 'addr val \\<times> bool) \\<Rightarrow> bool\"\nwhere\n  \"cut_and_update s vs \\<longleftrightarrow>\n   (\\<forall>ttas s' t x ta x' m'.\n      s -\\<triangleright>ttas\\<rightarrow>* s' \\<longrightarrow> ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) \\<longrightarrow>\n      thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow> t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m') \\<longrightarrow> actions_ok s' t ta \\<longrightarrow> \n   (\\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and>\n                   ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                   eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))))\""], ["", "lemma cut_and_updateI[intro?]:\n  \"(\\<And>ttas s' t x ta x' m'. \n     \\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)));\n       thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m'); actions_ok s' t ta \\<rbrakk>\n      \\<Longrightarrow> \\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and> \n                       ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))))\n    \\<Longrightarrow> cut_and_update s vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ttas s' t x ta x' m'.\n        \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n         ta_seq_consist P vs\n          (llist_of\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)));\n         thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n         t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n         actions_ok s' t ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' x'' m''.\n                             t \\<turnstile> \\<langle>x, shr\n                   s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                             actions_ok s' t ta' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas)))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                             eq_upto_seq_inconsist P\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas)))) \\<Longrightarrow>\n    cut_and_update s vs", "unfolding cut_and_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ttas s' t x ta x' m'.\n        \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n         ta_seq_consist P vs\n          (llist_of\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)));\n         thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n         t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n         actions_ok s' t ta\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' x'' m''.\n                             t \\<turnstile> \\<langle>x, shr\n                   s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                             actions_ok s' t ta' \\<and>\n                             ta_seq_consist P\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas)))\n                              (llist_of\n                                \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                             eq_upto_seq_inconsist P\n                              \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                              (mrw_values P vs\n                                (concat\n                                  (map (\\<lambda>(t, ta).\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                    ttas)))) \\<Longrightarrow>\n    \\<forall>ttas s' t x ta x' m'.\n       s -\\<triangleright>ttas\\<rightarrow>* s' \\<longrightarrow>\n       ta_seq_consist P vs\n        (llist_of\n          (concat\n            (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas))) \\<longrightarrow>\n       thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n       t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<longrightarrow>\n       actions_ok s' t ta \\<longrightarrow>\n       (\\<exists>ta' x'' m''.\n           t \\<turnstile> \\<langle>x, shr\n s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n           actions_ok s' t ta' \\<and>\n           ta_seq_consist P\n            (mrw_values P vs\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas)))\n            (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n           eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n            (mrw_values P vs\n              (concat\n                (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas))))", "by blast"], ["", "lemma cut_and_updateD:\n  \"\\<lbrakk> cut_and_update s vs; s -\\<triangleright>ttas\\<rightarrow>* s'; ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)));\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> (x, shr s') -ta\\<rightarrow> (x', m'); actions_ok s' t ta \\<rbrakk>\n  \\<Longrightarrow> \\<exists>ta' x'' m''. t \\<turnstile> (x, shr s') -ta'\\<rightarrow> (x'', m'') \\<and> actions_ok s' t ta' \\<and> \n                   ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                   eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cut_and_update s vs; s -\\<triangleright>ttas\\<rightarrow>* s';\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)));\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n     t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n     actions_ok s' t ta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' x'' m''.\n                         t \\<turnstile> \\<langle>x, shr\n               s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                         actions_ok s' t ta' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas)))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                         eq_upto_seq_inconsist P\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas)))", "unfolding cut_and_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ttas s' t x ta x' m'.\n                s -\\<triangleright>ttas\\<rightarrow>* s' \\<longrightarrow>\n                ta_seq_consist P vs\n                 (llist_of\n                   (concat\n                     (map (\\<lambda>(t, y).\n                              \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                       ttas))) \\<longrightarrow>\n                thr s' t =\n                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                t \\<turnstile> \\<langle>x, shr\n      s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<longrightarrow>\n                actions_ok s' t ta \\<longrightarrow>\n                (\\<exists>ta' x'' m''.\n                    t \\<turnstile> \\<langle>x, shr\n          s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                    actions_ok s' t ta' \\<and>\n                    ta_seq_consist P\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, y).\n                                  \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\n                     (llist_of\n                       \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, y).\n                                  \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas))));\n     s -\\<triangleright>ttas\\<rightarrow>* s';\n     ta_seq_consist P vs\n      (llist_of\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)));\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n     t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n     actions_ok s' t ta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' x'' m''.\n                         t \\<turnstile> \\<langle>x, shr\n               s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                         actions_ok s' t ta' \\<and>\n                         ta_seq_consist P\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas)))\n                          (llist_of\n                            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n                         eq_upto_seq_inconsist P\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                          (mrw_values P vs\n                            (concat\n                              (map (\\<lambda>(t, ta).\n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                ttas)))", "by blast"], ["", "lemma cut_and_update_imp_sc_completion:\n  \"cut_and_update s vs \\<Longrightarrow> sc_completion s vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut_and_update s vs \\<Longrightarrow> sc_completion s vs", "apply(rule sc_completionI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ttas s' t x ta x' m'.\n       \\<lbrakk>cut_and_update s vs;\n        s -\\<triangleright>ttas\\<rightarrow>* s';\n        ta_seq_consist P vs\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)));\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s' t ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x'' m''.\n                            t \\<turnstile> \\<langle>x, shr\n                  s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                            actions_ok s' t ta' \\<and>\n                            ta_seq_consist P\n                             (mrw_values P vs\n                               (concat\n                                 (map (\\<lambda>(t, ta).\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                   ttas)))\n                             (llist_of\n                               \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "apply(drule (5) cut_and_updateD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ttas s' t x ta x' m'.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        ta_seq_consist P vs\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               ttas)));\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        actions_ok s' t ta;\n        \\<exists>ta' x'' m''.\n           t \\<turnstile> \\<langle>x, shr\n s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n           actions_ok s' t ta' \\<and>\n           ta_seq_consist P\n            (mrw_values P vs\n              (concat\n                (map (\\<lambda>(t, ta).\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas)))\n            (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n           eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n            (mrw_values P vs\n              (concat\n                (map (\\<lambda>(t, ta).\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                  ttas)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' x'' m''.\n                            t \\<turnstile> \\<langle>x, shr\n                  s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n                            actions_ok s' t ta' \\<and>\n                            ta_seq_consist P\n                             (mrw_values P vs\n                               (concat\n                                 (map (\\<lambda>(t, ta).\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                                   ttas)))\n                             (llist_of\n                               \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sequential_completion:\n  assumes cut_and_update: \"cut_and_update s vs\"\n  and ta_seq_consist_convert_RA: \"\\<And>vs ln. ta_seq_consist P vs (llist_of (convert_RA ln))\"\n  and Red: \"s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and sc: \"ta_seq_consist P vs (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\"\n  and red: \"s' -t\\<triangleright>ta\\<rightarrow> s''\"\n  shows\n  \"\\<exists>ta' ttas'. mthr.Runs s' (LCons (t, ta') ttas') \\<and> \n     ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and> \n     eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "from red"], ["proof (chain)\npicking this:\n  s' -t\\<triangleright>ta\\<rightarrow> s''", "obtain ta' s''' \n    where red': \"redT s' (t, ta') s'''\"\n    and sc': \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (lappend (llist_of ttas) (LCons (t, ta') LNil))))\"\n    and eq: \"eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\""], ["proof (prove)\nusing this:\n  s' -t\\<triangleright>ta\\<rightarrow> s''\n\ngoal (1 subgoal):\n 1. (\\<And>ta' s'''.\n        \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n         ta_seq_consist P vs\n          (lconcat\n            (lmap\n              (\\<lambda>(t, ta).\n                  llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n         eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (redT_normal x x' m')"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t ta\n  redT_upd s' t ta x' m' s''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "note ts't = \\<open>thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>\n      and red = \\<open>t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\\<close>\n      and aok = \\<open>actions_ok s' t ta\\<close>\n      and s'' = \\<open>redT_upd s' t ta x' m' s''\\<close>"], ["proof (state)\nthis:\n  thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  actions_ok s' t ta\n  redT_upd s' t ta x' m' s''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "from cut_and_updateD[OF cut_and_update, OF Red sc ts't red aok]"], ["proof (chain)\npicking this:\n  \\<exists>ta' x'' m''.\n     t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n     actions_ok s' t ta' \\<and>\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)))\n      (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n     eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)))", "obtain ta' x'' m'' where red: \"t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle>\"\n      and sc': \"ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas))) (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\"\n      and eq: \"eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\"\n      and aok: \"actions_ok s' t ta'\""], ["proof (prove)\nusing this:\n  \\<exists>ta' x'' m''.\n     t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<and>\n     actions_ok s' t ta' \\<and>\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)))\n      (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>) \\<and>\n     eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)))\n\ngoal (1 subgoal):\n 1. (\\<And>ta' x'' m''.\n        \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n       s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n         ta_seq_consist P\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)))\n          (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>);\n         eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                ttas)));\n         actions_ok s' t ta'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\n   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\n  eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n  actions_ok s' t ta'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain ws''' where \"redT_updWs t (wset s') \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ws'''.\n        redT_updWs t (wset s') \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>\n         ws''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using redT_updWs_total"], ["proof (prove)\nusing this:\n  \\<exists>ws'. redT_updWs ?t ?ws ?was ws'\n\ngoal (1 subgoal):\n 1. (\\<And>ws'''.\n        redT_updWs t (wset s') \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>\n         ws''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  redT_updWs t (wset s') \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  redT_updWs t (wset s') \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws'''", "obtain s''' where s''': \"redT_upd s' t ta' x'' m'' s'''\""], ["proof (prove)\nusing this:\n  redT_updWs t (wset s') \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws'''\n\ngoal (1 subgoal):\n 1. (\\<And>s'''.\n        redT_upd s' t ta' x'' m'' s''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  redT_upd s' t ta' x'' m'' s'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "with red \\<open>thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close> aok"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t ta'\n  redT_upd s' t ta' x'' m'' s'''", "have \"s' -t\\<triangleright>ta'\\<rightarrow> s'''\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta'\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s' t ta'\n  redT_upd s' t ta' x'' m'' s'''\n\ngoal (1 subgoal):\n 1. s' -t\\<triangleright>ta'\\<rightarrow> s'''", "by(rule redT.redT_normal)"], ["proof (state)\nthis:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "from sc sc'"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\n   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)", "have \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (lappend (llist_of ttas) (LCons (t, ta') LNil))))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, y). \\<lbrace>y\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\n   (llist_of \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (lappend (llist_of ttas) (LCons (t, ta') LNil))))", "by(auto simp add: lmap_lappend_distrib ta_seq_consist_lappend split_def lconcat_llist_of[symmetric] o_def list_of_lconcat)"], ["proof (state)\nthis:\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<turnstile> \\<langle>x, shr s'\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s' t ta;\n        redT_upd s' t ta x' m' s''\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))", "show thesis"], ["proof (prove)\nusing this:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))\n\ngoal (1 subgoal):\n 1. thesis", "using eq"], ["proof (prove)\nusing this:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))\n  eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (redT_acquire x ln n)"], ["proof (state)\nthis:\n  ta = (K$ [], [], [], [], [], convert_RA n)\n  thr s' t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s' t)\n  may_acquire_all (locks s') t n\n  0 < n $ ln\n  s'' =\n  (acquire_all (locks s') t n,\n   (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s', interrupts s')\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (lappend (llist_of ttas) (LCons (t, ta) LNil))))\"\n      and \"eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas)))\""], ["proof (prove)\nusing this:\n  ta = (K$ [], [], [], [], [], convert_RA n)\n  thr s' t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s' t)\n  may_acquire_all (locks s') t n\n  0 < n $ ln\n  s'' =\n  (acquire_all (locks s') t n,\n   (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s', interrupts s')\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (lappend (llist_of ttas) (LCons (t, ta) LNil)))) &&&\n    eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas)))", "using sc"], ["proof (prove)\nusing this:\n  ta = (K$ [], [], [], [], [], convert_RA n)\n  thr s' t = \\<lfloor>(x, n)\\<rfloor>\n  \\<not> waiting (wset s' t)\n  may_acquire_all (locks s') t n\n  0 < n $ ln\n  s'' =\n  (acquire_all (locks s') t n,\n   (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s', interrupts s')\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (lappend (llist_of ttas) (LCons (t, ta) LNil)))) &&&\n    eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           ttas)))", "by(simp_all add: lmap_lappend_distrib ta_seq_consist_lappend split_def lconcat_llist_of[symmetric] o_def list_of_lconcat ta_seq_consist_convert_RA ta_seq_consist_imp_eq_upto_seq_inconsist_refl)"], ["proof (state)\nthis:\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta) LNil))))\n  eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>\\<And>ta' s'''.\n                   \\<lbrakk>s' -t\\<triangleright>ta'\\<rightarrow> s''';\n                    ta_seq_consist P vs\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (lappend (llist_of ttas) (LCons (t, ta') LNil))));\n                    eq_upto_seq_inconsist P\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n                     \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n                     (mrw_values P vs\n                       (concat\n                         (map (\\<lambda>(t, ta).\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                           ttas)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s' t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s' t);\n        may_acquire_all (locks s') t ln; 0 < ln $ n;\n        s'' =\n        (acquire_all (locks s') t ln,\n         (thr s'(t \\<mapsto> (x, no_wait_locks)), shr s'), wset s',\n         interrupts s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "with red"], ["proof (chain)\npicking this:\n  s' -t\\<triangleright>ta\\<rightarrow> s''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta) LNil))))\n  eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))", "show thesis"], ["proof (prove)\nusing this:\n  s' -t\\<triangleright>ta\\<rightarrow> s''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta) LNil))))\n  eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))\n  eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "txt \\<open>Now, find a sequentially consistent completion from @{term \"s'''\"} onwards.\\<close>"], ["proof (state)\nthis:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))\n  eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "from Red red'"], ["proof (chain)\npicking this:\n  s -\\<triangleright>ttas\\<rightarrow>* s'\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''", "have Red': \"s -\\<triangleright>ttas @ [(t, ta')]\\<rightarrow>* s'''\""], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas\\<rightarrow>* s'\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n\ngoal (1 subgoal):\n 1. s -\\<triangleright>ttas @ [(t, ta')]\\<rightarrow>* s'''", "unfolding RedT_def"], ["proof (prove)\nusing this:\n  mthr.Trsys s ttas s'\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n\ngoal (1 subgoal):\n 1. mthr.Trsys s (ttas @ [(t, ta')]) s'''", "by(auto intro: rtrancl3p_step)"], ["proof (state)\nthis:\n  s -\\<triangleright>ttas @ [(t, ta')]\\<rightarrow>* s'''\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "from sc sc'"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))", "have \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (llist_of (ttas @ [(t, ta')]))))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (llist_of (ttas @ [(t, ta')]))))", "by(simp add: o_def split_def lappend_llist_of_llist_of[symmetric])"], ["proof (state)\nthis:\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (llist_of (ttas @ [(t, ta')]))))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "with cut_and_update_imp_sc_completion[OF cut_and_update] Red'"], ["proof (chain)\npicking this:\n  sc_completion s vs\n  s -\\<triangleright>ttas @ [(t, ta')]\\<rightarrow>* s'''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (llist_of (ttas @ [(t, ta')]))))", "have \"sc_completion s''' (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (ttas @ [(t, ta')]))))\""], ["proof (prove)\nusing this:\n  sc_completion s vs\n  s -\\<triangleright>ttas @ [(t, ta')]\\<rightarrow>* s'''\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (llist_of (ttas @ [(t, ta')]))))\n\ngoal (1 subgoal):\n 1. sc_completion s'''\n     (mrw_values P vs\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ttas @ [(t, ta')]))))", "by(rule sc_completion_shift)"], ["proof (state)\nthis:\n  sc_completion s'''\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ [(t, ta')]))))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "from sequential_completion_Runs[OF this ta_seq_consist_convert_RA]"], ["proof (chain)\npicking this:\n  \\<exists>ttasa.\n     mthr.Runs s''' ttasa \\<and>\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (ttas @ [(t, ta')]))))\n      (lconcat\n        (lmap\n          (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttasa))", "obtain ttas' where \\<tau>Runs: \"mthr.Runs s''' ttas'\"\n    and sc'': \"ta_seq_consist P (mrw_values P vs (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (ttas @ [(t, ta')])))) \n                                (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) ttas'))\""], ["proof (prove)\nusing this:\n  \\<exists>ttasa.\n     mthr.Runs s''' ttasa \\<and>\n     ta_seq_consist P\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (ttas @ [(t, ta')]))))\n      (lconcat\n        (lmap\n          (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          ttasa))\n\ngoal (1 subgoal):\n 1. (\\<And>ttas'.\n        \\<lbrakk>mthr.Runs s''' ttas';\n         ta_seq_consist P\n          (mrw_values P vs\n            (concat\n              (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                (ttas @ [(t, ta')]))))\n          (lconcat\n            (lmap\n              (\\<lambda>(t, ta).\n                  llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas'))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mthr.Runs s''' ttas'\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ [(t, ta')]))))\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       ttas'))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "from red' \\<tau>Runs"], ["proof (chain)\npicking this:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n  mthr.Runs s''' ttas'", "have \"mthr.Runs s' (LCons (t, ta') ttas')\""], ["proof (prove)\nusing this:\n  s' -t\\<triangleright>ta'\\<rightarrow> s'''\n  mthr.Runs s''' ttas'\n\ngoal (1 subgoal):\n 1. mthr.Runs s' (LCons (t, ta') ttas')", ".."], ["proof (state)\nthis:\n  mthr.Runs s' (LCons (t, ta') ttas')\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "moreover"], ["proof (state)\nthis:\n  mthr.Runs s' (LCons (t, ta') ttas')\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "from sc sc' sc''"], ["proof (chain)\npicking this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ [(t, ta')]))))\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       ttas'))", "have \"ta_seq_consist P vs (lconcat (lmap (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (lappend (llist_of ttas) (LCons (t, ta') ttas'))))\""], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') LNil))))\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ [(t, ta')]))))\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       ttas'))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (lappend (llist_of ttas) (LCons (t, ta') ttas'))))", "unfolding lmap_lappend_distrib lconcat_lappend"], ["proof (prove)\nusing this:\n  ta_seq_consist P vs\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n  ta_seq_consist P vs\n   (lconcat\n     (lappend\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (llist_of ttas))\n       (lmap\n         (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (LCons (t, ta') LNil))))\n  ta_seq_consist P\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ttas @ [(t, ta')]))))\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       ttas'))\n\ngoal (1 subgoal):\n 1. ta_seq_consist P vs\n     (lconcat\n       (lappend\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (llist_of ttas))\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (LCons (t, ta') ttas'))))", "by(simp add: o_def ta_seq_consist_lappend split_def list_of_lconcat)"], ["proof (state)\nthis:\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') ttas'))))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "ultimately"], ["proof (chain)\npicking this:\n  mthr.Runs s' (LCons (t, ta') ttas')\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') ttas'))))", "show ?thesis"], ["proof (prove)\nusing this:\n  mthr.Runs s' (LCons (t, ta') ttas')\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') ttas'))))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "using eq"], ["proof (prove)\nusing this:\n  mthr.Runs s' (LCons (t, ta') ttas')\n  ta_seq_consist P vs\n   (lconcat\n     (lmap\n       (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (lappend (llist_of ttas) (LCons (t, ta') ttas'))))\n  eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n   \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n   (mrw_values P vs\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         ttas)))\n\ngoal (1 subgoal):\n 1. \\<exists>ta' ttas'.\n       mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n       ta_seq_consist P vs\n        (lconcat\n          (lmap\n            (\\<lambda>(t, ta).\n                llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n       eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n        \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n        (mrw_values P vs\n          (concat\n            (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n              ttas)))", "by blast"], ["proof (state)\nthis:\n  \\<exists>ta' ttas'.\n     mthr.Runs s' (LCons (t, ta') ttas') \\<and>\n     ta_seq_consist P vs\n      (lconcat\n        (lmap\n          (\\<lambda>(t, ta). llist_of \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n          (lappend (llist_of ttas) (LCons (t, ta') ttas')))) \\<and>\n     eq_upto_seq_inconsist P \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>o\\<^esub>\n      (mrw_values P vs\n        (concat\n          (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n            ttas)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}