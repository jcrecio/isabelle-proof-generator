{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWLifting.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma ts_okI:\n  \"\\<lbrakk> \\<And>t x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> P t x m \\<rbrakk> \\<Longrightarrow> ts_ok P ts m\"", "lemma ts_okE:\n  \"\\<lbrakk> ts_ok P ts m; \\<lbrakk> \\<And>t x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> P t x m \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"", "lemma ts_okD:\n  \"\\<And>ln. \\<lbrakk> ts_ok P ts m; ts t = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> P t x m\"", "lemma ts_ok_True [simp]:\n  \"ts_ok (\\<lambda>t m x. True) ts m\"", "lemma ts_ok_conj:\n  \"ts_ok (\\<lambda>t x m. P t x m \\<and> Q t x m) = (\\<lambda>ts m. ts_ok P ts m \\<and> ts_ok Q ts m)\"", "lemma ts_ok_mono:\n  \"\\<lbrakk> ts_ok P ts m; \\<And>t x. P t x m \\<Longrightarrow> Q t x m \\<rbrakk> \\<Longrightarrow> ts_ok Q ts m\"", "lemma ts_invI:\n  \"\\<lbrakk> \\<And>t x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> \\<exists>i. I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m \\<rbrakk> \\<Longrightarrow> ts_inv P I ts m\"", "lemma ts_invE:\n  \"\\<lbrakk> ts_inv P I ts m; \\<forall>t x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<longrightarrow> (\\<exists>i. I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m) \\<Longrightarrow> R \\<rbrakk> \\<Longrightarrow> R\"", "lemma ts_invD:\n  \"\\<And>ln. \\<lbrakk> ts_inv P I ts m; ts t = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> \\<exists>i. I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m\"", "lemma ts_inv_okI:\n  \"(\\<And>t. ts t = None \\<longleftrightarrow> I t = None) \\<Longrightarrow> ts_inv_ok ts I\"", "lemma ts_inv_okI2:\n  \"(\\<And>t. (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) \\<longleftrightarrow> (\\<exists>v. I t = \\<lfloor>v\\<rfloor>)) \\<Longrightarrow> ts_inv_ok ts I\"", "lemma ts_inv_okE:\n  \"\\<lbrakk> ts_inv_ok ts I; \\<forall>t. ts t = None \\<longleftrightarrow> I t = None \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma ts_inv_okE2:\n  \"\\<lbrakk> ts_inv_ok ts I; \\<forall>t. (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) \\<longleftrightarrow> (\\<exists>v. I t = \\<lfloor>v\\<rfloor>) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma ts_inv_okD:\n  \"ts_inv_ok ts I \\<Longrightarrow> (ts t = None) \\<longleftrightarrow> (I t = None)\"", "lemma ts_inv_okD2:\n  \"ts_inv_ok ts I \\<Longrightarrow> (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) \\<longleftrightarrow> (\\<exists>v. I t = \\<lfloor>v\\<rfloor>)\"", "lemma ts_inv_ok_conv_dom_eq:\n  \"ts_inv_ok ts I \\<longleftrightarrow> (dom ts = dom I)\"", "lemma ts_inv_ok_upd_ts:\n  \"\\<lbrakk> ts t = \\<lfloor>x\\<rfloor>; ts_inv_ok ts I \\<rbrakk> \\<Longrightarrow> ts_inv_ok (ts(t \\<mapsto> x')) I\"", "lemma ts_inv_upd_map_option:\n  assumes \"ts_inv P I ts m\"\n  and \"\\<And>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> P (the (I t)) t (fst (f (x, ln))) m\"\n  shows \"ts_inv P I (ts(t := (map_option f (ts t)))) m\"", "lemma upd_invs_append [simp]:\n  \"upd_invs I P (xs @ ys) = upd_invs (upd_invs I P xs) P ys\"", "lemma ts_inv_ok_upd_inv':\n \"ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updT' ts ta) (upd_inv I P ta)\"", "lemma ts_inv_ok_upd_invs':\n  \"ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas)\"", "lemma ts_inv_ok_upd_inv:\n \"ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updT ts ta) (upd_inv I P ta)\"", "lemma ts_inv_ok_upd_invs:\n  \"ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas)\"", "lemma ts_inv_ok_inv_ext_upd_inv:\n  \"\\<lbrakk> ts_inv_ok ts I; thread_ok ts ta \\<rbrakk> \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_inv I P ta\"", "lemma ts_inv_ok_inv_ext_upd_invs:\n  \"\\<lbrakk> ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n  \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas\"", "lemma upd_invs_Some:\n  \"\\<lbrakk> thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>; ts t = \\<lfloor>x\\<rfloor> \\<rbrakk> \\<Longrightarrow> upd_invs I Q tas t = \\<lfloor>i\\<rfloor>\"", "lemma upd_inv_Some_eq:\n  \"\\<lbrakk> thread_ok ts ta; ts t = \\<lfloor>x\\<rfloor> \\<rbrakk> \\<Longrightarrow> upd_inv I Q ta t = I t\"", "lemma upd_invs_Some_eq: \"\\<lbrakk> thread_oks ts tas; ts t = \\<lfloor>x\\<rfloor> \\<rbrakk> \\<Longrightarrow> upd_invs I Q tas t = I t\"", "lemma SOME_new_thread_upd_invs:\n  assumes Qsome: \"Q (SOME i. Q i t x m) t x m\"\n  and nt: \"NewThread t x m \\<in> set tas\"\n  and cct: \"thread_oks ts tas\"\n  shows \"\\<exists>i. upd_invs I Q tas t = \\<lfloor>i\\<rfloor> \\<and> Q i t x m\"", "lemma ts_ok_into_ts_inv_const:\n  assumes \"ts_ok P ts m\"\n  obtains I where \"ts_inv (\\<lambda>_. P) I ts m\"", "lemma ts_inv_const_into_ts_ok:\n  \"ts_inv (\\<lambda>_. P) I ts m \\<Longrightarrow> ts_ok P ts m\"", "lemma ts_inv_into_ts_ok_Ex:\n  \"ts_inv Q I ts m \\<Longrightarrow> ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m\"", "lemma ts_ok_Ex_into_ts_inv:\n  \"ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m \\<Longrightarrow> \\<exists>I. ts_inv Q I ts m\"", "lemma Ex_ts_inv_conv_ts_ok:\n  \"(\\<exists>I. ts_inv Q I ts m) \\<longleftrightarrow> (ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m)\""], "translations": [["", "lemma ts_okI:\n  \"\\<lbrakk> \\<And>t x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> P t x m \\<rbrakk> \\<Longrightarrow> ts_ok P ts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t x ln.\n        ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow>\n        P t x m) \\<Longrightarrow>\n    ts_ok P ts m", "by(auto simp add: ts_ok_def)"], ["", "lemma ts_okE:\n  \"\\<lbrakk> ts_ok P ts m; \\<lbrakk> \\<And>t x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> P t x m \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts_ok P ts m;\n     (\\<And>t x ln.\n         ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow>\n         P t x m) \\<Longrightarrow>\n     Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by(auto simp add: ts_ok_def)"], ["", "lemma ts_okD:\n  \"\\<And>ln. \\<lbrakk> ts_ok P ts m; ts t = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> P t x m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>ts_ok P ts m; ts t = \\<lfloor>(x, ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P t x m", "by(auto simp add: ts_ok_def)"], ["", "lemma ts_ok_True [simp]:\n  \"ts_ok (\\<lambda>t m x. True) ts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t m x. True) ts m", "by(auto intro: ts_okI)"], ["", "lemma ts_ok_conj:\n  \"ts_ok (\\<lambda>t x m. P t x m \\<and> Q t x m) = (\\<lambda>ts m. ts_ok P ts m \\<and> ts_ok Q ts m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t x m. P t x m \\<and> Q t x m) =\n    (\\<lambda>ts m. ts_ok P ts m \\<and> ts_ok Q ts m)", "by(auto intro: ts_okI intro!: ext dest: ts_okD)"], ["", "lemma ts_ok_mono:\n  \"\\<lbrakk> ts_ok P ts m; \\<And>t x. P t x m \\<Longrightarrow> Q t x m \\<rbrakk> \\<Longrightarrow> ts_ok Q ts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts_ok P ts m;\n     \\<And>t x. P t x m \\<Longrightarrow> Q t x m\\<rbrakk>\n    \\<Longrightarrow> ts_ok Q ts m", "by(auto intro!: ts_okI dest: ts_okD)"], ["", "text\\<open>Lifting for properites, that also require additional data that does not change during execution\\<close>"], ["", "definition\n  ts_inv :: \"('i \\<Rightarrow> 't \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool) \\<Rightarrow> ('t \\<rightharpoonup> 'i) \\<Rightarrow> ('l,'t,'x) thread_info \\<Rightarrow> 'm \\<Rightarrow> bool\"\nwhere\n  \"\\<And>ln. ts_inv P I ts m \\<equiv> \\<forall>t. case (ts t) of None \\<Rightarrow> True | \\<lfloor>(x, ln)\\<rfloor> \\<Rightarrow> \\<exists>i. I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m\""], ["", "lemma ts_invI:\n  \"\\<lbrakk> \\<And>t x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> \\<exists>i. I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m \\<rbrakk> \\<Longrightarrow> ts_inv P I ts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t x ln.\n        ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow>\n        \\<exists>i.\n           I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m) \\<Longrightarrow>\n    ts_inv P I ts m", "by(simp add: ts_inv_def)"], ["", "lemma ts_invE:\n  \"\\<lbrakk> ts_inv P I ts m; \\<forall>t x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<longrightarrow> (\\<exists>i. I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m) \\<Longrightarrow> R \\<rbrakk> \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts_inv P I ts m;\n     \\<forall>t x ln.\n        ts t = \\<lfloor>(x, ln)\\<rfloor> \\<longrightarrow>\n        (\\<exists>i.\n            I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m) \\<Longrightarrow>\n     R\\<rbrakk>\n    \\<Longrightarrow> R", "by(auto simp add: ts_inv_def)"], ["", "lemma ts_invD:\n  \"\\<And>ln. \\<lbrakk> ts_inv P I ts m; ts t = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> \\<exists>i. I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>ts_inv P I ts m; ts t = \\<lfloor>(x, ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            I t = \\<lfloor>i\\<rfloor> \\<and> P i t x m", "by(auto simp add: ts_inv_def)"], ["", "text \\<open>Wellformedness properties for lifting\\<close>"], ["", "definition\n  ts_inv_ok :: \"('l,'t,'x) thread_info \\<Rightarrow> ('t \\<rightharpoonup> 'i) \\<Rightarrow> bool\"\nwhere\n  \"ts_inv_ok ts I \\<equiv> \\<forall>t. ts t = None \\<longleftrightarrow> I t = None\""], ["", "lemma ts_inv_okI:\n  \"(\\<And>t. ts t = None \\<longleftrightarrow> I t = None) \\<Longrightarrow> ts_inv_ok ts I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. (ts t = None) = (I t = None)) \\<Longrightarrow> ts_inv_ok ts I", "by(clarsimp simp add: ts_inv_ok_def)"], ["", "lemma ts_inv_okI2:\n  \"(\\<And>t. (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) \\<longleftrightarrow> (\\<exists>v. I t = \\<lfloor>v\\<rfloor>)) \\<Longrightarrow> ts_inv_ok ts I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) =\n        (\\<exists>v. I t = \\<lfloor>v\\<rfloor>)) \\<Longrightarrow>\n    ts_inv_ok ts I", "by(force simp add: ts_inv_ok_def)"], ["", "lemma ts_inv_okE:\n  \"\\<lbrakk> ts_inv_ok ts I; \\<forall>t. ts t = None \\<longleftrightarrow> I t = None \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts_inv_ok ts I;\n     \\<forall>t. (ts t = None) = (I t = None) \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by(force simp add: ts_inv_ok_def)"], ["", "lemma ts_inv_okE2:\n  \"\\<lbrakk> ts_inv_ok ts I; \\<forall>t. (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) \\<longleftrightarrow> (\\<exists>v. I t = \\<lfloor>v\\<rfloor>) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts_inv_ok ts I;\n     \\<forall>t.\n        (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) =\n        (\\<exists>v. I t = \\<lfloor>v\\<rfloor>) \\<Longrightarrow>\n     P\\<rbrakk>\n    \\<Longrightarrow> P", "by(force simp add: ts_inv_ok_def)"], ["", "lemma ts_inv_okD:\n  \"ts_inv_ok ts I \\<Longrightarrow> (ts t = None) \\<longleftrightarrow> (I t = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I \\<Longrightarrow> (ts t = None) = (I t = None)", "by(erule ts_inv_okE, blast)"], ["", "lemma ts_inv_okD2:\n  \"ts_inv_ok ts I \\<Longrightarrow> (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) \\<longleftrightarrow> (\\<exists>v. I t = \\<lfloor>v\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I \\<Longrightarrow>\n    (\\<exists>v. ts t = \\<lfloor>v\\<rfloor>) =\n    (\\<exists>v. I t = \\<lfloor>v\\<rfloor>)", "by(erule ts_inv_okE2, blast)"], ["", "lemma ts_inv_ok_conv_dom_eq:\n  \"ts_inv_ok ts I \\<longleftrightarrow> (dom ts = dom I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (dom ts = dom I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (dom ts = dom I)", "have \"ts_inv_ok ts I \\<longleftrightarrow> (\\<forall>t. ts t = None \\<longleftrightarrow> I t = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (\\<forall>t. (ts t = None) = (I t = None))", "unfolding ts_inv_ok_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t. (ts t = None) = (I t = None)) =\n    (\\<forall>t. (ts t = None) = (I t = None))", "by blast"], ["proof (state)\nthis:\n  ts_inv_ok ts I = (\\<forall>t. (ts t = None) = (I t = None))\n\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (dom ts = dom I)", "also"], ["proof (state)\nthis:\n  ts_inv_ok ts I = (\\<forall>t. (ts t = None) = (I t = None))\n\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (dom ts = dom I)", "have \"\\<dots> \\<longleftrightarrow> (\\<forall>t. t \\<in> - dom ts \\<longleftrightarrow> t \\<in> - dom I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t. (ts t = None) = (I t = None)) =\n    (\\<forall>t. (t \\<in> - dom ts) = (t \\<in> - dom I))", "by(force)"], ["proof (state)\nthis:\n  (\\<forall>t. (ts t = None) = (I t = None)) =\n  (\\<forall>t. (t \\<in> - dom ts) = (t \\<in> - dom I))\n\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (dom ts = dom I)", "also"], ["proof (state)\nthis:\n  (\\<forall>t. (ts t = None) = (I t = None)) =\n  (\\<forall>t. (t \\<in> - dom ts) = (t \\<in> - dom I))\n\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (dom ts = dom I)", "have \"\\<dots> \\<longleftrightarrow> dom ts = dom I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t. (t \\<in> - dom ts) = (t \\<in> - dom I)) = (dom ts = dom I)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>t. (t \\<in> - dom ts) = (t \\<in> - dom I)) = (dom ts = dom I)\n\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (dom ts = dom I)", "finally"], ["proof (chain)\npicking this:\n  ts_inv_ok ts I = (dom ts = dom I)", "show ?thesis"], ["proof (prove)\nusing this:\n  ts_inv_ok ts I = (dom ts = dom I)\n\ngoal (1 subgoal):\n 1. ts_inv_ok ts I = (dom ts = dom I)", "."], ["proof (state)\nthis:\n  ts_inv_ok ts I = (dom ts = dom I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_inv_ok_upd_ts:\n  \"\\<lbrakk> ts t = \\<lfloor>x\\<rfloor>; ts_inv_ok ts I \\<rbrakk> \\<Longrightarrow> ts_inv_ok (ts(t \\<mapsto> x')) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = \\<lfloor>x\\<rfloor>; ts_inv_ok ts I\\<rbrakk>\n    \\<Longrightarrow> ts_inv_ok (ts(t \\<mapsto> x')) I", "by(auto dest!: ts_inv_okD intro!: ts_inv_okI split: if_splits)"], ["", "lemma ts_inv_upd_map_option:\n  assumes \"ts_inv P I ts m\"\n  and \"\\<And>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> P (the (I t)) t (fst (f (x, ln))) m\"\n  shows \"ts_inv P I (ts(t := (map_option f (ts t)))) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv P I (ts(t := map_option f (ts t))) m", "using assms"], ["proof (prove)\nusing this:\n  ts_inv P I ts m\n  ts t = \\<lfloor>(?x, ?ln)\\<rfloor> \\<Longrightarrow>\n  P (the (I t)) t (fst (f (?x, ?ln))) m\n\ngoal (1 subgoal):\n 1. ts_inv P I (ts(t := map_option f (ts t))) m", "by(fastforce intro!: ts_invI split: if_split_asm dest: ts_invD)"], ["", "fun upd_inv :: \"('t \\<rightharpoonup> 'i) \\<Rightarrow> ('i \\<Rightarrow> 't \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool) \\<Rightarrow> ('t,'x,'m) new_thread_action \\<Rightarrow> ('t \\<rightharpoonup> 'i)\"\nwhere\n  \"upd_inv I P (NewThread t x m) = I(t \\<mapsto> SOME i. P i t x m)\"\n| \"upd_inv I P _ = I\""], ["", "fun upd_invs :: \"('t \\<rightharpoonup> 'i) \\<Rightarrow> ('i \\<Rightarrow> 't \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool) \\<Rightarrow> ('t,'x,'m) new_thread_action list \\<Rightarrow> ('t \\<rightharpoonup> 'i)\"\nwhere\n  \"upd_invs I P [] = I\"\n| \"upd_invs I P (ta#tas) = upd_invs (upd_inv I P ta) P tas\""], ["", "lemma upd_invs_append [simp]:\n  \"upd_invs I P (xs @ ys) = upd_invs (upd_invs I P xs) P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_invs I P (xs @ ys) = upd_invs (upd_invs I P xs) P ys", "by(induct xs arbitrary: I)(auto)"], ["", "lemma ts_inv_ok_upd_inv':\n \"ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updT' ts ta) (upd_inv I P ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I \\<Longrightarrow>\n    ts_inv_ok (redT_updT' ts ta) (upd_inv I P ta)", "by(cases ta)(auto intro!: ts_inv_okI elim: ts_inv_okD del: iffI)"], ["", "lemma ts_inv_ok_upd_invs':\n  \"ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I \\<Longrightarrow>\n    ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas)", "proof(induct tas arbitrary: ts I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       ts_inv_ok ts I \\<Longrightarrow>\n       ts_inv_ok (redT_updTs' ts []) (upd_invs I P [])\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "case Nil"], ["proof (state)\nthis:\n  ts_inv_ok ts I\n\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       ts_inv_ok ts I \\<Longrightarrow>\n       ts_inv_ok (redT_updTs' ts []) (upd_invs I P [])\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "thus ?case"], ["proof (prove)\nusing this:\n  ts_inv_ok ts I\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updTs' ts []) (upd_invs I P [])", "by simp"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updTs' ts []) (upd_invs I P [])\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "case (Cons TA TAS TS I)"], ["proof (state)\nthis:\n  ts_inv_ok ?ts ?I \\<Longrightarrow>\n  ts_inv_ok (redT_updTs' ?ts TAS) (upd_invs ?I P TAS)\n  ts_inv_ok TS I\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "note IH = \\<open>\\<And>ts I. ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updTs' ts TAS) (upd_invs I P TAS)\\<close>"], ["proof (state)\nthis:\n  ts_inv_ok ?ts ?I \\<Longrightarrow>\n  ts_inv_ok (redT_updTs' ?ts TAS) (upd_invs ?I P TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "note esok = \\<open>ts_inv_ok TS I\\<close>"], ["proof (state)\nthis:\n  ts_inv_ok TS I\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "from esok"], ["proof (chain)\npicking this:\n  ts_inv_ok TS I", "have \"ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)\""], ["proof (prove)\nusing this:\n  ts_inv_ok TS I\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)", "by -(rule ts_inv_ok_upd_inv')"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "hence \"ts_inv_ok (redT_updTs' (redT_updT' TS TA) TAS) (upd_invs (upd_inv I P TA) P TAS)\""], ["proof (prove)\nusing this:\n  ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updTs' (redT_updT' TS TA) TAS)\n     (upd_invs (upd_inv I P TA) P TAS)", "by (rule IH)"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updTs' (redT_updT' TS TA) TAS)\n   (upd_invs (upd_inv I P TA) P TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs' ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs' ts (a # tas))\n                          (upd_invs I P (a # tas))", "thus ?case"], ["proof (prove)\nusing this:\n  ts_inv_ok (redT_updTs' (redT_updT' TS TA) TAS)\n   (upd_invs (upd_inv I P TA) P TAS)\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updTs' TS (TA # TAS)) (upd_invs I P (TA # TAS))", "by simp"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updTs' TS (TA # TAS)) (upd_invs I P (TA # TAS))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_inv_ok_upd_inv:\n \"ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updT ts ta) (upd_inv I P ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I \\<Longrightarrow>\n    ts_inv_ok (redT_updT ts ta) (upd_inv I P ta)", "apply(cases ta)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>ts_inv_ok ts I; ta = NewThread x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updT ts ta) (upd_inv I P ta)\n 2. \\<And>x21 x22.\n       \\<lbrakk>ts_inv_ok ts I; ta = ThreadExists x21 x22\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updT ts ta) (upd_inv I P ta)", "apply(auto intro!: ts_inv_okI elim: ts_inv_okD del: iffI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ts_inv_ok_upd_invs:\n  \"ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv_ok ts I \\<Longrightarrow>\n    ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas)", "proof(induct tas arbitrary: ts I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       ts_inv_ok ts I \\<Longrightarrow>\n       ts_inv_ok (redT_updTs ts []) (upd_invs I P [])\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "case Nil"], ["proof (state)\nthis:\n  ts_inv_ok ts I\n\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       ts_inv_ok ts I \\<Longrightarrow>\n       ts_inv_ok (redT_updTs ts []) (upd_invs I P [])\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "thus ?case"], ["proof (prove)\nusing this:\n  ts_inv_ok ts I\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updTs ts []) (upd_invs I P [])", "by simp"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updTs ts []) (upd_invs I P [])\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "case (Cons TA TAS TS I)"], ["proof (state)\nthis:\n  ts_inv_ok ?ts ?I \\<Longrightarrow>\n  ts_inv_ok (redT_updTs ?ts TAS) (upd_invs ?I P TAS)\n  ts_inv_ok TS I\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "note IH = \\<open>\\<And>ts I. ts_inv_ok ts I \\<Longrightarrow> ts_inv_ok (redT_updTs ts TAS) (upd_invs I P TAS)\\<close>"], ["proof (state)\nthis:\n  ts_inv_ok ?ts ?I \\<Longrightarrow>\n  ts_inv_ok (redT_updTs ?ts TAS) (upd_invs ?I P TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "note esok = \\<open>ts_inv_ok TS I\\<close>"], ["proof (state)\nthis:\n  ts_inv_ok TS I\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "from esok"], ["proof (chain)\npicking this:\n  ts_inv_ok TS I", "have \"ts_inv_ok (redT_updT TS TA) (upd_inv I P TA)\""], ["proof (prove)\nusing this:\n  ts_inv_ok TS I\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updT TS TA) (upd_inv I P TA)", "by -(rule ts_inv_ok_upd_inv)"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updT TS TA) (upd_inv I P TA)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "hence \"ts_inv_ok (redT_updTs (redT_updT TS TA) TAS) (upd_invs (upd_inv I P TA) P TAS)\""], ["proof (prove)\nusing this:\n  ts_inv_ok (redT_updT TS TA) (upd_inv I P TA)\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updTs (redT_updT TS TA) TAS)\n     (upd_invs (upd_inv I P TA) P TAS)", "by (rule IH)"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updTs (redT_updT TS TA) TAS)\n   (upd_invs (upd_inv I P TA) P TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   ts_inv_ok ts I \\<Longrightarrow>\n                   ts_inv_ok (redT_updTs ts tas) (upd_invs I P tas);\n        ts_inv_ok ts I\\<rbrakk>\n       \\<Longrightarrow> ts_inv_ok (redT_updTs ts (a # tas))\n                          (upd_invs I P (a # tas))", "thus ?case"], ["proof (prove)\nusing this:\n  ts_inv_ok (redT_updTs (redT_updT TS TA) TAS)\n   (upd_invs (upd_inv I P TA) P TAS)\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updTs TS (TA # TAS)) (upd_invs I P (TA # TAS))", "by simp"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updTs TS (TA # TAS)) (upd_invs I P (TA # TAS))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_inv_ok_inv_ext_upd_inv:\n  \"\\<lbrakk> ts_inv_ok ts I; thread_ok ts ta \\<rbrakk> \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_inv I P ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts_inv_ok ts I; thread_ok ts ta\\<rbrakk>\n    \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_inv I P ta", "by(cases ta)(auto intro!: map_le_same_upd dest: ts_inv_okD)"], ["", "lemma ts_inv_ok_inv_ext_upd_invs:\n  \"\\<lbrakk> ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n  \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n    \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas", "proof(induct tas arbitrary: ts I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       \\<lbrakk>ts_inv_ok ts I; thread_oks ts []\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P []\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "case Nil"], ["proof (state)\nthis:\n  ts_inv_ok ts I\n  thread_oks ts []\n\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       \\<lbrakk>ts_inv_ok ts I; thread_oks ts []\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P []\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "thus ?case"], ["proof (prove)\nusing this:\n  ts_inv_ok ts I\n  thread_oks ts []\n\ngoal (1 subgoal):\n 1. I \\<subseteq>\\<^sub>m upd_invs I P []", "by simp"], ["proof (state)\nthis:\n  I \\<subseteq>\\<^sub>m upd_invs I P []\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "case (Cons TA TAS TS I)"], ["proof (state)\nthis:\n  \\<lbrakk>ts_inv_ok ?ts ?I; thread_oks ?ts TAS\\<rbrakk>\n  \\<Longrightarrow> ?I \\<subseteq>\\<^sub>m upd_invs ?I P TAS\n  ts_inv_ok TS I\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "note IH = \\<open>\\<And>ts I. \\<lbrakk> ts_inv_ok ts I; thread_oks ts TAS\\<rbrakk> \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P TAS\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>ts_inv_ok ?ts ?I; thread_oks ?ts TAS\\<rbrakk>\n  \\<Longrightarrow> ?I \\<subseteq>\\<^sub>m upd_invs ?I P TAS\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "note esinv = \\<open>ts_inv_ok TS I\\<close>"], ["proof (state)\nthis:\n  ts_inv_ok TS I\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "note cct = \\<open>thread_oks TS (TA # TAS)\\<close>"], ["proof (state)\nthis:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "from esinv cct"], ["proof (chain)\npicking this:\n  ts_inv_ok TS I\n  thread_oks TS (TA # TAS)", "have \"I \\<subseteq>\\<^sub>m upd_inv I P TA\""], ["proof (prove)\nusing this:\n  ts_inv_ok TS I\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. I \\<subseteq>\\<^sub>m upd_inv I P TA", "by(auto intro: ts_inv_ok_inv_ext_upd_inv)"], ["proof (state)\nthis:\n  I \\<subseteq>\\<^sub>m upd_inv I P TA\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "also"], ["proof (state)\nthis:\n  I \\<subseteq>\\<^sub>m upd_inv I P TA\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "from esinv cct"], ["proof (chain)\npicking this:\n  ts_inv_ok TS I\n  thread_oks TS (TA # TAS)", "have \"ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)\""], ["proof (prove)\nusing this:\n  ts_inv_ok TS I\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)", "by(auto intro: ts_inv_ok_upd_inv')"], ["proof (state)\nthis:\n  ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "with cct"], ["proof (chain)\npicking this:\n  thread_oks TS (TA # TAS)\n  ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)", "have \"upd_inv I P TA \\<subseteq>\\<^sub>m upd_invs (upd_inv I P TA) P TAS\""], ["proof (prove)\nusing this:\n  thread_oks TS (TA # TAS)\n  ts_inv_ok (redT_updT' TS TA) (upd_inv I P TA)\n\ngoal (1 subgoal):\n 1. upd_inv I P TA \\<subseteq>\\<^sub>m upd_invs (upd_inv I P TA) P TAS", "by(auto intro: IH)"], ["proof (state)\nthis:\n  upd_inv I P TA \\<subseteq>\\<^sub>m upd_invs (upd_inv I P TA) P TAS\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>ts_inv_ok ts I; thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P tas;\n        ts_inv_ok ts I; thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq>\\<^sub>m upd_invs I P (a # tas)", "finally"], ["proof (chain)\npicking this:\n  I \\<subseteq>\\<^sub>m upd_invs (upd_inv I P TA) P TAS", "show ?case"], ["proof (prove)\nusing this:\n  I \\<subseteq>\\<^sub>m upd_invs (upd_inv I P TA) P TAS\n\ngoal (1 subgoal):\n 1. I \\<subseteq>\\<^sub>m upd_invs I P (TA # TAS)", "by simp"], ["proof (state)\nthis:\n  I \\<subseteq>\\<^sub>m upd_invs I P (TA # TAS)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_invs_Some:\n  \"\\<lbrakk> thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>; ts t = \\<lfloor>x\\<rfloor> \\<rbrakk> \\<Longrightarrow> upd_invs I Q tas t = \\<lfloor>i\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n     ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> upd_invs I Q tas t = \\<lfloor>i\\<rfloor>", "proof(induct tas arbitrary: ts I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       \\<lbrakk>thread_oks ts []; I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q [] t = \\<lfloor>i\\<rfloor>\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "case Nil"], ["proof (state)\nthis:\n  thread_oks ts []\n  I t = \\<lfloor>i\\<rfloor>\n  ts t = \\<lfloor>x\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       \\<lbrakk>thread_oks ts []; I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q [] t = \\<lfloor>i\\<rfloor>\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  thread_oks ts []\n  I t = \\<lfloor>i\\<rfloor>\n  ts t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs I Q [] t = \\<lfloor>i\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  upd_invs I Q [] t = \\<lfloor>i\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "case (Cons TA TAS TS I)"], ["proof (state)\nthis:\n  \\<lbrakk>thread_oks ?ts TAS; ?I t = \\<lfloor>i\\<rfloor>;\n   ?ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> upd_invs ?I Q TAS t = \\<lfloor>i\\<rfloor>\n  thread_oks TS (TA # TAS)\n  I t = \\<lfloor>i\\<rfloor>\n  TS t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "note IH = \\<open>\\<And>ts I. \\<lbrakk>thread_oks ts TAS; I t = \\<lfloor>i\\<rfloor>; ts t = \\<lfloor>x\\<rfloor>\\<rbrakk> \\<Longrightarrow> upd_invs I Q TAS t = \\<lfloor>i\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>thread_oks ?ts TAS; ?I t = \\<lfloor>i\\<rfloor>;\n   ?ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> upd_invs ?I Q TAS t = \\<lfloor>i\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "note cct = \\<open>thread_oks TS (TA # TAS)\\<close>"], ["proof (state)\nthis:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "note it = \\<open>I t = \\<lfloor>i\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  I t = \\<lfloor>i\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "note est = \\<open>TS t = \\<lfloor>x\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  TS t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "from cct"], ["proof (chain)\npicking this:\n  thread_oks TS (TA # TAS)", "have cctta: \"thread_ok TS TA\"\n    and ccttas: \"thread_oks (redT_updT' TS TA) TAS\""], ["proof (prove)\nusing this:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. thread_ok TS TA &&& thread_oks (redT_updT' TS TA) TAS", "by auto"], ["proof (state)\nthis:\n  thread_ok TS TA\n  thread_oks (redT_updT' TS TA) TAS\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "from cctta it est"], ["proof (chain)\npicking this:\n  thread_ok TS TA\n  I t = \\<lfloor>i\\<rfloor>\n  TS t = \\<lfloor>x\\<rfloor>", "have \"upd_inv I Q TA t = \\<lfloor>i\\<rfloor>\""], ["proof (prove)\nusing this:\n  thread_ok TS TA\n  I t = \\<lfloor>i\\<rfloor>\n  TS t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_inv I Q TA t = \\<lfloor>i\\<rfloor>", "by(cases TA, auto)"], ["proof (state)\nthis:\n  upd_inv I Q TA t = \\<lfloor>i\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  upd_inv I Q TA t = \\<lfloor>i\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "have \"redT_updT' TS TA t = \\<lfloor>x\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updT' TS TA t = \\<lfloor>x\\<rfloor>", "using cctta est"], ["proof (prove)\nusing this:\n  thread_ok TS TA\n  TS t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. redT_updT' TS TA t = \\<lfloor>x\\<rfloor>", "by - (rule redT_updT'_Some)"], ["proof (state)\nthis:\n  redT_updT' TS TA t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  upd_inv I Q TA t = \\<lfloor>i\\<rfloor>\n  redT_updT' TS TA t = \\<lfloor>x\\<rfloor>", "have \"upd_invs (upd_inv I Q TA) Q TAS t = \\<lfloor>i\\<rfloor>\""], ["proof (prove)\nusing this:\n  upd_inv I Q TA t = \\<lfloor>i\\<rfloor>\n  redT_updT' TS TA t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs (upd_inv I Q TA) Q TAS t = \\<lfloor>i\\<rfloor>", "using ccttas"], ["proof (prove)\nusing this:\n  upd_inv I Q TA t = \\<lfloor>i\\<rfloor>\n  redT_updT' TS TA t = \\<lfloor>x\\<rfloor>\n  thread_oks (redT_updT' TS TA) TAS\n\ngoal (1 subgoal):\n 1. upd_invs (upd_inv I Q TA) Q TAS t = \\<lfloor>i\\<rfloor>", "by -(erule IH)"], ["proof (state)\nthis:\n  upd_invs (upd_inv I Q TA) Q TAS t = \\<lfloor>i\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas; I t = \\<lfloor>i\\<rfloor>;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>i\\<rfloor>;\n        thread_oks ts (a # tas); I t = \\<lfloor>i\\<rfloor>;\n        ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = \\<lfloor>i\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  upd_invs (upd_inv I Q TA) Q TAS t = \\<lfloor>i\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs I Q (TA # TAS) t = \\<lfloor>i\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  upd_invs I Q (TA # TAS) t = \\<lfloor>i\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_inv_Some_eq:\n  \"\\<lbrakk> thread_ok ts ta; ts t = \\<lfloor>x\\<rfloor> \\<rbrakk> \\<Longrightarrow> upd_inv I Q ta t = I t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>thread_ok ts ta; ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> upd_inv I Q ta t = I t", "by(cases ta, auto)"], ["", "lemma upd_invs_Some_eq: \"\\<lbrakk> thread_oks ts tas; ts t = \\<lfloor>x\\<rfloor> \\<rbrakk> \\<Longrightarrow> upd_invs I Q tas t = I t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>thread_oks ts tas; ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> upd_invs I Q tas t = I t", "proof(induct tas arbitrary: ts I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       \\<lbrakk>thread_oks ts []; ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q [] t = I t\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "case Nil"], ["proof (state)\nthis:\n  thread_oks ts []\n  ts t = \\<lfloor>x\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       \\<lbrakk>thread_oks ts []; ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q [] t = I t\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "thus ?case"], ["proof (prove)\nusing this:\n  thread_oks ts []\n  ts t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs I Q [] t = I t", "by simp"], ["proof (state)\nthis:\n  upd_invs I Q [] t = I t\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "case (Cons TA TAS TS I)"], ["proof (state)\nthis:\n  \\<lbrakk>thread_oks ?ts TAS; ?ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> upd_invs ?I Q TAS t = ?I t\n  thread_oks TS (TA # TAS)\n  TS t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "note IH = \\<open>\\<And>ts I. \\<lbrakk>thread_oks ts TAS; ts t = \\<lfloor>x\\<rfloor>\\<rbrakk> \\<Longrightarrow> upd_invs I Q TAS t = I t\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>thread_oks ?ts TAS; ?ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> upd_invs ?I Q TAS t = ?I t\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "note cct = \\<open>thread_oks TS (TA # TAS)\\<close>"], ["proof (state)\nthis:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "note est = \\<open>TS t = \\<lfloor>x\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  TS t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "from cct est"], ["proof (chain)\npicking this:\n  thread_oks TS (TA # TAS)\n  TS t = \\<lfloor>x\\<rfloor>", "have \"upd_invs (upd_inv I Q TA) Q TAS t = upd_inv I Q TA t\""], ["proof (prove)\nusing this:\n  thread_oks TS (TA # TAS)\n  TS t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs (upd_inv I Q TA) Q TAS t = upd_inv I Q TA t", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TS t = \\<lfloor>x\\<rfloor>; thread_ok TS TA;\n     thread_oks (redT_updT' TS TA) TAS\\<rbrakk>\n    \\<Longrightarrow> upd_invs (upd_inv I Q TA) Q TAS t = upd_inv I Q TA t", "apply(erule IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TS t = \\<lfloor>x\\<rfloor>; thread_ok TS TA\\<rbrakk>\n    \\<Longrightarrow> redT_updT' TS TA t = \\<lfloor>x\\<rfloor>", "by(rule redT_updT'_Some)"], ["proof (state)\nthis:\n  upd_invs (upd_inv I Q TA) Q TAS t = upd_inv I Q TA t\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "also"], ["proof (state)\nthis:\n  upd_invs (upd_inv I Q TA) Q TAS t = upd_inv I Q TA t\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "from cct est"], ["proof (chain)\npicking this:\n  thread_oks TS (TA # TAS)\n  TS t = \\<lfloor>x\\<rfloor>", "have \"\\<dots> = I t\""], ["proof (prove)\nusing this:\n  thread_oks TS (TA # TAS)\n  TS t = \\<lfloor>x\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_inv I Q TA t = I t", "by(auto elim: upd_inv_Some_eq)"], ["proof (state)\nthis:\n  upd_inv I Q TA t = I t\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>thread_oks ts tas;\n                    ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t = I t;\n        thread_oks ts (a # tas); ts t = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t = I t", "finally"], ["proof (chain)\npicking this:\n  upd_invs (upd_inv I Q TA) Q TAS t = I t", "show ?case"], ["proof (prove)\nusing this:\n  upd_invs (upd_inv I Q TA) Q TAS t = I t\n\ngoal (1 subgoal):\n 1. upd_invs I Q (TA # TAS) t = I t", "by simp"], ["proof (state)\nthis:\n  upd_invs I Q (TA # TAS) t = I t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SOME_new_thread_upd_invs:\n  assumes Qsome: \"Q (SOME i. Q i t x m) t x m\"\n  and nt: \"NewThread t x m \\<in> set tas\"\n  and cct: \"thread_oks ts tas\"\n  shows \"\\<exists>i. upd_invs I Q tas t = \\<lfloor>i\\<rfloor> \\<and> Q i t x m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. upd_invs I Q tas t = \\<lfloor>i\\<rfloor> \\<and> Q i t x m", "proof(rule exI[where x=\"SOME i. Q i t x m\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor> \\<and>\n    Q (SOME i. Q i t x m) t x m", "from nt cct"], ["proof (chain)\npicking this:\n  NewThread t x m \\<in> set tas\n  thread_oks ts tas", "have \"upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\""], ["proof (prove)\nusing this:\n  NewThread t x m \\<in> set tas\n  thread_oks ts tas\n\ngoal (1 subgoal):\n 1. upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "proof(induct tas arbitrary: ts I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       \\<lbrakk>NewThread t x m \\<in> set []; thread_oks ts []\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q [] t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "case Nil"], ["proof (state)\nthis:\n  NewThread t x m \\<in> set []\n  thread_oks ts []\n\ngoal (2 subgoals):\n 1. \\<And>ts I.\n       \\<lbrakk>NewThread t x m \\<in> set []; thread_oks ts []\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q [] t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>\n 2. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  NewThread t x m \\<in> set []\n  thread_oks ts []\n\ngoal (1 subgoal):\n 1. upd_invs I Q [] t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  upd_invs I Q [] t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "case (Cons TA TAS TS I)"], ["proof (state)\nthis:\n  \\<lbrakk>NewThread t x m \\<in> set TAS; thread_oks ?ts TAS\\<rbrakk>\n  \\<Longrightarrow> upd_invs ?I Q TAS t =\n                    \\<lfloor>SOME i. Q i t x m\\<rfloor>\n  NewThread t x m \\<in> set (TA # TAS)\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "note IH = \\<open>\\<And>ts I. \\<lbrakk> NewThread t x m \\<in> set TAS; thread_oks ts TAS \\<rbrakk> \\<Longrightarrow> upd_invs I Q TAS t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>NewThread t x m \\<in> set TAS; thread_oks ?ts TAS\\<rbrakk>\n  \\<Longrightarrow> upd_invs ?I Q TAS t =\n                    \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "note nt = \\<open>NewThread t x m \\<in> set (TA # TAS)\\<close>"], ["proof (state)\nthis:\n  NewThread t x m \\<in> set (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "note cct = \\<open>thread_oks TS (TA # TAS)\\<close>"], ["proof (state)\nthis:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "{"], ["proof (state)\nthis:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "assume nt': \"NewThread t x m \\<in> set TAS\""], ["proof (state)\nthis:\n  NewThread t x m \\<in> set TAS\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "from cct"], ["proof (chain)\npicking this:\n  thread_oks TS (TA # TAS)", "have ?case"], ["proof (prove)\nusing this:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>thread_ok TS TA; thread_oks (redT_updT' TS TA) TAS\\<rbrakk>\n    \\<Longrightarrow> upd_invs (upd_inv I Q TA) Q TAS t =\n                      \\<lfloor>SOME i. Q i t x m\\<rfloor>", "by(rule IH[OF nt'])"], ["proof (state)\nthis:\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "}"], ["proof (state)\nthis:\n  NewThread t x m \\<in> set TAS \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  NewThread t x m \\<in> set TAS \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "{"], ["proof (state)\nthis:\n  NewThread t x m \\<in> set TAS \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "assume ta: \"TA = NewThread t x m\""], ["proof (state)\nthis:\n  TA = NewThread t x m\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "with cct"], ["proof (chain)\npicking this:\n  thread_oks TS (TA # TAS)\n  TA = NewThread t x m", "have rup: \"redT_updT' TS TA t = \\<lfloor>(undefined, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  thread_oks TS (TA # TAS)\n  TA = NewThread t x m\n\ngoal (1 subgoal):\n 1. redT_updT' TS TA t = \\<lfloor>(undefined, no_wait_locks)\\<rfloor>", "by(simp)"], ["proof (state)\nthis:\n  redT_updT' TS TA t = \\<lfloor>(undefined, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "from cct"], ["proof (chain)\npicking this:\n  thread_oks TS (TA # TAS)", "have cctta: \"thread_oks (redT_updT' TS TA) TAS\""], ["proof (prove)\nusing this:\n  thread_oks TS (TA # TAS)\n\ngoal (1 subgoal):\n 1. thread_oks (redT_updT' TS TA) TAS", "by simp"], ["proof (state)\nthis:\n  thread_oks (redT_updT' TS TA) TAS\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "from ta"], ["proof (chain)\npicking this:\n  TA = NewThread t x m", "have \"upd_inv I Q TA t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\""], ["proof (prove)\nusing this:\n  TA = NewThread t x m\n\ngoal (1 subgoal):\n 1. upd_inv I Q TA t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "by(simp)"], ["proof (state)\nthis:\n  upd_inv I Q TA t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "hence ?case"], ["proof (prove)\nusing this:\n  upd_inv I Q TA t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "by(clarsimp simp add: upd_invs_Some_eq[OF cctta, OF rup])"], ["proof (state)\nthis:\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "}"], ["proof (state)\nthis:\n  TA = NewThread t x m \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a tas ts I.\n       \\<lbrakk>\\<And>ts I.\n                   \\<lbrakk>NewThread t x m \\<in> set tas;\n                    thread_oks ts tas\\<rbrakk>\n                   \\<Longrightarrow> upd_invs I Q tas t =\n                                     \\<lfloor>SOME i. Q i t x m\\<rfloor>;\n        NewThread t x m \\<in> set (a # tas);\n        thread_oks ts (a # tas)\\<rbrakk>\n       \\<Longrightarrow> upd_invs I Q (a # tas) t =\n                         \\<lfloor>SOME i. Q i t x m\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  NewThread t x m \\<in> set TAS \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n  TA = NewThread t x m \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  NewThread t x m \\<in> set TAS \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n  TA = NewThread t x m \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "using nt"], ["proof (prove)\nusing this:\n  NewThread t x m \\<in> set TAS \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n  TA = NewThread t x m \\<Longrightarrow>\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n  NewThread t x m \\<in> set (TA # TAS)\n\ngoal (1 subgoal):\n 1. upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  upd_invs I Q (TA # TAS) t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor> \\<and>\n    Q (SOME i. Q i t x m) t x m", "with Qsome"], ["proof (chain)\npicking this:\n  Q (SOME i. Q i t x m) t x m\n  upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor>", "show \"upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor> \\<and> Q (SOME i. Q i t x m) t x m\""], ["proof (prove)\nusing this:\n  Q (SOME i. Q i t x m) t x m\n  upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor>\n\ngoal (1 subgoal):\n 1. upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor> \\<and>\n    Q (SOME i. Q i t x m) t x m", "by(simp)"], ["proof (state)\nthis:\n  upd_invs I Q tas t = \\<lfloor>SOME i. Q i t x m\\<rfloor> \\<and>\n  Q (SOME i. Q i t x m) t x m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_ok_into_ts_inv_const:\n  assumes \"ts_ok P ts m\"\n  obtains I where \"ts_inv (\\<lambda>_. P) I ts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        ts_inv (\\<lambda>_. P) I ts m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>I.\n        ts_inv (\\<lambda>_. P) I ts m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  ts_ok P ts m", "have \"ts_inv (\\<lambda>_. P) (\\<lambda>t. if t \\<in> dom ts then Some undefined else None) ts m\""], ["proof (prove)\nusing this:\n  ts_ok P ts m\n\ngoal (1 subgoal):\n 1. ts_inv (\\<lambda>_. P)\n     (\\<lambda>t.\n         if t \\<in> dom ts then \\<lfloor>undefined\\<rfloor> else None)\n     ts m", "by(auto intro!: ts_invI dest: ts_okD)"], ["proof (state)\nthis:\n  ts_inv (\\<lambda>_. P)\n   (\\<lambda>t.\n       if t \\<in> dom ts then \\<lfloor>undefined\\<rfloor> else None)\n   ts m\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        ts_inv (\\<lambda>_. P) I ts m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  ts_inv (\\<lambda>_. P)\n   (\\<lambda>t.\n       if t \\<in> dom ts then \\<lfloor>undefined\\<rfloor> else None)\n   ts m\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_inv_const_into_ts_ok:\n  \"ts_inv (\\<lambda>_. P) I ts m \\<Longrightarrow> ts_ok P ts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv (\\<lambda>_. P) I ts m \\<Longrightarrow> ts_ok P ts m", "by(auto intro!: ts_okI dest: ts_invD)"], ["", "lemma ts_inv_into_ts_ok_Ex:\n  \"ts_inv Q I ts m \\<Longrightarrow> ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv Q I ts m \\<Longrightarrow>\n    ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m", "by(rule ts_okI)(blast dest: ts_invD)"], ["", "lemma ts_ok_Ex_into_ts_inv:\n  \"ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m \\<Longrightarrow> \\<exists>I. ts_inv Q I ts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m \\<Longrightarrow>\n    \\<exists>I. ts_inv Q I ts m", "by(rule exI[where x=\"\\<lambda>t. \\<lfloor>SOME i. Q i t (fst (the (ts t))) m\\<rfloor>\"])(auto 4 4 dest: ts_okD intro: someI intro: ts_invI)"], ["", "lemma Ex_ts_inv_conv_ts_ok:\n  \"(\\<exists>I. ts_inv Q I ts m) \\<longleftrightarrow> (ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>I. ts_inv Q I ts m) =\n    ts_ok (\\<lambda>t x m. \\<exists>i. Q i t x m) ts m", "by(auto dest: ts_inv_into_ts_ok_Ex ts_ok_Ex_into_ts_inv)"], ["", "end"]]}