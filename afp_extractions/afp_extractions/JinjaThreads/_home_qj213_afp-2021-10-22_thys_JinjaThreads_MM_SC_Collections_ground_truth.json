{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/SC_Collections.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma rec_heapobj [simp]: \"rec_heapobj = case_heapobj\"", "lemma is_Arr_conv:\n  \"is_Arr arrobj = (\\<exists>T si f el. arrobj = Arr T si f el)\"", "lemma is_ArrE:\n  \"\\<lbrakk> is_Arr arrobj; \\<And>T si f el. arrobj = Arr T si f el \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"\n  \"\\<lbrakk> \\<not> is_Arr arrobj; \\<And>C fs. arrobj = Obj C fs \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma obj_ty_blank [iff]: \"obj_ty (blank P hT) = hT\"", "lemma new_Addr_SomeD: \"new_Addr h = \\<lfloor>a\\<rfloor> \\<Longrightarrow> rm_lookup a h = None\"", "lemma new_Addr_SomeI: \"\\<exists>a. new_Addr h = Some a\"", "lemma sc_start_heap_ok: \"sc_start_heap_ok P\"", "lemma sc_wf_start_state_iff:\n  \"sc_wf_start_state P C M vs \\<longleftrightarrow> (\\<exists>Ts T meth D. P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D \\<and> P,sc_start_heap P \\<turnstile>sc vs [:\\<le>] Ts)\"", "lemma sc_heap:\n  \"heap addr2thread_id thread_id2addr (sc_allocate P) sc_typeof_addr sc_heap_write P\"", "lemma sc_hext_new:\n  \"rm_lookup a h = None \\<Longrightarrow> h \\<unlhd>sc rm_update a arrobj h\"", "lemma sc_hext_upd_obj: \"rm_lookup a h = Some (Obj C fs) \\<Longrightarrow> h \\<unlhd>sc rm_update a (Obj C fs') h\"", "lemma sc_hext_upd_arr: \"\\<lbrakk> rm_lookup a h = Some (Arr T si f e) \\<rbrakk> \\<Longrightarrow> h \\<unlhd>sc rm_update a (Arr T si f' e') h\"", "lemma sc_conf_upd_obj: \"rm_lookup a h = Some(Obj C fs) \\<Longrightarrow> (P,rm_update a (Obj C fs') h \\<turnstile>sc x :\\<le> T) = (P,h \\<turnstile>sc x :\\<le> T)\"", "lemma sc_conf_upd_arr:\n  \"rm_lookup a h = Some(Arr T si f el) \\<Longrightarrow> (P,rm_update a (Arr T si f' el') h \\<turnstile>sc x :\\<le> T') = (P,h \\<turnstile>sc x :\\<le> T')\"", "lemma sc_oconf_hext: \"P,h \\<turnstile>sc obj \\<surd> \\<Longrightarrow> h \\<unlhd>sc h' \\<Longrightarrow> P,h' \\<turnstile>sc obj \\<surd>\"", "lemma map_of_fields_init_fields:\n  assumes \"map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\"\n  shows \"\\<exists>fs' v. tm_\\<alpha> (init_fields (map (\\<lambda>(FD, (T, fm)). (FD, T)) FDTs)) (String.explode F) = \\<lfloor>fs'\\<rfloor> \\<and> lm_\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and> sc.conf P h v T\"", "lemma sc_oconf_init_fields:\n  assumes \"P \\<turnstile> C has_fields FDTs\"\n  shows \"P,h \\<turnstile>sc (Obj C (init_fields (map (\\<lambda>(FD, (T, fm)). (FD, T)) FDTs))) \\<surd>\"", "lemma sc_oconf_init_arr:\n  assumes type: \"is_type P (T\\<lfloor>\\<rceil>)\"\n  shows \"P,h \\<turnstile>sc Arr T n (init_fields_array (map (\\<lambda>((F, D), (T, fm)). (F, T)) (TypeRel.fields P Object))) (init_cells T n) \\<surd>\"", "lemma sc_oconf_fupd [intro?]:\n  \"\\<lbrakk> P \\<turnstile> C has F:T (fm) in D; P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Obj C fs) \\<surd>;\n    fs' = (case tm_lookup (String.explode F) fs of None \\<Rightarrow> lm_empty () | Some fs' \\<Rightarrow> fs') \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Obj C (tm_update (String.explode F) (lm_update D v fs') fs)) \\<surd>\"", "lemma sc_oconf_fupd_arr [intro?]:\n  \"\\<lbrakk> P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Arr T si f el) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Arr T si f (rm_update i v el)) \\<surd>\"", "lemma sc_oconf_fupd_arr_fields:\n  \"\\<lbrakk> P \\<turnstile> Object has F:T (fm) in Object; P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Arr T' si f el) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Arr T' si (lm_update F v f) el) \\<surd>\"", "lemma sc_oconf_new: \"\\<lbrakk> P,h \\<turnstile>sc obj \\<surd>; rm_lookup a h = None \\<rbrakk> \\<Longrightarrow> P,rm_update a arrobj h \\<turnstile>sc obj \\<surd>\"", "lemmas sc_oconf_upd_obj = sc_oconf_hext [OF _ sc_hext_upd_obj]", "lemma sc_oconf_upd_arr:\n  assumes \"P,h \\<turnstile>sc obj \\<surd>\"\n  and ha: \"rm_lookup a h = \\<lfloor>Arr T si f el\\<rfloor>\"\n  shows \"P,rm_update a (Arr T si f' el') h \\<turnstile>sc obj \\<surd>\"", "lemma sc_oconf_blank: \"is_htype P hT \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>\"", "lemma sc_hconfD: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; rm_lookup a h = Some obj \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile>sc obj \\<surd>\"", "lemmas sc_preallocated_new = sc.preallocated_hext[OF _ sc_hext_new]", "lemmas sc_preallocated_upd_obj = sc.preallocated_hext [OF _ sc_hext_upd_obj]", "lemmas sc_preallocated_upd_arr = sc.preallocated_hext [OF _ sc_hext_upd_arr]", "lemma sc_hconf_new: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; rm_lookup a h = None; P,h \\<turnstile>sc obj \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc rm_update a obj h \\<surd>\"", "lemma sc_hconf_upd_obj: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; rm_lookup a h = Some (Obj C fs); P,h \\<turnstile>sc (Obj C fs') \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc rm_update a (Obj C fs') h \\<surd>\"", "lemma sc_hconf_upd_arr: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; rm_lookup a h = Some(Arr T si f el); P,h \\<turnstile>sc (Arr T si f' el') \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc rm_update a (Arr T si f' el') h \\<surd>\"", "lemma sc_heap_conf: \n  \"heap_conf addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_write (sc_hconf P) P\"", "lemma sc_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\"", "lemma sc_heap_conf_read:\n  \"heap_conf_read addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\"", "lemma sc_deterministic_heap_ops: \"\\<not> sc_spurious_wakeups \\<Longrightarrow> sc_deterministic_heap_ops P\"", "lemma eval_sc_heap_read_i_i_i_o:\n  \"Predicate.eval (sc_heap_read_i_i_i_o h ad al) = sc_heap_read h ad al\"", "lemma eval_sc_heap_write_i_i_i_i_o:\n  \"Predicate.eval (sc_heap_write_i_i_i_i_o h ad al v) = sc_heap_write h ad al v\""], "translations": [["", "lemma rec_heapobj [simp]: \"rec_heapobj = case_heapobj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_heapobj = case_heapobj", "by(auto intro!: ext split: heapobj.split)"], ["", "primrec obj_ty  :: \"heapobj \\<Rightarrow> htype\"\nwhere\n  \"obj_ty (Obj c f)   = Class_type c\"\n| \"obj_ty (Arr t si f e) = Array_type t si\""], ["", "fun is_Arr :: \"heapobj \\<Rightarrow> bool\" where\n  \"is_Arr (Obj C fs)      = False\"\n| \"is_Arr (Arr T f si el) = True\""], ["", "lemma is_Arr_conv:\n  \"is_Arr arrobj = (\\<exists>T si f el. arrobj = Arr T si f el)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Arr arrobj = (\\<exists>T si f el. arrobj = Arr T si f el)", "by(cases arrobj, auto)"], ["", "lemma is_ArrE:\n  \"\\<lbrakk> is_Arr arrobj; \\<And>T si f el. arrobj = Arr T si f el \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"\n  \"\\<lbrakk> \\<not> is_Arr arrobj; \\<And>C fs. arrobj = Obj C fs \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_Arr arrobj;\n      \\<And>T si f el.\n         arrobj = Arr T si f el \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis) &&&\n    (\\<lbrakk>\\<not> is_Arr arrobj;\n      \\<And>C fs. arrobj = Obj C fs \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis)", "by(cases arrobj, auto)+"], ["", "definition init_fields :: \"((vname \\<times> cname) \\<times> ty) list \\<Rightarrow> fields\"\nwhere\n  \"init_fields FDTs \\<equiv>\n  foldr (\\<lambda>((F, D), T) fields. \n           let F' = String.explode F\n           in tm_update F' (lm_update D (default_val T)\n                                      (case tm_lookup F' fields of None \\<Rightarrow> lm_empty () | Some lm \\<Rightarrow> lm)) fields)\n        FDTs (tm_empty ())\""], ["", "definition init_fields_array :: \"(vname \\<times> ty) list \\<Rightarrow> array_fields\"\nwhere\n  \"init_fields_array \\<equiv> lm.to_map \\<circ> map (\\<lambda>(F, T). (F, default_val T))\""], ["", "definition init_cells :: \"ty \\<Rightarrow> nat \\<Rightarrow> array_cells\"\nwhere \"init_cells T n = foldl (\\<lambda>cells i. rm_update i (default_val T) cells) (rm_empty ()) [0..<n]\""], ["", "primrec \\<comment> \\<open>a new, blank object with default values in all fields:\\<close>\n  blank :: \"'m prog \\<Rightarrow> htype \\<Rightarrow> heapobj\"\nwhere\n  \"blank P (Class_type C) = Obj C (init_fields (map (\\<lambda>(FD, (T, fm)). (FD, T)) (TypeRel.fields P C)))\"\n| \"blank P (Array_type T n) =\n   Arr T n (init_fields_array (map (\\<lambda>((F, D), (T, fm)). (F, T)) (TypeRel.fields P Object))) (init_cells T n)\""], ["", "lemma obj_ty_blank [iff]: \"obj_ty (blank P hT) = hT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_ty (blank P hT) = hT", "by(cases hT) simp_all"], ["", "subsection\\<open>Heap\\<close>"], ["", "type_synonym heap = \"(addr, heapobj) rbt\""], ["", "translations\n  (type) \"heap\" <= (type) \"(nat, heapobj) rbt\""], ["", "abbreviation sc_empty :: heap\nwhere \"sc_empty \\<equiv> rm_empty ()\""], ["", "fun the_obj :: \"heapobj \\<Rightarrow> cname \\<times> fields\" where\n  \"the_obj (Obj C fs) = (C, fs)\""], ["", "fun the_arr :: \"heapobj \\<Rightarrow> ty \\<times> nat \\<times> array_fields \\<times> array_cells\" where\n  \"the_arr (Arr T si f el) = (T, si, f, el)\""], ["", "abbreviation\n  cname_of :: \"heap \\<Rightarrow> addr \\<Rightarrow> cname\" where\n  \"cname_of hp a == fst (the_obj (the (rm_lookup a hp)))\""], ["", "definition new_Addr :: \"heap \\<Rightarrow> addr option\"\nwhere \"new_Addr h = Some (case rm_max h (\\<lambda>_. True) of None \\<Rightarrow> 0 | Some (a, _) \\<Rightarrow> a + 1)\""], ["", "definition sc_allocate :: \"'m prog \\<Rightarrow> heap \\<Rightarrow> htype \\<Rightarrow> (heap \\<times> addr) set\"\nwhere\n  \"sc_allocate P h hT = \n   (case new_Addr h of None \\<Rightarrow> {}\n                   | Some a \\<Rightarrow> {(rm_update a (blank P hT) h, a)})\""], ["", "definition sc_typeof_addr :: \"heap \\<Rightarrow> addr \\<Rightarrow> htype option\"\nwhere \"sc_typeof_addr h a = map_option obj_ty (rm_lookup a h)\""], ["", "inductive sc_heap_read :: \"heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> addr val \\<Rightarrow> bool\"\nfor h :: heap and a :: addr\nwhere\n  Obj: \"\\<lbrakk> rm_lookup a h = \\<lfloor>Obj C fs\\<rfloor>; tm_lookup (String.explode F) fs = \\<lfloor>fs'\\<rfloor>; lm_lookup D fs' = \\<lfloor>v\\<rfloor> \\<rbrakk> \\<Longrightarrow> sc_heap_read h a (CField D F) v\"\n| Arr: \"\\<lbrakk> rm_lookup a h = \\<lfloor>Arr T si f el\\<rfloor>; n < si \\<rbrakk> \\<Longrightarrow> sc_heap_read h a (ACell n) (the (rm_lookup n el))\"\n| ArrObj: \"\\<lbrakk> rm_lookup a h = \\<lfloor>Arr T si f el\\<rfloor>; lm_lookup F f = \\<lfloor>v\\<rfloor> \\<rbrakk> \\<Longrightarrow> sc_heap_read h a (CField Object F) v\""], ["", "hide_fact (open) Obj Arr ArrObj"], ["", "inductive_cases sc_heap_read_cases [elim!]:\n  \"sc_heap_read h a (CField C F) v\"\n  \"sc_heap_read h a (ACell n) v\""], ["", "inductive sc_heap_write :: \"heap \\<Rightarrow> addr \\<Rightarrow> addr_loc \\<Rightarrow> addr val \\<Rightarrow> heap \\<Rightarrow> bool\"\nfor h :: heap and a :: addr\nwhere\n  Obj:\n  \"\\<lbrakk> rm_lookup a h = \\<lfloor>Obj C fs\\<rfloor>; F' = String.explode F;\n     h' = rm_update a (Obj C (tm_update F' (lm_update D v (case tm_lookup (String.explode F) fs of None \\<Rightarrow> lm_empty () | Some fs' \\<Rightarrow> fs')) fs)) h \\<rbrakk>\n  \\<Longrightarrow> sc_heap_write h a (CField D F) v h'\"\n\n| Arr:\n  \"\\<lbrakk> rm_lookup a h = \\<lfloor>Arr T si f el\\<rfloor>; h' = rm_update a (Arr T si f (rm_update n v el)) h \\<rbrakk>\n  \\<Longrightarrow> sc_heap_write h a (ACell n) v h'\"\n\n| ArrObj:\n  \"\\<lbrakk> rm_lookup a h = \\<lfloor>Arr T si f el\\<rfloor>; h' = rm_update a (Arr T si (lm_update F v f) el) h \\<rbrakk>\n  \\<Longrightarrow> sc_heap_write h a (CField Object F) v h'\""], ["", "hide_fact (open) Obj Arr ArrObj"], ["", "inductive_cases sc_heap_write_cases [elim!]:\n  \"sc_heap_write h a (CField C F) v h'\"\n  \"sc_heap_write h a (ACell n) v h'\""], ["", "consts sc_spurious_wakeups :: bool"], ["", "lemma new_Addr_SomeD: \"new_Addr h = \\<lfloor>a\\<rfloor> \\<Longrightarrow> rm_lookup a h = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_Addr h = \\<lfloor>a\\<rfloor> \\<Longrightarrow> rm.lookup a h = None", "apply(simp add: new_Addr_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rm.max h (\\<lambda>_. True) = None; a = 0\\<rbrakk>\n    \\<Longrightarrow> rm.lookup 0 h = None\n 2. \\<And>x2.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>x2\\<rfloor>;\n        (case x2 of (a, x) \\<Rightarrow> Suc a) = a\\<rbrakk>\n       \\<Longrightarrow> rm.lookup a h = None", "apply(drule rm.max_None[OF rm.invar])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = 0; rel_of (rm.\\<alpha> h) (\\<lambda>_. True) = {}\\<rbrakk>\n    \\<Longrightarrow> rm.lookup 0 h = None\n 2. \\<And>x2.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>x2\\<rfloor>;\n        (case x2 of (a, x) \\<Rightarrow> Suc a) = a\\<rbrakk>\n       \\<Longrightarrow> rm.lookup a h = None", "apply(simp add: rm.lookup_correct rel_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>x2\\<rfloor>;\n        (case x2 of (a, x) \\<Rightarrow> Suc a) = a\\<rbrakk>\n       \\<Longrightarrow> rm.lookup a h = None", "apply(clarsimp simp add: rm.lookup_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>(aa, b)\\<rfloor>;\n        a = Suc aa\\<rbrakk>\n       \\<Longrightarrow> rm.\\<alpha> h (Suc aa) = None", "apply(frule rm.max_Some[OF rm.invar])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>(aa, b)\\<rfloor>;\n        a = Suc aa;\n        (aa, b) \\<in> rel_of (rm.\\<alpha> h) (\\<lambda>_. True)\\<rbrakk>\n       \\<Longrightarrow> rm.\\<alpha> h (Suc aa) = None", "apply(clarsimp simp add: rel_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>(aa, b)\\<rfloor>;\n        a = Suc aa; rm.\\<alpha> h aa = \\<lfloor>b\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> rm.\\<alpha> h (Suc aa) = None", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>(a, b)\\<rfloor>;\n        rm.\\<alpha> h a = \\<lfloor>b\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> rm.\\<alpha> h (Suc a) = None", "apply(rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>(a, b)\\<rfloor>;\n        rm.\\<alpha> h a = \\<lfloor>b\\<rfloor>;\n        rm.\\<alpha> h (Suc a) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> False", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>rm.max h (\\<lambda>_. True) = \\<lfloor>(a, b)\\<rfloor>;\n        rm.\\<alpha> h a = \\<lfloor>b\\<rfloor>;\n        rm.\\<alpha> h (Suc a) = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac k'=\"Suc a\" in rm.max_Some(2)[OF rm.invar])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b y.\n       \\<lbrakk>rm.\\<alpha> h a = \\<lfloor>b\\<rfloor>;\n        rm.\\<alpha> h (Suc a) = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (Suc a, ?v'23 a b y)\n                         \\<in> rel_of (rm.\\<alpha> h) (\\<lambda>_. True)\n 2. \\<And>a b y.\n       \\<lbrakk>rm.\\<alpha> h a = \\<lfloor>b\\<rfloor>;\n        rm.\\<alpha> h (Suc a) = \\<lfloor>y\\<rfloor>; Suc a \\<le> a\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp add: rel_of_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation sc: \n  heap_base\n    \"addr2thread_id\"\n    \"thread_id2addr\"\n    \"sc_spurious_wakeups\"\n    \"sc_empty\"\n    \"sc_allocate P\"\n    \"sc_typeof_addr\"\n    \"sc_heap_read\"\n    \"sc_heap_write\"\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>Translate notation from \\<open>heap_base\\<close>\\<close>"], ["", "abbreviation sc_preallocated :: \"'m prog \\<Rightarrow> heap \\<Rightarrow> bool\"\nwhere \"sc_preallocated == sc.preallocated TYPE('m)\""], ["", "abbreviation sc_start_tid :: \"'md prog \\<Rightarrow> thread_id\"\nwhere \"sc_start_tid \\<equiv> sc.start_tid TYPE('md)\""], ["", "abbreviation sc_start_heap_ok :: \"'m prog \\<Rightarrow> bool\"\nwhere \"sc_start_heap_ok \\<equiv> sc.start_heap_ok TYPE('m)\""], ["", "abbreviation sc_start_heap :: \"'m prog \\<Rightarrow> heap\"\nwhere \"sc_start_heap \\<equiv> sc.start_heap TYPE('m)\""], ["", "abbreviation sc_start_state :: \n  \"(cname \\<Rightarrow> mname \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> 'm \\<Rightarrow> addr val list \\<Rightarrow> 'x)\n  \\<Rightarrow> 'm prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> (addr, thread_id, 'x, heap, addr) state\"\nwhere\n  \"sc_start_state f P \\<equiv> sc.start_state TYPE('m) P f P\""], ["", "abbreviation sc_wf_start_state :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> bool\"\nwhere \"sc_wf_start_state P \\<equiv> sc.wf_start_state TYPE('m) P P\""], ["", "notation sc.conf (\"_,_ \\<turnstile>sc _ :\\<le> _\"  [51,51,51,51] 50)"], ["", "notation sc.confs (\"_,_ \\<turnstile>sc _ [:\\<le>] _\" [51,51,51,51] 50)"], ["", "notation sc.hext (\"_ \\<unlhd>sc _\" [51,51] 50)"], ["", "lemma new_Addr_SomeI: \"\\<exists>a. new_Addr h = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. new_Addr h = \\<lfloor>a\\<rfloor>", "by(simp add: new_Addr_def)"], ["", "lemma sc_start_heap_ok: \"sc_start_heap_ok P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_start_heap_ok P", "by(simp add: sc.start_heap_ok_def sc.start_heap_data_def initialization_list_def sc.create_initial_object_simps sc_allocate_def case_option_conv_if new_Addr_SomeI sys_xcpts_list_def del: blank.simps split del: option.split if_split)"], ["", "lemma sc_wf_start_state_iff:\n  \"sc_wf_start_state P C M vs \\<longleftrightarrow> (\\<exists>Ts T meth D. P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D \\<and> P,sc_start_heap P \\<turnstile>sc vs [:\\<le>] Ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_wf_start_state P C M vs =\n    (\\<exists>Ts T meth D.\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>meth\\<rfloor> in D \\<and>\n        P,sc_start_heap P \\<turnstile>sc vs [:\\<le>] Ts)", "by(simp add: sc.wf_start_state.simps sc_start_heap_ok)"], ["", "lemma sc_heap:\n  \"heap addr2thread_id thread_id2addr (sc_allocate P) sc_typeof_addr sc_heap_write P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) (sc_allocate P) sc_typeof_addr\n     sc_heap_write P", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 4. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "fix h' a h hT"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 4. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "assume \"(h', a) \\<in> sc_allocate P h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> sc_allocate P h hT\n\ngoal (4 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' a h hT.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n 3. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 4. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "thus \"sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', a) \\<in> sc_allocate P h hT\n\ngoal (1 subgoal):\n 1. sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>", "by(auto simp add: sc_allocate_def sc_typeof_addr_def rm.lookup_correct rm.update_correct dest: new_Addr_SomeD split: if_split_asm)"], ["proof (state)\nthis:\n  sc_typeof_addr h' a = \\<lfloor>hT\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 3. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 3. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "fix h h' hT a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 3. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "assume \"(h', a) \\<in> sc_allocate P h hT\""], ["proof (state)\nthis:\n  (h', a) \\<in> sc_allocate P h hT\n\ngoal (3 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h' h hT a.\n       (h', a) \\<in> sc_allocate P h hT \\<Longrightarrow> h \\<unlhd>sc h'\n 3. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "from this[symmetric]"], ["proof (chain)\npicking this:\n  (a, h') \\<in> (sc_allocate P h hT)\\<inverse>", "show \"h \\<unlhd>sc h'\""], ["proof (prove)\nusing this:\n  (a, h') \\<in> (sc_allocate P h hT)\\<inverse>\n\ngoal (1 subgoal):\n 1. h \\<unlhd>sc h'", "by(fastforce simp add: sc_allocate_def sc_typeof_addr_def sc.hext_def rm.lookup_correct rm.update_correct intro!: map_leI dest: new_Addr_SomeD)"], ["proof (state)\nthis:\n  h \\<unlhd>sc h'\n\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "fix h a al v h'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "assume \"sc_heap_write h a al v h'\""], ["proof (state)\nthis:\n  sc_heap_write h a al v h'\n\ngoal (2 subgoals):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>h a al v h'.\n       sc_heap_write h a al v h' \\<Longrightarrow> h \\<unlhd>sc h'", "thus \"h \\<unlhd>sc h'\""], ["proof (prove)\nusing this:\n  sc_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd>sc h'", "by(cases al)(auto intro!: sc.hextI simp add: sc_typeof_addr_def rm.lookup_correct rm.update_correct)"], ["proof (state)\nthis:\n  h \\<unlhd>sc h'\n\ngoal (1 subgoal):\n 1. \\<And>h a C.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> a = a", "qed simp"], ["", "interpretation sc: \n  heap \n    \"addr2thread_id\"\n    \"thread_id2addr\"\n    \"sc_spurious_wakeups\"\n    \"sc_empty\"\n    \"sc_allocate P\"\n    \"sc_typeof_addr\"\n    \"sc_heap_read\"\n    \"sc_heap_write\"\n    P\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) (sc_allocate P) sc_typeof_addr\n     sc_heap_write P", "by(rule sc_heap)"], ["", "declare sc.typeof_addr_thread_id2_addr_addr2thread_id [simp del]"], ["", "lemma sc_hext_new:\n  \"rm_lookup a h = None \\<Longrightarrow> h \\<unlhd>sc rm_update a arrobj h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rm.lookup a h = None \\<Longrightarrow> h \\<unlhd>sc rm.update a arrobj h", "by(rule sc.hextI)(auto simp add: sc_typeof_addr_def rm.lookup_correct rm.update_correct dest!: new_Addr_SomeD)"], ["", "lemma sc_hext_upd_obj: \"rm_lookup a h = Some (Obj C fs) \\<Longrightarrow> h \\<unlhd>sc rm_update a (Obj C fs') h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    h \\<unlhd>sc rm.update a (Obj C fs') h", "by(rule sc.hextI)(auto simp:fun_upd_apply sc_typeof_addr_def rm.lookup_correct rm.update_correct)"], ["", "lemma sc_hext_upd_arr: \"\\<lbrakk> rm_lookup a h = Some (Arr T si f e) \\<rbrakk> \\<Longrightarrow> h \\<unlhd>sc rm_update a (Arr T si f' e') h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rm.lookup a h = \\<lfloor>Arr T si f e\\<rfloor> \\<Longrightarrow>\n    h \\<unlhd>sc rm.update a (Arr T si f' e') h", "by(rule sc.hextI)(auto simp:fun_upd_apply sc_typeof_addr_def rm.lookup_correct rm.update_correct)"], ["", "subsection \\<open>Conformance\\<close>"], ["", "definition sc_oconf :: \"'m prog \\<Rightarrow> heap \\<Rightarrow> heapobj \\<Rightarrow> bool\"   (\"_,_ \\<turnstile>sc _ \\<surd>\" [51,51,51] 50)\nwhere\n  \"P,h \\<turnstile>sc obj \\<surd>  \\<equiv>\n   (case obj of \n     Obj C fs \\<Rightarrow> \n        is_class P C \\<and> \n        (\\<forall>F D T fm. P \\<turnstile> C has F:T (fm) in D \\<longrightarrow> \n           (\\<exists>fs' v. tm_\\<alpha> fs (String.explode F) = Some fs' \\<and> lm_\\<alpha> fs' D = Some v \\<and> P,h \\<turnstile>sc v :\\<le> T))\n   | Arr T si f el \\<Rightarrow> \n      is_type P (T\\<lfloor>\\<rceil>) \\<and> (\\<forall>n. n < si \\<longrightarrow> (\\<exists>v. rm_\\<alpha> el n = Some v \\<and> P,h \\<turnstile>sc v :\\<le> T)) \\<and>\n      (\\<forall>F T fm. P \\<turnstile> Object has F:T (fm) in Object \\<longrightarrow> (\\<exists>v. lm_lookup F f = Some v \\<and> P,h \\<turnstile>sc v :\\<le> T)))\""], ["", "definition sc_hconf :: \"'m prog \\<Rightarrow> heap \\<Rightarrow> bool\"  (\"_ \\<turnstile>sc _ \\<surd>\" [51,51] 50)\nwhere \"P \\<turnstile>sc h \\<surd> \\<longleftrightarrow> (\\<forall>a obj. rm_\\<alpha> h a = Some obj \\<longrightarrow> P,h \\<turnstile>sc obj \\<surd>)\""], ["", "interpretation sc: \n  heap_conf_base  \n    \"addr2thread_id\"\n    \"thread_id2addr\"\n    \"sc_spurious_wakeups\"\n    \"sc_empty\"\n    \"sc_allocate P\"\n    \"sc_typeof_addr\"\n    \"sc_heap_read\"\n    \"sc_heap_write\"\n    \"sc_hconf P\"\n    \"P\"\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma sc_conf_upd_obj: \"rm_lookup a h = Some(Obj C fs) \\<Longrightarrow> (P,rm_update a (Obj C fs') h \\<turnstile>sc x :\\<le> T) = (P,h \\<turnstile>sc x :\\<le> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    (P,rm.update a (Obj C fs') h \\<turnstile>sc x :\\<le> T) =\n    (P,h \\<turnstile>sc x :\\<le> T)", "apply (unfold sc.conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        sc.typeof_h (rm.update a (Obj C fs') h) x =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        sc.typeof_h h x = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)", "apply (rule val.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        sc.typeof_h (rm.update a (Obj C fs') h) Unit =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        sc.typeof_h h Unit = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)\n 2. rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        sc.typeof_h (rm.update a (Obj C fs') h) Null =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        sc.typeof_h h Null = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)\n 3. \\<And>x.\n       rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           sc.typeof_h (rm.update a (Obj C fs') h) (Bool x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           sc.typeof_h h (Bool x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)\n 4. \\<And>x.\n       rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           sc.typeof_h (rm.update a (Obj C fs') h) (Intg x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           sc.typeof_h h (Intg x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)\n 5. \\<And>x.\n       rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           sc.typeof_h (rm.update a (Obj C fs') h) (Addr x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           sc.typeof_h h (Addr x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)", "apply (auto simp:fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x z.\n       \\<lbrakk>rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor>;\n        P \\<turnstile> ty_of_htype z \\<le> T;\n        sc_typeof_addr (rm.update a (Obj C fs') h) x =\n        \\<lfloor>z\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            (\\<exists>z.\n                                sc_typeof_addr h x =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T') \\<and>\n                            P \\<turnstile> T' \\<le> T\n 2. \\<And>x z.\n       \\<lbrakk>rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor>;\n        P \\<turnstile> ty_of_htype z \\<le> T;\n        sc_typeof_addr h x = \\<lfloor>z\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            (\\<exists>z.\n                                sc_typeof_addr (rm.update a (Obj C fs') h)\n                                 x =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T') \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply (auto simp add: sc_typeof_addr_def rm.lookup_correct rm.update_correct split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sc_conf_upd_arr:\n  \"rm_lookup a h = Some(Arr T si f el) \\<Longrightarrow> (P,rm_update a (Arr T si f' el') h \\<turnstile>sc x :\\<le> T') = (P,h \\<turnstile>sc x :\\<le> T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor> \\<Longrightarrow>\n    (P,rm.update a (Arr T si f' el') h \\<turnstile>sc x :\\<le> T') =\n    (P,h \\<turnstile>sc x :\\<le> T')", "apply(unfold sc.conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'a.\n        sc.typeof_h (rm.update a (Arr T si f' el') h) x =\n        \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T') =\n    (\\<exists>T'a.\n        sc.typeof_h h x = \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T')", "apply (rule val.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'a.\n        sc.typeof_h (rm.update a (Arr T si f' el') h) Unit =\n        \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T') =\n    (\\<exists>T'a.\n        sc.typeof_h h Unit = \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T')\n 2. rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'a.\n        sc.typeof_h (rm.update a (Arr T si f' el') h) Null =\n        \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T') =\n    (\\<exists>T'a.\n        sc.typeof_h h Null = \\<lfloor>T'a\\<rfloor> \\<and>\n        P \\<turnstile> T'a \\<le> T')\n 3. \\<And>x.\n       rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'a.\n           sc.typeof_h (rm.update a (Arr T si f' el') h) (Bool x) =\n           \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T') =\n       (\\<exists>T'a.\n           sc.typeof_h h (Bool x) = \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T')\n 4. \\<And>x.\n       rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'a.\n           sc.typeof_h (rm.update a (Arr T si f' el') h) (Intg x) =\n           \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T') =\n       (\\<exists>T'a.\n           sc.typeof_h h (Intg x) = \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T')\n 5. \\<And>x.\n       rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'a.\n           sc.typeof_h (rm.update a (Arr T si f' el') h) (Addr x) =\n           \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T') =\n       (\\<exists>T'a.\n           sc.typeof_h h (Addr x) = \\<lfloor>T'a\\<rfloor> \\<and>\n           P \\<turnstile> T'a \\<le> T')", "apply (auto simp:fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x z.\n       \\<lbrakk>rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor>;\n        P \\<turnstile> ty_of_htype z \\<le> T';\n        sc_typeof_addr (rm.update a (Arr T si f' el') h) x =\n        \\<lfloor>z\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'a.\n                            (\\<exists>z.\n                                sc_typeof_addr h x =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T'a) \\<and>\n                            P \\<turnstile> T'a \\<le> T'\n 2. \\<And>x z.\n       \\<lbrakk>rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor>;\n        P \\<turnstile> ty_of_htype z \\<le> T';\n        sc_typeof_addr h x = \\<lfloor>z\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'a.\n                            (\\<exists>z.\n                                sc_typeof_addr\n                                 (rm.update a (Arr T si f' el') h) x =\n                                \\<lfloor>z\\<rfloor> \\<and>\n                                ty_of_htype z = T'a) \\<and>\n                            P \\<turnstile> T'a \\<le> T'", "apply(auto simp add: sc_typeof_addr_def rm.lookup_correct rm.update_correct split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sc_oconf_hext: \"P,h \\<turnstile>sc obj \\<surd> \\<Longrightarrow> h \\<unlhd>sc h' \\<Longrightarrow> P,h' \\<turnstile>sc obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile>sc obj \\<surd>; h \\<unlhd>sc h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile>sc obj \\<surd>", "unfolding sc_oconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case obj of\n             Obj C fs \\<Rightarrow>\n               is_class P C \\<and>\n               (\\<forall>F D T fm.\n                   P \\<turnstile> C has F:T (fm) in D \\<longrightarrow>\n                   (\\<exists>fs' v.\n                       tm.\\<alpha> fs (literal.explode F) =\n                       \\<lfloor>fs'\\<rfloor> \\<and>\n                       lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n                       P,h \\<turnstile>sc v :\\<le> T))\n             | Arr T si f el \\<Rightarrow>\n                 is_type P (T\\<lfloor>\\<rceil>) \\<and>\n                 (\\<forall>n<si.\n                     \\<exists>v.\n                        rm.\\<alpha> el n = \\<lfloor>v\\<rfloor> \\<and>\n                        P,h \\<turnstile>sc v :\\<le> T) \\<and>\n                 (\\<forall>F T fm.\n                     P \\<turnstile> Object has F:T (fm) in Object \\<longrightarrow>\n                     (\\<exists>v.\n                         lm.lookup F f = \\<lfloor>v\\<rfloor> \\<and>\n                         P,h \\<turnstile>sc v :\\<le> T));\n     h \\<unlhd>sc h'\\<rbrakk>\n    \\<Longrightarrow> case obj of\n                      Obj C fs \\<Rightarrow>\n                        is_class P C \\<and>\n                        (\\<forall>F D T fm.\n                            P \\<turnstile> C has F:T (fm) in D \\<longrightarrow>\n                            (\\<exists>fs' v.\n                                tm.\\<alpha> fs (literal.explode F) =\n                                \\<lfloor>fs'\\<rfloor> \\<and>\n                                lm.\\<alpha> fs' D =\n                                \\<lfloor>v\\<rfloor> \\<and>\n                                P,h' \\<turnstile>sc v :\\<le> T))\n                      | Arr T si f el \\<Rightarrow>\n                          is_type P (T\\<lfloor>\\<rceil>) \\<and>\n                          (\\<forall>n<si.\n                              \\<exists>v.\n                                 rm.\\<alpha> el n =\n                                 \\<lfloor>v\\<rfloor> \\<and>\n                                 P,h' \\<turnstile>sc v :\\<le> T) \\<and>\n                          (\\<forall>F T fm.\n                              P \\<turnstile> Object has F:T (fm) in Object \\<longrightarrow>\n                              (\\<exists>v.\n                                  lm.lookup F f = \\<lfloor>v\\<rfloor> \\<and>\n                                  P,h' \\<turnstile>sc v :\\<le> T))", "by(fastforce split: heapobj.split elim: sc.conf_hext)"], ["", "lemma map_of_fields_init_fields:\n  assumes \"map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\"\n  shows \"\\<exists>fs' v. tm_\\<alpha> (init_fields (map (\\<lambda>(FD, (T, fm)). (FD, T)) FDTs)) (String.explode F) = \\<lfloor>fs'\\<rfloor> \\<and> lm_\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and> sc.conf P h v T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fs' v.\n       tm.\\<alpha> (init_fields (map (\\<lambda>(FD, T, fm). (FD, T)) FDTs))\n        (literal.explode F) =\n       \\<lfloor>fs'\\<rfloor> \\<and>\n       lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n       P,h \\<turnstile>sc v :\\<le> T", "using assms"], ["proof (prove)\nusing this:\n  map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>fs' v.\n       tm.\\<alpha> (init_fields (map (\\<lambda>(FD, T, fm). (FD, T)) FDTs))\n        (literal.explode F) =\n       \\<lfloor>fs'\\<rfloor> \\<and>\n       lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n       P,h \\<turnstile>sc v :\\<le> T", "by(induct FDTs)(auto simp add: tm.lookup_correct tm.update_correct lm.update_correct init_fields_def String.explode_inject)"], ["", "lemma sc_oconf_init_fields:\n  assumes \"P \\<turnstile> C has_fields FDTs\"\n  shows \"P,h \\<turnstile>sc (Obj C (init_fields (map (\\<lambda>(FD, (T, fm)). (FD, T)) FDTs))) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Obj C\n                        (init_fields\n                          (map (\\<lambda>(FD, T, fm). (FD, T))\n                            FDTs)) \\<surd>", "using assms has_fields_is_class[OF assms] map_of_fields_init_fields[of FDTs]"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  is_class P C\n  map_of FDTs (?F, ?D) = \\<lfloor>(?T, ?fm)\\<rfloor> \\<Longrightarrow>\n  \\<exists>fs' v.\n     tm.\\<alpha> (init_fields (map (\\<lambda>(FD, T, fm). (FD, T)) FDTs))\n      (literal.explode ?F) =\n     \\<lfloor>fs'\\<rfloor> \\<and>\n     lm.\\<alpha> fs' ?D = \\<lfloor>v\\<rfloor> \\<and>\n     ?P,?h \\<turnstile>sc v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Obj C\n                        (init_fields\n                          (map (\\<lambda>(FD, T, fm). (FD, T))\n                            FDTs)) \\<surd>", "by(fastforce simp add: has_field_def sc_oconf_def dest: has_fields_fun)"], ["", "lemma sc_oconf_init_arr:\n  assumes type: \"is_type P (T\\<lfloor>\\<rceil>)\"\n  shows \"P,h \\<turnstile>sc Arr T n (init_fields_array (map (\\<lambda>((F, D), (T, fm)). (F, T)) (TypeRel.fields P Object))) (init_cells T n) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "fix n'"], ["proof (state)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "assume \"n' < n\""], ["proof (state)\nthis:\n  n' < n\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "{"], ["proof (state)\nthis:\n  n' < n\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "fix rm and k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "assume \"\\<forall>i<k. \\<exists>v. rm_\\<alpha> rm i = \\<lfloor>v\\<rfloor> \\<and> sc.conf P h v T\""], ["proof (state)\nthis:\n  \\<forall>i<k.\n     \\<exists>v.\n        rm.\\<alpha> rm i = \\<lfloor>v\\<rfloor> \\<and>\n        P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "with \\<open>n' < n\\<close>"], ["proof (chain)\npicking this:\n  n' < n\n  \\<forall>i<k.\n     \\<exists>v.\n        rm.\\<alpha> rm i = \\<lfloor>v\\<rfloor> \\<and>\n        P,h \\<turnstile>sc v :\\<le> T", "have \"\\<exists>v. rm_\\<alpha> (foldl (\\<lambda>cells i. rm_update i (default_val T) cells) rm [k..<n]) n' = \\<lfloor>v\\<rfloor> \\<and> sc.conf P h v T\""], ["proof (prove)\nusing this:\n  n' < n\n  \\<forall>i<k.\n     \\<exists>v.\n        rm.\\<alpha> rm i = \\<lfloor>v\\<rfloor> \\<and>\n        P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       rm.\\<alpha>\n        (foldl (\\<lambda>cells i. rm.update i (default_val T) cells) rm\n          [k..<n])\n        n' =\n       \\<lfloor>v\\<rfloor> \\<and>\n       P,h \\<turnstile>sc v :\\<le> T", "by(induct m\\<equiv>\"n-k\" arbitrary: n k rm)(auto simp add: rm.update_correct upt_conv_Cons type)"], ["proof (state)\nthis:\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells) rm\n        [k..<n])\n      n' =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "}"], ["proof (state)\nthis:\n  \\<forall>i<?k2.\n     \\<exists>v.\n        rm.\\<alpha> ?rm2 i = \\<lfloor>v\\<rfloor> \\<and>\n        P,h \\<turnstile>sc v :\\<le> T \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells) ?rm2\n        [?k2..<n])\n      n' =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "from this[of 0 \"rm_empty ()\"]"], ["proof (chain)\npicking this:\n  \\<forall>i<0.\n     \\<exists>v.\n        rm.\\<alpha> (rm.empty ()) i = \\<lfloor>v\\<rfloor> \\<and>\n        P,h \\<turnstile>sc v :\\<le> T \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      n' =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T", "have \"\\<exists>v. rm_\\<alpha> (foldl (\\<lambda>cells i. rm_update i (default_val T) cells) (rm_empty ()) [0..<n]) n' = \\<lfloor>v\\<rfloor> \\<and> sc.conf P h v T\""], ["proof (prove)\nusing this:\n  \\<forall>i<0.\n     \\<exists>v.\n        rm.\\<alpha> (rm.empty ()) i = \\<lfloor>v\\<rfloor> \\<and>\n        P,h \\<turnstile>sc v :\\<le> T \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      n' =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       rm.\\<alpha>\n        (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n          (rm.empty ()) [0..<n])\n        n' =\n       \\<lfloor>v\\<rfloor> \\<and>\n       P,h \\<turnstile>sc v :\\<le> T", "by simp"], ["proof (state)\nthis:\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      n' =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "}"], ["proof (state)\nthis:\n  ?n'2 < n \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      ?n'2 =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "moreover"], ["proof (state)\nthis:\n  ?n'2 < n \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      ?n'2 =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "{"], ["proof (state)\nthis:\n  ?n'2 < n \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      ?n'2 =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "fix F T fm"], ["proof (state)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "assume \"P \\<turnstile> Object has F:T (fm) in Object\""], ["proof (state)\nthis:\n  P \\<turnstile> Object has F:T (fm) in Object\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> Object has F:T (fm) in Object", "obtain FDTs where has: \"P \\<turnstile> Object has_fields FDTs\"\n      and FDTs: \"map_of FDTs (F, Object) = \\<lfloor>(T, fm)\\<rfloor>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Object has F:T (fm) in Object\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> Object has_fields FDTs;\n         map_of FDTs (F, Object) = \\<lfloor>(T, fm)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: has_field_def)"], ["proof (state)\nthis:\n  P \\<turnstile> Object has_fields FDTs\n  map_of FDTs (F, Object) = \\<lfloor>(T, fm)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "from has"], ["proof (chain)\npicking this:\n  P \\<turnstile> Object has_fields FDTs", "have \"snd ` fst ` set FDTs \\<subseteq> {Object}\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. snd ` fst ` set FDTs \\<subseteq> {Object}", "by(rule Object_has_fields_Object)"], ["proof (state)\nthis:\n  snd ` fst ` set FDTs \\<subseteq> {Object}\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "with FDTs"], ["proof (chain)\npicking this:\n  map_of FDTs (F, Object) = \\<lfloor>(T, fm)\\<rfloor>\n  snd ` fst ` set FDTs \\<subseteq> {Object}", "have \"map_of (map ((\\<lambda>(F, T). (F, default_val T)) \\<circ> (\\<lambda>((F, D), T, fm). (F, T))) FDTs) F = \\<lfloor>default_val T\\<rfloor>\""], ["proof (prove)\nusing this:\n  map_of FDTs (F, Object) = \\<lfloor>(T, fm)\\<rfloor>\n  snd ` fst ` set FDTs \\<subseteq> {Object}\n\ngoal (1 subgoal):\n 1. map_of\n     (map (((\\<lambda>(F, T). (F, default_val T)) \\<circ>\\<circ> case_prod)\n            (\\<lambda>(F, D) (T, fm). (F, T)))\n       FDTs)\n     F =\n    \\<lfloor>default_val T\\<rfloor>", "by(induct FDTs) auto"], ["proof (state)\nthis:\n  map_of\n   (map (((\\<lambda>(F, T). (F, default_val T)) \\<circ>\\<circ> case_prod)\n          (\\<lambda>(F, D) (T, fm). (F, T)))\n     FDTs)\n   F =\n  \\<lfloor>default_val T\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "with has FDTs"], ["proof (chain)\npicking this:\n  P \\<turnstile> Object has_fields FDTs\n  map_of FDTs (F, Object) = \\<lfloor>(T, fm)\\<rfloor>\n  map_of\n   (map (((\\<lambda>(F, T). (F, default_val T)) \\<circ>\\<circ> case_prod)\n          (\\<lambda>(F, D) (T, fm). (F, T)))\n     FDTs)\n   F =\n  \\<lfloor>default_val T\\<rfloor>", "have \"\\<exists>v. lm_lookup F (init_fields_array (map (\\<lambda>((F, D), T, fm). (F, T)) (TypeRel.fields P Object))) = \\<lfloor>v\\<rfloor> \\<and>\n              sc.conf P h v T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Object has_fields FDTs\n  map_of FDTs (F, Object) = \\<lfloor>(T, fm)\\<rfloor>\n  map_of\n   (map (((\\<lambda>(F, T). (F, default_val T)) \\<circ>\\<circ> case_prod)\n          (\\<lambda>(F, D) (T, fm). (F, T)))\n     FDTs)\n   F =\n  \\<lfloor>default_val T\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       lm.lookup F\n        (init_fields_array\n          (map (\\<lambda>((F, D), T, fm). (F, T))\n            (TypeRel.fields P Object))) =\n       \\<lfloor>v\\<rfloor> \\<and>\n       P,h \\<turnstile>sc v :\\<le> T", "by(auto simp add: init_fields_array_def lm_correct has_field_def)"], ["proof (state)\nthis:\n  \\<exists>v.\n     lm.lookup F\n      (init_fields_array\n        (map (\\<lambda>((F, D), T, fm). (F, T))\n          (TypeRel.fields P Object))) =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "}"], ["proof (state)\nthis:\n  P \\<turnstile> Object has ?F2:?Ta2 (?fm2) in Object \\<Longrightarrow>\n  \\<exists>v.\n     lm.lookup ?F2\n      (init_fields_array\n        (map (\\<lambda>((F, D), T, fm). (F, T))\n          (TypeRel.fields P Object))) =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> ?Ta2\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  ?n'2 < n \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      ?n'2 =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n  P \\<turnstile> Object has ?F2:?Ta2 (?fm2) in Object \\<Longrightarrow>\n  \\<exists>v.\n     lm.lookup ?F2\n      (init_fields_array\n        (map (\\<lambda>((F, D), T, fm). (F, T))\n          (TypeRel.fields P Object))) =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> ?Ta2", "show ?thesis"], ["proof (prove)\nusing this:\n  ?n'2 < n \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      ?n'2 =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n  P \\<turnstile> Object has ?F2:?Ta2 (?fm2) in Object \\<Longrightarrow>\n  \\<exists>v.\n     lm.lookup ?F2\n      (init_fields_array\n        (map (\\<lambda>((F, D), T, fm). (F, T))\n          (TypeRel.fields P Object))) =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> ?Ta2\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "using type"], ["proof (prove)\nusing this:\n  ?n'2 < n \\<Longrightarrow>\n  \\<exists>v.\n     rm.\\<alpha>\n      (foldl (\\<lambda>cells i. rm.update i (default_val T) cells)\n        (rm.empty ()) [0..<n])\n      ?n'2 =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> T\n  P \\<turnstile> Object has ?F2:?Ta2 (?fm2) in Object \\<Longrightarrow>\n  \\<exists>v.\n     lm.lookup ?F2\n      (init_fields_array\n        (map (\\<lambda>((F, D), T, fm). (F, T))\n          (TypeRel.fields P Object))) =\n     \\<lfloor>v\\<rfloor> \\<and>\n     P,h \\<turnstile>sc v :\\<le> ?Ta2\n  is_type P (T\\<lfloor>\\<rceil>)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T n\n                        (init_fields_array\n                          (map (\\<lambda>((F, D), T, fm). (F, T))\n                            (TypeRel.fields P Object)))\n                        (init_cells T n) \\<surd>", "by(auto simp add: sc_oconf_def init_cells_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc Arr T n\n                      (init_fields_array\n                        (map (\\<lambda>((F, D), T, fm). (F, T))\n                          (TypeRel.fields P Object)))\n                      (init_cells T n) \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sc_oconf_fupd [intro?]:\n  \"\\<lbrakk> P \\<turnstile> C has F:T (fm) in D; P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Obj C fs) \\<surd>;\n    fs' = (case tm_lookup (String.explode F) fs of None \\<Rightarrow> lm_empty () | Some fs' \\<Rightarrow> fs') \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Obj C (tm_update (String.explode F) (lm_update D v fs') fs)) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T (fm) in D;\n     P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc Obj C fs \\<surd>;\n     fs' =\n     (case tm.lookup (literal.explode F) fs of\n      None \\<Rightarrow> lm.empty ()\n      | \\<lfloor>fs'\\<rfloor> \\<Rightarrow> fs')\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc Obj C\n    (tm.update (literal.explode F) (lm.update D v fs') fs) \\<surd>", "unfolding sc_oconf_def has_field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>FDTs.\n                P \\<turnstile> C has_fields FDTs \\<and>\n                map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>;\n     P,h \\<turnstile>sc v :\\<le> T;\n     case Obj C fs of\n     Obj C fs \\<Rightarrow>\n       is_class P C \\<and>\n       (\\<forall>F D T fm.\n           (\\<exists>FDTs.\n               P \\<turnstile> C has_fields FDTs \\<and>\n               map_of FDTs (F, D) =\n               \\<lfloor>(T, fm)\\<rfloor>) \\<longrightarrow>\n           (\\<exists>fs' v.\n               tm.\\<alpha> fs (literal.explode F) =\n               \\<lfloor>fs'\\<rfloor> \\<and>\n               lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n               P,h \\<turnstile>sc v :\\<le> T))\n     | Arr T si f el \\<Rightarrow>\n         is_type P (T\\<lfloor>\\<rceil>) \\<and>\n         (\\<forall>n<si.\n             \\<exists>v.\n                rm.\\<alpha> el n = \\<lfloor>v\\<rfloor> \\<and>\n                P,h \\<turnstile>sc v :\\<le> T) \\<and>\n         (\\<forall>F T fm.\n             (\\<exists>FDTs.\n                 P \\<turnstile> Object has_fields FDTs \\<and>\n                 map_of FDTs (F, Object) =\n                 \\<lfloor>(T, fm)\\<rfloor>) \\<longrightarrow>\n             (\\<exists>v.\n                 lm.lookup F f = \\<lfloor>v\\<rfloor> \\<and>\n                 P,h \\<turnstile>sc v :\\<le> T));\n     fs' =\n     (case tm.lookup (literal.explode F) fs of\n      None \\<Rightarrow> lm.empty ()\n      | \\<lfloor>fs'\\<rfloor> \\<Rightarrow> fs')\\<rbrakk>\n    \\<Longrightarrow> case Obj C\n                            (tm.update (literal.explode F)\n                              (lm.update D v fs') fs) of\n                      Obj C fs \\<Rightarrow>\n                        is_class P C \\<and>\n                        (\\<forall>F D T fm.\n                            (\\<exists>FDTs.\n                                P \\<turnstile> C has_fields FDTs \\<and>\n                                map_of FDTs (F, D) =\n                                \\<lfloor>(T, fm)\\<rfloor>) \\<longrightarrow>\n                            (\\<exists>fs' v.\n                                tm.\\<alpha> fs (literal.explode F) =\n                                \\<lfloor>fs'\\<rfloor> \\<and>\n                                lm.\\<alpha> fs' D =\n                                \\<lfloor>v\\<rfloor> \\<and>\n                                P,h \\<turnstile>sc v :\\<le> T))\n                      | Arr T si f el \\<Rightarrow>\n                          is_type P (T\\<lfloor>\\<rceil>) \\<and>\n                          (\\<forall>n<si.\n                              \\<exists>v.\n                                 rm.\\<alpha> el n =\n                                 \\<lfloor>v\\<rfloor> \\<and>\n                                 P,h \\<turnstile>sc v :\\<le> T) \\<and>\n                          (\\<forall>F T fm.\n                              (\\<exists>FDTs.\n                                  P \\<turnstile> Object has_fields FDTs \\<and>\n                                  map_of FDTs (F, Object) =\n                                  \\<lfloor>(T,\n      fm)\\<rfloor>) \\<longrightarrow>\n                              (\\<exists>v.\n                                  lm.lookup F f = \\<lfloor>v\\<rfloor> \\<and>\n                                  P,h \\<turnstile>sc v :\\<le> T))", "apply(auto dest: has_fields_fun simp add: lm.update_correct tm.update_correct tm.lookup_correct String.explode_inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>FDTs Da Ta fma FDTsa.\n       \\<lbrakk>P,h \\<turnstile>sc v :\\<le> T;\n        tm.\\<alpha> fs (literal.explode F) = None; is_class P C;\n        \\<forall>F D T.\n           (\\<exists>fm FDTs.\n               P \\<turnstile> C has_fields FDTs \\<and>\n               map_of FDTs (F, D) =\n               \\<lfloor>(T, fm)\\<rfloor>) \\<longrightarrow>\n           (\\<exists>fs'.\n               tm.\\<alpha> fs (literal.explode F) =\n               \\<lfloor>fs'\\<rfloor> \\<and>\n               (\\<exists>v.\n                   lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n                   P,h \\<turnstile>sc v :\\<le> T));\n        P \\<turnstile> C has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>; fs' = lm.empty ();\n        Da \\<noteq> D; P \\<turnstile> C has_fields FDTsa;\n        map_of FDTsa (F, Da) = \\<lfloor>(Ta, fma)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            lm.\\<alpha> (lm.empty ()) Da =\n                            \\<lfloor>v\\<rfloor> \\<and>\n                            P,h \\<turnstile>sc v :\\<le> Ta\n 2. \\<And>FDTs Da Ta fma FDTsa.\n       \\<lbrakk>P,h \\<turnstile>sc v :\\<le> T; is_class P C;\n        \\<forall>F D T.\n           (\\<exists>fm FDTs.\n               P \\<turnstile> C has_fields FDTs \\<and>\n               map_of FDTs (F, D) =\n               \\<lfloor>(T, fm)\\<rfloor>) \\<longrightarrow>\n           (\\<exists>fs'.\n               tm.\\<alpha> fs (literal.explode F) =\n               \\<lfloor>fs'\\<rfloor> \\<and>\n               (\\<exists>v.\n                   lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n                   P,h \\<turnstile>sc v :\\<le> T));\n        tm.\\<alpha> fs (literal.explode F) = \\<lfloor>fs'\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>; Da \\<noteq> D;\n        P \\<turnstile> C has_fields FDTsa;\n        map_of FDTsa (F, Da) = \\<lfloor>(Ta, fma)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            lm.\\<alpha> fs' Da = \\<lfloor>v\\<rfloor> \\<and>\n                            P,h \\<turnstile>sc v :\\<le> Ta", "apply(drule (1) has_fields_fun, fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs Da Ta fma FDTsa.\n       \\<lbrakk>P,h \\<turnstile>sc v :\\<le> T; is_class P C;\n        \\<forall>F D T.\n           (\\<exists>fm FDTs.\n               P \\<turnstile> C has_fields FDTs \\<and>\n               map_of FDTs (F, D) =\n               \\<lfloor>(T, fm)\\<rfloor>) \\<longrightarrow>\n           (\\<exists>fs'.\n               tm.\\<alpha> fs (literal.explode F) =\n               \\<lfloor>fs'\\<rfloor> \\<and>\n               (\\<exists>v.\n                   lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n                   P,h \\<turnstile>sc v :\\<le> T));\n        tm.\\<alpha> fs (literal.explode F) = \\<lfloor>fs'\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>(T, fm)\\<rfloor>; Da \\<noteq> D;\n        P \\<turnstile> C has_fields FDTsa;\n        map_of FDTsa (F, Da) = \\<lfloor>(Ta, fma)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            lm.\\<alpha> fs' Da = \\<lfloor>v\\<rfloor> \\<and>\n                            P,h \\<turnstile>sc v :\\<le> Ta", "apply(drule (1) has_fields_fun, fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sc_oconf_fupd_arr [intro?]:\n  \"\\<lbrakk> P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Arr T si f el) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Arr T si f (rm_update i v el)) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile>sc v :\\<le> T;\n     P,h \\<turnstile>sc Arr T si f el \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc Arr T si f\n    (rm.update i v el) \\<surd>", "unfolding sc_oconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile>sc v :\\<le> T;\n     case Arr T si f el of\n     Obj C fs \\<Rightarrow>\n       is_class P C \\<and>\n       (\\<forall>F D T fm.\n           P \\<turnstile> C has F:T (fm) in D \\<longrightarrow>\n           (\\<exists>fs' v.\n               tm.\\<alpha> fs (literal.explode F) =\n               \\<lfloor>fs'\\<rfloor> \\<and>\n               lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n               P,h \\<turnstile>sc v :\\<le> T))\n     | Arr T si f el \\<Rightarrow>\n         is_type P (T\\<lfloor>\\<rceil>) \\<and>\n         (\\<forall>n<si.\n             \\<exists>v.\n                rm.\\<alpha> el n = \\<lfloor>v\\<rfloor> \\<and>\n                P,h \\<turnstile>sc v :\\<le> T) \\<and>\n         (\\<forall>F T fm.\n             P \\<turnstile> Object has F:T (fm) in Object \\<longrightarrow>\n             (\\<exists>v.\n                 lm.lookup F f = \\<lfloor>v\\<rfloor> \\<and>\n                 P,h \\<turnstile>sc v :\\<le> T))\\<rbrakk>\n    \\<Longrightarrow> case Arr T si f (rm.update i v el) of\n                      Obj C fs \\<Rightarrow>\n                        is_class P C \\<and>\n                        (\\<forall>F D T fm.\n                            P \\<turnstile> C has F:T (fm) in D \\<longrightarrow>\n                            (\\<exists>fs' v.\n                                tm.\\<alpha> fs (literal.explode F) =\n                                \\<lfloor>fs'\\<rfloor> \\<and>\n                                lm.\\<alpha> fs' D =\n                                \\<lfloor>v\\<rfloor> \\<and>\n                                P,h \\<turnstile>sc v :\\<le> T))\n                      | Arr T si f el \\<Rightarrow>\n                          is_type P (T\\<lfloor>\\<rceil>) \\<and>\n                          (\\<forall>n<si.\n                              \\<exists>v.\n                                 rm.\\<alpha> el n =\n                                 \\<lfloor>v\\<rfloor> \\<and>\n                                 P,h \\<turnstile>sc v :\\<le> T) \\<and>\n                          (\\<forall>F T fm.\n                              P \\<turnstile> Object has F:T (fm) in Object \\<longrightarrow>\n                              (\\<exists>v.\n                                  lm.lookup F f = \\<lfloor>v\\<rfloor> \\<and>\n                                  P,h \\<turnstile>sc v :\\<le> T))", "by(auto simp add: rm.update_correct)"], ["", "lemma sc_oconf_fupd_arr_fields:\n  \"\\<lbrakk> P \\<turnstile> Object has F:T (fm) in Object; P,h \\<turnstile>sc v :\\<le> T; P,h \\<turnstile>sc (Arr T' si f el) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> P,h \\<turnstile>sc (Arr T' si (lm_update F v f) el) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Object has F:T (fm) in Object;\n     P,h \\<turnstile>sc v :\\<le> T;\n     P,h \\<turnstile>sc Arr T' si f el \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc Arr T' si (lm.update F v f)\n    el \\<surd>", "unfolding sc_oconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Object has F:T (fm) in Object;\n     P,h \\<turnstile>sc v :\\<le> T;\n     case Arr T' si f el of\n     Obj C fs \\<Rightarrow>\n       is_class P C \\<and>\n       (\\<forall>F D T fm.\n           P \\<turnstile> C has F:T (fm) in D \\<longrightarrow>\n           (\\<exists>fs' v.\n               tm.\\<alpha> fs (literal.explode F) =\n               \\<lfloor>fs'\\<rfloor> \\<and>\n               lm.\\<alpha> fs' D = \\<lfloor>v\\<rfloor> \\<and>\n               P,h \\<turnstile>sc v :\\<le> T))\n     | Arr T si f el \\<Rightarrow>\n         is_type P (T\\<lfloor>\\<rceil>) \\<and>\n         (\\<forall>n<si.\n             \\<exists>v.\n                rm.\\<alpha> el n = \\<lfloor>v\\<rfloor> \\<and>\n                P,h \\<turnstile>sc v :\\<le> T) \\<and>\n         (\\<forall>F T fm.\n             P \\<turnstile> Object has F:T (fm) in Object \\<longrightarrow>\n             (\\<exists>v.\n                 lm.lookup F f = \\<lfloor>v\\<rfloor> \\<and>\n                 P,h \\<turnstile>sc v :\\<le> T))\\<rbrakk>\n    \\<Longrightarrow> case Arr T' si (lm.update F v f) el of\n                      Obj C fs \\<Rightarrow>\n                        is_class P C \\<and>\n                        (\\<forall>F D T fm.\n                            P \\<turnstile> C has F:T (fm) in D \\<longrightarrow>\n                            (\\<exists>fs' v.\n                                tm.\\<alpha> fs (literal.explode F) =\n                                \\<lfloor>fs'\\<rfloor> \\<and>\n                                lm.\\<alpha> fs' D =\n                                \\<lfloor>v\\<rfloor> \\<and>\n                                P,h \\<turnstile>sc v :\\<le> T))\n                      | Arr T si f el \\<Rightarrow>\n                          is_type P (T\\<lfloor>\\<rceil>) \\<and>\n                          (\\<forall>n<si.\n                              \\<exists>v.\n                                 rm.\\<alpha> el n =\n                                 \\<lfloor>v\\<rfloor> \\<and>\n                                 P,h \\<turnstile>sc v :\\<le> T) \\<and>\n                          (\\<forall>F T fm.\n                              P \\<turnstile> Object has F:T (fm) in Object \\<longrightarrow>\n                              (\\<exists>v.\n                                  lm.lookup F f = \\<lfloor>v\\<rfloor> \\<and>\n                                  P,h \\<turnstile>sc v :\\<le> T))", "by(auto dest: has_field_fun simp add: lm_correct)"], ["", "lemma sc_oconf_new: \"\\<lbrakk> P,h \\<turnstile>sc obj \\<surd>; rm_lookup a h = None \\<rbrakk> \\<Longrightarrow> P,rm_update a arrobj h \\<turnstile>sc obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile>sc obj \\<surd>; rm.lookup a h = None\\<rbrakk>\n    \\<Longrightarrow> P,rm.update a arrobj h \\<turnstile>sc obj \\<surd>", "by(erule sc_oconf_hext)(rule sc_hext_new)"], ["", "lemmas sc_oconf_upd_obj = sc_oconf_hext [OF _ sc_hext_upd_obj]"], ["", "lemma sc_oconf_upd_arr:\n  assumes \"P,h \\<turnstile>sc obj \\<surd>\"\n  and ha: \"rm_lookup a h = \\<lfloor>Arr T si f el\\<rfloor>\"\n  shows \"P,rm_update a (Arr T si f' el') h \\<turnstile>sc obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,rm.update a (Arr T si f' el') h \\<turnstile>sc obj \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  P,h \\<turnstile>sc obj \\<surd>\n  rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,rm.update a (Arr T si f' el') h \\<turnstile>sc obj \\<surd>", "by(fastforce simp add: sc_oconf_def sc_conf_upd_arr[OF ha] split: heapobj.split)"], ["", "lemma sc_oconf_blank: \"is_htype P hT \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_htype P hT \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>", "apply(cases hT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_htype P hT; hT = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>\n 2. \\<And>x21 x22.\n       \\<lbrakk>is_htype P hT; hT = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>", "apply(fastforce dest: map_of_fields_init_fields simp add: has_field_def sc_oconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>is_htype P hT; hT = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc blank P hT \\<surd>", "by(auto intro: sc_oconf_init_arr)"], ["", "lemma sc_hconfD: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; rm_lookup a h = Some obj \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile>sc obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n     rm.lookup a h = \\<lfloor>obj\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc obj \\<surd>", "unfolding sc_hconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a obj.\n                rm.\\<alpha> h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                P,h \\<turnstile>sc obj \\<surd>;\n     rm.lookup a h = \\<lfloor>obj\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile>sc obj \\<surd>", "by(auto simp add: rm.lookup_correct)"], ["", "lemmas sc_preallocated_new = sc.preallocated_hext[OF _ sc_hext_new]"], ["", "lemmas sc_preallocated_upd_obj = sc.preallocated_hext [OF _ sc_hext_upd_obj]"], ["", "lemmas sc_preallocated_upd_arr = sc.preallocated_hext [OF _ sc_hext_upd_arr]"], ["", "lemma sc_hconf_new: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; rm_lookup a h = None; P,h \\<turnstile>sc obj \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc rm_update a obj h \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile>sc h \\<surd>; rm.lookup a h = None;\n     P,h \\<turnstile>sc obj \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile>sc rm.update a obj h \\<surd>", "unfolding sc_hconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a obj.\n                rm.\\<alpha> h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                P,h \\<turnstile>sc obj \\<surd>;\n     rm.lookup a h = None; P,h \\<turnstile>sc obj \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa obja.\n                         rm.\\<alpha> (rm.update a obj h) aa =\n                         \\<lfloor>obja\\<rfloor> \\<longrightarrow>\n                         P,rm.update a obj h \\<turnstile>sc obja \\<surd>", "by(auto intro: sc_oconf_new simp add: rm.lookup_correct rm.update_correct)"], ["", "lemma sc_hconf_upd_obj: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; rm_lookup a h = Some (Obj C fs); P,h \\<turnstile>sc (Obj C fs') \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc rm_update a (Obj C fs') h \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n     rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor>;\n     P,h \\<turnstile>sc Obj C fs' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile>sc rm.update a (Obj C fs') h \\<surd>", "unfolding sc_hconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a obj.\n                rm.\\<alpha> h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                P,h \\<turnstile>sc obj \\<surd>;\n     rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor>;\n     P,h \\<turnstile>sc Obj C fs' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa obj.\n                         rm.\\<alpha> (rm.update a (Obj C fs') h) aa =\n                         \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                         P,rm.update a (Obj C fs')\n                            h \\<turnstile>sc obj \\<surd>", "by(auto intro: sc_oconf_upd_obj simp add: rm.lookup_correct rm.update_correct)"], ["", "lemma sc_hconf_upd_arr: \"\\<lbrakk> P \\<turnstile>sc h \\<surd>; rm_lookup a h = Some(Arr T si f el); P,h \\<turnstile>sc (Arr T si f' el') \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile>sc rm_update a (Arr T si f' el') h \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n     rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor>;\n     P,h \\<turnstile>sc Arr T si f' el' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile>sc rm.update a (Arr T si f' el')\n  h \\<surd>", "unfolding sc_hconf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a obj.\n                rm.\\<alpha> h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                P,h \\<turnstile>sc obj \\<surd>;\n     rm.lookup a h = \\<lfloor>Arr T si f el\\<rfloor>;\n     P,h \\<turnstile>sc Arr T si f' el' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa obj.\n                         rm.\\<alpha> (rm.update a (Arr T si f' el') h) aa =\n                         \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                         P,rm.update a (Arr T si f' el')\n                            h \\<turnstile>sc obj \\<surd>", "by(auto intro: sc_oconf_upd_arr simp add: rm.lookup_correct rm.update_correct)"], ["", "lemma sc_heap_conf: \n  \"heap_conf addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) (rm.empty ()) (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) P", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. P \\<turnstile>sc rm.empty () \\<surd>\n 2. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 3. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 4. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "show \"P \\<turnstile>sc sc_empty \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile>sc rm.empty () \\<surd>", "by(simp add: sc_hconf_def rm.empty_correct)"], ["proof (state)\nthis:\n  P \\<turnstile>sc rm.empty () \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "fix h a hT"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "assume \"sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>\" \"P \\<turnstile>sc h \\<surd>\""], ["proof (state)\nthis:\n  sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile>sc h \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>h a hT.\n       \\<lbrakk>sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> is_htype P hT\n 2. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 3. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "thus \"is_htype P hT\""], ["proof (prove)\nusing this:\n  sc_typeof_addr h a = \\<lfloor>hT\\<rfloor>\n  P \\<turnstile>sc h \\<surd>\n\ngoal (1 subgoal):\n 1. is_htype P hT", "by(auto simp add: sc_typeof_addr_def sc_oconf_def dest!: sc_hconfD split: heapobj.split_asm)"], ["proof (state)\nthis:\n  is_htype P hT\n\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "fix h' hT h a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "assume \"P \\<turnstile>sc h \\<surd>\" \"(h', a) \\<in> sc_allocate P h hT\" \"is_htype P hT\""], ["proof (state)\nthis:\n  P \\<turnstile>sc h \\<surd>\n  (h', a) \\<in> sc_allocate P h hT\n  is_htype P hT\n\ngoal (2 subgoals):\n 1. \\<And>h' h hT a.\n       \\<lbrakk>(h', a) \\<in> sc_allocate P h hT;\n        P \\<turnstile>sc h \\<surd>; is_htype P hT\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>\n 2. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "thus \"P \\<turnstile>sc h' \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  (h', a) \\<in> sc_allocate P h hT\n  is_htype P hT\n\ngoal (1 subgoal):\n 1. P \\<turnstile>sc h' \\<surd>", "by(auto simp add: sc_allocate_def dest!: new_Addr_SomeD intro: sc_hconf_new sc_oconf_blank split: if_split_asm)"], ["proof (state)\nthis:\n  P \\<turnstile>sc h' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "fix h a al T v h'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "assume \"P \\<turnstile>sc h \\<surd>\"\n    and \"sc.addr_loc_type P h a al T\"\n    and \"P,h \\<turnstile>sc v :\\<le> T\"\n    and \"sc_heap_write h a al v h'\""], ["proof (state)\nthis:\n  P \\<turnstile>sc h \\<surd>\n  sc.addr_loc_type P h a al T\n  P,h \\<turnstile>sc v :\\<le> T\n  sc_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. \\<And>h a al v h' T.\n       \\<lbrakk>sc_heap_write h a al v h'; P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T; P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile>sc h' \\<surd>", "thus \"P \\<turnstile>sc h' \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  sc.addr_loc_type P h a al T\n  P,h \\<turnstile>sc v :\\<le> T\n  sc_heap_write h a al v h'\n\ngoal (1 subgoal):\n 1. P \\<turnstile>sc h' \\<surd>", "by(cases al)(fastforce elim!: sc.addr_loc_type.cases simp add: sc_typeof_addr_def intro: sc_hconf_upd_obj sc_oconf_fupd sc_hconfD sc_hconf_upd_arr sc_oconf_fupd_arr sc_oconf_fupd_arr_fields)+"], ["proof (state)\nthis:\n  P \\<turnstile>sc h' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation sc: \n  heap_conf\n    \"addr2thread_id\"\n    \"thread_id2addr\"\n    \"sc_spurious_wakeups\"\n    \"sc_empty\"\n    \"sc_allocate P\"\n    \"sc_typeof_addr\"\n    \"sc_heap_read\"\n    \"sc_heap_write\"\n    \"sc_hconf P\"\n    \"P\"\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) (rm.empty ()) (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) P", "by(rule sc_heap_conf)"], ["", "lemma sc_heap_progress:\n  \"heap_progress addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) (rm.empty ())\n     (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "fix h a al T"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "assume hconf: \"P \\<turnstile>sc h \\<surd>\"\n    and alt: \"sc.addr_loc_type P h a al T\""], ["proof (state)\nthis:\n  P \\<turnstile>sc h \\<surd>\n  sc.addr_loc_type P h a al T\n\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "from alt"], ["proof (chain)\npicking this:\n  sc.addr_loc_type P h a al T", "obtain arrobj where arrobj: \"rm_lookup a h = \\<lfloor>arrobj\\<rfloor>\""], ["proof (prove)\nusing this:\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. (\\<And>arrobj.\n        rm.lookup a h = \\<lfloor>arrobj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: sc.addr_loc_type.cases simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>h a al T.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        sc.addr_loc_type P h a al T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "from alt"], ["proof (chain)\npicking this:\n  sc.addr_loc_type P h a al T", "show \"\\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U F fm D.\n       \\<lbrakk>al = CField D F; sc_typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of U has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "case (addr_loc_type_field U F fm D)"], ["proof (state)\nthis:\n  al = CField D F\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n\ngoal (2 subgoals):\n 1. \\<And>U F fm D.\n       \\<lbrakk>al = CField D F; sc_typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of U has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "note [simp] = \\<open>al = CField D F\\<close>"], ["proof (state)\nthis:\n  al = CField D F\n\ngoal (2 subgoals):\n 1. \\<And>U F fm D.\n       \\<lbrakk>al = CField D F; sc_typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of U has F:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "proof(cases \"arrobj\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "case (Obj C' fs)"], ["proof (state)\nthis:\n  arrobj = Obj C' fs\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "with \\<open>sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\\<close> arrobj"], ["proof (chain)\npicking this:\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Obj C' fs", "have [simp]: \"C' = class_type_of U\""], ["proof (prove)\nusing this:\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Obj C' fs\n\ngoal (1 subgoal):\n 1. C' = class_type_of U", "by(auto simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  C' = class_type_of U\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "from hconf arrobj Obj"], ["proof (chain)\npicking this:\n  P \\<turnstile>sc h \\<surd>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Obj C' fs", "have \"P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Obj C' fs\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>", "by(auto dest: sc_hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "with \\<open>P \\<turnstile> class_type_of U has F:T (fm) in D\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n  P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>", "obtain fs' v \n      where \"tm_lookup (String.explode F) fs = \\<lfloor>fs'\\<rfloor>\" \"lm_lookup D fs' = \\<lfloor>v\\<rfloor>\" \"P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n  P,h \\<turnstile>sc Obj (class_type_of U) fs \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>fs' v.\n        \\<lbrakk>tm.lookup (literal.explode F) fs = \\<lfloor>fs'\\<rfloor>;\n         lm.lookup D fs' = \\<lfloor>v\\<rfloor>;\n         P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: sc_oconf_def tm.lookup_correct lm.lookup_correct)"], ["proof (state)\nthis:\n  tm.lookup (literal.explode F) fs = \\<lfloor>fs'\\<rfloor>\n  lm.lookup D fs' = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       arrobj = Obj x11 x12 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  tm.lookup (literal.explode F) fs = \\<lfloor>fs'\\<rfloor>\n  lm.lookup D fs' = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "using Obj arrobj"], ["proof (prove)\nusing this:\n  tm.lookup (literal.explode F) fs = \\<lfloor>fs'\\<rfloor>\n  lm.lookup D fs' = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n  arrobj = Obj C' fs\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "by(auto intro: sc_heap_read.intros)"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "case (Arr T' si f el)"], ["proof (state)\nthis:\n  arrobj = Arr T' si f el\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "with \\<open>sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\\<close> arrobj"], ["proof (chain)\npicking this:\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Arr T' si f el", "have [simp]: \"U = Array_type T' si\""], ["proof (prove)\nusing this:\n  sc_typeof_addr h a = \\<lfloor>U\\<rfloor>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Arr T' si f el\n\ngoal (1 subgoal):\n 1. U = Array_type T' si", "by(auto simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  U = Array_type T' si\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "from hconf arrobj Arr"], ["proof (chain)\npicking this:\n  P \\<turnstile>sc h \\<surd>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Arr T' si f el", "have \"P,h \\<turnstile>sc Arr T' si f el \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  arrobj = Arr T' si f el\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T' si f el \\<surd>", "by(auto dest: sc_hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc Arr T' si f el \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "from \\<open>P \\<turnstile> class_type_of U has F:T (fm) in D\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> class_type_of U has F:T (fm) in D", "have [simp]: \"D = Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n\ngoal (1 subgoal):\n 1. D = Object", "by(auto dest: has_field_decl_above)"], ["proof (state)\nthis:\n  D = Object\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "with \\<open>P,h \\<turnstile>sc Arr T' si f el \\<surd>\\<close> \\<open>P \\<turnstile> class_type_of U has F:T (fm) in D\\<close>"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>sc Arr T' si f el \\<surd>\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n  D = Object", "obtain v where \"lm_lookup F f = \\<lfloor>v\\<rfloor>\" \"P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>sc Arr T' si f el \\<surd>\n  P \\<turnstile> class_type_of U has F:T (fm) in D\n  D = Object\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>lm.lookup F f = \\<lfloor>v\\<rfloor>;\n         P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: sc_oconf_def)"], ["proof (state)\nthis:\n  lm.lookup F f = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24.\n       arrobj = Arr x21 x22 x23 x24 \\<Longrightarrow>\n       \\<exists>v.\n          sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  lm.lookup F f = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "using Arr arrobj"], ["proof (prove)\nusing this:\n  lm.lookup F f = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n  arrobj = Arr T' si f el\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "by(auto intro: sc_heap_read.intros)"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "case (addr_loc_type_cell n' n)"], ["proof (state)\nthis:\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "with arrobj"], ["proof (chain)\npicking this:\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'", "obtain si f el\n      where [simp]: \"arrobj = Arr T si f el\""], ["proof (prove)\nusing this:\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'\n\ngoal (1 subgoal):\n 1. (\\<And>si f el.\n        arrobj = Arr T si f el \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases arrobj)(auto simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  arrobj = Arr T si f el\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "from addr_loc_type_cell arrobj"], ["proof (chain)\npicking this:\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>", "have [simp]: \"al = ACell n\" and n: \"n < si\""], ["proof (prove)\nusing this:\n  al = ACell n\n  sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>\n  n < n'\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. al = ACell n &&& n < si", "by(auto simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  al = ACell n\n  n < si\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "from hconf arrobj"], ["proof (chain)\npicking this:\n  P \\<turnstile>sc h \\<surd>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>", "have \"P,h \\<turnstile>sc Arr T si f el \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile>sc h \\<surd>\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc Arr T si f el \\<surd>", "by(auto dest: sc_hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc Arr T si f el \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "with n"], ["proof (chain)\npicking this:\n  n < si\n  P,h \\<turnstile>sc Arr T si f el \\<surd>", "obtain v where \"rm_lookup n el = \\<lfloor>v\\<rfloor>\" \"P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  n < si\n  P,h \\<turnstile>sc Arr T si f el \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>rm.lookup n el = \\<lfloor>v\\<rfloor>;\n         P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: sc_oconf_def rm.lookup_correct)"], ["proof (state)\nthis:\n  rm.lookup n el = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>n' n.\n       \\<lbrakk>al = ACell n;\n        sc_typeof_addr h a = \\<lfloor>Array_type T n'\\<rfloor>;\n        n < n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            sc_heap_read h a al v \\<and>\n                            P,h \\<turnstile>sc v :\\<le> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  rm.lookup n el = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "using arrobj n"], ["proof (prove)\nusing this:\n  rm.lookup n el = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile>sc v :\\<le> T\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  n < si\n\ngoal (1 subgoal):\n 1. \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T", "by(fastforce intro: sc_heap_read.intros)"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v. sc_heap_read h a al v \\<and> P,h \\<turnstile>sc v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "fix h a al T v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "assume alt: \"sc.addr_loc_type P h a al T\""], ["proof (state)\nthis:\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "from alt"], ["proof (chain)\npicking this:\n  sc.addr_loc_type P h a al T", "obtain arrobj where arrobj: \"rm_lookup a h = \\<lfloor>arrobj\\<rfloor>\""], ["proof (prove)\nusing this:\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. (\\<And>arrobj.\n        rm.lookup a h = \\<lfloor>arrobj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: sc.addr_loc_type.cases simp add: sc_typeof_addr_def)"], ["proof (state)\nthis:\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>h a al T v.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; sc.addr_loc_type P h a al T;\n        P,h \\<turnstile>sc v :\\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'. sc_heap_write h a al v h'", "thus \"\\<exists>h'. sc_heap_write h a al v h'\""], ["proof (prove)\nusing this:\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>h'. sc_heap_write h a al v h'", "using alt"], ["proof (prove)\nusing this:\n  rm.lookup a h = \\<lfloor>arrobj\\<rfloor>\n  sc.addr_loc_type P h a al T\n\ngoal (1 subgoal):\n 1. \\<exists>h'. sc_heap_write h a al v h'", "by(cases arrobj)(fastforce intro: sc_heap_write.intros elim!: sc.addr_loc_type.cases simp add: sc_typeof_addr_def dest: has_field_decl_above)+"], ["proof (state)\nthis:\n  \\<exists>h'. sc_heap_write h a al v h'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation sc: \n  heap_progress\n    \"addr2thread_id\"\n    \"thread_id2addr\"\n    \"sc_spurious_wakeups\"\n    \"sc_empty\"\n    \"sc_allocate P\"\n    \"sc_typeof_addr\"\n    \"sc_heap_read\"\n    \"sc_heap_write\"\n    \"sc_hconf P\"\n    \"P\"\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_progress (\\<lambda>x. x) (\\<lambda>x. x) (rm.empty ())\n     (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     P", "by(rule sc_heap_progress)"], ["", "lemma sc_heap_conf_read:\n  \"heap_conf_read addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) (rm.empty ())\n     (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>sc_heap_read h a al v; sc.addr_loc_type P h a al T;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc v :\\<le> T", "fix h a al v T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>sc_heap_read h a al v; sc.addr_loc_type P h a al T;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc v :\\<le> T", "assume read: \"sc_heap_read h a al v\"\n    and alt: \"sc.addr_loc_type P h a al T\"\n    and hconf: \"P \\<turnstile>sc h \\<surd>\""], ["proof (state)\nthis:\n  sc_heap_read h a al v\n  sc.addr_loc_type P h a al T\n  P \\<turnstile>sc h \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>h a al v T.\n       \\<lbrakk>sc_heap_read h a al v; sc.addr_loc_type P h a al T;\n        P \\<turnstile>sc h \\<surd>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc v :\\<le> T", "thus \"P,h \\<turnstile>sc v :\\<le> T\""], ["proof (prove)\nusing this:\n  sc_heap_read h a al v\n  sc.addr_loc_type P h a al T\n  P \\<turnstile>sc h \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>sc v :\\<le> T", "apply(auto elim!: sc_heap_read.cases sc.addr_loc_type.cases simp add: sc_typeof_addr_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F fm D C fs fs'.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        P \\<turnstile> C has F:T (fm) in D; al = CField D F;\n        rm.lookup a h = \\<lfloor>Obj C fs\\<rfloor>;\n        tm.lookup (literal.explode F) fs = \\<lfloor>fs'\\<rfloor>;\n        lm.lookup D fs' = \\<lfloor>v\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc v :\\<le> T\n 2. \\<And>F fm Ta si f el.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>;\n        P \\<turnstile> Object has F:T (fm) in Object; al = CField Object F;\n        rm.lookup a h = \\<lfloor>Arr Ta si f el\\<rfloor>;\n        lm.lookup F f = \\<lfloor>v\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc v :\\<le> T\n 3. \\<And>n' n f el.\n       \\<lbrakk>P \\<turnstile>sc h \\<surd>; al = ACell n;\n        rm.lookup a h = \\<lfloor>Arr T n' f el\\<rfloor>; n < n';\n        v = the (rm.lookup n el)\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile>sc the (rm.lookup n el) :\\<le> T", "apply(fastforce dest!: sc_hconfD simp add: sc_oconf_def tm.lookup_correct lm.lookup_correct rm.lookup_correct)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P,h \\<turnstile>sc v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation sc: \n  heap_conf_read\n    \"addr2thread_id\"\n    \"thread_id2addr\"\n    \"sc_spurious_wakeups\"\n    \"sc_empty\"\n    \"sc_allocate P\"\n    \"sc_typeof_addr\"\n    \"sc_heap_read\"\n    \"sc_heap_write\"\n    \"sc_hconf P\"\n    \"P\"\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) (rm.empty ())\n     (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     P", "by(rule sc_heap_conf_read)"], ["", "abbreviation sc_deterministic_heap_ops :: \"'m prog \\<Rightarrow> bool\"\nwhere \"sc_deterministic_heap_ops \\<equiv> sc.deterministic_heap_ops TYPE('m)\""], ["", "lemma sc_deterministic_heap_ops: \"\\<not> sc_spurious_wakeups \\<Longrightarrow> sc_deterministic_heap_ops P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sc_spurious_wakeups \\<Longrightarrow> sc_deterministic_heap_ops P", "by(rule sc.deterministic_heap_opsI)(auto elim: sc_heap_read.cases sc_heap_write.cases simp add: sc_allocate_def)"], ["", "subsection \\<open>Code generation\\<close>"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  sc_heap_read"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  sc_heap_write"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma eval_sc_heap_read_i_i_i_o:\n  \"Predicate.eval (sc_heap_read_i_i_i_o h ad al) = sc_heap_read h ad al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (sc_heap_read_i_i_i_o h ad al) = sc_heap_read h ad al", "by(auto elim: sc_heap_read_i_i_i_oE intro: sc_heap_read_i_i_i_oI intro!: ext)"], ["", "lemma eval_sc_heap_write_i_i_i_i_o:\n  \"Predicate.eval (sc_heap_write_i_i_i_i_o h ad al v) = sc_heap_write h ad al v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (sc_heap_write_i_i_i_i_o h ad al v) = sc_heap_write h ad al v", "by(auto elim: sc_heap_write_i_i_i_i_oE intro: sc_heap_write_i_i_i_i_oI intro!: ext)"], ["", "end"]]}