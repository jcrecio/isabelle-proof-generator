{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/J1Deadlock.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma IUF_red_taD:\n  \"True,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\n  \\<Longrightarrow> \\<exists>e' ta' s'. False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta'\\<rightarrow> \\<langle>e', s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\"\n\n  and IUFs_reds_taD:\n  \"True,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\n  \\<Longrightarrow> \\<exists>es' ta' s'. False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta'\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\"", "lemma IUF_Red1_taD:\n  assumes \"True,P,t \\<turnstile>1 \\<langle>ex/exs, h\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs', h'\\<rangle>\"\n  shows \"\\<exists>ex' exs' h' ta'. False,P,t \\<turnstile>1 \\<langle>ex/exs, h\\<rangle> -ta'\\<rightarrow> \\<langle>ex'/exs', h'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\"", "lemma mred1'_mred1_must_sync_eq:\n  \"Red1_mthr.must_sync False P t x (shr s) = Red1_mthr.must_sync True P t x (shr s)\"", "lemma Red1_Red1'_deadlock_inv:\n  \"Red1_mthr.deadlock True P s = Red1_mthr.deadlock False P s\""], "translations": [["", "lemma IUF_red_taD:\n  \"True,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\n  \\<Longrightarrow> \\<exists>e' ta' s'. False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta'\\<rightarrow> \\<langle>e', s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\"\n\n  and IUFs_reds_taD:\n  \"True,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\n  \\<Longrightarrow> \\<exists>es' ta' s'. False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta'\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (True,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     \\<exists>e' ta' s'.\n        False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                \\<langle>e',s'\\<rangle> \\<and>\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n        set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n        (\\<exists>s. Red1_mthr.actions_ok s t ta')) &&&\n    (True,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                            \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     \\<exists>es' ta' s'.\n        False,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta'\\<rightarrow>]\n                                \\<langle>es',s'\\<rangle> \\<and>\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n        set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n        (\\<exists>s. Red1_mthr.actions_ok s t ta'))", "proof(induct rule: red1_reds1.inducts)"], ["proof (state)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 102 subgoals...", "case Red1InstanceOf"], ["proof (state)\nthis:\n  typeof\\<^bsub>hp s_\\<^esub> v_ = \\<lfloor>U_\\<rfloor>\n  b_ = (v_ \\<noteq> Null \\<and> P \\<turnstile> U_ \\<le> T_)\n\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 102 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof\\<^bsub>hp s_\\<^esub> v_ = \\<lfloor>U_\\<rfloor>\n  b_ = (v_ \\<noteq> Null \\<and> P \\<turnstile> U_ \\<le> T_)\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>Val v_ instanceof T_,\n                                s_\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "using [[hypsubst_thin = true]]"], ["proof (prove)\nusing this:\n  typeof\\<^bsub>hp s_\\<^esub> v_ = \\<lfloor>U_\\<rfloor>\n  b_ = (v_ \\<noteq> Null \\<and> P \\<turnstile> U_ \\<le> T_)\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>Val v_ instanceof T_,\n                                s_\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "by(auto intro!: exI red1_reds1.Red1InstanceOf simp del: split_paired_Ex)((subst fst_conv snd_conv wset_def)+, simp)"], ["proof (state)\nthis:\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>Val v_ instanceof T_,\n                              s_\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks\n                  \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (101 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 101 subgoals...", "next"], ["proof (state)\ngoal (101 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 101 subgoals...", "case Red1CallExternal"], ["proof (state)\nthis:\n  typeof_addr (hp s_) a_ = \\<lfloor>T_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  T_ sees M_: Ts_\\<rightarrow>Tr_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n\ngoal (101 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 101 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s_) a_ = \\<lfloor>T_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  T_ sees M_: Ts_\\<rightarrow>Tr_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                                s_\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta_\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>ta_\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>ta_\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "by(fastforce simp del: split_paired_Ex dest: red_external_ta_satisfiable[where final=\"final_expr1 :: ('addr expr1 \\<times> 'addr val list) \\<times> ('addr expr1 \\<times> 'addr val list) list \\<Rightarrow> bool\"] intro: red1_reds1.Red1CallExternal)"], ["proof (state)\nthis:\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                              s_\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta_\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>ta_\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>ta_\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (100 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 100 subgoals...", "next"], ["proof (state)\ngoal (100 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 100 subgoals...", "case Lock1Synchronized"], ["proof (state)\nthis:\n  V_ < length xs_\n\ngoal (100 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 100 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  V_ < length xs_\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>sync\\<^bsub>V_\\<^esub> (addr a_) e_,\n                                (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks \\<lbrace>\\<lbrace>(Lock, a_),\n                    SyncLock a_\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>\\<lbrace>(Lock, a_),\n                    SyncLock a_\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>\\<lbrace>(Lock, a_),\n                    SyncLock a_\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "by(auto intro!: exI exI[where x=\"(K$ None, (Map.empty, undefined), Map.empty, {})\"] red1_reds1.Lock1Synchronized simp del: split_paired_Ex simp add: lock_ok_las_def finfun_upd_apply may_lock.intros(1))"], ["proof (state)\nthis:\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>sync\\<^bsub>V_\\<^esub> (addr a_) e_,\n                              (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>\\<lbrace>(Lock, a_),\n                  SyncLock a_\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>\\<lbrace>(Lock, a_),\n                  SyncLock a_\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>\\<lbrace>(Lock, a_),\n                  SyncLock a_\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (99 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 99 subgoals...", "next"], ["proof (state)\ngoal (99 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 99 subgoals...", "case (Synchronized1Red2 e s ta e' s' V a)"], ["proof (state)\nthis:\n  True,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',s'\\<rangle>\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (99 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 99 subgoals...", "then"], ["proof (chain)\npicking this:\n  True,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',s'\\<rangle>\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')", "obtain e' ta' s'\n    where \"False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow> \\<langle>e',s'\\<rangle>\"\n    and L: \"collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\"\n    and aok: \"\\<exists>s. Red1_mthr.actions_ok s t ta'\""], ["proof (prove)\nusing this:\n  True,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',s'\\<rangle>\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (1 subgoal):\n 1. (\\<And>ta' e' s'.\n        \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>e,\n    s\\<rangle> -ta'\\<rightarrow>\n   \\<langle>e',s'\\<rangle>;\n         collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n         \\<subseteq> collect_locks\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n         set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n         \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n         collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n         \\<subseteq> collect_interrupts\n                      \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n         \\<exists>s. Red1_mthr.actions_ok s t ta'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e',s'\\<rangle>\n  collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n  \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n  set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n  \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n  collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n  \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n  \\<exists>s. Red1_mthr.actions_ok s t ta'\n\ngoal (99 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 99 subgoals...", "from \\<open>False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow> \\<langle>e',s'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e',s'\\<rangle>", "have \"False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e, s\\<rangle> -ta'\\<rightarrow> \\<langle>insync\\<^bsub>V\\<^esub> (a) e', s'\\<rangle>\""], ["proof (prove)\nusing this:\n  False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>e',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e,\n                             s\\<rangle> -ta'\\<rightarrow>\n                            \\<langle>insync\\<^bsub>V\\<^esub> (a) e',\n                             s'\\<rangle>", "by(rule red1_reds1.Synchronized1Red2)"], ["proof (state)\nthis:\n  False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e,\n                           s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>insync\\<^bsub>V\\<^esub> (a) e',\n                           s'\\<rangle>\n\ngoal (99 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 99 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e,\n                           s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>insync\\<^bsub>V\\<^esub> (a) e',\n                           s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e,\n                                s\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "using L aok"], ["proof (prove)\nusing this:\n  False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e,\n                           s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>insync\\<^bsub>V\\<^esub> (a) e',\n                           s'\\<rangle>\n  collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n  \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n  set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n  \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n  collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n  \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n  \\<exists>s. Red1_mthr.actions_ok s t ta'\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e,\n                                s\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "by blast"], ["proof (state)\nthis:\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e,\n                              s\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 98 subgoals...", "next"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 98 subgoals...", "case Unlock1Synchronized"], ["proof (state)\nthis:\n  xs_ ! V_ = Addr a'_\n  V_ < length xs_\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 98 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  xs_ ! V_ = Addr a'_\n  V_ < length xs_\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V_\\<^esub> (a_) Val\n                                 v_,\n                                (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks \\<lbrace>\\<lbrace>(Unlock, a'_),\n                    SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>\\<lbrace>(Unlock, a'_),\n                    SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>\\<lbrace>(Unlock, a'_),\n                    SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "by(auto simp del: split_paired_Ex intro!: exI exI[where x=\"(K$ \\<lfloor>(t, 0)\\<rfloor>, (Map.empty, undefined), Map.empty, {})\"] red1_reds1.Unlock1Synchronized simp add: lock_ok_las_def finfun_upd_apply)"], ["proof (state)\nthis:\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V_\\<^esub> (a_) Val v_,\n                              (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>\\<lbrace>(Unlock, a'_),\n                  SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>\\<lbrace>(Unlock, a'_),\n                  SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>\\<lbrace>(Unlock, a'_),\n                  SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 97 subgoals...", "next"], ["proof (state)\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 97 subgoals...", "case Unlock1SynchronizedFail"], ["proof (state)\nthis:\n  True\n  xs_ ! V_ = Addr a'_\n  V_ < length xs_\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 97 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  True\n  xs_ ! V_ = Addr a'_\n  V_ < length xs_\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V_\\<^esub> (a_) Val\n                                 v_,\n                                (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>\\<lbrace>(UnlockFail,\n a'_)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>\\<lbrace>(UnlockFail,\n    a'_)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>\\<lbrace>(UnlockFail,\n a'_)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "by(auto simp del: split_paired_Ex intro!: exI exI[where x=\"(K$ \\<lfloor>(t, 0)\\<rfloor>, (Map.empty, undefined), Map.empty, {})\"] red1_reds1.Unlock1Synchronized simp add: lock_ok_las_def finfun_upd_apply collect_locks_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V_\\<^esub> (a_) Val v_,\n                              (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks\n                  \\<lbrace>\\<lbrace>(UnlockFail,\n                                     a'_)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>\\<lbrace>(UnlockFail,\n  a'_)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>\\<lbrace>(UnlockFail,\n                                     a'_)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 96 subgoals...", "next"], ["proof (state)\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 96 subgoals...", "case Synchronized1Throw2"], ["proof (state)\nthis:\n  xs_ ! V_ = Addr a'_\n  V_ < length xs_\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 96 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  xs_ ! V_ = Addr a'_\n  V_ < length xs_\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V_\\<^esub> (a_) Throw\n                                 ad_,\n                                (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks \\<lbrace>\\<lbrace>(Unlock, a'_),\n                    SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>\\<lbrace>(Unlock, a'_),\n                    SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>\\<lbrace>(Unlock, a'_),\n                    SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "by(auto simp del: split_paired_Ex intro!: exI exI[where x=\"(K$ \\<lfloor>(t, 0)\\<rfloor>, (Map.empty, undefined), Map.empty, {})\"] red1_reds1.Synchronized1Throw2 simp add: lock_ok_las_def finfun_upd_apply)"], ["proof (state)\nthis:\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V_\\<^esub> (a_) Throw\n                               ad_,\n                              (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>\\<lbrace>(Unlock, a'_),\n                  SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>\\<lbrace>(Unlock, a'_),\n                  SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>\\<lbrace>(Unlock, a'_),\n                  SyncUnlock a'_\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (95 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 95 subgoals...", "next"], ["proof (state)\ngoal (95 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 95 subgoals...", "case Synchronized1Throw2Fail"], ["proof (state)\nthis:\n  True\n  xs_ ! V_ = Addr a'_\n  V_ < length xs_\n\ngoal (95 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 95 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  True\n  xs_ ! V_ = Addr a'_\n  V_ < length xs_\n\ngoal (1 subgoal):\n 1. \\<exists>e' ta' s'.\n       False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V_\\<^esub> (a_) Throw\n                                 ad_,\n                                (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>e',s'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>\\<lbrace>(UnlockFail,\n a'_)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>\\<lbrace>(UnlockFail,\n    a'_)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>\\<lbrace>(UnlockFail,\n a'_)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "by(auto simp del: split_paired_Ex intro!: exI exI[where x=\"(K$ \\<lfloor>(t, 0)\\<rfloor>, (Map.empty, undefined), Map.empty, {})\"] red1_reds1.Synchronized1Throw2 simp add: lock_ok_las_def finfun_upd_apply collect_locks_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<exists>e' ta' s'.\n     False,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V_\\<^esub> (a_) Throw\n                               ad_,\n                              (h_, xs_)\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks\n                  \\<lbrace>\\<lbrace>(UnlockFail,\n                                     a'_)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>\\<lbrace>(UnlockFail,\n  a'_)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>\\<lbrace>(UnlockFail,\n                                     a'_)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (94 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>NewHeapElem a\n       (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>NewHeapElem a\n    (Class_type C)\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>new C,\n                                   (h, l)\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>NewHeapElem a\n                      (Array_type T\n                        (nat (sint\n                               i)))\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       \\<exists>e' ta' s'.\n          False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n                     (Intg i)\\<rceil>,\n                                   s\\<rangle> -ta'\\<rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n          (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val\n (Intg i)\\<rceil>,\n               (h, l)\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<exists>e' ta' s'.\n           False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast C e,\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e' ta' s'.\n                            False,P,t \\<turnstile>1 \\<langle>Cast T (Val v),\n               s\\<rangle> -ta'\\<rightarrow>\n              \\<langle>e',s'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<exists>e' ta' s'.\n            False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta'\\<rightarrow>\n                                    \\<langle>e',s'\\<rangle> \\<and>\n            collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n            \\<subseteq> collect_locks\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n            \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n            collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n            \\<subseteq> collect_interrupts\n                         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n            (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e' ta' s'.\n                             False,P,t \\<turnstile>1 \\<langle>e instanceof T,\n                s\\<rangle> -ta'\\<rightarrow>\n               \\<langle>e',s'\\<rangle> \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> set\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                             (\\<exists>s. Red1_mthr.actions_ok s t ta')\nA total of 94 subgoals...", "qed(fastforce intro: red1_reds1.intros)+"], ["", "lemma IUF_Red1_taD:\n  assumes \"True,P,t \\<turnstile>1 \\<langle>ex/exs, h\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs', h'\\<rangle>\"\n  shows \"\\<exists>ex' exs' h' ta'. False,P,t \\<turnstile>1 \\<langle>ex/exs, h\\<rangle> -ta'\\<rightarrow> \\<langle>ex'/exs', h'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ex' exs' h' ta'.\n       False,P,t \\<turnstile>1 \\<langle>ex/exs,h\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>ex'/exs',h'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "using assms"], ["proof (prove)\nusing this:\n  True,P,t \\<turnstile>1 \\<langle>ex/exs,h\\<rangle> -ta\\<rightarrow>\n                         \\<langle>ex'/exs',h'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>ex' exs' h' ta'.\n       False,P,t \\<turnstile>1 \\<langle>ex/exs,h\\<rangle> -ta'\\<rightarrow>\n                               \\<langle>ex'/exs',h'\\<rangle> \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n       (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply(cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e x taa e' x'.\n       \\<lbrakk>ex = (e, x); ta = extTA2J1 P taa; ex' = (e', x');\n        exs' = exs;\n        True,P,t \\<turnstile>1 \\<langle>e,(h, x)\\<rangle> -taa\\<rightarrow>\n                               \\<langle>e',(h', x')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>ex/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ex = (e, x); ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>ex/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>ex = (e', x'); exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>ex/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply(safe dest!: IUF_red_taD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e x a aa ab ac ad b e' x' e'a ae af ag ah ai ba aj bb ak al bc am\n       bd.\n       \\<lbrakk>ta = extTA2J1 P (a, aa, ab, ac, ad, b); ex' = (e', x');\n        exs' = exs; ex = (e, x);\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (h, x)\\<rangle> -(ae, af, ag, ah, ai,\n             ba)\\<rightarrow>\n                                \\<langle>e'a,(aj, bb)\\<rangle>;\n        collect_locks\n         \\<lbrace>(ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks\n                     \\<lbrace>(a, aa, ab, ac, ad,\n                               b)\\<rbrace>\\<^bsub>l\\<^esub>;\n        set \\<lbrace>(ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> set \\<lbrace>(a, aa, ab, ac, ad,\n                                  b)\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts\n         \\<lbrace>(ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>(a, aa, ab, ac, ad,\n                               b)\\<rbrace>\\<^bsub>i\\<^esub>;\n        lock_ok_las (locks (ak, (al, bc), am, bd)) t\n         \\<lbrace>(ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ak, (al, bc), am, bd))\n         \\<lbrace>(ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>t\\<^esub>;\n        Red1_mthr.cond_action_oks (ak, (al, bc), am, bd) t\n         \\<lbrace>(ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ak, (al, bc), am, bd)) t\n         \\<lbrace>(ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ak, (al, bc), am, bd))\n         \\<lbrace>(ae, af, ag, ah, ai,\n                   ba)\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>extTA2J1 P\n             (a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>extTA2J1 P\n             (a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>extTA2J1 P\n             (a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs'a h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e',\n                        x')/(e, x) # exs',\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs'a,h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply(simp del: split_paired_Ex)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e x a aa ab ac ad b e' x' e'a ae af ag ah ai ba aj bb ak al bc am\n       bd.\n       \\<lbrakk>ta =\n                (a, map (convert_new_thread_action (extNTA2J1 P)) aa, ab,\n                 ac, ad, b);\n        ex' = (e', x'); exs' = exs; ex = (e, x);\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (h, x)\\<rangle> -(ae, af, ag, ah, ai,\n             ba)\\<rightarrow>\n                                \\<langle>e'a,(aj, bb)\\<rangle>;\n        collect_locks ae \\<subseteq> collect_locks a;\n        set ag \\<subseteq> set ab;\n        collect_interrupts ai \\<subseteq> collect_interrupts ad;\n        lock_ok_las ak t ae; thread_oks al af;\n        Red1_mthr.cond_action_oks (ak, (al, bc), am, bd) t ag;\n        wset_actions_ok am t ah; interrupt_actions_ok bd ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks a \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set ab \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts ad \\<and>\n                            (\\<exists>s.\n                                lock_ok_las (locks s) t\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                                thread_oks (thr s)\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                                Red1_mthr.cond_action_oks s t\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                                wset_actions_ok (wset s) t\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                                interrupt_actions_ok (interrupts s)\n                                 \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs'a h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e',\n                        x')/(e, x) # exs',\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs'a,h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply(rule exI conjI)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>e x a aa ab ac ad b e' x' e'a ae af ag ah ai ba aj bb ak al bc am\n       bd.\n       \\<lbrakk>ta =\n                (a, map (convert_new_thread_action (extNTA2J1 P)) aa, ab,\n                 ac, ad, b);\n        ex' = (e', x'); exs' = exs; ex = (e, x);\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (h, x)\\<rangle> -(ae, af, ag, ah, ai,\n             ba)\\<rightarrow>\n                                \\<langle>e'a,(aj, bb)\\<rangle>;\n        collect_locks ae \\<subseteq> collect_locks a;\n        set ag \\<subseteq> set ab;\n        collect_interrupts ai \\<subseteq> collect_interrupts ad;\n        lock_ok_las ak t ae; thread_oks al af;\n        Red1_mthr.cond_action_oks (ak, (al, bc), am, bd) t ag;\n        wset_actions_ok am t ah; interrupt_actions_ok bd ai\\<rbrakk>\n       \\<Longrightarrow> False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n            h\\<rangle> -?ta'23 e x a aa ab ac ad b e' x' e'a ae af ag ah ai\n                         ba aj bb ak al bc am bd\\<rightarrow>\n           \\<langle>?ex'17 e x a aa ab ac ad b e' x' e'a ae af ag ah ai ba\n                     aj bb ak al bc am\n                     bd/?exs'19 e x a aa ab ac ad b e' x' e'a ae af ag ah ai\n                         ba aj bb ak al bc am bd,\n            ?h'21 e x a aa ab ac ad b e' x' e'a ae af ag ah ai ba aj bb ak\n             al bc am bd\\<rangle>\n 2. \\<And>e x a aa ab ac ad b e' x' e'a ae af ag ah ai ba aj bb ak al bc am\n       bd.\n       \\<lbrakk>ta =\n                (a, map (convert_new_thread_action (extNTA2J1 P)) aa, ab,\n                 ac, ad, b);\n        ex' = (e', x'); exs' = exs; ex = (e, x);\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (h, x)\\<rangle> -(ae, af, ag, ah, ai,\n             ba)\\<rightarrow>\n                                \\<langle>e'a,(aj, bb)\\<rangle>;\n        collect_locks ae \\<subseteq> collect_locks a;\n        set ag \\<subseteq> set ab;\n        collect_interrupts ai \\<subseteq> collect_interrupts ad;\n        lock_ok_las ak t ae; thread_oks al af;\n        Red1_mthr.cond_action_oks (ak, (al, bc), am, bd) t ag;\n        wset_actions_ok am t ah; interrupt_actions_ok bd ai\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>?ta'23 e x a aa ab ac ad b e' x' e'a ae\n                                    af ag ah ai ba aj bb ak al bc am\n                                    bd\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks a \\<and>\n                         set \\<lbrace>?ta'23 e x a aa ab ac ad b e' x' e'a\n ae af ag ah ai ba aj bb ak al bc am bd\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> set ab \\<and>\n                         collect_interrupts\n                          \\<lbrace>?ta'23 e x a aa ab ac ad b e' x' e'a ae\n                                    af ag ah ai ba aj bb ak al bc am\n                                    bd\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts ad \\<and>\n                         (\\<exists>s.\n                             lock_ok_las (locks s) t\n                              \\<lbrace>?ta'23 e x a aa ab ac ad b e' x' e'a\n  ae af ag ah ai ba aj bb ak al bc am bd\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             thread_oks (thr s)\n                              \\<lbrace>?ta'23 e x a aa ab ac ad b e' x' e'a\n  ae af ag ah ai ba aj bb ak al bc am bd\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                             Red1_mthr.cond_action_oks s t\n                              \\<lbrace>?ta'23 e x a aa ab ac ad b e' x' e'a\n  ae af ag ah ai ba aj bb ak al bc am bd\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             wset_actions_ok (wset s) t\n                              \\<lbrace>?ta'23 e x a aa ab ac ad b e' x' e'a\n  ae af ag ah ai ba aj bb ak al bc am bd\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                             interrupt_actions_ok (interrupts s)\n                              \\<lbrace>?ta'23 e x a aa ab ac ad b e' x' e'a\n  ae af ag ah ai ba aj bb ak al bc am bd\\<rbrace>\\<^bsub>i\\<^esub>)\n 3. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 4. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs'a h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e',\n                        x')/(e, x) # exs',\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs'a,h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply(erule red1Red)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e x a aa ab ac ad b e' x' e'a ae af ag ah ai ba aj bb ak al bc am\n       bd.\n       \\<lbrakk>ta =\n                (a, map (convert_new_thread_action (extNTA2J1 P)) aa, ab,\n                 ac, ad, b);\n        ex' = (e', x'); exs' = exs; ex = (e, x);\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (h, x)\\<rangle> -(ae, af, ag, ah, ai,\n             ba)\\<rightarrow>\n                                \\<langle>e'a,(aj, bb)\\<rangle>;\n        collect_locks ae \\<subseteq> collect_locks a;\n        set ag \\<subseteq> set ab;\n        collect_interrupts ai \\<subseteq> collect_interrupts ad;\n        lock_ok_las ak t ae; thread_oks al af;\n        Red1_mthr.cond_action_oks (ak, (al, bc), am, bd) t ag;\n        wset_actions_ok am t ah; interrupt_actions_ok bd ai\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>extTA2J1 P\n                                    (ae, af, ag, ah, ai,\n                                     ba)\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks a \\<and>\n                         set \\<lbrace>extTA2J1 P\n (ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> set ab \\<and>\n                         collect_interrupts\n                          \\<lbrace>extTA2J1 P\n                                    (ae, af, ag, ah, ai,\n                                     ba)\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts ad \\<and>\n                         (\\<exists>s.\n                             lock_ok_las (locks s) t\n                              \\<lbrace>extTA2J1 P\n  (ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             thread_oks (thr s)\n                              \\<lbrace>extTA2J1 P\n  (ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                             Red1_mthr.cond_action_oks s t\n                              \\<lbrace>extTA2J1 P\n  (ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             wset_actions_ok (wset s) t\n                              \\<lbrace>extTA2J1 P\n  (ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                             interrupt_actions_ok (interrupts s)\n                              \\<lbrace>extTA2J1 P\n  (ae, af, ag, ah, ai, ba)\\<rbrace>\\<^bsub>i\\<^esub>)\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs'a h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e',\n                        x')/(e, x) # exs',\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs'a,h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e x a aa ab ac ad b e' x' e'a ae af ag ah ai ba aj bb ak al bc am\n       bd.\n       \\<lbrakk>ta =\n                (a, map (convert_new_thread_action (extNTA2J1 P)) aa, ab,\n                 ac, ad, b);\n        ex' = (e', x'); exs' = exs; ex = (e, x);\n        False,P,t \\<turnstile>1 \\<langle>e,\n                                 (h, x)\\<rangle> -(ae, af, ag, ah, ai,\n             ba)\\<rightarrow>\n                                \\<langle>e'a,(aj, bb)\\<rangle>;\n        collect_locks ae \\<subseteq> collect_locks a;\n        set ag \\<subseteq> set ab;\n        collect_interrupts ai \\<subseteq> collect_interrupts ad;\n        lock_ok_las ak t ae; thread_oks al af;\n        Red1_mthr.cond_action_oks (ak, (al, bc), am, bd) t ag;\n        wset_actions_ok am t ah; interrupt_actions_ok bd ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lock_ok_las a t ae \\<and>\n                            (\\<exists>aa.\n                                thread_oks aa af \\<and>\n                                (\\<exists>b ab ba.\n                                    Red1_mthr.cond_action_oks\n                                     (a, (aa, b), ab, ba) t ag \\<and>\n                                    wset_actions_ok ab t ah \\<and>\n                                    interrupt_actions_ok ba ai))\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 3. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs'a h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e',\n                        x')/(e, x) # exs',\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs'a,h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs' h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e, x)/exs,\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs',h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')\n 2. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs'a h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e',\n                        x')/(e, x) # exs',\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs'a,h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply(rule exI conjI red1Call)+"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> call1 e =\n                         \\<lfloor>(?a154 e a M vs U Ts T body D x,\n                                   ?M154 e a M vs U Ts T body D x,\n                                   ?vs154 e a M vs U Ts T body D x)\\<rfloor>\n 2. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr h (?a154 e a M vs U Ts T body D x) =\n                         \\<lfloor>?U154 e a M vs U Ts T body D x\\<rfloor>\n 3. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> class_type_of\n   (?U154 e a M vs U Ts T body D\n     x) sees ?M154 e a M vs U Ts T body D\n              x: ?Ts154 e a M vs U Ts T body D\n                  x\\<rightarrow>?T154 e a M vs U Ts T body D\n                                 x = \\<lfloor>?body154 e a M vs U Ts T body\n         D x\\<rfloor> in ?D154 e a M vs U Ts T body D x\n 4. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> length (?vs154 e a M vs U Ts T body D x) =\n                         length (?Ts154 e a M vs U Ts T body D x)\n 5. \\<And>e a M vs U Ts T body D x.\n       \\<lbrakk>ta = \\<lbrace>\\<rbrace>;\n        ex' =\n        (blocks1 0 (Class D # Ts) body,\n         Addr a # vs @ replicate (max_vars body) undefined_value);\n        exs' = (e, x) # exs; h' = h; call1 e = \\<lfloor>(a, M, vs)\\<rfloor>;\n        typeof_addr h a = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        U sees M: Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D;\n        length vs = length Ts; ex = (e, x)\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> set\n\\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                         (\\<exists>s.\n                             Red1_mthr.actions_ok s t \\<lbrace>\\<rbrace>)\n 6. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ex' exs'a h' ta'.\n                            False,P,t \\<turnstile>1 \\<langle>(e',\n                        x')/(e, x) # exs',\n               h\\<rangle> -ta'\\<rightarrow>\n              \\<langle>ex'/exs'a,h'\\<rangle> \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> set\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                            (\\<exists>s. Red1_mthr.actions_ok s t ta')", "apply(auto simp add: lock_ok_las_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b exs'a h' aa ab ac ad.\n                            (\\<exists>ba.\n                                False,P,t \\<turnstile>1 \\<langle>(e',\n                            x')/(e, x) # exs',\n                   h\\<rangle> -(aa, ab, [], ac, ad, ba)\\<rightarrow>\n                  \\<langle>(a, b)/exs'a,h'\\<rangle>) \\<and>\n                            collect_locks aa\n                            \\<subseteq> collect_locks (K$ []) \\<and>\n                            collect_interrupts ad\n                            \\<subseteq> collect_interrupts [] \\<and>\n                            (\\<exists>a.\n                                \\<forall>l.\n                                   lock_actions_ok (a $ l) t\n                                    (aa $ l)) \\<and>\n                            (\\<exists>a. thread_oks a ab) \\<and>\n                            (\\<exists>a. wset_actions_ok a t ac) \\<and>\n                            (\\<exists>b. interrupt_actions_ok b ad)", "apply(rule exI conjI red1Return)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> final e'\n 2. \\<And>e' x' e x.\n       \\<lbrakk>exs = (e, x) # exs'; ta = \\<lbrace>\\<rbrace>;\n        ex' = (inline_call e' e, x); h' = h; final e';\n        ex = (e', x')\\<rbrakk>\n       \\<Longrightarrow> collect_locks (K$ [])\n                         \\<subseteq> collect_locks (K$ []) \\<and>\n                         collect_interrupts []\n                         \\<subseteq> collect_interrupts [] \\<and>\n                         (\\<exists>a.\n                             \\<forall>l.\n                                lock_actions_ok (a $ l) t\n                                 ((K$ []) $ l)) \\<and>\n                         (\\<exists>a. thread_oks a []) \\<and>\n                         (\\<exists>a. wset_actions_ok a t []) \\<and>\n                         (\\<exists>b. interrupt_actions_ok b [])", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mred1'_mred1_must_sync_eq:\n  \"Red1_mthr.must_sync False P t x (shr s) = Red1_mthr.must_sync True P t x (shr s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.must_sync False P t x (shr s) =\n    Red1_mthr.must_sync True P t x (shr s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Red1_mthr.must_sync False P t x (shr s) \\<Longrightarrow>\n    Red1_mthr.must_sync True P t x (shr s)\n 2. Red1_mthr.must_sync True P t x (shr s) \\<Longrightarrow>\n    Red1_mthr.must_sync False P t x (shr s)", "assume \"Red1_mthr.must_sync False P t x (shr s)\""], ["proof (state)\nthis:\n  Red1_mthr.must_sync False P t x (shr s)\n\ngoal (2 subgoals):\n 1. Red1_mthr.must_sync False P t x (shr s) \\<Longrightarrow>\n    Red1_mthr.must_sync True P t x (shr s)\n 2. Red1_mthr.must_sync True P t x (shr s) \\<Longrightarrow>\n    Red1_mthr.must_sync False P t x (shr s)", "thus \"Red1_mthr.must_sync True P t x (shr s)\""], ["proof (prove)\nusing this:\n  Red1_mthr.must_sync False P t x (shr s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.must_sync True P t x (shr s)", "by(rule Red1_mthr.must_syncE)(rule Red1_mthr.must_syncI, auto simp add: split_def simp del: split_paired_Ex intro: Red1_False_into_Red1_True)"], ["proof (state)\nthis:\n  Red1_mthr.must_sync True P t x (shr s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.must_sync True P t x (shr s) \\<Longrightarrow>\n    Red1_mthr.must_sync False P t x (shr s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Red1_mthr.must_sync True P t x (shr s) \\<Longrightarrow>\n    Red1_mthr.must_sync False P t x (shr s)", "assume \"Red1_mthr.must_sync True P t x (shr s)\""], ["proof (state)\nthis:\n  Red1_mthr.must_sync True P t x (shr s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.must_sync True P t x (shr s) \\<Longrightarrow>\n    Red1_mthr.must_sync False P t x (shr s)", "thus \"Red1_mthr.must_sync False P t x (shr s)\""], ["proof (prove)\nusing this:\n  Red1_mthr.must_sync True P t x (shr s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.must_sync False P t x (shr s)", "apply(rule Red1_mthr.must_syncE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta x' m' sa.\n       \\<lbrakk>Red1_mthr.r_syntax True P t x (shr s) ta x' m';\n        Red1_mthr.actions_ok sa t ta; shr s = shr sa\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync False P t x (shr s)", "apply(rule Red1_mthr.must_syncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta x' m' sa.\n       \\<lbrakk>Red1_mthr.r_syntax True P t x (shr s) ta x' m';\n        Red1_mthr.actions_ok sa t ta; shr s = shr sa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m' sa.\n                            Red1_mthr.r_syntax False P t x (shr s) ta x'\n                             m' \\<and>\n                            Red1_mthr.actions_ok sa t ta", "apply(cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta x' m' sa a b.\n       \\<lbrakk>Red1_mthr.r_syntax True P t x (shr s) ta x' m';\n        Red1_mthr.actions_ok sa t ta; shr s = shr sa; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m' sa.\n                            Red1_mthr.r_syntax False P t x (shr s) ta x'\n                             m' \\<and>\n                            Red1_mthr.actions_ok sa t ta", "apply(auto simp add: split_beta split_paired_Ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae ba bb m' af ag ah bd ai be bf.\n       \\<lbrakk>True,P,t \\<turnstile>1 \\<langle>(ai, be)/bf,\n  shr s\\<rangle> -(a, aa, ab, ac, ad, b)\\<rightarrow>\n \\<langle>(ae, ba)/bb,m'\\<rangle>;\n        x = ((ai, be), bf); lock_ok_las af t a; thread_oks ag aa;\n        Red1_mthr.cond_action_oks (af, (ag, shr s), ah, bd) t ab;\n        wset_actions_ok ah t ac; interrupt_actions_ok bd ad\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ab ac ad.\n                            (\\<exists>b ae ba bb.\n                                Ex (Red1 False P t (ai, be) bf (shr s)\n                                     (a, aa, ab, ac, ad, b) (ae, ba)\n                                     bb)) \\<and>\n                            (\\<exists>ae.\n                                lock_ok_las ae t a \\<and>\n                                (\\<exists>a.\n                                    thread_oks a aa \\<and>\n                                    (\\<exists>b aa ba.\n  Red1_mthr.cond_action_oks (ae, (a, b), aa, ba) t ab \\<and>\n  wset_actions_ok aa t ac \\<and> interrupt_actions_ok ba ad)))", "apply(drule IUF_Red1_taD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae ba bb m' af ag ah bd ai be bf.\n       \\<lbrakk>x = ((ai, be), bf); lock_ok_las af t a; thread_oks ag aa;\n        Red1_mthr.cond_action_oks (af, (ag, shr s), ah, bd) t ab;\n        wset_actions_ok ah t ac; interrupt_actions_ok bd ad;\n        \\<exists>ex' exs' h' ta'.\n           False,P,t \\<turnstile>1 \\<langle>(ai, be)/bf,\n                                    shr s\\<rangle> -ta'\\<rightarrow>\n                                   \\<langle>ex'/exs',h'\\<rangle> \\<and>\n           collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n           \\<subseteq> collect_locks\n                        \\<lbrace>(a, aa, ab, ac, ad,\n                                  b)\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n           set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n           \\<subseteq> set \\<lbrace>(a, aa, ab, ac, ad,\n                                     b)\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n           collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n           \\<subseteq> collect_interrupts\n                        \\<lbrace>(a, aa, ab, ac, ad,\n                                  b)\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n           (\\<exists>s. Red1_mthr.actions_ok s t ta')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ab ac ad.\n                            (\\<exists>b ae ba bb.\n                                Ex (Red1 False P t (ai, be) bf (shr s)\n                                     (a, aa, ab, ac, ad, b) (ae, ba)\n                                     bb)) \\<and>\n                            (\\<exists>ae.\n                                lock_ok_las ae t a \\<and>\n                                (\\<exists>a.\n                                    thread_oks a aa \\<and>\n                                    (\\<exists>b aa ba.\n  Red1_mthr.cond_action_oks (ae, (a, b), aa, ba) t ab \\<and>\n  wset_actions_ok aa t ac \\<and> interrupt_actions_ok ba ad)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad af ag ah bd ai be bf.\n       \\<lbrakk>x = ((ai, be), bf); lock_ok_las af t a; thread_oks ag aa;\n        Red1_mthr.cond_action_oks (af, (ag, shr s), ah, bd) t ab;\n        wset_actions_ok ah t ac; interrupt_actions_ok bd ad;\n        \\<exists>aa b exs' h' ac ae af ag ah.\n           (\\<exists>ba.\n               False,P,t \\<turnstile>1 \\<langle>(ai, be)/bf,\n  shr s\\<rangle> -(ac, ae, af, ag, ah, ba)\\<rightarrow>\n \\<langle>(aa, b)/exs',h'\\<rangle>) \\<and>\n           collect_locks ac \\<subseteq> collect_locks a \\<and>\n           set af \\<subseteq> set ab \\<and>\n           collect_interrupts ah \\<subseteq> collect_interrupts ad \\<and>\n           (\\<exists>a.\n               lock_ok_las a t ac \\<and>\n               (\\<exists>aa.\n                   thread_oks aa ae \\<and>\n                   (\\<exists>b ab ba.\n                       Red1_mthr.cond_action_oks (a, (aa, b), ab, ba) t\n                        af \\<and>\n                       wset_actions_ok ab t ag \\<and>\n                       interrupt_actions_ok ba ah)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa ab ac ad.\n                            (\\<exists>b ae ba bb.\n                                Ex (Red1 False P t (ai, be) bf (shr s)\n                                     (a, aa, ab, ac, ad, b) (ae, ba)\n                                     bb)) \\<and>\n                            (\\<exists>ae.\n                                lock_ok_las ae t a \\<and>\n                                (\\<exists>a.\n                                    thread_oks a aa \\<and>\n                                    (\\<exists>b aa ba.\n  Red1_mthr.cond_action_oks (ae, (a, b), aa, ba) t ab \\<and>\n  wset_actions_ok aa t ac \\<and> interrupt_actions_ok ba ad)))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Red1_mthr.must_sync False P t x (shr s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red1_Red1'_deadlock_inv:\n  \"Red1_mthr.deadlock True P s = Red1_mthr.deadlock False P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.deadlock True P s = Red1_mthr.deadlock False P s", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Red1_mthr.deadlock True P s \\<Longrightarrow>\n    Red1_mthr.deadlock False P s\n 2. Red1_mthr.deadlock False P s \\<Longrightarrow>\n    Red1_mthr.deadlock True P s", "assume dead: \"Red1_mthr.deadlock True P s\""], ["proof (state)\nthis:\n  Red1_mthr.deadlock True P s\n\ngoal (2 subgoals):\n 1. Red1_mthr.deadlock True P s \\<Longrightarrow>\n    Red1_mthr.deadlock False P s\n 2. Red1_mthr.deadlock False P s \\<Longrightarrow>\n    Red1_mthr.deadlock True P s", "show \"Red1_mthr.deadlock False P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.deadlock False P s", "proof(rule multithreaded_base.deadlockI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr1 x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync False P t x (shr s) \\<and>\n                         (\\<forall>LT.\n                             Red1_mthr.can_sync False P t x (shr s)\n                              LT \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 Red1_mthr.must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr1 x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync False P t x (shr s) \\<and>\n                         (\\<forall>LT.\n                             Red1_mthr.can_sync False P t x (shr s)\n                              LT \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 Red1_mthr.must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume tst: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n      and nfin: \"\\<not> final_expr1 x\"\n      and wst: \"wset s t = None\""], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final_expr1 x\n  wset s t = None\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr1 x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync False P t x (shr s) \\<and>\n                         (\\<forall>LT.\n                             Red1_mthr.can_sync False P t x (shr s)\n                              LT \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 Red1_mthr.must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "with dead"], ["proof (chain)\npicking this:\n  Red1_mthr.deadlock True P s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final_expr1 x\n  wset s t = None", "obtain ms: \"Red1_mthr.must_sync True P t x (shr s)\"\n      and cs [rule_format]: \"\\<forall>LT. Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. final_thread.must_wait final_expr1 s t lt (dom (thr s)))\""], ["proof (prove)\nusing this:\n  Red1_mthr.deadlock True P s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final_expr1 x\n  wset s t = None\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Red1_mthr.must_sync True P t x (shr s);\n      \\<forall>LT.\n         Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n         (\\<exists>lt\\<in>LT.\n             Red1_mthr.must_wait s t lt (dom (thr s)))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule Red1_mthr.deadlockD1)"], ["proof (state)\nthis:\n  Red1_mthr.must_sync True P t x (shr s)\n  Red1_mthr.can_sync True P t x (shr s) ?LT \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT. Red1_mthr.must_wait s t lt (dom (thr s))\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr1 x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync False P t x (shr s) \\<and>\n                         (\\<forall>LT.\n                             Red1_mthr.can_sync False P t x (shr s)\n                              LT \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 Red1_mthr.must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "from ms[folded mred1'_mred1_must_sync_eq]"], ["proof (chain)\npicking this:\n  Red1_mthr.must_sync False P t x (shr s)", "show \"Red1_mthr.must_sync False P t x (shr s) \\<and>\n             (\\<forall>LT. Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n                   (\\<exists>lt\\<in>LT. final_thread.must_wait final_expr1 s t lt (dom (thr s))))\""], ["proof (prove)\nusing this:\n  Red1_mthr.must_sync False P t x (shr s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.must_sync False P t x (shr s) \\<and>\n    (\\<forall>LT.\n        Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n        (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>LT.\n       Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n       (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s)))", "show \"\\<forall>LT. Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n         (\\<exists>lt\\<in>LT. final_thread.must_wait final_expr1 s t lt (dom (thr s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>LT.\n       Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n       (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s)))", "proof(intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync False P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "fix LT"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync False P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "assume \"Red1_mthr.can_sync False P t x (shr s) LT\""], ["proof (state)\nthis:\n  Red1_mthr.can_sync False P t x (shr s) LT\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync False P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "then"], ["proof (chain)\npicking this:\n  Red1_mthr.can_sync False P t x (shr s) LT", "obtain ta x' m' where \"mred1' P t (x, shr s) ta (x', m')\" \n          and [simp]: \"LT = collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  Red1_mthr.can_sync False P t x (shr s) LT\n\ngoal (1 subgoal):\n 1. (\\<And>ta x' m'.\n        \\<lbrakk>Red1_mthr.r_syntax False P t x (shr s) ta x' m';\n         LT = collect_waits ta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule Red1_mthr.can_syncE)"], ["proof (state)\nthis:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n  LT = collect_waits ta\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync False P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "hence \"mred1 P t (x, shr s) ta (x', m')\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax False P t x (shr s) ta x' m'\n  LT = collect_waits ta\n\ngoal (1 subgoal):\n 1. Red1_mthr.r_syntax True P t x (shr s) ta x' m'", "by(auto simp add: split_beta intro: Red1_False_into_Red1_True)"], ["proof (state)\nthis:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync False P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "hence \"Red1_mthr.can_sync True P t x (shr s) LT\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n\ngoal (1 subgoal):\n 1. Red1_mthr.can_sync True P t x (shr s) LT", "by(rule Red1_mthr.can_syncI) simp"], ["proof (state)\nthis:\n  Red1_mthr.can_sync True P t x (shr s) LT\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync False P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "thus \"\\<exists>lt\\<in>LT. final_thread.must_wait final_expr1 s t lt (dom (thr s))\""], ["proof (prove)\nusing this:\n  Red1_mthr.can_sync True P t x (shr s) LT\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "by(rule cs)"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>LT.\n     Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n     (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Red1_mthr.must_sync False P t x (shr s) \\<and>\n  (\\<forall>LT.\n      Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))))\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t x ln l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\" \"0 < ln $ l\" \"\\<not> waiting (wset s t)\""], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset s t)\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "thus \"\\<exists>l t'. 0 < ln $ l \\<and> t \\<noteq> t' \\<and> thr s t' \\<noteq> None \\<and> has_lock ((locks s) $ l) t'\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset s t)\n\ngoal (1 subgoal):\n 1. \\<exists>l t'.\n       0 < ln $ l \\<and>\n       t \\<noteq> t' \\<and>\n       thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'", "by(rule Red1_mthr.deadlockD2[OF dead]) blast"], ["proof (state)\nthis:\n  \\<exists>l t'.\n     0 < ln $ l \\<and>\n     t \\<noteq> t' \\<and>\n     thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t x w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "thus \"wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "by(rule Red1_mthr.deadlockD3[OF dead, rule_format])"], ["proof (state)\nthis:\n  wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Red1_mthr.deadlock False P s\n\ngoal (1 subgoal):\n 1. Red1_mthr.deadlock False P s \\<Longrightarrow>\n    Red1_mthr.deadlock True P s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Red1_mthr.deadlock False P s \\<Longrightarrow>\n    Red1_mthr.deadlock True P s", "assume dead: \"Red1_mthr.deadlock False P s\""], ["proof (state)\nthis:\n  Red1_mthr.deadlock False P s\n\ngoal (1 subgoal):\n 1. Red1_mthr.deadlock False P s \\<Longrightarrow>\n    Red1_mthr.deadlock True P s", "show \"Red1_mthr.deadlock True P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.deadlock True P s", "proof(rule Red1_mthr.deadlockI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr1 x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync True P t x (shr s) \\<and>\n                         (\\<forall>LT.\n                             Red1_mthr.can_sync True P t x (shr s)\n                              LT \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 Red1_mthr.must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr1 x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync True P t x (shr s) \\<and>\n                         (\\<forall>LT.\n                             Red1_mthr.can_sync True P t x (shr s)\n                              LT \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 Red1_mthr.must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume tst: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n      and nfin: \"\\<not> final_expr1 x\"\n      and wst: \"wset s t = None\""], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final_expr1 x\n  wset s t = None\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr1 x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync True P t x (shr s) \\<and>\n                         (\\<forall>LT.\n                             Red1_mthr.can_sync True P t x (shr s)\n                              LT \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 Red1_mthr.must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "with dead"], ["proof (chain)\npicking this:\n  Red1_mthr.deadlock False P s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final_expr1 x\n  wset s t = None", "obtain ms: \"Red1_mthr.must_sync False P t x (shr s)\"\n      and cs [rule_format]: \"\\<forall>LT. Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. final_thread.must_wait final_expr1 s t lt (dom (thr s)))\""], ["proof (prove)\nusing this:\n  Red1_mthr.deadlock False P s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final_expr1 x\n  wset s t = None\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Red1_mthr.must_sync False P t x (shr s);\n      \\<forall>LT.\n         Red1_mthr.can_sync False P t x (shr s) LT \\<longrightarrow>\n         (\\<exists>lt\\<in>LT.\n             Red1_mthr.must_wait s t lt (dom (thr s)))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule Red1_mthr.deadlockD1)"], ["proof (state)\nthis:\n  Red1_mthr.must_sync False P t x (shr s)\n  Red1_mthr.can_sync False P t x (shr s) ?LT \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT. Red1_mthr.must_wait s t lt (dom (thr s))\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final_expr1 x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.must_sync True P t x (shr s) \\<and>\n                         (\\<forall>LT.\n                             Red1_mthr.can_sync True P t x (shr s)\n                              LT \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 Red1_mthr.must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "from ms[unfolded mred1'_mred1_must_sync_eq]"], ["proof (chain)\npicking this:\n  Red1_mthr.must_sync True P t x (shr s)", "show \"Red1_mthr.must_sync True P t x (shr s) \\<and>\n             (\\<forall>LT. Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n                   (\\<exists>lt\\<in>LT. final_thread.must_wait final_expr1 s t lt (dom (thr s))))\""], ["proof (prove)\nusing this:\n  Red1_mthr.must_sync True P t x (shr s)\n\ngoal (1 subgoal):\n 1. Red1_mthr.must_sync True P t x (shr s) \\<and>\n    (\\<forall>LT.\n        Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n        (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n       (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s)))", "show \"\\<forall>LT. Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n         (\\<exists>lt\\<in>LT. final_thread.must_wait final_expr1 s t lt (dom (thr s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n       (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s)))", "proof(intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "fix LT"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "assume \"Red1_mthr.can_sync True P t x (shr s) LT\""], ["proof (state)\nthis:\n  Red1_mthr.can_sync True P t x (shr s) LT\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "then"], ["proof (chain)\npicking this:\n  Red1_mthr.can_sync True P t x (shr s) LT", "obtain ta x' m' where \"mred1 P t (x, shr s) ta (x', m')\" \n          and [simp]: \"LT = collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  Red1_mthr.can_sync True P t x (shr s) LT\n\ngoal (1 subgoal):\n 1. (\\<And>ta x' m'.\n        \\<lbrakk>Red1_mthr.r_syntax True P t x (shr s) ta x' m';\n         LT = collect_waits ta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule Red1_mthr.can_syncE)"], ["proof (state)\nthis:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n  LT = collect_waits ta\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "then"], ["proof (chain)\npicking this:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n  LT = collect_waits ta", "obtain e xs exs e' xs' exs' where x [simp]: \"x = ((e, xs), exs)\" \"x' = ((e', xs'), exs')\"\n          and red: \"True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs, shr s\\<rangle> -ta\\<rightarrow> \\<langle>(e', xs')/exs', m'\\<rangle>\""], ["proof (prove)\nusing this:\n  Red1_mthr.r_syntax True P t x (shr s) ta x' m'\n  LT = collect_waits ta\n\ngoal (1 subgoal):\n 1. (\\<And>e xs exs e' xs' exs'.\n        \\<lbrakk>x = ((e, xs), exs); x' = ((e', xs'), exs');\n         True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                                 shr s\\<rangle> -ta\\<rightarrow>\n                                \\<langle>(e', xs')/exs',m'\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x, cases x') fastforce"], ["proof (state)\nthis:\n  x = ((e, xs), exs)\n  x' = ((e', xs'), exs')\n  True,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                          shr s\\<rangle> -ta\\<rightarrow>\n                         \\<langle>(e', xs')/exs',m'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "from IUF_Red1_taD[OF red]"], ["proof (chain)\npicking this:\n  \\<exists>ex' exs' h' ta'.\n     False,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                              shr s\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>ex'/exs',h'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')", "obtain ex'' exs'' h'' ta' \n          where red': \"False,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,shr s\\<rangle> -ta'\\<rightarrow> \\<langle>ex''/exs'',h''\\<rangle>\"\n          and \"collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<exists>ex' exs' h' ta'.\n     False,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                              shr s\\<rangle> -ta'\\<rightarrow>\n                             \\<langle>ex'/exs',h'\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     set \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n     (\\<exists>s. Red1_mthr.actions_ok s t ta')\n\ngoal (1 subgoal):\n 1. (\\<And>ta' ex'' exs'' h''.\n        \\<lbrakk>False,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n    shr s\\<rangle> -ta'\\<rightarrow>\n   \\<langle>ex''/exs'',h''\\<rangle>;\n         collect_waits ta' \\<subseteq> collect_waits ta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto blast"], ["proof (state)\nthis:\n  False,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                           shr s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>ex''/exs'',h''\\<rangle>\n  collect_waits ta' \\<subseteq> collect_waits ta\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "then"], ["proof (chain)\npicking this:\n  False,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                           shr s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>ex''/exs'',h''\\<rangle>\n  collect_waits ta' \\<subseteq> collect_waits ta", "obtain LT' where cs': \"Red1_mthr.can_sync False P t x (shr s) LT'\" \n          and LT': \"LT' \\<subseteq> LT\""], ["proof (prove)\nusing this:\n  False,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                           shr s\\<rangle> -ta'\\<rightarrow>\n                          \\<langle>ex''/exs'',h''\\<rangle>\n  collect_waits ta' \\<subseteq> collect_waits ta\n\ngoal (1 subgoal):\n 1. (\\<And>LT'.\n        \\<lbrakk>Red1_mthr.can_sync False P t x (shr s) LT';\n         LT' \\<subseteq> LT\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ex'')(fastforce intro!: Red1_mthr.can_syncI)"], ["proof (state)\nthis:\n  Red1_mthr.can_sync False P t x (shr s) LT'\n  LT' \\<subseteq> LT\n\ngoal (1 subgoal):\n 1. \\<And>LT.\n       Red1_mthr.can_sync True P t x (shr s) LT \\<Longrightarrow>\n       \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "with cs[of LT']"], ["proof (chain)\npicking this:\n  Red1_mthr.can_sync False P t x (shr s) LT' \\<Longrightarrow>\n  \\<exists>lt\\<in>LT'. Red1_mthr.must_wait s t lt (dom (thr s))\n  Red1_mthr.can_sync False P t x (shr s) LT'\n  LT' \\<subseteq> LT", "show \"\\<exists>lt\\<in>LT. final_thread.must_wait final_expr1 s t lt (dom (thr s))\""], ["proof (prove)\nusing this:\n  Red1_mthr.can_sync False P t x (shr s) LT' \\<Longrightarrow>\n  \\<exists>lt\\<in>LT'. Red1_mthr.must_wait s t lt (dom (thr s))\n  Red1_mthr.can_sync False P t x (shr s) LT'\n  LT' \\<subseteq> LT\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))", "by auto"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>LT.\n     Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n     (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Red1_mthr.must_sync True P t x (shr s) \\<and>\n  (\\<forall>LT.\n      Red1_mthr.can_sync True P t x (shr s) LT \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. Red1_mthr.must_wait s t lt (dom (thr s))))\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t x ln l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\" \"0 < ln $ l\" \"\\<not> waiting (wset s t)\""], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset s t)\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "thus \"\\<exists>l t'. 0 < ln $ l \\<and> t \\<noteq> t' \\<and> thr s t' \\<noteq> None \\<and> has_lock ((locks s) $ l) t'\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset s t)\n\ngoal (1 subgoal):\n 1. \\<exists>l t'.\n       0 < ln $ l \\<and>\n       t \\<noteq> t' \\<and>\n       thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'", "by(rule Red1_mthr.deadlockD2[OF dead]) blast"], ["proof (state)\nthis:\n  \\<exists>l t'.\n     0 < ln $ l \\<and>\n     t \\<noteq> t' \\<and>\n     thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t x w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "thus \"wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "by(rule Red1_mthr.deadlockD3[OF dead, rule_format])"], ["proof (state)\nthis:\n  wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Red1_mthr.deadlock True P s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}