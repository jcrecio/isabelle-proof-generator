{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/J1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma extNTA2J1_iff [simp]:\n  \"extNTA2J1 P (C, M, a) = (({0:Class (fst (method P C M))=None; the (snd (snd (snd (method P C M))))}, Addr a # replicate (max_vars (the (snd (snd (snd (method P C M)))))) undefined_value), [])\"", "lemma max_vars_extRet2J1 [simp]: \n  \"max_vars e = 0 \\<Longrightarrow> max_vars (extRet2J1 e va) = 0\"", "lemma red1_preserves_len: \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> length (lcl s') = length (lcl s)\"\n  and reds1_preserves_len: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> length (lcl s') = length (lcl s)\"", "lemma reds1_preserves_elen: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> length es' = length es\"", "lemma red1_Val_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>Val v, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"", "lemma red1_Throw_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>Throw a, xs\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"", "lemma reds1_Nil_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>[], s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\"", "lemma reds1_Val_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>map Val vs, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\"", "lemma reds1_map_Val_Throw_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>map Val vs @ Throw a # es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\"", "lemma red1_max_vars_decr: \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> max_vars e' \\<le> max_vars e\" \n  and reds1_max_varss_decr: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> max_varss es' \\<le> max_varss es\"", "lemma red1_new_thread_heap: \"\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t' ex h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h = hp s'\"\n  and reds1_new_thread_heap: \"\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t' ex h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h = hp s'\"", "lemma red1_new_threadD:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t' x H \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>a M vs va T Ts Tr D. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va, hp s'\\<rangle> \\<and> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D\"\n  and reds1_new_threadD:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t' x H \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>a M vs va T Ts Tr D. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va, hp s'\\<rangle> \\<and> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D\"", "lemma red1_call_synthesized: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; call1 e = \\<lfloor>aMvs\\<rfloor> \\<rbrakk> \\<Longrightarrow> synthesized_call P (hp s) aMvs\"\n  and reds1_calls_synthesized: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; calls1 es = \\<lfloor>aMvs\\<rfloor> \\<rbrakk> \\<Longrightarrow> synthesized_call P (hp s) aMvs\"", "lemma red1_preserves_B: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<B> e n\\<rbrakk> \\<Longrightarrow> \\<B> e' n\"\n  and reds1_preserves_Bs: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<B>s es n\\<rbrakk> \\<Longrightarrow> \\<B>s es' n\"", "lemma red1_hext_incr: \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> hext (hp s) (hp s')\"\n  and reds1_hext_incr: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> hext (hp s) (hp s')\"", "lemma Red1_hext_incr: \"uf,P,t \\<turnstile>1 \\<langle>ex/exs,h\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',h'\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\"", "lemma \\<tau>move1_\\<tau>moves1_intros:\n  fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move1NewArray: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (newA T\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move1Cast: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Cast U e)\"\n  and \\<tau>move1CastRed: \"\\<tau>move1 P h (Cast U (Val v))\"\n  and \\<tau>move1InstanceOf: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e instanceof U)\"\n  and \\<tau>move1InstanceOfRed: \"\\<tau>move1 P h ((Val v) instanceof U)\"\n  and \\<tau>move1BinOp1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<guillemotleft>bop\\<guillemotright>e')\"\n  and \\<tau>move1BinOp2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Val v\\<guillemotleft>bop\\<guillemotright>e)\"\n  and \\<tau>move1BinOp: \"\\<tau>move1 P h (Val v\\<guillemotleft>bop\\<guillemotright>Val v')\"\n  and \\<tau>move1Var: \"\\<tau>move1 P h (Var V)\"\n  and \\<tau>move1LAss: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (V := e)\"\n  and \\<tau>move1LAssRed: \"\\<tau>move1 P h (V := Val v)\"\n  and \\<tau>move1AAcc1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<lfloor>e'\\<rceil>)\"\n  and \\<tau>move1AAcc2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Val v\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move1AAss1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (AAss e e' e'')\"\n  and \\<tau>move1AAss2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (AAss (Val v) e e')\"\n  and \\<tau>move1AAss3: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (AAss (Val v) (Val v') e)\"\n  and \\<tau>move1ALength: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<bullet>length)\"\n  and \\<tau>move1FAcc: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<bullet>F{D})\"\n  and \\<tau>move1FAss1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (FAss e F D e')\"\n  and \\<tau>move1FAss2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (FAss (Val v) F D e)\"\n  and \\<tau>move1CAS1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\"\n  and \\<tau>move1CAS2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e''))\"\n  and \\<tau>move1CAS3: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e))\"\n  and \\<tau>move1CallObj: \"\\<tau>move1 P h obj \\<Longrightarrow> \\<tau>move1 P h (obj\\<bullet>M(ps))\"\n  and \\<tau>move1CallParams: \"\\<tau>moves1 P h ps \\<Longrightarrow> \\<tau>move1 P h (Val v\\<bullet>M(ps))\"\n  and \\<tau>move1Call: \"(\\<And>T C Ts Tr D. \\<lbrakk> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>; class_type_of' T = \\<lfloor>C\\<rfloor>; P \\<turnstile> C sees M:Ts\\<rightarrow>Tr = Native in D \\<rbrakk> \\<Longrightarrow> \\<tau>external_defs D M) \\<Longrightarrow> \\<tau>move1 P h (Val v\\<bullet>M(map Val vs))\"\n  and \\<tau>move1BlockSome: \"\\<tau>move1 P h {V:T=\\<lfloor>v\\<rfloor>; e}\"\n  and \\<tau>move1Block: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h {V:T=None; e}\"\n  and \\<tau>move1BlockRed: \"\\<tau>move1 P h {V:T=None; Val v}\"\n  and \\<tau>move1Sync: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (sync\\<^bsub>V'\\<^esub> (e) e')\"\n  and \\<tau>move1InSync: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (insync\\<^bsub>V'\\<^esub> (a) e)\"\n  and \\<tau>move1Seq: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e;;e')\"\n  and \\<tau>move1SeqRed: \"\\<tau>move1 P h (Val v;; e)\"\n  and \\<tau>move1Cond: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (if (e) e1 else e2)\"\n  and \\<tau>move1CondRed: \"\\<tau>move1 P h (if (Val v) e1 else e2)\"\n  and \\<tau>move1WhileRed: \"\\<tau>move1 P h (while (c) e)\"\n  and \\<tau>move1Throw: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (throw e)\"\n  and \\<tau>move1ThrowNull: \"\\<tau>move1 P h (throw null)\"\n  and \\<tau>move1Try: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (try e catch(C V) e'')\"\n  and \\<tau>move1TryRed: \"\\<tau>move1 P h (try Val v catch(C V) e)\"\n  and \\<tau>move1TryThrow: \"\\<tau>move1 P h (try Throw a catch(C V) e)\"\n  and \\<tau>move1NewArrayThrow: \"\\<tau>move1 P h (newA T\\<lfloor>Throw a\\<rceil>)\"\n  and \\<tau>move1CastThrow: \"\\<tau>move1 P h (Cast T (Throw a))\"\n  and \\<tau>move1InstanceOfThrow: \"\\<tau>move1 P h ((Throw a) instanceof T)\"\n  and \\<tau>move1BinOpThrow1: \"\\<tau>move1 P h (Throw a \\<guillemotleft>bop\\<guillemotright> e2)\"\n  and \\<tau>move1BinOpThrow2: \"\\<tau>move1 P h (Val v \\<guillemotleft>bop\\<guillemotright> Throw a)\"\n  and \\<tau>move1LAssThrow: \"\\<tau>move1 P h (V:=(Throw a))\"\n  and \\<tau>move1AAccThrow1: \"\\<tau>move1 P h (Throw a\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move1AAccThrow2: \"\\<tau>move1 P h (Val v\\<lfloor>Throw a\\<rceil>)\"\n  and \\<tau>move1AAssThrow1: \"\\<tau>move1 P h (AAss (Throw a) e e')\"\n  and \\<tau>move1AAssThrow2: \"\\<tau>move1 P h (AAss (Val v) (Throw a) e')\"\n  and \\<tau>move1AAssThrow3: \"\\<tau>move1 P h (AAss (Val v) (Val v') (Throw a))\"\n  and \\<tau>move1ALengthThrow: \"\\<tau>move1 P h (Throw a\\<bullet>length)\"\n  and \\<tau>move1FAccThrow: \"\\<tau>move1 P h (Throw a\\<bullet>F{D})\"\n  and \\<tau>move1FAssThrow1: \"\\<tau>move1 P h (Throw a\\<bullet>F{D} := e)\"\n  and \\<tau>move1FAssThrow2: \"\\<tau>move1 P h (FAss (Val v) F D (Throw a))\"\n  and \\<tau>move1CASThrow1: \"\\<tau>move1 P h (CompareAndSwap (Throw a) D F e e')\"\n  and \\<tau>move1CASThrow2: \"\\<tau>move1 P h (CompareAndSwap (Val v) D F (Throw a) e')\"\n  and \\<tau>move1CASThrow3: \"\\<tau>move1 P h (CompareAndSwap (Val v) D F (Val v') (Throw a))\"\n  and \\<tau>move1CallThrowObj: \"\\<tau>move1 P h (Throw a\\<bullet>M(es))\"\n  and \\<tau>move1CallThrowParams: \"\\<tau>move1 P h (Val v\\<bullet>M(map Val vs @ Throw a # es))\"\n  and \\<tau>move1BlockThrow: \"\\<tau>move1 P h {V:T=None; Throw a}\"\n  and \\<tau>move1SyncThrow: \"\\<tau>move1 P h (sync\\<^bsub>V'\\<^esub> (Throw a) e)\"\n  and \\<tau>move1SeqThrow: \"\\<tau>move1 P h (Throw a;;e)\"\n  and \\<tau>move1CondThrow: \"\\<tau>move1 P h (if (Throw a) e1 else e2)\"\n  and \\<tau>move1ThrowThrow: \"\\<tau>move1 P h (throw (Throw a))\"\n\n  and \\<tau>moves1Hd: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>moves1 P h (e # es)\"\n  and \\<tau>moves1Tl: \"\\<tau>moves1 P h es \\<Longrightarrow> \\<tau>moves1 P h (Val v # es)\"", "lemma \\<tau>moves1_map_Val [dest!]:\n  \"\\<tau>moves1 P h (map Val es) \\<Longrightarrow> False\"", "lemma \\<tau>moves1_map_Val_ThrowD [simp]: \"\\<tau>moves1 P h (map Val vs @ Throw a # es) = False\"", "lemma fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move1_not_call1:\n  \"call1 e = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow> \\<tau>move1 P h e \\<longleftrightarrow> (synthesized_call P h (a, M, vs) \\<longrightarrow> \\<tau>external' P h a M)\"\n  and \\<tau>moves1_not_calls1:\n  \"calls1 es = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow> \\<tau>moves1 P h es \\<longleftrightarrow> (synthesized_call P h (a, M, vs) \\<longrightarrow> \\<tau>external' P h a M)\"", "lemma red1_\\<tau>_taD: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move1 P (hp s) e \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"\n  and reds1_\\<tau>_taD: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves1 P (hp s) es \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"", "lemma \\<tau>move1_heap_unchanged: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move1 P (hp s) e \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"\n  and \\<tau>moves1_heap_unchanged: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves1 P (hp s) es \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"", "lemma \\<tau>Move1_iff:\n  \"\\<tau>Move1 P h exexs \\<longleftrightarrow> (let ((e, _), _) = exexs in \\<tau>move1 P h e \\<or> final e)\"", "lemma \\<tau>red1_iff [iff]:\n  \"\\<tau>red1g uf P t h (e, xs) (e', xs') = (uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle> \\<and> \\<tau>move1 P h e)\"", "lemma \\<tau>reds1_iff [iff]:\n  \"\\<tau>reds1g uf P t h (es, xs) (es', xs') = (uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle> \\<and> \\<tau>moves1 P h es)\"", "lemma \\<tau>red1t_1step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e', xs')\"", "lemma \\<tau>red1t_2step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e; \n     uf,P,t \\<turnstile>1 \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move1 P h e' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e'', xs'')\"", "lemma \\<tau>red1t_3step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e; \n     uf,P,t \\<turnstile>1 \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move1 P h e';\n     uf,P,t \\<turnstile>1 \\<langle>e'', (h, xs'')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e''', (h, xs''')\\<rangle>; \\<tau>move1 P h e'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e''', xs''')\"", "lemma \\<tau>reds1t_1step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es', xs')\"", "lemma \\<tau>reds1t_2step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es; \n     uf,P,t \\<turnstile>1 \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves1 P h es' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es'', xs'')\"", "lemma \\<tau>reds1t_3step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es; \n     uf,P,t \\<turnstile>1 \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves1 P h es';\n     uf,P,t \\<turnstile>1 \\<langle>es'', (h, xs'')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es''', (h, xs''')\\<rangle>; \\<tau>moves1 P h es'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es''', xs''')\"", "lemma \\<tau>red1r_1step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e', xs')\"", "lemma \\<tau>red1r_2step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e; \n     uf,P,t \\<turnstile>1 \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move1 P h e' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e'', xs'')\"", "lemma \\<tau>red1r_3step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e; \n     uf,P,t \\<turnstile>1 \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move1 P h e';\n     uf,P,t \\<turnstile>1 \\<langle>e'', (h, xs'')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e''', (h, xs''')\\<rangle>; \\<tau>move1 P h e'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e''', xs''')\"", "lemma \\<tau>reds1r_1step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es', xs')\"", "lemma \\<tau>reds1r_2step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es; \n     uf,P,t \\<turnstile>1 \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves1 P h es' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es'', xs'')\"", "lemma \\<tau>reds1r_3step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es; \n     uf,P,t \\<turnstile>1 \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves1 P h es';\n     uf,P,t \\<turnstile>1 \\<langle>es'', (h, xs'')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es''', (h, xs''')\\<rangle>; \\<tau>moves1 P h es'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es''', xs''')\"", "lemma \\<tau>red1t_preserves_len: \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> length xs' = length xs\"", "lemma \\<tau>red1r_preserves_len: \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> length xs' = length xs\"", "lemma \\<tau>red1t_inj_\\<tau>reds1t: \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>reds1gt uf P t h (e # es, xs) (e' # es, xs')\"", "lemma \\<tau>reds1t_cons_\\<tau>reds1t: \"\\<tau>reds1gt uf P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>reds1gt uf P t h (Val v # es, xs) (Val v # es', xs')\"", "lemma \\<tau>red1r_inj_\\<tau>reds1r: \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>reds1gr uf P t h (e # es, xs) (e' # es, xs')\"", "lemma \\<tau>reds1r_cons_\\<tau>reds1r: \"\\<tau>reds1gr uf P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>reds1gr uf P t h (Val v # es, xs) (Val v # es', xs')\"", "lemma NewArray_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (newA T\\<lfloor>e\\<rceil>, xs) (newA T\\<lfloor>e'\\<rceil>, xs')\"", "lemma Cast_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Cast T e, xs) (Cast T e', xs')\"", "lemma InstanceOf_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e instanceof T, xs) (e' instanceof T, xs')\"", "lemma BinOp_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (e1, xs) (e1', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs) (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')\"", "lemma BinOp_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (e2, xs) (e2', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs) (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')\"", "lemma LAss_\\<tau>red1t:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (V := e, xs) (V := e', xs')\"", "lemma AAcc_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (a\\<lfloor>i\\<rceil>, xs) (a'\\<lfloor>i\\<rceil>, xs')\"", "lemma AAcc_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val a\\<lfloor>i\\<rceil>, xs) (Val a\\<lfloor>i'\\<rceil>, xs')\"", "lemma AAss_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (a\\<lfloor>i\\<rceil> := e, xs) (a'\\<lfloor>i\\<rceil> := e, xs')\"", "lemma AAss_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val a\\<lfloor>i\\<rceil> := e, xs) (Val a\\<lfloor>i'\\<rceil> := e, xs')\"", "lemma AAss_\\<tau>red1t_xt3:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs) (Val a\\<lfloor>Val i\\<rceil> := e', xs')\"", "lemma ALength_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')\"", "lemma FAcc_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')\"", "lemma FAss_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e\\<bullet>F{D} := e2, xs) (e'\\<bullet>F{D} := e2, xs')\"", "lemma FAss_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v\\<bullet>F{D} := e, xs) (Val v\\<bullet>F{D} := e', xs')\"", "lemma CAS_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs) (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')\"", "lemma CAS_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')\"", "lemma CAS_\\<tau>red1t_xt3:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')\"", "lemma Call_\\<tau>red1t_obj:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')\"", "lemma Call_\\<tau>red1t_param:\n  \"\\<tau>reds1gt uf P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v\\<bullet>M(es), xs) (Val v\\<bullet>M(es'), xs')\"", "lemma Block_None_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h ({V:T=None; e}, xs) ({V:T=None; e'}, xs')\"", "lemma Block_\\<tau>red1t_Some:\n  \"\\<lbrakk> \\<tau>red1gt uf P t h (e, xs[V := v]) (e', xs'); V < length xs \\<rbrakk> \n  \\<Longrightarrow> \\<tau>red1gt uf P t h ({V:Ty=\\<lfloor>v\\<rfloor>; e}, xs) ({V:Ty=None; e'}, xs')\"", "lemma Sync_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs) (sync\\<^bsub>V\\<^esub> (e') e2, xs')\"", "lemma InSync_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (insync\\<^bsub>V\\<^esub> (a) e, xs) (insync\\<^bsub>V\\<^esub> (a) e', xs')\"", "lemma Seq_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e;;e2, xs) (e';;e2, xs')\"", "lemma Cond_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')\"", "lemma Throw_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (throw e, xs) (throw e', xs')\"", "lemma Try_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (try e catch(C V) e2, xs) (try e' catch(C V) e2, xs')\"", "lemma NewArray_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (newA T\\<lfloor>e\\<rceil>, xs) (newA T\\<lfloor>e'\\<rceil>, xs')\"", "lemma Cast_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Cast T e, xs) (Cast T e', xs')\"", "lemma InstanceOf_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e instanceof T, xs) (e' instanceof T, xs')\"", "lemma BinOp_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (e1, xs) (e1', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs) (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')\"", "lemma BinOp_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (e2, xs) (e2', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs) (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')\"", "lemma LAss_\\<tau>red1r:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (V := e, xs) (V := e', xs')\"", "lemma AAcc_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (a\\<lfloor>i\\<rceil>, xs) (a'\\<lfloor>i\\<rceil>, xs')\"", "lemma AAcc_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val a\\<lfloor>i\\<rceil>, xs) (Val a\\<lfloor>i'\\<rceil>, xs')\"", "lemma AAss_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (a\\<lfloor>i\\<rceil> := e, xs) (a'\\<lfloor>i\\<rceil> := e, xs')\"", "lemma AAss_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val a\\<lfloor>i\\<rceil> := e, xs) (Val a\\<lfloor>i'\\<rceil> := e, xs')\"", "lemma AAss_\\<tau>red1r_xt3:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs) (Val a\\<lfloor>Val i\\<rceil> := e', xs')\"", "lemma ALength_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')\"", "lemma FAcc_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')\"", "lemma FAss_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e\\<bullet>F{D} := e2, xs) (e'\\<bullet>F{D} := e2, xs')\"", "lemma FAss_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v\\<bullet>F{D} := e, xs) (Val v\\<bullet>F{D} := e', xs')\"", "lemma CAS_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs) (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')\"", "lemma CAS_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')\"", "lemma CAS_\\<tau>red1r_xt3:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')\"", "lemma Call_\\<tau>red1r_obj:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')\"", "lemma Call_\\<tau>red1r_param:\n  \"\\<tau>reds1gr uf P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v\\<bullet>M(es), xs) (Val v\\<bullet>M(es'), xs')\"", "lemma Block_None_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h ({V:T=None; e}, xs) ({V:T=None; e'}, xs')\"", "lemma Block_\\<tau>red1r_Some:\n  \"\\<lbrakk> \\<tau>red1gr uf P t h (e, xs[V := v]) (e', xs'); V < length xs \\<rbrakk> \n  \\<Longrightarrow> \\<tau>red1gr uf P t h ({V:Ty=\\<lfloor>v\\<rfloor>; e}, xs) ({V:Ty=None; e'}, xs')\"", "lemma Sync_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs) (sync\\<^bsub>V\\<^esub> (e') e2, xs')\"", "lemma InSync_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (insync\\<^bsub>V\\<^esub> (a) e, xs) (insync\\<^bsub>V\\<^esub> (a) e', xs')\"", "lemma Seq_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e;;e2, xs) (e';;e2, xs')\"", "lemma Cond_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')\"", "lemma Throw_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (throw e, xs) (throw e', xs')\"", "lemma Try_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (try e catch(C V) e2, xs) (try e' catch(C V) e2, xs')\"", "lemma \\<tau>red1t_ThrowD [dest]: \"\\<tau>red1gt uf P t h (Throw a, xs) (e'', xs'') \\<Longrightarrow> e'' = Throw a \\<and> xs'' = xs\"", "lemma \\<tau>red1r_ThrowD [dest]: \"\\<tau>red1gr uf P t h (Throw a, xs) (e'', xs'') \\<Longrightarrow> e'' = Throw a \\<and> xs'' = xs\"", "lemma \\<tau>Red1_conv [iff]:\n  \"\\<tau>Red1g uf P t h (ex, exs) (ex', exs') = (uf,P,t \\<turnstile>1 \\<langle>ex/exs, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>ex'/exs', h\\<rangle> \\<and> \\<tau>Move1 P h (ex, exs))\"", "lemma \\<tau>red1t_into_\\<tau>Red1t:\n  \"\\<tau>red1gt uf P t h (e, xs) (e'', xs'') \\<Longrightarrow> \\<tau>Red1gt uf P t h ((e, xs), exs) ((e'', xs''), exs)\"", "lemma \\<tau>red1r_into_\\<tau>Red1r:\n  \"\\<tau>red1gr uf P t h (e, xs) (e'', xs'') \\<Longrightarrow> \\<tau>Red1gr uf P t h ((e, xs), exs) ((e'', xs''), exs)\"", "lemma red1_max_vars: \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> max_vars e' \\<le> max_vars e\"\n  and reds1_max_varss: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> max_varss es' \\<le> max_varss es\"", "lemma \\<tau>red1t_max_vars: \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> max_vars e' \\<le> max_vars e\"", "lemma \\<tau>red1r_max_vars: \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> max_vars e' \\<le> max_vars e\"", "lemma \\<tau>red1r_Val:\n  \"\\<tau>red1gr uf P t h (Val v, xs) s' \\<longleftrightarrow> s' = (Val v, xs)\"", "lemma \\<tau>red1t_Val:\n  \"\\<tau>red1gt uf P t h (Val v, xs) s' \\<longleftrightarrow> False\"", "lemma \\<tau>reds1r_map_Val:\n  \"\\<tau>reds1gr uf P t h (map Val vs, xs) s' \\<longleftrightarrow> s' = (map Val vs, xs)\"", "lemma \\<tau>reds1t_map_Val:\n  \"\\<tau>reds1gt uf P t h (map Val vs, xs) s' \\<longleftrightarrow> False\"", "lemma \\<tau>reds1r_map_Val_Throw:\n  \"\\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs) s' \\<longleftrightarrow> s' = (map Val vs @ Throw a # es, xs)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma \\<tau>reds1t_map_Val_Throw:\n  \"\\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs) s' \\<longleftrightarrow> False\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma \\<tau>red1r_Throw:\n  \"\\<tau>red1gr uf P t h (Throw a, xs) s' \\<longleftrightarrow> s' = (Throw a, xs)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma \\<tau>red1t_Throw:\n  \"\\<tau>red1gt uf P t h (Throw a, xs) s' \\<longleftrightarrow> False\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma red1_False_into_red1_True:\n  \"False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> True,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  and reds1_False_into_reds1_True:\n  \"False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> True,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\"", "lemma Red1_False_into_Red1_True:\n  assumes \"False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\"\n  shows \"True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\"", "lemma red1_Suspend_is_call:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> call1 e' \\<noteq> None\"\n  and reds_Suspend_is_calls:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> calls1 es' \\<noteq> None\"", "lemma Red1_Suspend_is_call:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>(e, xs)/exs, h\\<rangle> -ta\\<rightarrow> \\<langle>(e', xs')/exs', h'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> call1 e' \\<noteq> None\"", "lemma Red1_mthr: \"multithreaded final_expr1 (mred1g uf P)\"", "lemma red1_\\<tau>move1_heap_unchanged: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move1 P (hp s) e \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"\n  and red1_\\<tau>moves1_heap_unchanged: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves1 P (hp s) es \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"", "lemma Red1_\\<tau>mthr_wf: \"\\<tau>multithreaded_wf final_expr1 (mred1g uf P) (\\<tau>MOVE1 P)\"", "lemma \\<tau>Red1't_into_Red1'_\\<tau>mthr_silent_movet:\n  \"\\<tau>Red1gt uf P t h (ex2, exs2) (ex2'', exs2'')\n  \\<Longrightarrow> Red1_mthr.silent_movet uf P t ((ex2, exs2), h) ((ex2'', exs2''), h)\"", "lemma \\<tau>Red1t_into_Red1'_\\<tau>mthr_silent_moves:\n  \"\\<tau>Red1gt uf P t h (ex2, exs2) (ex2'', exs2'')\n  \\<Longrightarrow> Red1_mthr.silent_moves uf P t ((ex2, exs2), h) ((ex2'', exs2''), h)\"", "lemma \\<tau>Red1'r_into_Red1'_\\<tau>mthr_silent_moves:\n  \"\\<tau>Red1gr uf P t h (ex, exs) (ex', exs') \\<Longrightarrow> Red1_mthr.silent_moves uf P t ((ex, exs), h) ((ex', exs'), h)\"", "lemma \\<tau>Red1r_rtranclpD:\n  \"\\<tau>Red1gr uf P t h s s' \\<Longrightarrow> \\<tau>trsys.silent_moves (mred1g uf P t) (\\<tau>MOVE1 P) (s, h) (s', h)\"", "lemma \\<tau>Red1t_tranclpD:\n  \"\\<tau>Red1gt uf P t h s s' \\<Longrightarrow> \\<tau>trsys.silent_movet (mred1g uf P t) (\\<tau>MOVE1 P) (s, h) (s', h)\"", "lemma \\<tau>mreds1_Val_Nil: \"\\<tau>trsys.silent_moves (mred1g uf P t) (\\<tau>MOVE1 P) (((Val v, xs), []), h) s \\<longleftrightarrow> s = (((Val v, xs), []), h)\"", "lemma \\<tau>mreds1_Throw_Nil:\n  \"\\<tau>trsys.silent_moves (mred1g uf P t) (\\<tau>MOVE1 P) (((Throw a, xs), []), h) s \\<longleftrightarrow> s = (((Throw a, xs), []), h)\""], "translations": [["", "lemma extNTA2J1_iff [simp]:\n  \"extNTA2J1 P (C, M, a) = (({0:Class (fst (method P C M))=None; the (snd (snd (snd (method P C M))))}, Addr a # replicate (max_vars (the (snd (snd (snd (method P C M)))))) undefined_value), [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extNTA2J1 P (C, M, a) =\n    (({0:Class\n          (fst (method P C M))=None; the (snd (snd (snd (method P C M))))},\n      Addr a #\n      replicate (max_vars (the (snd (snd (snd (method P C M))))))\n       undefined_value),\n     [])", "by(simp add: extNTA2J1_def split_beta)"], ["", "abbreviation extTA2J1 :: \n  \"'addr J1_prog \\<Rightarrow> ('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'heap) J1_thread_action\"\nwhere \"extTA2J1 P \\<equiv> convert_extTA (extNTA2J1 P)\""], ["", "abbreviation (input) extRet2J1 :: \"'addr expr1 \\<Rightarrow> 'addr extCallRet \\<Rightarrow> 'addr expr1\"\nwhere \"extRet2J1 \\<equiv> extRet2J\""], ["", "lemma max_vars_extRet2J1 [simp]: \n  \"max_vars e = 0 \\<Longrightarrow> max_vars (extRet2J1 e va) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_vars e = 0 \\<Longrightarrow> max_vars (extRet2J e va) = 0", "by(cases va) simp_all"], ["", "context J1_heap_base begin"], ["", "abbreviation J1_start_state :: \"'addr J1_prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> ('addr, 'thread_id, 'heap) J1_state\"\nwhere\n  \"J1_start_state \\<equiv> \n   start_state (\\<lambda>C M Ts T body vs. ((blocks1 0 (Class C # Ts) body, Null # vs @ replicate (max_vars body) undefined_value), []))\""], ["", "inductive red1 :: \n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr expr1 \\<Rightarrow> 'heap \\<times> 'addr locals1 \n  \\<Rightarrow> ('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> 'addr expr1 \\<Rightarrow> 'heap \\<times> 'addr locals1 \\<Rightarrow> bool\"\n  (\"_,_,_ \\<turnstile>1 ((1\\<langle>_,/_\\<rangle>) -_\\<rightarrow>/ (1\\<langle>_,/_\\<rangle>))\" [51,51,0,0,0,0,0,0] 81)\n  and reds1 ::\n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr expr1 list \\<Rightarrow> 'heap \\<times> 'addr locals1\n  \\<Rightarrow> ('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> 'addr expr1 list \\<Rightarrow> 'heap \\<times> 'addr locals1 \\<Rightarrow> bool\"\n  (\"_,_,_ \\<turnstile>1 ((1\\<langle>_,/_\\<rangle>) [-_\\<rightarrow>]/ (1\\<langle>_,/_\\<rangle>))\" [51,51,0,0,0,0,0,0] 81)\nfor uf :: bool and P :: \"'addr J1_prog\" and t :: 'thread_id\nwhere\n  Red1New:\n  \"(h', a) \\<in> allocate h (Class_type C)\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>new C, (h, l)\\<rangle> -\\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>\\<rightarrow> \\<langle>addr a, (h', l)\\<rangle>\"\n\n| Red1NewFail:\n  \"allocate h (Class_type C) = {}\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>new C, (h, l)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW OutOfMemory, (h, l)\\<rangle>\"\n\n| New1ArrayRed:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>e\\<rceil>, s\\<rangle> -ta\\<rightarrow> \\<langle>newA T\\<lfloor>e'\\<rceil>, s'\\<rangle>\"\n\n| Red1NewArray:\n  \"\\<lbrakk> 0 <=s i; (h', a) \\<in> allocate h (Array_type T (nat (sint i))) \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val (Intg i)\\<rceil>, (h, l)\\<rangle> -\\<lbrace>NewHeapElem a (Array_type T (nat (sint i)))\\<rbrace>\\<rightarrow> \\<langle>addr a, (h', l)\\<rangle>\"\n\n| Red1NewArrayNegative:\n  \"i <s 0 \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val (Intg i)\\<rceil>, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NegativeArraySize, s\\<rangle>\"\n\n| Red1NewArrayFail:\n  \"\\<lbrakk> 0 <=s i; allocate h (Array_type T (nat (sint i))) = {} \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Val (Intg i)\\<rceil>, (h, l)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW OutOfMemory, (h, l)\\<rangle>\"\n\n| Cast1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>Cast C e, s\\<rangle> -ta\\<rightarrow> \\<langle>Cast C e', s'\\<rangle>\"\n\n| Red1Cast:\n \"\\<lbrakk> typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>; P \\<turnstile> U \\<le> T \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>Cast T (Val v), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Val v, s\\<rangle>\"\n\n| Red1CastFail:\n  \"\\<lbrakk> typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>; \\<not> P \\<turnstile> U \\<le> T \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>Cast T (Val v), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW ClassCast, s\\<rangle>\"\n\n| InstanceOf1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>e instanceof T, s\\<rangle> -ta\\<rightarrow> \\<langle>e' instanceof T, s'\\<rangle>\"\n\n| Red1InstanceOf:\n  \"\\<lbrakk> typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>; b \\<longleftrightarrow> v \\<noteq> Null \\<and> P \\<turnstile> U \\<le> T \\<rbrakk>\n   \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(Val v) instanceof T, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Val (Bool b), s\\<rangle>\"\n\n| Bin1OpRed1:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>e \\<guillemotleft>bop\\<guillemotright> e2, s\\<rangle> -ta\\<rightarrow> \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e2, s'\\<rangle>\"\n\n| Bin1OpRed2:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(Val v) \\<guillemotleft>bop\\<guillemotright> e, s\\<rangle> -ta\\<rightarrow> \\<langle>(Val v) \\<guillemotleft>bop\\<guillemotright> e', s'\\<rangle>\"\n\n| Red1BinOp:\n  \"binop bop v1 v2 = Some (Inl v) \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>(Val v1) \\<guillemotleft>bop\\<guillemotright> (Val v2), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Val v, s\\<rangle>\"\n\n| Red1BinOpFail:\n  \"binop bop v1 v2 = Some (Inr a) \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>(Val v1) \\<guillemotleft>bop\\<guillemotright> (Val v2), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n\n| Red1Var:\n  \"\\<lbrakk> (lcl s)!V = v; V < size (lcl s) \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>Var V, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Val v, s\\<rangle>\"\n\n| LAss1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>V:=e, s\\<rangle> -ta\\<rightarrow> \\<langle>V:=e', s'\\<rangle>\"\n\n| Red1LAss:\n  \"V < size l\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>V:=(Val v), (h, l)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>unit, (h, l[V := v])\\<rangle>\"\n\n| AAcc1Red1:\n  \"uf,P,t \\<turnstile>1 \\<langle>a, s\\<rangle> -ta\\<rightarrow> \\<langle>a', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>a\\<lfloor>i\\<rceil>, s\\<rangle> -ta\\<rightarrow> \\<langle>a'\\<lfloor>i\\<rceil>, s'\\<rangle>\"\n\n| AAcc1Red2:\n  \"uf,P,t \\<turnstile>1 \\<langle>i, s\\<rangle> -ta\\<rightarrow> \\<langle>i', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(Val a)\\<lfloor>i\\<rceil>, s\\<rangle> -ta\\<rightarrow> \\<langle>(Val a)\\<lfloor>i'\\<rceil>, s'\\<rangle>\"\n\n| Red1AAccNull:\n  \"uf,P,t \\<turnstile>1 \\<langle>null\\<lfloor>Val i\\<rceil>, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| Red1AAccBounds:\n  \"\\<lbrakk> typeof_addr (hp s) a = \\<lfloor>Array_type T n\\<rfloor>; i <s 0 \\<or> sint i \\<ge> int n \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(addr a)\\<lfloor>Val (Intg i)\\<rceil>, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW ArrayIndexOutOfBounds, s\\<rangle>\"\n\n| Red1AAcc:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>; 0 <=s i; sint i < int n;\n     heap_read h a (ACell (nat (sint i))) v \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(addr a)\\<lfloor>Val (Intg i)\\<rceil>, (h, xs)\\<rangle> -\\<lbrace>ReadMem a (ACell (nat (sint i))) v\\<rbrace>\\<rightarrow> \\<langle>Val v, (h, xs)\\<rangle>\"\n\n| AAss1Red1:\n  \"uf,P,t \\<turnstile>1 \\<langle>a, s\\<rangle> -ta\\<rightarrow> \\<langle>a', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>a\\<lfloor>i\\<rceil> := e, s\\<rangle> -ta\\<rightarrow> \\<langle>a'\\<lfloor>i\\<rceil> := e, s'\\<rangle>\"\n\n| AAss1Red2:\n  \"uf,P,t \\<turnstile>1 \\<langle>i, s\\<rangle> -ta\\<rightarrow> \\<langle>i', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(Val a)\\<lfloor>i\\<rceil> := e, s\\<rangle> -ta\\<rightarrow> \\<langle>(Val a)\\<lfloor>i'\\<rceil> := e, s'\\<rangle>\"\n\n| AAss1Red3:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>AAss (Val a) (Val i) e, s\\<rangle> -ta\\<rightarrow> \\<langle>(Val a)\\<lfloor>Val i\\<rceil> := e', s'\\<rangle>\"\n\n| Red1AAssNull:\n  \"uf,P,t \\<turnstile>1 \\<langle>AAss null (Val i) (Val e), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| Red1AAssBounds:\n  \"\\<lbrakk> typeof_addr (hp s) a = \\<lfloor>Array_type T n\\<rfloor>; i <s 0 \\<or> sint i \\<ge> int n \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>AAss (addr a) (Val (Intg i)) (Val e), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW ArrayIndexOutOfBounds, s\\<rangle>\"\n\n| Red1AAssStore:\n  \"\\<lbrakk> typeof_addr (hp s) a = \\<lfloor>Array_type T n\\<rfloor>; 0 <=s i; sint i < int n;\n     typeof\\<^bsub>hp s\\<^esub> w = \\<lfloor>U\\<rfloor>; \\<not> (P \\<turnstile> U \\<le> T) \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>AAss (addr a) (Val (Intg i)) (Val w), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW ArrayStore, s\\<rangle>\"\n\n| Red1AAss:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>; 0 <=s i; sint i < int n; typeof\\<^bsub>h\\<^esub> w = Some U; P \\<turnstile> U \\<le> T;\n     heap_write h a (ACell (nat (sint i))) w h' \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>AAss (addr a) (Val (Intg i)) (Val w), (h, l)\\<rangle> -\\<lbrace>WriteMem a (ACell (nat (sint i))) w\\<rbrace>\\<rightarrow> \\<langle>unit, (h', l)\\<rangle>\"\n\n| ALength1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>a, s\\<rangle> -ta\\<rightarrow> \\<langle>a', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>a\\<bullet>length, s\\<rangle> -ta\\<rightarrow> \\<langle>a'\\<bullet>length, s'\\<rangle>\"\n\n| Red1ALength:\n  \"typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor> \n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>addr a\\<bullet>length, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Val (Intg (word_of_nat n)), (h, xs)\\<rangle>\"\n\n| Red1ALengthNull:\n  \"uf,P,t \\<turnstile>1 \\<langle>null\\<bullet>length, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| FAcc1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>e\\<bullet>F{D}, s\\<rangle> -ta\\<rightarrow> \\<langle>e'\\<bullet>F{D}, s'\\<rangle>\"\n\n| Red1FAcc:\n  \"heap_read h a (CField D F) v\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(addr a)\\<bullet>F{D}, (h, xs)\\<rangle> -\\<lbrace>ReadMem a (CField D F) v\\<rbrace>\\<rightarrow> \\<langle>Val v, (h, xs)\\<rangle>\"\n\n| Red1FAccNull:\n  \"uf,P,t \\<turnstile>1 \\<langle>null\\<bullet>F{D}, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| FAss1Red1:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>e\\<bullet>F{D}:=e2, s\\<rangle> -ta\\<rightarrow> \\<langle>e'\\<bullet>F{D}:=e2, s'\\<rangle>\"\n\n| FAss1Red2:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>FAss (Val v) F D e, s\\<rangle> -ta\\<rightarrow> \\<langle>Val v\\<bullet>F{D}:=e', s'\\<rangle>\"\n\n| Red1FAss:\n  \"heap_write h a (CField D F) v h' \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>FAss (addr a) F D (Val v), (h, l)\\<rangle> -\\<lbrace>WriteMem a (CField D F) v\\<rbrace>\\<rightarrow> \\<langle>unit, (h', l)\\<rangle>\"\n\n| Red1FAssNull:\n  \"uf,P,t \\<turnstile>1 \\<langle>FAss null F D (Val v), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| CAS1Red1:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), s\\<rangle> -ta\\<rightarrow> \\<langle>e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), s'\\<rangle>\"\n\n| CAS1Red2:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), s\\<rangle> -ta\\<rightarrow> \\<langle>Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), s'\\<rangle>\"\n\n| CAS1Red3:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), s\\<rangle> -ta\\<rightarrow> \\<langle>Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), s'\\<rangle>\"\n\n| CAS1Null:\n  \"uf,P,t \\<turnstile>1 \\<langle>null\\<bullet>compareAndSwap(D\\<bullet>F, Val v, Val v'), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| Red1CASSucceed:\n  \"\\<lbrakk> heap_read h a (CField D F) v; heap_write h a (CField D F) v' h' \\<rbrakk> \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>addr a\\<bullet>compareAndSwap(D\\<bullet>F, Val v, Val v'), (h, l)\\<rangle> \n  -\\<lbrace>ReadMem a (CField D F) v, WriteMem a (CField D F) v'\\<rbrace>\\<rightarrow> \n  \\<langle>true, (h', l)\\<rangle>\"\n\n| Red1CASFail:\n  \"\\<lbrakk> heap_read h a (CField D F) v''; v \\<noteq> v'' \\<rbrakk> \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>addr a\\<bullet>compareAndSwap(D\\<bullet>F, Val v, Val v'), (h, l)\\<rangle> \n  -\\<lbrace>ReadMem a (CField D F) v''\\<rbrace>\\<rightarrow> \n  \\<langle>false, (h, l)\\<rangle>\"\n\n| Call1Obj:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>e\\<bullet>M(es), s\\<rangle> -ta\\<rightarrow> \\<langle>e'\\<bullet>M(es), s'\\<rangle>\"\n\n| Call1Params:\n  \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>(Val v)\\<bullet>M(es),s\\<rangle> -ta\\<rightarrow> \\<langle>(Val v)\\<bullet>M(es'),s'\\<rangle>\"\n\n| Red1CallExternal:\n  \"\\<lbrakk> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor>; P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D; P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>;\n     e' = extRet2J1 ((addr a)\\<bullet>M(map Val vs)) va; s' = (h', lcl s) \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(addr a)\\<bullet>M(map Val vs), s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n\n| Red1CallNull:\n  \"uf,P,t \\<turnstile>1 \\<langle>null\\<bullet>M(map Val vs), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| Block1Some:\n  \"V < length x \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>{V:T=\\<lfloor>v\\<rfloor>; e}, (h, x)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>{V:T=None; e}, (h, x[V := v])\\<rangle>\"\n\n| Block1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, (h, x)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', x')\\<rangle>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>{V:T=None; e}, (h, x)\\<rangle> -ta\\<rightarrow> \\<langle>{V:T=None; e'}, (h', x')\\<rangle>\"\n\n| Red1Block:\n  \"uf,P,t \\<turnstile>1 \\<langle>{V:T=None; Val u}, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Val u, s\\<rangle>\"\n\n| Synchronized1Red1:\n  \"uf,P,t \\<turnstile>1 \\<langle>o', s\\<rangle> -ta\\<rightarrow> \\<langle>o'', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>sync\\<^bsub>V\\<^esub> (o') e, s\\<rangle> -ta\\<rightarrow> \\<langle>sync\\<^bsub>V\\<^esub> (o'') e, s'\\<rangle>\"\n\n| Synchronized1Null:\n  \"V < length xs \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>sync\\<^bsub>V\\<^esub> (null) e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, (h, xs[V := Null])\\<rangle>\"\n\n| Lock1Synchronized:\n  \"V < length xs \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>sync\\<^bsub>V\\<^esub> (addr a) e, (h, xs)\\<rangle> -\\<lbrace>Lock\\<rightarrow>a, SyncLock a\\<rbrace>\\<rightarrow> \\<langle>insync\\<^bsub>V\\<^esub> (a) e, (h, xs[V := Addr a])\\<rangle>\"\n\n| Synchronized1Red2:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e, s\\<rangle> -ta\\<rightarrow> \\<langle>insync\\<^bsub>V\\<^esub> (a) e', s'\\<rangle>\"\n\n| Unlock1Synchronized:\n  \"\\<lbrakk> xs ! V = Addr a'; V < length xs \\<rbrakk> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) (Val v), (h, xs)\\<rangle> -\\<lbrace>Unlock\\<rightarrow>a', SyncUnlock a'\\<rbrace>\\<rightarrow> \\<langle>Val v, (h, xs)\\<rangle>\"\n\n| Unlock1SynchronizedNull:\n  \"\\<lbrakk> xs ! V = Null; V < length xs \\<rbrakk> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) (Val v), (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, (h, xs)\\<rangle>\"\n\n| Unlock1SynchronizedFail:\n  \"\\<lbrakk> uf; xs ! V = Addr a'; V < length xs \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) (Val v), (h, xs)\\<rangle> -\\<lbrace>UnlockFail\\<rightarrow>a'\\<rbrace>\\<rightarrow> \\<langle>THROW IllegalMonitorState, (h, xs)\\<rangle>\"\n\n| Seq1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>e;;e2, s\\<rangle> -ta\\<rightarrow> \\<langle>e';;e2, s'\\<rangle>\"\n\n| Red1Seq:\n  \"uf,P,t \\<turnstile>1 \\<langle>Seq (Val v) e, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e, s\\<rangle>\"\n\n| Cond1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>b, s\\<rangle> -ta\\<rightarrow> \\<langle>b', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>if (b) e1 else e2, s\\<rangle> -ta\\<rightarrow> \\<langle>if (b') e1 else e2, s'\\<rangle>\"\n\n| Red1CondT:\n  \"uf,P,t \\<turnstile>1 \\<langle>if (true) e1 else e2, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e1, s\\<rangle>\"\n\n| Red1CondF:\n  \"uf,P,t \\<turnstile>1 \\<langle>if (false) e1 else e2, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e2, s\\<rangle>\"\n\n| Red1While:\n  \"uf,P,t \\<turnstile>1 \\<langle>while(b) c, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>if (b) (c;;while(b) c) else unit, s\\<rangle>\"\n\n| Throw1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>throw e, s\\<rangle> -ta\\<rightarrow> \\<langle>throw e', s'\\<rangle>\"\n\n| Red1ThrowNull:\n  \"uf,P,t \\<turnstile>1 \\<langle>throw null, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| Try1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>try e catch(C V) e2, s\\<rangle> -ta\\<rightarrow> \\<langle>try e' catch(C V) e2, s'\\<rangle>\"\n\n| Red1Try:\n  \"uf,P,t \\<turnstile>1 \\<langle>try (Val v) catch(C V) e2, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Val v, s\\<rangle>\"\n\n| Red1TryCatch:\n  \"\\<lbrakk> typeof_addr h a = \\<lfloor>Class_type D\\<rfloor>; P \\<turnstile> D \\<preceq>\\<^sup>* C; V < length x \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>try (Throw a) catch(C V) e2, (h, x)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>{V:Class C=None; e2}, (h, x[V := Addr a])\\<rangle>\"\n\n| Red1TryFail:\n  \"\\<lbrakk> typeof_addr (hp s) a = \\<lfloor>Class_type D\\<rfloor>; \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>try (Throw a) catch(C V) e2, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n\n| List1Red1:\n  \"uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>e#es,s\\<rangle> [-ta\\<rightarrow>] \\<langle>e'#es,s'\\<rangle>\"\n\n| List1Red2:\n  \"uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n  uf,P,t \\<turnstile>1 \\<langle>Val v # es,s\\<rangle> [-ta\\<rightarrow>] \\<langle>Val v # es',s'\\<rangle>\"\n\n| New1ArrayThrow: \"uf,P,t \\<turnstile>1 \\<langle>newA T\\<lfloor>Throw a\\<rceil>, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Cast1Throw: \"uf,P,t \\<turnstile>1 \\<langle>Cast C (Throw a), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| InstanceOf1Throw: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a) instanceof T, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Bin1OpThrow1: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a) \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Bin1OpThrow2: \"uf,P,t \\<turnstile>1 \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> (Throw a), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| LAss1Throw: \"uf,P,t \\<turnstile>1 \\<langle>V:=(Throw a), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| AAcc1Throw1: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a)\\<lfloor>i\\<rceil>, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| AAcc1Throw2: \"uf,P,t \\<turnstile>1 \\<langle>(Val v)\\<lfloor>Throw a\\<rceil>, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| AAss1Throw1: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a)\\<lfloor>i\\<rceil> := e, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| AAss1Throw2: \"uf,P,t \\<turnstile>1 \\<langle>(Val v)\\<lfloor>Throw a\\<rceil> := e, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| AAss1Throw3: \"uf,P,t \\<turnstile>1 \\<langle>AAss (Val v) (Val i) (Throw a), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| ALength1Throw: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a)\\<bullet>length, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| FAcc1Throw: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a)\\<bullet>F{D}, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| FAss1Throw1: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a)\\<bullet>F{D}:=e\\<^sub>2, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| FAss1Throw2: \"uf,P,t \\<turnstile>1 \\<langle>FAss (Val v) F D (Throw a), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| CAS1Throw: \"uf,P,t \\<turnstile>1 \\<langle>Throw a\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| CAS1Throw2: \"uf,P,t \\<turnstile>1 \\<langle>Val v\\<bullet>compareAndSwap(D\\<bullet>F, Throw a, e3), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| CAS1Throw3: \"uf,P,t \\<turnstile>1 \\<langle>Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', Throw a), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Call1ThrowObj: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a)\\<bullet>M(es), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Call1ThrowParams: \"\\<lbrakk> es = map Val vs @ Throw a # es' \\<rbrakk> \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(Val v)\\<bullet>M(es), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Block1Throw: \"uf,P,t \\<turnstile>1 \\<langle>{V:T=None; Throw a}, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Synchronized1Throw1: \"uf,P,t \\<turnstile>1 \\<langle>sync\\<^bsub>V\\<^esub> (Throw a) e, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Synchronized1Throw2:\n  \"\\<lbrakk> xs ! V = Addr a'; V < length xs \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) Throw ad, (h, xs)\\<rangle> -\\<lbrace>Unlock\\<rightarrow>a', SyncUnlock a'\\<rbrace>\\<rightarrow> \\<langle>Throw ad, (h, xs)\\<rangle>\"\n| Synchronized1Throw2Fail:\n  \"\\<lbrakk> uf; xs ! V = Addr a'; V < length xs \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) Throw ad, (h, xs)\\<rangle> -\\<lbrace>UnlockFail\\<rightarrow>a'\\<rbrace>\\<rightarrow> \\<langle>THROW IllegalMonitorState, (h, xs)\\<rangle>\"\n| Synchronized1Throw2Null:\n  \"\\<lbrakk> xs ! V = Null; V < length xs \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) Throw ad, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>THROW NullPointer, (h, xs)\\<rangle>\"\n| Seq1Throw: \"uf,P,t \\<turnstile>1 \\<langle>(Throw a);;e\\<^sub>2, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Cond1Throw: \"uf,P,t \\<turnstile>1 \\<langle>if (Throw a) e\\<^sub>1 else e\\<^sub>2, s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\"\n| Throw1Throw: \"uf,P,t \\<turnstile>1 \\<langle>throw(Throw a), s\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>Throw a, s\\<rangle>\""], ["", "inductive_cases red1_cases:\n  \"uf,P,t \\<turnstile>1 \\<langle>new C, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>new T\\<lfloor>e\\<rceil>, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>e \\<guillemotleft>bop\\<guillemotright> e', s\\<rangle> -ta\\<rightarrow> \\<langle>e'', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>Var V, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>V:=e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>a\\<lfloor>i\\<rceil>, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>a\\<lfloor>i\\<rceil> := e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>a\\<bullet>length, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>e\\<bullet>F{D}, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>e\\<bullet>F{D} := e2, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''), s\\<rangle> -ta\\<rightarrow> \\<langle>e''', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>e\\<bullet>M(es), s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>{V:T=vo; e}, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>sync\\<^bsub>V\\<^esub> (o') e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>insync\\<^bsub>V\\<^esub> (a) e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>e;;e', s\\<rangle> -ta\\<rightarrow> \\<langle>e'', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>throw e, s \\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  \"uf,P,t \\<turnstile>1 \\<langle>try e catch(C V) e'', s \\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\""], ["", "inductive Red1 ::\n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) list \\<Rightarrow> 'heap\n  \\<Rightarrow> ('addr, 'thread_id, 'heap) J1_thread_action\n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) list \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  (\"_,_,_ \\<turnstile>1 ((1\\<langle>_'/_,/_\\<rangle>) -_\\<rightarrow>/ (1\\<langle>_'/_,/_\\<rangle>))\" [51,51,0,0,0,0,0,0,0,0] 81)\nfor uf :: bool and P :: \"'addr J1_prog\" and t :: 'thread_id\nwhere\n\n  red1Red:\n  \"uf,P,t \\<turnstile>1 \\<langle>e, (h, x)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', x')\\<rangle>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(e, x)/exs, h\\<rangle> -extTA2J1 P ta\\<rightarrow> \\<langle>(e', x')/exs, h'\\<rangle>\"\n\n| red1Call:\n  \"\\<lbrakk> call1 e = \\<lfloor>(a, M, vs)\\<rfloor>; typeof_addr h a = \\<lfloor>U\\<rfloor>; \n     P \\<turnstile> class_type_of U sees M:Ts\\<rightarrow>T = \\<lfloor>body\\<rfloor> in D; \n     size vs = size Ts \\<rbrakk>\n  \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(e, x)/exs, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>(blocks1 0 (Class D#Ts) body, Addr a # vs @ replicate (max_vars body) undefined_value)/(e, x)#exs, h\\<rangle>\"\n\n| red1Return:\n  \"final e' \\<Longrightarrow> uf,P,t \\<turnstile>1 \\<langle>(e', x')/(e, x)#exs, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>(inline_call e' e, x)/exs, h\\<rangle>\""], ["", "abbreviation mred1g :: \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> ('addr,'thread_id,('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list,'heap,'addr,('addr, 'thread_id) obs_event) semantics\"\nwhere \"mred1g uf P \\<equiv> \\<lambda>t ((ex, exs), h) ta ((ex', exs'), h'). uf,P,t \\<turnstile>1 \\<langle>ex/exs, h\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs', h'\\<rangle>\""], ["", "abbreviation mred1' :: \n  \"'addr J1_prog \\<Rightarrow> ('addr,'thread_id,('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list,'heap,'addr,('addr, 'thread_id) obs_event) semantics\"\nwhere \"mred1' \\<equiv> mred1g False\""], ["", "abbreviation mred1 :: \n  \"'addr J1_prog \\<Rightarrow> ('addr,'thread_id,('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list,'heap,'addr,('addr, 'thread_id) obs_event) semantics\"\nwhere \"mred1 \\<equiv> mred1g True\""], ["", "lemma red1_preserves_len: \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> length (lcl s') = length (lcl s)\"\n  and reds1_preserves_len: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> length (lcl s') = length (lcl s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     length (lcl s') = length (lcl s)) &&&\n    (uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                          \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     length (lcl s') = length (lcl s))", "by(induct rule: red1_reds1.inducts)(auto)"], ["", "lemma reds1_preserves_elen: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> length es' = length es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                         \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n    length es' = length es", "by(induct es arbitrary: es')(auto elim: reds1.cases)"], ["", "lemma red1_Val_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>Val v, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> uf,P,t \\<turnstile>1 \\<langle>Val v,s\\<rangle> -ta\\<rightarrow>\n                                \\<langle>e',s'\\<rangle>", "by(auto elim: red1.cases)"], ["", "lemma red1_Throw_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>Throw a, xs\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> uf,P,t \\<turnstile>1 \\<langle>Throw a,\n                                 xs\\<rangle> -ta\\<rightarrow>\n                                \\<langle>e',s'\\<rangle>", "by(auto elim: red1.cases)"], ["", "lemma reds1_Nil_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>[], s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> uf,P,t \\<turnstile>1 \\<langle>[],s\\<rangle> [-ta\\<rightarrow>]\n                                \\<langle>es',s'\\<rangle>", "by(auto elim: reds1.cases)"], ["", "lemma reds1_Val_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>map Val vs, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> uf,P,t \\<turnstile>1 \\<langle>map Val vs,\n                                 s\\<rangle> [-ta\\<rightarrow>]\n                                \\<langle>es',s'\\<rangle>", "by(induct vs arbitrary: es')(auto elim: reds1.cases)"], ["", "lemma reds1_map_Val_Throw_iff [iff]:\n  \"\\<not> uf,P,t \\<turnstile>1 \\<langle>map Val vs @ Throw a # es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> uf,P,t \\<turnstile>1 \\<langle>map Val vs @ Throw a # es,\n                                 s\\<rangle> [-ta\\<rightarrow>]\n                                \\<langle>es',s'\\<rangle>", "by(induct vs arbitrary: es')(auto elim: reds1.cases elim!: red1_cases)"], ["", "lemma red1_max_vars_decr: \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> max_vars e' \\<le> max_vars e\" \n  and reds1_max_varss_decr: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> max_varss es' \\<le> max_varss es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     max_vars e' \\<le> max_vars e) &&&\n    (uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                          \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     max_varss es' \\<le> max_varss es)", "by(induct rule: red1_reds1.inducts)(auto)"], ["", "lemma red1_new_thread_heap: \"\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t' ex h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h = hp s'\"\n  and reds1_new_thread_heap: \"\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t' ex h \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> h = hp s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      NewThread t' ex h\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> h = hp s') &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      NewThread t' ex h\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> h = hp s')", "apply(induct rule: red1_reds1.inducts)"], ["proof (prove)\ngoal (102 subgoals):\n 1. \\<And>h' a ha C l.\n       \\<lbrakk>(h', a) \\<in> allocate ha (Class_type C);\n        NewThread t' ex h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Class_type\n C)\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp (h', l)\n 2. \\<And>ha C l.\n       \\<lbrakk>allocate ha (Class_type C) = {};\n        NewThread t' ex h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp (ha, l)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' ex h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        h = hp s';\n        NewThread t' ex h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp s'\n 4. \\<And>i h' a ha T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate ha (Array_type T (nat (sint i)));\n        NewThread t' ex h\n        \\<in> set \\<lbrace>\\<lbrace>NewHeapElem a\n                                     (Array_type T\n (nat (sint i)))\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp (h', l)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        NewThread t' ex h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp s\n 6. \\<And>i ha T l.\n       \\<lbrakk>0 \\<le>s i; allocate ha (Array_type T (nat (sint i))) = {};\n        NewThread t' ex h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp (ha, l)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        NewThread t' ex h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        h = hp s';\n        NewThread t' ex h\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp s'\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        NewThread t' ex h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp s\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        NewThread t' ex h\n        \\<in> set \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> h = hp s\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         NewThread t' ex h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         h = hp s';\n         NewThread t' ex h\n         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> h = hp s'\nA total of 102 subgoals...", "apply(fastforce dest: red_ext_new_thread_heap simp add: ta_upd_simps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red1_new_threadD:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; NewThread t' x H \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>a M vs va T Ts Tr D. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va, hp s'\\<rangle> \\<and> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D\"\n  and reds1_new_threadD:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; NewThread t' x H \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>a M vs va T Ts Tr D. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va, hp s'\\<rangle> \\<and> typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees M:Ts\\<rightarrow>Tr = Native in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      NewThread t' x H\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>a M vs va T Ts Tr D.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,hp s'\\<rangle> \\<and>\n                          typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n                          P \\<turnstile> class_type_of\n    T sees M: Ts\\<rightarrow>Tr = Native in D) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      NewThread t' x H\n      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>a M vs va T Ts Tr D.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n     hp s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,hp s'\\<rangle> \\<and>\n                          typeof_addr (hp s) a = \\<lfloor>T\\<rfloor> \\<and>\n                          P \\<turnstile> class_type_of\n    T sees M: Ts\\<rightarrow>Tr = Native in D)", "by(induct rule: red1_reds1.inducts)(fastforce simp add: ta_upd_simps)+"], ["", "lemma red1_call_synthesized: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; call1 e = \\<lfloor>aMvs\\<rfloor> \\<rbrakk> \\<Longrightarrow> synthesized_call P (hp s) aMvs\"\n  and reds1_calls_synthesized: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; calls1 es = \\<lfloor>aMvs\\<rfloor> \\<rbrakk> \\<Longrightarrow> synthesized_call P (hp s) aMvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      call1 e = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> synthesized_call P (hp s) aMvs) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      calls1 es = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> synthesized_call P (hp s) aMvs)", "apply(induct rule: red1_reds1.inducts)"], ["proof (prove)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        call1 (new C) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp (h, l)) aMvs\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        call1 (new C) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp (h, l)) aMvs\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        call1 e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        synthesized_call P (hp s) aMvs;\n        call1 (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp s) aMvs\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        call1 (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp (h, l)) aMvs\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        call1 (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp s) aMvs\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        call1 (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp (h, l)) aMvs\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        call1 e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        synthesized_call P (hp s) aMvs;\n        call1 (Cast C e) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp s) aMvs\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        call1 (Cast T (Val v)) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp s) aMvs\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        call1 (Cast T (Val v)) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> synthesized_call P (hp s) aMvs\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         call1 e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         synthesized_call P (hp s) aMvs;\n         call1 (e instanceof T) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> synthesized_call P (hp s) aMvs\nA total of 102 subgoals...", "apply(auto split: if_split_asm simp add: is_vals_conv append_eq_map_conv synthesized_call_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa T M Ts Tr D vs ab ac ad ae af ba va h'.\n       \\<lbrakk>typeof_addr a aa = \\<lfloor>T\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        T sees M: Ts\\<rightarrow>Tr = Native in D;\n        P,t \\<turnstile> \\<langle>aa\\<bullet>M(vs),\n                         a\\<rangle> -(ab, ac, ad, ae, af,\nba)\\<rightarrow>ext \\<langle>va,h'\\<rangle>;\n        aMvs = (aa, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts Tr.\n                            Ex (Method_native P (class_type_of T) M Ts Tr)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red1_preserves_B: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<B> e n\\<rbrakk> \\<Longrightarrow> \\<B> e' n\"\n  and reds1_preserves_Bs: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<B>s es n\\<rbrakk> \\<Longrightarrow> \\<B>s es' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      \\<B> e n\\<rbrakk>\n     \\<Longrightarrow> \\<B> e' n) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      \\<B>s es n\\<rbrakk>\n     \\<Longrightarrow> \\<B>s es' n)", "by(induct arbitrary: n and n rule: red1_reds1.inducts)(auto)"], ["", "end"], ["", "context J1_heap begin"], ["", "lemma red1_hext_incr: \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> hext (hp s) (hp s')\"\n  and reds1_hext_incr: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> hext (hp s) (hp s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     hp s \\<unlhd> hp s') &&&\n    (uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                          \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     hp s \\<unlhd> hp s')", "by(induct rule: red1_reds1.inducts)(auto intro: hext_heap_ops red_external_hext)"], ["", "lemma Red1_hext_incr: \"uf,P,t \\<turnstile>1 \\<langle>ex/exs,h\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',h'\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uf,P,t \\<turnstile>1 \\<langle>ex/exs,h\\<rangle> -ta\\<rightarrow>\n                         \\<langle>ex'/exs',h'\\<rangle> \\<Longrightarrow>\n    h \\<unlhd> h'", "by(auto elim!: Red1.cases dest: red1_hext_incr)"], ["", "end"], ["", "subsection \\<open>Silent moves\\<close>"], ["", "context J1_heap_base begin"], ["", "primrec \\<tau>move1 :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> ('a, 'b, 'addr) exp \\<Rightarrow> bool\"\n  and \\<tau>moves1 :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> ('a, 'b, 'addr) exp list \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>move1 P h (new C) \\<longleftrightarrow> False\"\n| \"\\<tau>move1 P h (newA T\\<lfloor>e\\<rceil>) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a)\"\n| \"\\<tau>move1 P h (Cast U e) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> final e\"\n| \"\\<tau>move1 P h (e instanceof T) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> final e\"\n| \"\\<tau>move1 P h (e \\<guillemotleft>bop\\<guillemotright> e') \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v \\<and> (\\<tau>move1 P h e' \\<or> final e'))\"\n| \"\\<tau>move1 P h (Val v) \\<longleftrightarrow> False\"\n| \"\\<tau>move1 P h (Var V) \\<longleftrightarrow> True\"\n| \"\\<tau>move1 P h (V := e) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> final e\"\n| \"\\<tau>move1 P h (a\\<lfloor>i\\<rceil>) \\<longleftrightarrow> \\<tau>move1 P h a \\<or> (\\<exists>ad. a = Throw ad) \\<or> (\\<exists>v. a = Val v \\<and> (\\<tau>move1 P h i \\<or> (\\<exists>a. i = Throw a)))\"\n| \"\\<tau>move1 P h (AAss a i e) \\<longleftrightarrow> \\<tau>move1 P h a \\<or> (\\<exists>ad. a = Throw ad) \\<or> (\\<exists>v. a = Val v \\<and> (\\<tau>move1 P h i \\<or> (\\<exists>a. i = Throw a) \\<or> (\\<exists>v. i = Val v \\<and> (\\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a)))))\"\n| \"\\<tau>move1 P h (a\\<bullet>length) \\<longleftrightarrow> \\<tau>move1 P h a \\<or> (\\<exists>ad. a = Throw ad)\"\n| \"\\<tau>move1 P h (e\\<bullet>F{D}) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a)\"\n| \"\\<tau>move1 P h (FAss e F D e') \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v \\<and> (\\<tau>move1 P h e' \\<or> (\\<exists>a. e' = Throw a)))\"\n| \"\\<tau>move1 P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v \\<and> \n  (\\<tau>move1 P h e' \\<or> (\\<exists>a. e' = Throw a) \\<or> (\\<exists>v. e' = Val v \\<and> (\\<tau>move1 P h e'' \\<or> (\\<exists>a. e'' = Throw a)))))\"\n| \"\\<tau>move1 P h (e\\<bullet>M(es)) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v \\<and> \n   (\\<tau>moves1 P h es \\<or> (\\<exists>vs a es'. es = map Val vs @ Throw a # es') \\<or> \n    (\\<exists>vs. es = map Val vs \\<and> (v = Null \\<or> (\\<forall>T C Ts Tr D. typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor> \\<longrightarrow> class_type_of' T = \\<lfloor>C\\<rfloor> \\<longrightarrow> P \\<turnstile> C sees M:Ts\\<rightarrow>Tr = Native in D \\<longrightarrow> \\<tau>external_defs D M)))))\"\n| \"\\<tau>move1 P h ({V:T=vo; e}) \\<longleftrightarrow> vo \\<noteq> None \\<or> \\<tau>move1 P h e \\<or> final e\"\n| \"\\<tau>move1 P h (sync\\<^bsub>V'\\<^esub>(e) e') \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a)\"\n| \"\\<tau>move1 P h (insync\\<^bsub>V'\\<^esub>(ad) e) \\<longleftrightarrow> \\<tau>move1 P h e\"\n| \"\\<tau>move1 P h (e;;e') \\<longleftrightarrow> \\<tau>move1 P h e \\<or> final e\"\n| \"\\<tau>move1 P h (if (e) e' else e'') \\<longleftrightarrow> \\<tau>move1 P h e \\<or> final e\"\n| \"\\<tau>move1 P h (while (e) e') = True\"\n| \"\\<tau>move1 P h (throw e) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> e = null\"\n| \"\\<tau>move1 P h (try e catch(C V) e') \\<longleftrightarrow> \\<tau>move1 P h e \\<or> final e\"\n\n| \"\\<tau>moves1 P h [] \\<longleftrightarrow> False\"\n| \"\\<tau>moves1 P h (e # es) \\<longleftrightarrow> \\<tau>move1 P h e \\<or> (\\<exists>v. e = Val v \\<and> \\<tau>moves1 P h es)\""], ["", "fun \\<tau>Move1 :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> (('a, 'b, 'addr) exp \\<times> 'c) \\<times> (('a, 'b, 'addr) exp \\<times> 'd) list \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>Move1 P h ((e, x), exs) = (\\<tau>move1 P h e \\<or> final e)\""], ["", "definition \\<tau>red1g :: \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1g uf P t h exs e'xs' = (uf,P,t \\<turnstile>1 \\<langle>fst exs, (h, snd exs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>fst e'xs', (h, snd e'xs')\\<rangle> \\<and> \\<tau>move1 P h (fst exs))\""], ["", "definition \\<tau>reds1g :: \n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>reds1g uf P t h esxs es'xs' =\n   (uf,P,t \\<turnstile>1 \\<langle>fst esxs, (h, snd esxs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>fst es'xs', (h, snd es'xs')\\<rangle> \\<and> \\<tau>moves1 P h (fst esxs))\""], ["", "abbreviation \\<tau>red1gt :: \n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1gt uf P t h \\<equiv> (\\<tau>red1g uf P t h)^++\""], ["", "abbreviation \\<tau>reds1gt ::\n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds1gt uf P t h \\<equiv> (\\<tau>reds1g uf P t h)^++\""], ["", "abbreviation \\<tau>red1gr ::\n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1gr uf P t h \\<equiv> (\\<tau>red1g uf P t h)^**\""], ["", "abbreviation \\<tau>reds1gr ::\n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds1gr uf P t h \\<equiv> (\\<tau>reds1g uf P t h)^**\""], ["", "definition \\<tau>Red1g ::\n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list)\n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1g uf P t h exexs ex'exs' = (uf,P,t \\<turnstile>1 \\<langle>fst exexs/snd exexs, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>fst ex'exs'/snd ex'exs', h\\<rangle> \\<and> \\<tau>Move1 P h exexs)\""], ["", "abbreviation \\<tau>Red1gt ::\n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1gt uf P t h \\<equiv> (\\<tau>Red1g uf P t h)^++\""], ["", "abbreviation \\<tau>Red1gr :: \n  \"bool \\<Rightarrow> 'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1gr uf P t h \\<equiv> (\\<tau>Red1g uf P t h)^**\""], ["", "abbreviation \\<tau>red1 :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1 \\<equiv> \\<tau>red1g True\""], ["", "abbreviation \\<tau>reds1 :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds1 \\<equiv> \\<tau>reds1g True\""], ["", "abbreviation \\<tau>red1t :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1t \\<equiv> \\<tau>red1gt True\""], ["", "abbreviation \\<tau>reds1t ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds1t \\<equiv> \\<tau>reds1gt True\""], ["", "abbreviation \\<tau>red1r ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1r \\<equiv> \\<tau>red1gr True\""], ["", "abbreviation \\<tau>reds1r ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds1r \\<equiv> \\<tau>reds1gr True\""], ["", "abbreviation \\<tau>Red1 ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list)\n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1 \\<equiv> \\<tau>Red1g True\""], ["", "abbreviation \\<tau>Red1t ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1t \\<equiv> \\<tau>Red1gt True\""], ["", "abbreviation \\<tau>Red1r :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1r \\<equiv> \\<tau>Red1gr True\""], ["", "abbreviation \\<tau>red1' :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1' \\<equiv> \\<tau>red1g False\""], ["", "abbreviation \\<tau>reds1' :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds1' \\<equiv> \\<tau>reds1g False\""], ["", "abbreviation \\<tau>red1't ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1't \\<equiv> \\<tau>red1gt False\""], ["", "abbreviation \\<tau>reds1't :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds1't \\<equiv> \\<tau>reds1gt False\""], ["", "abbreviation \\<tau>red1'r ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>red1'r \\<equiv> \\<tau>red1gr False\""], ["", "abbreviation \\<tau>reds1'r :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> ('addr expr1 list \\<times> 'addr locals1) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds1'r \\<equiv> \\<tau>reds1gr False\""], ["", "abbreviation \\<tau>Red1' ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1' \\<equiv> \\<tau>Red1g False\""], ["", "abbreviation \\<tau>Red1't ::\n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1't \\<equiv> \\<tau>Red1gt False\""], ["", "abbreviation \\<tau>Red1'r :: \n  \"'addr J1_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \n  \\<Rightarrow> ('addr expr1 \\<times> 'addr locals1) \\<times> (('addr expr1 \\<times> 'addr locals1) list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red1'r \\<equiv> \\<tau>Red1gr False\""], ["", "abbreviation \\<tau>MOVE1 :: \n  \"'m prog \\<Rightarrow> ((('addr expr1 \\<times> 'addr locals1) \\<times> ('addr expr1 \\<times> 'addr locals1) list) \\<times> 'heap, ('addr, 'thread_id, 'heap) J1_thread_action) trsys\"\nwhere \"\\<tau>MOVE1 P \\<equiv> \\<lambda>(exexs, h) ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<epsilon>\""], ["", "lemma \\<tau>move1_\\<tau>moves1_intros:\n  fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move1NewArray: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (newA T\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move1Cast: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Cast U e)\"\n  and \\<tau>move1CastRed: \"\\<tau>move1 P h (Cast U (Val v))\"\n  and \\<tau>move1InstanceOf: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e instanceof U)\"\n  and \\<tau>move1InstanceOfRed: \"\\<tau>move1 P h ((Val v) instanceof U)\"\n  and \\<tau>move1BinOp1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<guillemotleft>bop\\<guillemotright>e')\"\n  and \\<tau>move1BinOp2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Val v\\<guillemotleft>bop\\<guillemotright>e)\"\n  and \\<tau>move1BinOp: \"\\<tau>move1 P h (Val v\\<guillemotleft>bop\\<guillemotright>Val v')\"\n  and \\<tau>move1Var: \"\\<tau>move1 P h (Var V)\"\n  and \\<tau>move1LAss: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (V := e)\"\n  and \\<tau>move1LAssRed: \"\\<tau>move1 P h (V := Val v)\"\n  and \\<tau>move1AAcc1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<lfloor>e'\\<rceil>)\"\n  and \\<tau>move1AAcc2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Val v\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move1AAss1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (AAss e e' e'')\"\n  and \\<tau>move1AAss2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (AAss (Val v) e e')\"\n  and \\<tau>move1AAss3: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (AAss (Val v) (Val v') e)\"\n  and \\<tau>move1ALength: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<bullet>length)\"\n  and \\<tau>move1FAcc: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<bullet>F{D})\"\n  and \\<tau>move1FAss1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (FAss e F D e')\"\n  and \\<tau>move1FAss2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (FAss (Val v) F D e)\"\n  and \\<tau>move1CAS1: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\"\n  and \\<tau>move1CAS2: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e''))\"\n  and \\<tau>move1CAS3: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e))\"\n  and \\<tau>move1CallObj: \"\\<tau>move1 P h obj \\<Longrightarrow> \\<tau>move1 P h (obj\\<bullet>M(ps))\"\n  and \\<tau>move1CallParams: \"\\<tau>moves1 P h ps \\<Longrightarrow> \\<tau>move1 P h (Val v\\<bullet>M(ps))\"\n  and \\<tau>move1Call: \"(\\<And>T C Ts Tr D. \\<lbrakk> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>; class_type_of' T = \\<lfloor>C\\<rfloor>; P \\<turnstile> C sees M:Ts\\<rightarrow>Tr = Native in D \\<rbrakk> \\<Longrightarrow> \\<tau>external_defs D M) \\<Longrightarrow> \\<tau>move1 P h (Val v\\<bullet>M(map Val vs))\"\n  and \\<tau>move1BlockSome: \"\\<tau>move1 P h {V:T=\\<lfloor>v\\<rfloor>; e}\"\n  and \\<tau>move1Block: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h {V:T=None; e}\"\n  and \\<tau>move1BlockRed: \"\\<tau>move1 P h {V:T=None; Val v}\"\n  and \\<tau>move1Sync: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (sync\\<^bsub>V'\\<^esub> (e) e')\"\n  and \\<tau>move1InSync: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (insync\\<^bsub>V'\\<^esub> (a) e)\"\n  and \\<tau>move1Seq: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e;;e')\"\n  and \\<tau>move1SeqRed: \"\\<tau>move1 P h (Val v;; e)\"\n  and \\<tau>move1Cond: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (if (e) e1 else e2)\"\n  and \\<tau>move1CondRed: \"\\<tau>move1 P h (if (Val v) e1 else e2)\"\n  and \\<tau>move1WhileRed: \"\\<tau>move1 P h (while (c) e)\"\n  and \\<tau>move1Throw: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (throw e)\"\n  and \\<tau>move1ThrowNull: \"\\<tau>move1 P h (throw null)\"\n  and \\<tau>move1Try: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (try e catch(C V) e'')\"\n  and \\<tau>move1TryRed: \"\\<tau>move1 P h (try Val v catch(C V) e)\"\n  and \\<tau>move1TryThrow: \"\\<tau>move1 P h (try Throw a catch(C V) e)\"\n  and \\<tau>move1NewArrayThrow: \"\\<tau>move1 P h (newA T\\<lfloor>Throw a\\<rceil>)\"\n  and \\<tau>move1CastThrow: \"\\<tau>move1 P h (Cast T (Throw a))\"\n  and \\<tau>move1InstanceOfThrow: \"\\<tau>move1 P h ((Throw a) instanceof T)\"\n  and \\<tau>move1BinOpThrow1: \"\\<tau>move1 P h (Throw a \\<guillemotleft>bop\\<guillemotright> e2)\"\n  and \\<tau>move1BinOpThrow2: \"\\<tau>move1 P h (Val v \\<guillemotleft>bop\\<guillemotright> Throw a)\"\n  and \\<tau>move1LAssThrow: \"\\<tau>move1 P h (V:=(Throw a))\"\n  and \\<tau>move1AAccThrow1: \"\\<tau>move1 P h (Throw a\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move1AAccThrow2: \"\\<tau>move1 P h (Val v\\<lfloor>Throw a\\<rceil>)\"\n  and \\<tau>move1AAssThrow1: \"\\<tau>move1 P h (AAss (Throw a) e e')\"\n  and \\<tau>move1AAssThrow2: \"\\<tau>move1 P h (AAss (Val v) (Throw a) e')\"\n  and \\<tau>move1AAssThrow3: \"\\<tau>move1 P h (AAss (Val v) (Val v') (Throw a))\"\n  and \\<tau>move1ALengthThrow: \"\\<tau>move1 P h (Throw a\\<bullet>length)\"\n  and \\<tau>move1FAccThrow: \"\\<tau>move1 P h (Throw a\\<bullet>F{D})\"\n  and \\<tau>move1FAssThrow1: \"\\<tau>move1 P h (Throw a\\<bullet>F{D} := e)\"\n  and \\<tau>move1FAssThrow2: \"\\<tau>move1 P h (FAss (Val v) F D (Throw a))\"\n  and \\<tau>move1CASThrow1: \"\\<tau>move1 P h (CompareAndSwap (Throw a) D F e e')\"\n  and \\<tau>move1CASThrow2: \"\\<tau>move1 P h (CompareAndSwap (Val v) D F (Throw a) e')\"\n  and \\<tau>move1CASThrow3: \"\\<tau>move1 P h (CompareAndSwap (Val v) D F (Val v') (Throw a))\"\n  and \\<tau>move1CallThrowObj: \"\\<tau>move1 P h (Throw a\\<bullet>M(es))\"\n  and \\<tau>move1CallThrowParams: \"\\<tau>move1 P h (Val v\\<bullet>M(map Val vs @ Throw a # es))\"\n  and \\<tau>move1BlockThrow: \"\\<tau>move1 P h {V:T=None; Throw a}\"\n  and \\<tau>move1SyncThrow: \"\\<tau>move1 P h (sync\\<^bsub>V'\\<^esub> (Throw a) e)\"\n  and \\<tau>move1SeqThrow: \"\\<tau>move1 P h (Throw a;;e)\"\n  and \\<tau>move1CondThrow: \"\\<tau>move1 P h (if (Throw a) e1 else e2)\"\n  and \\<tau>move1ThrowThrow: \"\\<tau>move1 P h (throw (Throw a))\"\n\n  and \\<tau>moves1Hd: \"\\<tau>move1 P h e \\<Longrightarrow> \\<tau>moves1 P h (e # es)\"\n  and \\<tau>moves1Tl: \"\\<tau>moves1 P h es \\<Longrightarrow> \\<tau>moves1 P h (Val v # es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((((\\<tau>move1 P h e \\<Longrightarrow>\n          \\<tau>move1 P h (newA T\\<lfloor>e\\<rceil>)) &&&\n         (\\<tau>move1 P h e \\<Longrightarrow>\n          \\<tau>move1 P h (Cast U e))) &&&\n        \\<tau>move1 P h (Cast U (Val v)) &&&\n        (\\<tau>move1 P h e \\<Longrightarrow>\n         \\<tau>move1 P h (e instanceof U))) &&&\n       (\\<tau>move1 P h (Val v instanceof U) &&&\n        (\\<tau>move1 P h e \\<Longrightarrow>\n         \\<tau>move1 P h (e \\<guillemotleft>bop\\<guillemotright> e'))) &&&\n       (\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h (Val v \\<guillemotleft>bop\\<guillemotright> e)) &&&\n       \\<tau>move1 P h\n        (Val v \\<guillemotleft>bop\\<guillemotright> Val v')) &&&\n      ((\\<tau>move1 P h (Var V) &&&\n        (\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (V:=e))) &&&\n       \\<tau>move1 P h (V:=Val v) &&&\n       (\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h (e\\<lfloor>e'\\<rceil>))) &&&\n      ((\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h (Val v\\<lfloor>e\\<rceil>)) &&&\n       (\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h (e\\<lfloor>e'\\<rceil> := e''))) &&&\n      (\\<tau>move1 P h e \\<Longrightarrow>\n       \\<tau>move1 P h (Val v\\<lfloor>e\\<rceil> := e')) &&&\n      (\\<tau>move1 P h e \\<Longrightarrow>\n       \\<tau>move1 P h (Val v\\<lfloor>Val v'\\<rceil> := e)) &&&\n      (\\<tau>move1 P h e \\<Longrightarrow>\n       \\<tau>move1 P h (e\\<bullet>length))) &&&\n     ((((\\<tau>move1 P h e \\<Longrightarrow>\n         \\<tau>move1 P h (e\\<bullet>F{D})) &&&\n        (\\<tau>move1 P h e \\<Longrightarrow>\n         \\<tau>move1 P h (e\\<bullet>F{D} := e'))) &&&\n       (\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h (Val v\\<bullet>F{D} := e)) &&&\n       (\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h\n         (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')))) &&&\n      ((\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h\n         (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e''))) &&&\n       (\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h\n         (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e)))) &&&\n      (\\<tau>move1 P h obj \\<Longrightarrow>\n       \\<tau>move1 P h (obj\\<bullet>M(ps))) &&&\n      (\\<tau>moves1 P h ps \\<Longrightarrow>\n       \\<tau>move1 P h (Val v\\<bullet>M(ps)))) &&&\n     ((((\\<And>T C Ts Tr D.\n            \\<lbrakk>typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n             class_type_of' T = \\<lfloor>C\\<rfloor>;\n             P \\<turnstile> C sees M: Ts\\<rightarrow>Tr = Native in D\\<rbrakk>\n            \\<Longrightarrow> \\<tau>external_defs D M) \\<Longrightarrow>\n        \\<tau>move1 P h (Val v\\<bullet>M(map Val vs))) &&&\n       \\<tau>move1 P h {V:T=\\<lfloor>v\\<rfloor>; e}) &&&\n      (\\<tau>move1 P h e \\<Longrightarrow>\n       \\<tau>move1 P h {V:T=None; e}) &&&\n      \\<tau>move1 P h {V:T=None; Val v}) &&&\n     ((\\<tau>move1 P h e \\<Longrightarrow>\n       \\<tau>move1 P h (sync\\<^bsub>V'\\<^esub> (e) e')) &&&\n      (\\<tau>move1 P h e \\<Longrightarrow>\n       \\<tau>move1 P h (insync\\<^bsub>V'\\<^esub> (a) e))) &&&\n     (\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (e;; e')) &&&\n     \\<tau>move1 P h (Val v;; e) &&&\n     (\\<tau>move1 P h e \\<Longrightarrow>\n      \\<tau>move1 P h (if (e) e1 else e2))) &&&\n    ((((\\<tau>move1 P h (if (Val v) e1 else e2) &&&\n        \\<tau>move1 P h (while (c) e)) &&&\n       (\\<tau>move1 P h e \\<Longrightarrow> \\<tau>move1 P h (throw e)) &&&\n       \\<tau>move1 P h (throw null)) &&&\n      ((\\<tau>move1 P h e \\<Longrightarrow>\n        \\<tau>move1 P h (try e catch(C V) e'')) &&&\n       \\<tau>move1 P h (try Val v catch(C V) e)) &&&\n      \\<tau>move1 P h (try Throw a catch(C V) e) &&&\n      \\<tau>move1 P h (newA T\\<lfloor>Throw a\\<rceil>)) &&&\n     ((\\<tau>move1 P h (Cast T (Throw a)) &&&\n       \\<tau>move1 P h (Throw a instanceof T)) &&&\n      \\<tau>move1 P h (Throw a \\<guillemotleft>bop\\<guillemotright> e2) &&&\n      \\<tau>move1 P h\n       (Val v \\<guillemotleft>bop\\<guillemotright> Throw a)) &&&\n     (\\<tau>move1 P h (V:=Throw a) &&&\n      \\<tau>move1 P h (Throw a\\<lfloor>e\\<rceil>)) &&&\n     \\<tau>move1 P h (Val v\\<lfloor>Throw a\\<rceil>) &&&\n     \\<tau>move1 P h (Throw a\\<lfloor>e\\<rceil> := e') &&&\n     \\<tau>move1 P h (Val v\\<lfloor>Throw a\\<rceil> := e')) &&&\n    (((\\<tau>move1 P h (Val v\\<lfloor>Val v'\\<rceil> := Throw a) &&&\n       \\<tau>move1 P h (Throw a\\<bullet>length)) &&&\n      \\<tau>move1 P h (Throw a\\<bullet>F{D}) &&&\n      \\<tau>move1 P h (Throw a\\<bullet>F{D} := e)) &&&\n     (\\<tau>move1 P h (Val v\\<bullet>F{D} := Throw a) &&&\n      \\<tau>move1 P h\n       (Throw a\\<bullet>compareAndSwap(D\\<bullet>F, e, e'))) &&&\n     \\<tau>move1 P h\n      (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Throw a, e')) &&&\n     \\<tau>move1 P h\n      (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', Throw a))) &&&\n    ((\\<tau>move1 P h (Throw a\\<bullet>M(es)) &&&\n      \\<tau>move1 P h (Val v\\<bullet>M(map Val vs @ Throw a # es))) &&&\n     \\<tau>move1 P h {V:T=None; Throw a} &&&\n     \\<tau>move1 P h (sync\\<^bsub>V'\\<^esub> (Throw a) e)) &&&\n    (\\<tau>move1 P h (Throw a;; e) &&&\n     \\<tau>move1 P h (if (Throw a) e1 else e2)) &&&\n    \\<tau>move1 P h (throw (Throw a)) &&&\n    (\\<tau>move1 P h e \\<Longrightarrow> \\<tau>moves1 P h (e # es)) &&&\n    (\\<tau>moves1 P h es \\<Longrightarrow> \\<tau>moves1 P h (Val v # es))", "by fastforce+"], ["", "lemma \\<tau>moves1_map_Val [dest!]:\n  \"\\<tau>moves1 P h (map Val es) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>moves1 P h (map Val es) \\<Longrightarrow> False", "by(induct es)(auto)"], ["", "lemma \\<tau>moves1_map_Val_ThrowD [simp]: \"\\<tau>moves1 P h (map Val vs @ Throw a # es) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>moves1 P h (map Val vs @ Throw a # es) = False", "by(induct vs)(fastforce)+"], ["", "lemma fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move1_not_call1:\n  \"call1 e = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow> \\<tau>move1 P h e \\<longleftrightarrow> (synthesized_call P h (a, M, vs) \\<longrightarrow> \\<tau>external' P h a M)\"\n  and \\<tau>moves1_not_calls1:\n  \"calls1 es = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow> \\<tau>moves1 P h es \\<longleftrightarrow> (synthesized_call P h (a, M, vs) \\<longrightarrow> \\<tau>external' P h a M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (call1 e = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n     \\<tau>move1 P h e =\n     (synthesized_call P h (a, M, vs) \\<longrightarrow>\n      \\<tau>external' P h a M)) &&&\n    (calls1 es = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n     \\<tau>moves1 P h es =\n     (synthesized_call P h (a, M, vs) \\<longrightarrow>\n      \\<tau>external' P h a M))", "apply(induct e and es rule: call1.induct calls1.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       call1 (new x) = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n       \\<tau>move1 P h (new x) =\n       (synthesized_call P h (a, M, vs) \\<longrightarrow>\n        \\<tau>external' P h a M)\n 2. \\<And>x1 x2.\n       \\<lbrakk>call1 x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move1 P h x2 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call1 (newA x1\\<lfloor>x2\\<rceil>) =\n        \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move1 P h (newA x1\\<lfloor>x2\\<rceil>) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 3. \\<And>x1 x2.\n       \\<lbrakk>call1 x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move1 P h x2 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call1 (Cast x1 x2) = \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move1 P h (Cast x1 x2) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 4. \\<And>x1 x2.\n       \\<lbrakk>call1 x1 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move1 P h x1 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call1 (x1 instanceof x2) = \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move1 P h (x1 instanceof x2) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 5. \\<And>x.\n       call1 (Val x) = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n       \\<tau>move1 P h (Val x) =\n       (synthesized_call P h (a, M, vs) \\<longrightarrow>\n        \\<tau>external' P h a M)\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call1 x1 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move1 P h x1 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call1 x3 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n        \\<tau>move1 P h x3 =\n        (synthesized_call P h (a, M, vs) \\<longrightarrow>\n         \\<tau>external' P h a M);\n        call1 (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move1 P h\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 7. \\<And>x.\n       call1 (Var x) = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n       \\<tau>move1 P h (Var x) =\n       (synthesized_call P h (a, M, vs) \\<longrightarrow>\n        \\<tau>external' P h a M)\n 8. \\<And>x1 x2.\n       \\<lbrakk>call1 x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move1 P h x2 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call1 (x1:=x2) = \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move1 P h (x1:=x2) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 9. \\<And>x1 x2.\n       \\<lbrakk>call1 x1 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move1 P h x1 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call1 x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n        \\<tau>move1 P h x2 =\n        (synthesized_call P h (a, M, vs) \\<longrightarrow>\n         \\<tau>external' P h a M);\n        call1 (x1\\<lfloor>x2\\<rceil>) =\n        \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move1 P h (x1\\<lfloor>x2\\<rceil>) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call1 x1 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                 \\<tau>move1 P h x1 =\n                 (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                  \\<tau>external' P h a M);\n         call1 x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n         \\<tau>move1 P h x2 =\n         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n          \\<tau>external' P h a M);\n         call1 x3 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n         \\<tau>move1 P h x3 =\n         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n          \\<tau>external' P h a M);\n         call1 (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move1 P h (x1\\<lfloor>x2\\<rceil> := x3) =\n                          (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                           \\<tau>external' P h a M)\nA total of 25 subgoals...", "apply(auto split: if_split_asm simp add: is_vals_conv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>vsa aa es'.\n       \\<lbrakk>synthesized_call P h (a, M, vs);\n        map Val vs = map Val vsa @ Throw aa # es'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>external' P h a M\n 2. \\<lbrakk>synthesized_call P h (a, M, vs);\n     \\<forall>T.\n        (\\<exists>z.\n            typeof_addr h a = \\<lfloor>z\\<rfloor> \\<and>\n            ty_of_htype z = T) \\<longrightarrow>\n        (\\<forall>C.\n            class_type_of' T = \\<lfloor>C\\<rfloor> \\<longrightarrow>\n            (\\<forall>Ts Tr D.\n                P \\<turnstile> C sees M: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n                \\<tau>external_defs D M))\\<rbrakk>\n    \\<Longrightarrow> \\<tau>external' P h a M\n 3. \\<And>z Ts Tr D.\n       \\<lbrakk>\\<not> \\<tau>moves1 P h (map Val vs);\n        \\<forall>vsa a es'. map Val vs \\<noteq> map Val vsa @ Throw a # es';\n        typeof_addr h a = \\<lfloor>z\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        z sees M: Ts\\<rightarrow>Tr = Native in D;\n        \\<not> synthesized_call P h (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>external_defs D M\n 4. \\<And>z Ts Tr D.\n       \\<lbrakk>\\<not> \\<tau>moves1 P h (map Val vs);\n        \\<forall>vsa a es'. map Val vs \\<noteq> map Val vsa @ Throw a # es';\n        typeof_addr h a = \\<lfloor>z\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        z sees M: Ts\\<rightarrow>Tr = Native in D;\n        \\<tau>external' P h a M\\<rbrakk>\n       \\<Longrightarrow> \\<tau>external_defs D M", "apply(fastforce simp add: synthesized_call_def map_eq_append_conv \\<tau>external'_def \\<tau>external_def dest: sees_method_fun)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red1_\\<tau>_taD: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move1 P (hp s) e \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"\n  and reds1_\\<tau>_taD: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves1 P (hp s) es \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      \\<tau>move1 P (hp s) e\\<rbrakk>\n     \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      \\<tau>moves1 P (hp s) es\\<rbrakk>\n     \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>)", "apply(induct rule: red1_reds1.inducts)"], ["proof (prove)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<tau>move1 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace> =\n                         \\<lbrace>\\<rbrace>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<tau>move1 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<tau>move1 P (hp s) e \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>;\n        \\<tau>move1 P (hp s) (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<tau>move1 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a\n                                   (Array_type T (nat (sint i)))\\<rbrace> =\n                         \\<lbrace>\\<rbrace>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<tau>move1 P (hp s) (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<tau>move1 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<tau>move1 P (hp s) e \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>;\n        \\<tau>move1 P (hp s) (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<tau>move1 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<tau>move1 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<tau>move1 P (hp s) e \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>;\n         \\<tau>move1 P (hp s) (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\nA total of 102 subgoals...", "apply(fastforce simp add: map_eq_append_conv \\<tau>external'_def \\<tau>external_def dest: \\<tau>external'_red_external_TA_empty)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>move1_heap_unchanged: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move1 P (hp s) e \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"\n  and \\<tau>moves1_heap_unchanged: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves1 P (hp s) es \\<rbrakk> \\<Longrightarrow> hp s' = hp s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      \\<tau>move1 P (hp s) e\\<rbrakk>\n     \\<Longrightarrow> hp s' = hp s) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      \\<tau>moves1 P (hp s) es\\<rbrakk>\n     \\<Longrightarrow> hp s' = hp s)", "apply(induct rule: red1_reds1.inducts)"], ["proof (prove)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<tau>move1 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> hp (h', l) = hp (h, l)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<tau>move1 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> hp (h, l) = hp (h, l)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<tau>move1 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n        \\<tau>move1 P (hp s) (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp s' = hp s\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<tau>move1 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp (h', l) = hp (h, l)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<tau>move1 P (hp s) (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<tau>move1 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp (h, l) = hp (h, l)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<tau>move1 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n        \\<tau>move1 P (hp s) (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> hp s' = hp s\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<tau>move1 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<tau>move1 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<tau>move1 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n         \\<tau>move1 P (hp s) (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> hp s' = hp s\nA total of 102 subgoals...", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa T M Ts Tr D vs ab ac ad ae af ba va h' vsa ah es'.\n       \\<lbrakk>typeof_addr a aa = \\<lfloor>T\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        T sees M: Ts\\<rightarrow>Tr = Native in D;\n        P,t \\<turnstile> \\<langle>aa\\<bullet>M(vs),\n                         a\\<rangle> -(ab, ac, ad, ae, af,\nba)\\<rightarrow>ext \\<langle>va,h'\\<rangle>;\n        map Val vs = map Val vsa @ Throw ah # es'\\<rbrakk>\n       \\<Longrightarrow> h' = a\n 2. \\<And>a aa T M Ts Tr D vs ab ac ad ae af ba va h'.\n       \\<lbrakk>typeof_addr a aa = \\<lfloor>T\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        T sees M: Ts\\<rightarrow>Tr = Native in D;\n        P,t \\<turnstile> \\<langle>aa\\<bullet>M(vs),\n                         a\\<rangle> -(ab, ac, ad, ae, af,\nba)\\<rightarrow>ext \\<langle>va,h'\\<rangle>;\n        \\<forall>Ts Tr D.\n           P \\<turnstile> class_type_of\n                           T sees M: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n           \\<tau>external_defs D M\\<rbrakk>\n       \\<Longrightarrow> h' = a", "apply(fastforce simp add: map_eq_append_conv \\<tau>external'_def \\<tau>external_def dest: \\<tau>external'_red_external_heap_unchanged)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Move1_iff:\n  \"\\<tau>Move1 P h exexs \\<longleftrightarrow> (let ((e, _), _) = exexs in \\<tau>move1 P h e \\<or> final e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Move1 P h exexs =\n    (let ((e, uu_), uu_) = exexs in \\<tau>move1 P h e \\<or> final e)", "by(cases exexs)(auto)"], ["", "lemma \\<tau>red1_iff [iff]:\n  \"\\<tau>red1g uf P t h (e, xs) (e', xs') = (uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle> \\<and> \\<tau>move1 P h e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1g uf P t h (e, xs) (e', xs') =\n    (uf,P,t \\<turnstile>1 \\<langle>e,\n                           (h, xs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                          \\<langle>e',(h, xs')\\<rangle> \\<and>\n     \\<tau>move1 P h e)", "by(simp add: \\<tau>red1g_def)"], ["", "lemma \\<tau>reds1_iff [iff]:\n  \"\\<tau>reds1g uf P t h (es, xs) (es', xs') = (uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle> \\<and> \\<tau>moves1 P h es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1g uf P t h (es, xs) (es', xs') =\n    (uf,P,t \\<turnstile>1 \\<langle>es,\n                           (h, xs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                          \\<langle>es',(h, xs')\\<rangle> \\<and>\n     \\<tau>moves1 P h es)", "by(simp add: \\<tau>reds1g_def)"], ["", "lemma \\<tau>red1t_1step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,\n                                   (h, xs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                  \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move1 P h e\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e', xs')", "by(blast intro: tranclp.r_into_trancl)"], ["", "lemma \\<tau>red1t_2step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e; \n     uf,P,t \\<turnstile>1 \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move1 P h e' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,\n                                   (h, xs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                  \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move1 P h e;\n     uf,P,t \\<turnstile>1 \\<langle>e',\n                           (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                          \\<langle>e'',(h, xs'')\\<rangle>;\n     \\<tau>move1 P h e'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e'', xs'')", "by(blast intro: tranclp.trancl_into_trancl[OF \\<tau>red1t_1step])"], ["", "lemma \\<tau>red1t_3step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e; \n     uf,P,t \\<turnstile>1 \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move1 P h e';\n     uf,P,t \\<turnstile>1 \\<langle>e'', (h, xs'')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e''', (h, xs''')\\<rangle>; \\<tau>move1 P h e'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e''', xs''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,\n                                   (h, xs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                  \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move1 P h e;\n     uf,P,t \\<turnstile>1 \\<langle>e',\n                           (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                          \\<langle>e'',(h, xs'')\\<rangle>;\n     \\<tau>move1 P h e';\n     uf,P,t \\<turnstile>1 \\<langle>e'',\n                           (h, xs'')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                          \\<langle>e''',(h, xs''')\\<rangle>;\n     \\<tau>move1 P h e''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red1gt uf P t h (e, xs) (e''', xs''')", "by(blast intro: tranclp.trancl_into_trancl[OF \\<tau>red1t_2step])"], ["", "lemma \\<tau>reds1t_1step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,\n                                   (h, xs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                  \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves1 P h es\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es', xs')", "by(blast intro: tranclp.r_into_trancl)"], ["", "lemma \\<tau>reds1t_2step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es; \n     uf,P,t \\<turnstile>1 \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves1 P h es' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,\n                                   (h, xs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                  \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves1 P h es;\n     uf,P,t \\<turnstile>1 \\<langle>es',\n                           (h, xs')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                          \\<langle>es'',(h, xs'')\\<rangle>;\n     \\<tau>moves1 P h es'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es'', xs'')", "by(blast intro: tranclp.trancl_into_trancl[OF \\<tau>reds1t_1step])"], ["", "lemma \\<tau>reds1t_3step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es; \n     uf,P,t \\<turnstile>1 \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves1 P h es';\n     uf,P,t \\<turnstile>1 \\<langle>es'', (h, xs'')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es''', (h, xs''')\\<rangle>; \\<tau>moves1 P h es'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es''', xs''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,\n                                   (h, xs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                  \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves1 P h es;\n     uf,P,t \\<turnstile>1 \\<langle>es',\n                           (h, xs')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                          \\<langle>es'',(h, xs'')\\<rangle>;\n     \\<tau>moves1 P h es';\n     uf,P,t \\<turnstile>1 \\<langle>es'',\n                           (h, xs'')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                          \\<langle>es''',(h, xs''')\\<rangle>;\n     \\<tau>moves1 P h es''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds1gt uf P t h (es, xs) (es''', xs''')", "by(blast intro: tranclp.trancl_into_trancl[OF \\<tau>reds1t_2step])"], ["", "lemma \\<tau>red1r_1step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,\n                                   (h, xs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                  \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move1 P h e\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e', xs')", "by(blast intro: r_into_rtranclp)"], ["", "lemma \\<tau>red1r_2step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e; \n     uf,P,t \\<turnstile>1 \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move1 P h e' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,\n                                   (h, xs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                  \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move1 P h e;\n     uf,P,t \\<turnstile>1 \\<langle>e',\n                           (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                          \\<langle>e'',(h, xs'')\\<rangle>;\n     \\<tau>move1 P h e'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e'', xs'')", "by(blast intro: rtranclp.rtrancl_into_rtrancl[OF \\<tau>red1r_1step])"], ["", "lemma \\<tau>red1r_3step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move1 P h e; \n     uf,P,t \\<turnstile>1 \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move1 P h e';\n     uf,P,t \\<turnstile>1 \\<langle>e'', (h, xs'')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e''', (h, xs''')\\<rangle>; \\<tau>move1 P h e'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e''', xs''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,\n                                   (h, xs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                  \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move1 P h e;\n     uf,P,t \\<turnstile>1 \\<langle>e',\n                           (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                          \\<langle>e'',(h, xs'')\\<rangle>;\n     \\<tau>move1 P h e';\n     uf,P,t \\<turnstile>1 \\<langle>e'',\n                           (h, xs'')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                          \\<langle>e''',(h, xs''')\\<rangle>;\n     \\<tau>move1 P h e''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red1gr uf P t h (e, xs) (e''', xs''')", "by(blast intro: rtranclp.rtrancl_into_rtrancl[OF \\<tau>red1r_2step])"], ["", "lemma \\<tau>reds1r_1step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,\n                                   (h, xs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                  \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves1 P h es\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es', xs')", "by(blast intro: r_into_rtranclp)"], ["", "lemma \\<tau>reds1r_2step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es; \n     uf,P,t \\<turnstile>1 \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves1 P h es' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,\n                                   (h, xs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                  \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves1 P h es;\n     uf,P,t \\<turnstile>1 \\<langle>es',\n                           (h, xs')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                          \\<langle>es'',(h, xs'')\\<rangle>;\n     \\<tau>moves1 P h es'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es'', xs'')", "by(blast intro: rtranclp.rtrancl_into_rtrancl[OF \\<tau>reds1r_1step])"], ["", "lemma \\<tau>reds1r_3step:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves1 P h es; \n     uf,P,t \\<turnstile>1 \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves1 P h es';\n     uf,P,t \\<turnstile>1 \\<langle>es'', (h, xs'')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es''', (h, xs''')\\<rangle>; \\<tau>moves1 P h es'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es''', xs''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,\n                                   (h, xs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                  \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves1 P h es;\n     uf,P,t \\<turnstile>1 \\<langle>es',\n                           (h, xs')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                          \\<langle>es'',(h, xs'')\\<rangle>;\n     \\<tau>moves1 P h es';\n     uf,P,t \\<turnstile>1 \\<langle>es'',\n                           (h, xs'')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                          \\<langle>es''',(h, xs''')\\<rangle>;\n     \\<tau>moves1 P h es''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds1gr uf P t h (es, xs) (es''', xs''')", "by(blast intro: rtranclp.rtrancl_into_rtrancl[OF \\<tau>reds1r_2step])"], ["", "lemma \\<tau>red1t_preserves_len: \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> length xs' = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    length xs' = length xs", "by(induct rule: tranclp_induct2)(auto dest: red1_preserves_len)"], ["", "lemma \\<tau>red1r_preserves_len: \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> length xs' = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    length xs' = length xs", "by(induct rule: rtranclp_induct2)(auto dest: red1_preserves_len)"], ["", "lemma \\<tau>red1t_inj_\\<tau>reds1t: \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>reds1gt uf P t h (e # es, xs) (e' # es, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>reds1gt uf P t h (e # es, xs) (e' # es, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl List1Red1 \\<tau>moves1Hd)"], ["", "lemma \\<tau>reds1t_cons_\\<tau>reds1t: \"\\<tau>reds1gt uf P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>reds1gt uf P t h (Val v # es, xs) (Val v # es', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1gt uf P t h (es, xs) (es', xs') \\<Longrightarrow>\n    \\<tau>reds1gt uf P t h (Val v # es, xs) (Val v # es', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl List1Red2 \\<tau>moves1Tl)"], ["", "lemma \\<tau>red1r_inj_\\<tau>reds1r: \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>reds1gr uf P t h (e # es, xs) (e' # es, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>reds1gr uf P t h (e # es, xs) (e' # es, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl List1Red1 \\<tau>moves1Hd)"], ["", "lemma \\<tau>reds1r_cons_\\<tau>reds1r: \"\\<tau>reds1gr uf P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>reds1gr uf P t h (Val v # es, xs) (Val v # es', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1gr uf P t h (es, xs) (es', xs') \\<Longrightarrow>\n    \\<tau>reds1gr uf P t h (Val v # es, xs) (Val v # es', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl List1Red2 \\<tau>moves1Tl)"], ["", "lemma NewArray_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (newA T\\<lfloor>e\\<rceil>, xs) (newA T\\<lfloor>e'\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (newA T\\<lfloor>e\\<rceil>, xs)\n     (newA T\\<lfloor>e'\\<rceil>, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl New1ArrayRed \\<tau>move1NewArray)"], ["", "lemma Cast_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Cast T e, xs) (Cast T e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (Cast T e, xs) (Cast T e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Cast1Red \\<tau>move1Cast)"], ["", "lemma InstanceOf_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e instanceof T, xs) (e' instanceof T, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (e instanceof T, xs) (e' instanceof T, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl InstanceOf1Red \\<tau>move1InstanceOf)"], ["", "lemma BinOp_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (e1, xs) (e1', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs) (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e1, xs) (e1', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs)\n     (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Bin1OpRed1 \\<tau>move1BinOp1)"], ["", "lemma BinOp_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (e2, xs) (e2', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs) (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e2, xs) (e2', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h\n     (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs)\n     (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Bin1OpRed2 \\<tau>move1BinOp2)"], ["", "lemma LAss_\\<tau>red1t:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (V := e, xs) (V := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (V:=e, xs) (V:=e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl LAss1Red \\<tau>move1LAss)"], ["", "lemma AAcc_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (a\\<lfloor>i\\<rceil>, xs) (a'\\<lfloor>i\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (a\\<lfloor>i\\<rceil>, xs)\n     (a'\\<lfloor>i\\<rceil>, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAcc1Red1 \\<tau>move1AAcc1)"], ["", "lemma AAcc_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val a\\<lfloor>i\\<rceil>, xs) (Val a\\<lfloor>i'\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (i, xs) (i', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (Val a\\<lfloor>i\\<rceil>, xs)\n     (Val a\\<lfloor>i'\\<rceil>, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAcc1Red2 \\<tau>move1AAcc2)"], ["", "lemma AAss_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (a\\<lfloor>i\\<rceil> := e, xs) (a'\\<lfloor>i\\<rceil> := e, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (a\\<lfloor>i\\<rceil> := e, xs)\n     (a'\\<lfloor>i\\<rceil> := e, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAss1Red1 \\<tau>move1AAss1)"], ["", "lemma AAss_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val a\\<lfloor>i\\<rceil> := e, xs) (Val a\\<lfloor>i'\\<rceil> := e, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (i, xs) (i', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (Val a\\<lfloor>i\\<rceil> := e, xs)\n     (Val a\\<lfloor>i'\\<rceil> := e, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAss1Red2 \\<tau>move1AAss2)"], ["", "lemma AAss_\\<tau>red1t_xt3:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs) (Val a\\<lfloor>Val i\\<rceil> := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs)\n     (Val a\\<lfloor>Val i\\<rceil> := e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAss1Red3 \\<tau>move1AAss3)"], ["", "lemma ALength_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl ALength1Red \\<tau>move1ALength)"], ["", "lemma FAcc_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl FAcc1Red \\<tau>move1FAcc)"], ["", "lemma FAss_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e\\<bullet>F{D} := e2, xs) (e'\\<bullet>F{D} := e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (e\\<bullet>F{D} := e2, xs)\n     (e'\\<bullet>F{D} := e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl FAss1Red1 \\<tau>move1FAss1)"], ["", "lemma FAss_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v\\<bullet>F{D} := e, xs) (Val v\\<bullet>F{D} := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (Val v\\<bullet>F{D} := e, xs)\n     (Val v\\<bullet>F{D} := e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl FAss1Red2 \\<tau>move1FAss2)"], ["", "lemma CAS_\\<tau>red1t_xt1:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs) (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h\n     (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs)\n     (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CAS1Red1)"], ["", "lemma CAS_\\<tau>red1t_xt2:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs)\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CAS1Red2)"], ["", "lemma CAS_\\<tau>red1t_xt3:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs)\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CAS1Red3)"], ["", "lemma Call_\\<tau>red1t_obj:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Call1Obj \\<tau>move1CallObj)"], ["", "lemma Call_\\<tau>red1t_param:\n  \"\\<tau>reds1gt uf P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v\\<bullet>M(es), xs) (Val v\\<bullet>M(es'), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1gt uf P t h (es, xs) (es', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (Val v\\<bullet>M(es), xs)\n     (Val v\\<bullet>M(es'), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Call1Params \\<tau>move1CallParams)"], ["", "lemma Block_None_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h ({V:T=None; e}, xs) ({V:T=None; e'}, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h ({V:T=None; e}, xs) ({V:T=None; e'}, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl \\<tau>move1Block elim!: Block1Red)"], ["", "lemma Block_\\<tau>red1t_Some:\n  \"\\<lbrakk> \\<tau>red1gt uf P t h (e, xs[V := v]) (e', xs'); V < length xs \\<rbrakk> \n  \\<Longrightarrow> \\<tau>red1gt uf P t h ({V:Ty=\\<lfloor>v\\<rfloor>; e}, xs) ({V:Ty=None; e'}, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>red1gt uf P t h (e, xs[V := v]) (e', xs');\n     V < length xs\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red1gt uf P t h\n                       ({V:Ty=\\<lfloor>v\\<rfloor>; e}, xs)\n                       ({V:Ty=None; e'}, xs')", "by(blast intro: tranclp_into_tranclp2 Block1Some \\<tau>move1BlockSome Block_None_\\<tau>red1t_xt)"], ["", "lemma Sync_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs) (sync\\<^bsub>V\\<^esub> (e') e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs)\n     (sync\\<^bsub>V\\<^esub> (e') e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Synchronized1Red1 \\<tau>move1Sync)"], ["", "lemma InSync_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (insync\\<^bsub>V\\<^esub> (a) e, xs) (insync\\<^bsub>V\\<^esub> (a) e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (insync\\<^bsub>V\\<^esub> (a) e, xs)\n     (insync\\<^bsub>V\\<^esub> (a) e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Synchronized1Red2 \\<tau>move1InSync)"], ["", "lemma Seq_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (e;;e2, xs) (e';;e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (e;; e2, xs) (e';; e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Seq1Red \\<tau>move1Seq)"], ["", "lemma Cond_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Cond1Red \\<tau>move1Cond)"], ["", "lemma Throw_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (throw e, xs) (throw e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (throw e, xs) (throw e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Throw1Red \\<tau>move1Throw)"], ["", "lemma Try_\\<tau>red1t_xt:\n  \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gt uf P t h (try e catch(C V) e2, xs) (try e' catch(C V) e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gt uf P t h (try e catch(C V) e2, xs)\n     (try e' catch(C V) e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl Try1Red \\<tau>move1Try)"], ["", "lemma NewArray_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (newA T\\<lfloor>e\\<rceil>, xs) (newA T\\<lfloor>e'\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (newA T\\<lfloor>e\\<rceil>, xs)\n     (newA T\\<lfloor>e'\\<rceil>, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl New1ArrayRed \\<tau>move1NewArray)"], ["", "lemma Cast_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Cast T e, xs) (Cast T e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Cast T e, xs) (Cast T e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Cast1Red \\<tau>move1Cast)"], ["", "lemma InstanceOf_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e instanceof T, xs) (e' instanceof T, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (e instanceof T, xs) (e' instanceof T, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl InstanceOf1Red \\<tau>move1InstanceOf)"], ["", "lemma BinOp_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (e1, xs) (e1', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs) (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e1, xs) (e1', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs)\n     (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Bin1OpRed1 \\<tau>move1BinOp1)"], ["", "lemma BinOp_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (e2, xs) (e2', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs) (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e2, xs) (e2', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h\n     (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs)\n     (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Bin1OpRed2 \\<tau>move1BinOp2)"], ["", "lemma LAss_\\<tau>red1r:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (V := e, xs) (V := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (V:=e, xs) (V:=e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl LAss1Red \\<tau>move1LAss)"], ["", "lemma AAcc_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (a\\<lfloor>i\\<rceil>, xs) (a'\\<lfloor>i\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (a\\<lfloor>i\\<rceil>, xs)\n     (a'\\<lfloor>i\\<rceil>, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAcc1Red1 \\<tau>move1AAcc1)"], ["", "lemma AAcc_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val a\\<lfloor>i\\<rceil>, xs) (Val a\\<lfloor>i'\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (i, xs) (i', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Val a\\<lfloor>i\\<rceil>, xs)\n     (Val a\\<lfloor>i'\\<rceil>, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAcc1Red2 \\<tau>move1AAcc2)"], ["", "lemma AAss_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (a\\<lfloor>i\\<rceil> := e, xs) (a'\\<lfloor>i\\<rceil> := e, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (a\\<lfloor>i\\<rceil> := e, xs)\n     (a'\\<lfloor>i\\<rceil> := e, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAss1Red1 \\<tau>move1AAss1)"], ["", "lemma AAss_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val a\\<lfloor>i\\<rceil> := e, xs) (Val a\\<lfloor>i'\\<rceil> := e, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (i, xs) (i', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Val a\\<lfloor>i\\<rceil> := e, xs)\n     (Val a\\<lfloor>i'\\<rceil> := e, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAss1Red2 \\<tau>move1AAss2)"], ["", "lemma AAss_\\<tau>red1r_xt3:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs) (Val a\\<lfloor>Val i\\<rceil> := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs)\n     (Val a\\<lfloor>Val i\\<rceil> := e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAss1Red3 \\<tau>move1AAss3)"], ["", "lemma ALength_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl ALength1Red \\<tau>move1ALength)"], ["", "lemma FAcc_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl FAcc1Red \\<tau>move1FAcc)"], ["", "lemma FAss_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e\\<bullet>F{D} := e2, xs) (e'\\<bullet>F{D} := e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (e\\<bullet>F{D} := e2, xs)\n     (e'\\<bullet>F{D} := e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl FAss1Red1 \\<tau>move1FAss1)"], ["", "lemma FAss_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v\\<bullet>F{D} := e, xs) (Val v\\<bullet>F{D} := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Val v\\<bullet>F{D} := e, xs)\n     (Val v\\<bullet>F{D} := e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl FAss1Red2 \\<tau>move1FAss2)"], ["", "lemma CAS_\\<tau>red1r_xt1:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs) (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h\n     (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs)\n     (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CAS1Red1)"], ["", "lemma CAS_\\<tau>red1r_xt2:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs)\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CAS1Red2)"], ["", "lemma CAS_\\<tau>red1r_xt3:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs)\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CAS1Red3)"], ["", "lemma Call_\\<tau>red1r_obj:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Call1Obj \\<tau>move1CallObj)"], ["", "lemma Call_\\<tau>red1r_param:\n  \"\\<tau>reds1gr uf P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v\\<bullet>M(es), xs) (Val v\\<bullet>M(es'), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1gr uf P t h (es, xs) (es', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Val v\\<bullet>M(es), xs)\n     (Val v\\<bullet>M(es'), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Call1Params \\<tau>move1CallParams)"], ["", "lemma Block_None_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h ({V:T=None; e}, xs) ({V:T=None; e'}, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h ({V:T=None; e}, xs) ({V:T=None; e'}, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl \\<tau>move1Block elim!: Block1Red)"], ["", "lemma Block_\\<tau>red1r_Some:\n  \"\\<lbrakk> \\<tau>red1gr uf P t h (e, xs[V := v]) (e', xs'); V < length xs \\<rbrakk> \n  \\<Longrightarrow> \\<tau>red1gr uf P t h ({V:Ty=\\<lfloor>v\\<rfloor>; e}, xs) ({V:Ty=None; e'}, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>red1gr uf P t h (e, xs[V := v]) (e', xs');\n     V < length xs\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red1gr uf P t h\n                       ({V:Ty=\\<lfloor>v\\<rfloor>; e}, xs)\n                       ({V:Ty=None; e'}, xs')", "by(blast intro: converse_rtranclp_into_rtranclp Block1Some \\<tau>move1BlockSome Block_None_\\<tau>red1r_xt)"], ["", "lemma Sync_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs) (sync\\<^bsub>V\\<^esub> (e') e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs)\n     (sync\\<^bsub>V\\<^esub> (e') e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Synchronized1Red1 \\<tau>move1Sync)"], ["", "lemma InSync_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (insync\\<^bsub>V\\<^esub> (a) e, xs) (insync\\<^bsub>V\\<^esub> (a) e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (insync\\<^bsub>V\\<^esub> (a) e, xs)\n     (insync\\<^bsub>V\\<^esub> (a) e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Synchronized1Red2 \\<tau>move1InSync)"], ["", "lemma Seq_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (e;;e2, xs) (e';;e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (e;; e2, xs) (e';; e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Seq1Red \\<tau>move1Seq)"], ["", "lemma Cond_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Cond1Red \\<tau>move1Cond)"], ["", "lemma Throw_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (throw e, xs) (throw e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (throw e, xs) (throw e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Throw1Red \\<tau>move1Throw)"], ["", "lemma Try_\\<tau>red1r_xt:\n  \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red1gr uf P t h (try e catch(C V) e2, xs) (try e' catch(C V) e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (try e catch(C V) e2, xs)\n     (try e' catch(C V) e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl Try1Red \\<tau>move1Try)"], ["", "lemma \\<tau>red1t_ThrowD [dest]: \"\\<tau>red1gt uf P t h (Throw a, xs) (e'', xs'') \\<Longrightarrow> e'' = Throw a \\<and> xs'' = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (Throw a, xs) (e'', xs'') \\<Longrightarrow>\n    e'' = Throw a \\<and> xs'' = xs", "by(induct rule: tranclp_induct2)(auto)"], ["", "lemma \\<tau>red1r_ThrowD [dest]: \"\\<tau>red1gr uf P t h (Throw a, xs) (e'', xs'') \\<Longrightarrow> e'' = Throw a \\<and> xs'' = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (Throw a, xs) (e'', xs'') \\<Longrightarrow>\n    e'' = Throw a \\<and> xs'' = xs", "by(induct rule: rtranclp_induct2)(auto)"], ["", "lemma \\<tau>Red1_conv [iff]:\n  \"\\<tau>Red1g uf P t h (ex, exs) (ex', exs') = (uf,P,t \\<turnstile>1 \\<langle>ex/exs, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>ex'/exs', h\\<rangle> \\<and> \\<tau>Move1 P h (ex, exs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red1g uf P t h (ex, exs) (ex', exs') =\n    (uf,P,t \\<turnstile>1 \\<langle>ex/exs,\n                           h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                          \\<langle>ex'/exs',h\\<rangle> \\<and>\n     \\<tau>Move1 P h (ex, exs))", "by(simp add: \\<tau>Red1g_def)"], ["", "lemma \\<tau>red1t_into_\\<tau>Red1t:\n  \"\\<tau>red1gt uf P t h (e, xs) (e'', xs'') \\<Longrightarrow> \\<tau>Red1gt uf P t h ((e, xs), exs) ((e'', xs''), exs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e'', xs'') \\<Longrightarrow>\n    \\<tau>Red1gt uf P t h ((e, xs), exs) ((e'', xs''), exs)", "by(induct rule: tranclp_induct2)(fastforce dest: red1Red intro: \\<tau>move1Block tranclp.intros)+"], ["", "lemma \\<tau>red1r_into_\\<tau>Red1r:\n  \"\\<tau>red1gr uf P t h (e, xs) (e'', xs'') \\<Longrightarrow> \\<tau>Red1gr uf P t h ((e, xs), exs) ((e'', xs''), exs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e'', xs'') \\<Longrightarrow>\n    \\<tau>Red1gr uf P t h ((e, xs), exs) ((e'', xs''), exs)", "by(induct rule: rtranclp_induct2)(fastforce dest: red1Red intro: \\<tau>move1Block rtranclp.intros)+"], ["", "lemma red1_max_vars: \"uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> max_vars e' \\<le> max_vars e\"\n  and reds1_max_varss: \"uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> max_varss es' \\<le> max_varss es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     max_vars e' \\<le> max_vars e) &&&\n    (uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                          \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     max_varss es' \\<le> max_varss es)", "by(induct rule: red1_reds1.inducts) auto"], ["", "lemma \\<tau>red1t_max_vars: \"\\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow> max_vars e' \\<le> max_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    max_vars e' \\<le> max_vars e", "by(induct rule: tranclp_induct2)(auto dest: red1_max_vars)"], ["", "lemma \\<tau>red1r_max_vars: \"\\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow> max_vars e' \\<le> max_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (e, xs) (e', xs') \\<Longrightarrow>\n    max_vars e' \\<le> max_vars e", "by(induct rule: rtranclp_induct2)(auto dest: red1_max_vars)"], ["", "lemma \\<tau>red1r_Val:\n  \"\\<tau>red1gr uf P t h (Val v, xs) s' \\<longleftrightarrow> s' = (Val v, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (Val v, xs) s' = (s' = (Val v, xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>red1gr uf P t h (Val v, xs) s' \\<Longrightarrow> s' = (Val v, xs)\n 2. s' = (Val v, xs) \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v, xs) s'", "assume \"\\<tau>red1gr uf P t h (Val v, xs) s'\""], ["proof (state)\nthis:\n  \\<tau>red1gr uf P t h (Val v, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>red1gr uf P t h (Val v, xs) s' \\<Longrightarrow> s' = (Val v, xs)\n 2. s' = (Val v, xs) \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v, xs) s'", "thus \"s' = (Val v, xs)\""], ["proof (prove)\nusing this:\n  \\<tau>red1gr uf P t h (Val v, xs) s'\n\ngoal (1 subgoal):\n 1. s' = (Val v, xs)", "by induct(auto)"], ["proof (state)\nthis:\n  s' = (Val v, xs)\n\ngoal (1 subgoal):\n 1. s' = (Val v, xs) \\<Longrightarrow> \\<tau>red1gr uf P t h (Val v, xs) s'", "qed auto"], ["", "lemma \\<tau>red1t_Val:\n  \"\\<tau>red1gt uf P t h (Val v, xs) s' \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (Val v, xs) s' = False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>red1gt uf P t h (Val v, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v, xs) s'", "assume \"\\<tau>red1gt uf P t h (Val v, xs) s'\""], ["proof (state)\nthis:\n  \\<tau>red1gt uf P t h (Val v, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>red1gt uf P t h (Val v, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v, xs) s'", "thus False"], ["proof (prove)\nusing this:\n  \\<tau>red1gt uf P t h (Val v, xs) s'\n\ngoal (1 subgoal):\n 1. False", "by induct auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False \\<Longrightarrow> \\<tau>red1gt uf P t h (Val v, xs) s'", "qed auto"], ["", "lemma \\<tau>reds1r_map_Val:\n  \"\\<tau>reds1gr uf P t h (map Val vs, xs) s' \\<longleftrightarrow> s' = (map Val vs, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1gr uf P t h (map Val vs, xs) s' = (s' = (map Val vs, xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>reds1gr uf P t h (map Val vs, xs) s' \\<Longrightarrow>\n    s' = (map Val vs, xs)\n 2. s' = (map Val vs, xs) \\<Longrightarrow>\n    \\<tau>reds1gr uf P t h (map Val vs, xs) s'", "assume \"\\<tau>reds1gr uf P t h (map Val vs, xs) s'\""], ["proof (state)\nthis:\n  \\<tau>reds1gr uf P t h (map Val vs, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>reds1gr uf P t h (map Val vs, xs) s' \\<Longrightarrow>\n    s' = (map Val vs, xs)\n 2. s' = (map Val vs, xs) \\<Longrightarrow>\n    \\<tau>reds1gr uf P t h (map Val vs, xs) s'", "thus \"s' = (map Val vs, xs)\""], ["proof (prove)\nusing this:\n  \\<tau>reds1gr uf P t h (map Val vs, xs) s'\n\ngoal (1 subgoal):\n 1. s' = (map Val vs, xs)", "by induct auto"], ["proof (state)\nthis:\n  s' = (map Val vs, xs)\n\ngoal (1 subgoal):\n 1. s' = (map Val vs, xs) \\<Longrightarrow>\n    \\<tau>reds1gr uf P t h (map Val vs, xs) s'", "qed auto"], ["", "lemma \\<tau>reds1t_map_Val:\n  \"\\<tau>reds1gt uf P t h (map Val vs, xs) s' \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1gt uf P t h (map Val vs, xs) s' = False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>reds1gt uf P t h (map Val vs, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>reds1gt uf P t h (map Val vs, xs) s'", "assume \"\\<tau>reds1gt uf P t h (map Val vs, xs) s'\""], ["proof (state)\nthis:\n  \\<tau>reds1gt uf P t h (map Val vs, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>reds1gt uf P t h (map Val vs, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>reds1gt uf P t h (map Val vs, xs) s'", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<tau>reds1gt uf P t h (map Val vs, xs) s'\n\ngoal (1 subgoal):\n 1. False", "by induct auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False \\<Longrightarrow> \\<tau>reds1gt uf P t h (map Val vs, xs) s'", "qed auto"], ["", "lemma \\<tau>reds1r_map_Val_Throw:\n  \"\\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs) s' \\<longleftrightarrow> s' = (map Val vs @ Throw a # es, xs)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs) s' =\n    (s' = (map Val vs @ Throw a # es, xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs)\n     s' \\<Longrightarrow>\n    s' = (map Val vs @ Throw a # es, xs)\n 2. s' = (map Val vs @ Throw a # es, xs) \\<Longrightarrow>\n    \\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs) s'", "assume ?lhs"], ["proof (state)\nthis:\n  \\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs)\n     s' \\<Longrightarrow>\n    s' = (map Val vs @ Throw a # es, xs)\n 2. s' = (map Val vs @ Throw a # es, xs) \\<Longrightarrow>\n    \\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs) s'", "thus ?rhs"], ["proof (prove)\nusing this:\n  \\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs) s'\n\ngoal (1 subgoal):\n 1. s' = (map Val vs @ Throw a # es, xs)", "by induct auto"], ["proof (state)\nthis:\n  s' = (map Val vs @ Throw a # es, xs)\n\ngoal (1 subgoal):\n 1. s' = (map Val vs @ Throw a # es, xs) \\<Longrightarrow>\n    \\<tau>reds1gr uf P t h (map Val vs @ Throw a # es, xs) s'", "qed auto"], ["", "lemma \\<tau>reds1t_map_Val_Throw:\n  \"\\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs) s' \\<longleftrightarrow> False\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs) s' = False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs)\n     s' \\<Longrightarrow>\n    False\n 2. False \\<Longrightarrow>\n    \\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs) s'", "assume ?lhs"], ["proof (state)\nthis:\n  \\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs)\n     s' \\<Longrightarrow>\n    False\n 2. False \\<Longrightarrow>\n    \\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs) s'", "thus ?rhs"], ["proof (prove)\nusing this:\n  \\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs) s'\n\ngoal (1 subgoal):\n 1. False", "by induct auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False \\<Longrightarrow>\n    \\<tau>reds1gt uf P t h (map Val vs @ Throw a # es, xs) s'", "qed auto"], ["", "lemma \\<tau>red1r_Throw:\n  \"\\<tau>red1gr uf P t h (Throw a, xs) s' \\<longleftrightarrow> s' = (Throw a, xs)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gr uf P t h (Throw a, xs) s' = (s' = (Throw a, xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>red1gr uf P t h (Throw a, xs) s' \\<Longrightarrow>\n    s' = (Throw a, xs)\n 2. s' = (Throw a, xs) \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Throw a, xs) s'", "assume ?lhs"], ["proof (state)\nthis:\n  \\<tau>red1gr uf P t h (Throw a, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>red1gr uf P t h (Throw a, xs) s' \\<Longrightarrow>\n    s' = (Throw a, xs)\n 2. s' = (Throw a, xs) \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Throw a, xs) s'", "thus ?rhs"], ["proof (prove)\nusing this:\n  \\<tau>red1gr uf P t h (Throw a, xs) s'\n\ngoal (1 subgoal):\n 1. s' = (Throw a, xs)", "by induct auto"], ["proof (state)\nthis:\n  s' = (Throw a, xs)\n\ngoal (1 subgoal):\n 1. s' = (Throw a, xs) \\<Longrightarrow>\n    \\<tau>red1gr uf P t h (Throw a, xs) s'", "qed simp"], ["", "lemma \\<tau>red1t_Throw:\n  \"\\<tau>red1gt uf P t h (Throw a, xs) s' \\<longleftrightarrow> False\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red1gt uf P t h (Throw a, xs) s' = False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>red1gt uf P t h (Throw a, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>red1gt uf P t h (Throw a, xs) s'", "assume ?lhs"], ["proof (state)\nthis:\n  \\<tau>red1gt uf P t h (Throw a, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>red1gt uf P t h (Throw a, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>red1gt uf P t h (Throw a, xs) s'", "thus ?rhs"], ["proof (prove)\nusing this:\n  \\<tau>red1gt uf P t h (Throw a, xs) s'\n\ngoal (1 subgoal):\n 1. False", "by induct auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False \\<Longrightarrow> \\<tau>red1gt uf P t h (Throw a, xs) s'", "qed simp"], ["", "lemma red1_False_into_red1_True:\n  \"False,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> True,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>\"\n  and reds1_False_into_reds1_True:\n  \"False,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> True,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (False,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     True,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>e',s'\\<rangle>) &&&\n    (False,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                             \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     True,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                            \\<langle>es',s'\\<rangle>)", "by (induct rule: red1_reds1.inducts) (auto intro: red1_reds1.intros)"], ["", "lemma Red1_False_into_Red1_True:\n  assumes \"False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\"\n  shows \"True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow> \\<langle>ex'/exs',m'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                           \\<langle>ex'/exs',m'\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  False,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                          \\<langle>ex'/exs',m'\\<rangle>\n\ngoal (1 subgoal):\n 1. True,P,t \\<turnstile>1 \\<langle>ex/exs,shr s\\<rangle> -ta\\<rightarrow>\n                           \\<langle>ex'/exs',m'\\<rangle>", "by(cases)(auto dest: Red1.intros red1_False_into_red1_True)"], ["", "lemma red1_Suspend_is_call:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> call1 e' \\<noteq> None\"\n  and reds_Suspend_is_calls:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> calls1 es' \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> call1 e' \\<noteq> None) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n     \\<Longrightarrow> calls1 es' \\<noteq> None)", "by(induct rule: red1_reds1.inducts)(auto dest: red_external_Suspend_StaySame)"], ["", "lemma Red1_Suspend_is_call:\n  \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>(e, xs)/exs, h\\<rangle> -ta\\<rightarrow> \\<langle>(e', xs')/exs', h'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> call1 e' \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>(e, xs)/exs,\n                                   h\\<rangle> -ta\\<rightarrow>\n                                  \\<langle>(e', xs')/exs',h'\\<rangle>;\n     Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> call1 e' \\<noteq> None", "by(auto elim!: Red1.cases dest: red1_Suspend_is_call)"], ["", "lemma Red1_mthr: \"multithreaded final_expr1 (mred1g uf P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded final_expr1 (mred1g uf P)", "by(unfold_locales)(fastforce elim!: Red1.cases dest: red1_new_thread_heap)+"], ["", "lemma red1_\\<tau>move1_heap_unchanged: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move1 P (hp s) e \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"\n  and red1_\\<tau>moves1_heap_unchanged: \"\\<lbrakk> uf,P,t \\<turnstile>1 \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves1 P (hp s) es \\<rbrakk> \\<Longrightarrow> hp s' = hp s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                   \\<langle>e',s'\\<rangle>;\n      \\<tau>move1 P (hp s) e\\<rbrakk>\n     \\<Longrightarrow> hp s' = hp s) &&&\n    (\\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                                   \\<langle>es',s'\\<rangle>;\n      \\<tau>moves1 P (hp s) es\\<rbrakk>\n     \\<Longrightarrow> hp s' = hp s)", "apply(induct rule: red1_reds1.inducts)"], ["proof (prove)\ngoal (102 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<tau>move1 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> hp (h', l) = hp (h, l)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<tau>move1 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> hp (h, l) = hp (h, l)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<tau>move1 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n        \\<tau>move1 P (hp s) (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp s' = hp s\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<tau>move1 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp (h', l) = hp (h, l)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<tau>move1 P (hp s) (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<tau>move1 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp (h, l) = hp (h, l)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n        \\<tau>move1 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n        \\<tau>move1 P (hp s) (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> hp s' = hp s\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<tau>move1 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<tau>move1 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n\\<langle>e',s'\\<rangle>;\n         \\<tau>move1 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n         \\<tau>move1 P (hp s) (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> hp s' = hp s\nA total of 102 subgoals...", "apply(fastforce simp add: map_eq_append_conv \\<tau>external'_def \\<tau>external_def dest: \\<tau>external'_red_external_heap_unchanged)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Red1_\\<tau>mthr_wf: \"\\<tau>multithreaded_wf final_expr1 (mred1g uf P) (\\<tau>MOVE1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr1 (mred1g uf P)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr1 (mred1g uf P)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)", "interpret multithreaded final_expr1 \"mred1g uf P\" convert_RA"], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded final_expr1 (mred1g uf P)", "by(rule Red1_mthr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr1 (mred1g uf P)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr1 (mred1g uf P)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>r_syntax t x m ta x' m';\n        (case (x, m) of\n         (exexs, h) \\<Rightarrow>\n           \\<lambda>ta s.\n              \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (exexs, h) \\<Rightarrow>\n          \\<lambda>ta s.\n             \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "fix x1 m1 t ta1 x1' m1'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>r_syntax t x m ta x' m';\n        (case (x, m) of\n         (exexs, h) \\<Rightarrow>\n           \\<lambda>ta s.\n              \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (exexs, h) \\<Rightarrow>\n          \\<lambda>ta s.\n             \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "assume \"mred1g uf P t (x1, m1) ta1 (x1', m1')\" \"\\<tau>MOVE1 P (x1, m1) ta1 (x1', m1')\""], ["proof (state)\nthis:\n  r_syntax t x1 m1 ta1 x1' m1'\n  (case (x1, m1) of\n   (exexs, h) \\<Rightarrow>\n     \\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n   ta1 (x1', m1')\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>r_syntax t x m ta x' m';\n        (case (x, m) of\n         (exexs, h) \\<Rightarrow>\n           \\<lambda>ta s.\n              \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (exexs, h) \\<Rightarrow>\n          \\<lambda>ta s.\n             \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "thus \"m1 = m1'\""], ["proof (prove)\nusing this:\n  r_syntax t x1 m1 ta1 x1' m1'\n  (case (x1, m1) of\n   (exexs, h) \\<Rightarrow>\n     \\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n   ta1 (x1', m1')\n\ngoal (1 subgoal):\n 1. m1 = m1'", "by(cases x1)(fastforce elim!: Red1.cases dest: red1_\\<tau>move1_heap_unchanged)"], ["proof (state)\nthis:\n  m1 = m1'\n\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (exexs, h) \\<Rightarrow>\n          \\<lambda>ta s.\n             \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (exexs, h) \\<Rightarrow>\n          \\<lambda>ta s.\n             \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "fix s ta s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (exexs, h) \\<Rightarrow>\n          \\<lambda>ta s.\n             \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "assume \"\\<tau>MOVE1 P s ta s'\""], ["proof (state)\nthis:\n  (case s of\n   (exexs, h) \\<Rightarrow>\n     \\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n   ta s'\n\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (exexs, h) \\<Rightarrow>\n          \\<lambda>ta s.\n             \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "thus \"ta = \\<epsilon>\""], ["proof (prove)\nusing this:\n  (case s of\n   (exexs, h) \\<Rightarrow>\n     \\<lambda>ta s. \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n   ta s'\n\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "by(simp add: split_beta)"], ["proof (state)\nthis:\n  ta = \\<lbrace>\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>multithreaded_wf final_expr1 (mred1g uf P)\n   (\\<lambda>(exexs, h) ta s.\n       \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale J1_heap_base < Red1_mthr: \n  \\<tau>multithreaded_wf \n    final_expr1\n    \"mred1g uf P\"\n    convert_RA\n    \"\\<tau>MOVE1 P\"\n  for uf P"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr1 (mred1g uf P)\n     (\\<lambda>(exexs, h) ta s.\n         \\<tau>Move1 P h exexs \\<and> ta = \\<lbrace>\\<rbrace>)", "by(rule Red1_\\<tau>mthr_wf)"], ["", "context J1_heap_base begin"], ["", "lemma \\<tau>Red1't_into_Red1'_\\<tau>mthr_silent_movet:\n  \"\\<tau>Red1gt uf P t h (ex2, exs2) (ex2'', exs2'')\n  \\<Longrightarrow> Red1_mthr.silent_movet uf P t ((ex2, exs2), h) ((ex2'', exs2''), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red1gt uf P t h (ex2, exs2) (ex2'', exs2'') \\<Longrightarrow>\n    Red1_mthr.silent_movet uf P t ((ex2, exs2), h) ((ex2'', exs2''), h)", "apply(induct rule: tranclp_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<tau>Red1g uf P t h (ex2, exs2) (a, b) \\<Longrightarrow>\n       Red1_mthr.silent_movet uf P t ((ex2, exs2), h) ((a, b), h)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red1gt uf P t h (ex2, exs2) (a, b);\n        \\<tau>Red1g uf P t h (a, b) (aa, ba);\n        Red1_mthr.silent_movet uf P t ((ex2, exs2), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_movet uf P t ((ex2, exs2), h)\n                          ((aa, ba), h)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>ex2/exs2,\nh\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                     \\<langle>(a, b)/ba,h\\<rangle>;\n        \\<tau>Move1 P h (ex2, exs2)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_movet uf P t ((ex2, exs2), h)\n                          (((a, b), ba), h)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red1gt uf P t h (ex2, exs2) (a, b);\n        \\<tau>Red1g uf P t h (a, b) (aa, ba);\n        Red1_mthr.silent_movet uf P t ((ex2, exs2), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_movet uf P t ((ex2, exs2), h)\n                          ((aa, ba), h)", "apply(rule tranclp.r_into_trancl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>uf,P,t \\<turnstile>1 \\<langle>ex2/exs2,\nh\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                     \\<langle>(a, b)/ba,h\\<rangle>;\n        \\<tau>Move1 P h (ex2, exs2)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_move uf P t ((ex2, exs2), h)\n                          (((a, b), ba), h)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red1gt uf P t h (ex2, exs2) (a, b);\n        \\<tau>Red1g uf P t h (a, b) (aa, ba);\n        Red1_mthr.silent_movet uf P t ((ex2, exs2), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_movet uf P t ((ex2, exs2), h)\n                          ((aa, ba), h)", "apply(simp add: Red1_mthr.silent_move_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red1gt uf P t h (ex2, exs2) (a, b);\n        \\<tau>Red1g uf P t h (a, b) (aa, ba);\n        Red1_mthr.silent_movet uf P t ((ex2, exs2), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_movet uf P t ((ex2, exs2), h)\n                          ((aa, ba), h)", "apply(erule tranclp.trancl_into_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red1gt uf P t h (ex2, exs2) (a, b);\n        \\<tau>Red1g uf P t h (a, b) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_move uf P t ((a, b), h)\n                          ((aa, ba), h)", "apply(simp add: Red1_mthr.silent_move_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Red1t_into_Red1'_\\<tau>mthr_silent_moves:\n  \"\\<tau>Red1gt uf P t h (ex2, exs2) (ex2'', exs2'')\n  \\<Longrightarrow> Red1_mthr.silent_moves uf P t ((ex2, exs2), h) ((ex2'', exs2''), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red1gt uf P t h (ex2, exs2) (ex2'', exs2'') \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t ((ex2, exs2), h) ((ex2'', exs2''), h)", "by(rule tranclp_into_rtranclp)(rule \\<tau>Red1't_into_Red1'_\\<tau>mthr_silent_movet)"], ["", "lemma \\<tau>Red1'r_into_Red1'_\\<tau>mthr_silent_moves:\n  \"\\<tau>Red1gr uf P t h (ex, exs) (ex', exs') \\<Longrightarrow> Red1_mthr.silent_moves uf P t ((ex, exs), h) ((ex', exs'), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red1gr uf P t h (ex, exs) (ex', exs') \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t ((ex, exs), h) ((ex', exs'), h)", "apply(induct rule: rtranclp_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Red1_mthr.silent_moves uf P t ((ex, exs), h) ((ex, exs), h)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red1gr uf P t h (ex, exs) (a, b);\n        \\<tau>Red1g uf P t h (a, b) (aa, ba);\n        Red1_mthr.silent_moves uf P t ((ex, exs), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_moves uf P t ((ex, exs), h)\n                          ((aa, ba), h)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red1gr uf P t h (ex, exs) (a, b);\n        \\<tau>Red1g uf P t h (a, b) (aa, ba);\n        Red1_mthr.silent_moves uf P t ((ex, exs), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_moves uf P t ((ex, exs), h)\n                          ((aa, ba), h)", "apply(erule rtranclp.rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red1gr uf P t h (ex, exs) (a, b);\n        \\<tau>Red1g uf P t h (a, b) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_move uf P t ((a, b), h)\n                          ((aa, ba), h)", "apply(simp add: Red1_mthr.silent_move_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Red1r_rtranclpD:\n  \"\\<tau>Red1gr uf P t h s s' \\<Longrightarrow> \\<tau>trsys.silent_moves (mred1g uf P t) (\\<tau>MOVE1 P) (s, h) (s', h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red1gr uf P t h s s' \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t (s, h) (s', h)", "apply(induct rule: rtranclp_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Red1_mthr.silent_moves uf P t (s, h) (s, h)\n 2. \\<And>y z.\n       \\<lbrakk>\\<tau>Red1gr uf P t h s y; \\<tau>Red1g uf P t h y z;\n        Red1_mthr.silent_moves uf P t (s, h) (y, h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_moves uf P t (s, h) (z, h)", "apply(auto elim!: rtranclp.rtrancl_into_rtrancl intro: \\<tau>trsys.silent_move.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Red1t_tranclpD:\n  \"\\<tau>Red1gt uf P t h s s' \\<Longrightarrow> \\<tau>trsys.silent_movet (mred1g uf P t) (\\<tau>MOVE1 P) (s, h) (s', h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red1gt uf P t h s s' \\<Longrightarrow>\n    Red1_mthr.silent_movet uf P t (s, h) (s', h)", "apply(induct rule: tranclp_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<tau>Red1g uf P t h s y \\<Longrightarrow>\n       Red1_mthr.silent_movet uf P t (s, h) (y, h)\n 2. \\<And>y z.\n       \\<lbrakk>\\<tau>Red1gt uf P t h s y; \\<tau>Red1g uf P t h y z;\n        Red1_mthr.silent_movet uf P t (s, h) (y, h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_movet uf P t (s, h) (z, h)", "apply(rule tranclp.r_into_trancl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<tau>Red1g uf P t h s y \\<Longrightarrow>\n       Red1_mthr.silent_move uf P t (s, h) (y, h)\n 2. \\<And>y z.\n       \\<lbrakk>\\<tau>Red1gt uf P t h s y; \\<tau>Red1g uf P t h y z;\n        Red1_mthr.silent_movet uf P t (s, h) (y, h)\\<rbrakk>\n       \\<Longrightarrow> Red1_mthr.silent_movet uf P t (s, h) (z, h)", "apply(auto elim!: tranclp.trancl_into_trancl intro!: \\<tau>trsys.silent_move.intros simp: \\<tau>Red1g_def split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>mreds1_Val_Nil: \"\\<tau>trsys.silent_moves (mred1g uf P t) (\\<tau>MOVE1 P) (((Val v, xs), []), h) s \\<longleftrightarrow> s = (((Val v, xs), []), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.silent_moves uf P t (((Val v, xs), []), h) s =\n    (s = (((Val v, xs), []), h))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Red1_mthr.silent_moves uf P t (((Val v, xs), []), h) s \\<Longrightarrow>\n    s = (((Val v, xs), []), h)\n 2. s = (((Val v, xs), []), h) \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t (((Val v, xs), []), h) s", "assume \"\\<tau>trsys.silent_moves (mred1g uf P t) (\\<tau>MOVE1 P) (((Val v, xs), []), h) s\""], ["proof (state)\nthis:\n  Red1_mthr.silent_moves uf P t (((Val v, xs), []), h) s\n\ngoal (2 subgoals):\n 1. Red1_mthr.silent_moves uf P t (((Val v, xs), []), h) s \\<Longrightarrow>\n    s = (((Val v, xs), []), h)\n 2. s = (((Val v, xs), []), h) \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t (((Val v, xs), []), h) s", "thus \"s = (((Val v, xs), []), h)\""], ["proof (prove)\nusing this:\n  Red1_mthr.silent_moves uf P t (((Val v, xs), []), h) s\n\ngoal (1 subgoal):\n 1. s = (((Val v, xs), []), h)", "by induct(auto elim!: Red1_mthr.silent_move.cases Red1.cases)"], ["proof (state)\nthis:\n  s = (((Val v, xs), []), h)\n\ngoal (1 subgoal):\n 1. s = (((Val v, xs), []), h) \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t (((Val v, xs), []), h) s", "qed auto"], ["", "lemma \\<tau>mreds1_Throw_Nil:\n  \"\\<tau>trsys.silent_moves (mred1g uf P t) (\\<tau>MOVE1 P) (((Throw a, xs), []), h) s \\<longleftrightarrow> s = (((Throw a, xs), []), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Red1_mthr.silent_moves uf P t (((Throw a, xs), []), h) s =\n    (s = (((Throw a, xs), []), h))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Red1_mthr.silent_moves uf P t (((Throw a, xs), []), h)\n     s \\<Longrightarrow>\n    s = (((Throw a, xs), []), h)\n 2. s = (((Throw a, xs), []), h) \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t (((Throw a, xs), []), h) s", "assume \"\\<tau>trsys.silent_moves (mred1g uf P t) (\\<tau>MOVE1 P) (((Throw a, xs), []), h) s\""], ["proof (state)\nthis:\n  Red1_mthr.silent_moves uf P t (((Throw a, xs), []), h) s\n\ngoal (2 subgoals):\n 1. Red1_mthr.silent_moves uf P t (((Throw a, xs), []), h)\n     s \\<Longrightarrow>\n    s = (((Throw a, xs), []), h)\n 2. s = (((Throw a, xs), []), h) \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t (((Throw a, xs), []), h) s", "thus \"s = (((Throw a, xs), []), h)\""], ["proof (prove)\nusing this:\n  Red1_mthr.silent_moves uf P t (((Throw a, xs), []), h) s\n\ngoal (1 subgoal):\n 1. s = (((Throw a, xs), []), h)", "by induct(auto elim!: Red1_mthr.silent_move.cases Red1.cases)"], ["proof (state)\nthis:\n  s = (((Throw a, xs), []), h)\n\ngoal (1 subgoal):\n 1. s = (((Throw a, xs), []), h) \\<Longrightarrow>\n    Red1_mthr.silent_moves uf P t (((Throw a, xs), []), h) s", "qed auto"], ["", "end"], ["", "end"]]}