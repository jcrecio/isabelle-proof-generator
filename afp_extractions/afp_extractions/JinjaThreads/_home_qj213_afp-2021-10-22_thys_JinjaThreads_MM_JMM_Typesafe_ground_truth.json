{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/JMM_Typesafe.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma typeof_h_conv_typeof_h [heap_independent, iff]: \"h.typeof_h h = typeof_h\"", "lemmas typeof_h_simps [simp] = h.typeof_h.simps [unfolded heap_independent]", "lemma cname_of_conv_cname_of [heap_independent, iff]: \"h.cname_of h = cname_of\"", "lemma addr_loc_type_conv_addr_loc_type [heap_independent, iff]: \n  \"h.addr_loc_type P h = addr_loc_type P\"", "lemmas addr_loc_type_cases [cases pred: addr_loc_type] = \n  h.addr_loc_type.cases[unfolded heap_independent]", "lemmas addr_loc_type_intros = h.addr_loc_type.intros[unfolded heap_independent]", "lemma typeof_addr_loc_conv_typeof_addr_loc [heap_independent, iff]:\n  \"h.typeof_addr_loc P h = typeof_addr_loc P\"", "lemma conf_conv_conf [heap_independent, iff]: \"h.conf P h = conf P\"", "lemmas defval_conf [simp] = h.defval_conf[unfolded heap_independent]", "lemma lconf_conv_lconf [heap_independent, iff]: \"h.lconf P h = lconf P\"", "lemma confs_conv_confs [heap_independent, iff]: \"h.confs P h = confs P\"", "lemma tconf_conv_tconf [heap_independent, iff]: \"h.tconf P h = tconf P\"", "lemma vs_conf_conv_vs_conf [heap_independent, iff]: \"h.vs_conf P h = vs_conf P\"", "lemmas vs_confI = h.vs_confI[unfolded heap_independent]", "lemmas vs_confD = h.vs_confD[unfolded heap_independent]", "lemma vs_conf_vs_type_all [simp]: \"vs_conf P (vs_type_all P)\"", "lemma w_addrs_vs_type_all: \"w_addrs (vs_type_all P) \\<subseteq> dom typeof_addr\"", "lemma w_addrs_vs_type_all_in_vs_type_all:\n  \"(\\<Union>ad \\<in> w_addrs (vs_type_all P). {(ad, al)|al. \\<exists>T. P \\<turnstile> ad@al : T}) \\<subseteq> {adal. vs_type_all P adal \\<noteq> {}}\"", "lemmas vs_conf_insert_iff = h.vs_conf_insert_iff[unfolded heap_independent]", "lemma vs_conf_w_value_WriteMemD: \n  \"\\<lbrakk> vs_conf P (w_value P vs ob); ob = NormalAction (WriteMem ad al v) \\<rbrakk>\n  \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\"", "lemma vs_conf_w_values_WriteMemD:\n  \"\\<lbrakk> vs_conf P (w_values P vs obs); NormalAction (WriteMem ad al v) \\<in> set obs \\<rbrakk>\n  \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\"", "lemma w_values_vs_type_all_start_heap_obs:\n  assumes wf: \"wf_syscls P\"\n  shows \"w_values P (vs_type_all P) (map snd (lift_start_obs h.start_tid h.start_heap_obs)) = vs_type_all P\"\n  (is \"?lhs = ?rhs\")", "lemma lprefix_lappend2I: \"lprefix xs ys \\<Longrightarrow> lprefix xs (lappend ys zs)\"", "lemma known_addrs_typeable_in_vs_type_all:\n  \"h.if.known_addrs_state s \\<subseteq> dom typeof_addr \n  \\<Longrightarrow> (\\<Union>a \\<in> h.if.known_addrs_state s. {(a, al)|al. \\<exists>T. P \\<turnstile> a@al : T}) \\<subseteq> {adal. vs_type_all P adal \\<noteq> {}}\"", "lemma if_NewHeapElem_typed: \n  \"\\<lbrakk> t \\<turnstile> xh -ta\\<rightarrow>i x'h'; NormalAction (NewHeapElem ad CTn) \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\"", "lemma if_redT_NewHeapElem_typed:\n  \"\\<lbrakk> h.mthr.if.redT s (t, ta) s'; NormalAction (NewHeapElem ad CTn) \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\"", "lemma non_speculative_written_value_typeable:\n  assumes wfx_start: \"ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\" \n  and wfP: \"wf_syscls P\"\n  and E: \"E \\<in> h.\\<E>_start f P C M vs status\"\n  and \"write\": \"w \\<in> write_actions E\"\n  and adal: \"(ad, al) \\<in> action_loc P E w\"\n  and ns: \"non_speculative P (vs_type_all P) (lmap snd (ltake (enat w) E))\"\n  shows \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> value_written P E w (ad, al) :\\<le> T\"", "lemma hb_read_value_typeable:\n  assumes wfx_start: \"ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\" \n    (is \"ts_ok wfx (thr ?start_state) _\")\n  and wfP: \"wf_syscls P\"\n  and E: \"E \\<in> h.\\<E>_start f P C M vs status\"\n  and wf: \"P \\<turnstile> (E, ws) \\<surd>\"\n  and races: \"\\<And>a ad al v. \\<lbrakk> enat a < llength E; action_obs E a = NormalAction (ReadMem ad al v); \\<not> P,E \\<turnstile> ws a \\<le>hb a \\<rbrakk>\n              \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\"\n  and r: \"enat a < llength E\"\n  and read: \"action_obs E a = NormalAction (ReadMem ad al v)\"\n  shows \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\"", "theorem \n  assumes wfx_start: \"ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\" \n  and wfP: \"wf_syscls P\"\n  and justified: \"P \\<turnstile> (E, ws) weakly_justified_by J\"\n  and J: \"range (justifying_exec \\<circ> J) \\<subseteq> h.\\<E>_start f P C M vs status\"\n  shows read_value_typeable_justifying:\n    \"\\<lbrakk> 0 < n; enat a < llength (justifying_exec (J n));\n      action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\" \n  and read_value_typeable_justifed:\n    \"\\<lbrakk> E \\<in> h.\\<E>_start f P C M vs status; P \\<turnstile> (E, ws) \\<surd>;\n       enat a < llength E; action_obs E a = NormalAction (ReadMem ad al v) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], "translations": [["", "lemma typeof_h_conv_typeof_h [heap_independent, iff]: \"h.typeof_h h = typeof_h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.typeof_h h = typeof_h", "by(rule ext)(case_tac x, simp_all add: typeof_h_def)"], ["", "lemmas typeof_h_simps [simp] = h.typeof_h.simps [unfolded heap_independent]"], ["", "definition cname_of :: \"'addr \\<Rightarrow> cname\"\nwhere \"cname_of = h.cname_of undefined\""], ["", "lemma cname_of_conv_cname_of [heap_independent, iff]: \"h.cname_of h = cname_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.cname_of h = cname_of", "by(simp add: cname_of_def h.cname_of_def[abs_def])"], ["", "definition addr_loc_type :: \"'m prog \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> ty \\<Rightarrow> bool\"\nwhere \"addr_loc_type P = h.addr_loc_type P undefined\""], ["", "notation addr_loc_type (\"_ \\<turnstile> _@_ : _\" [50, 50, 50, 50] 51)"], ["", "lemma addr_loc_type_conv_addr_loc_type [heap_independent, iff]: \n  \"h.addr_loc_type P h = addr_loc_type P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.addr_loc_type P h = addr_loc_type P", "by(simp add: addr_loc_type_def h.addr_loc_type_def)"], ["", "lemmas addr_loc_type_cases [cases pred: addr_loc_type] = \n  h.addr_loc_type.cases[unfolded heap_independent]"], ["", "lemmas addr_loc_type_intros = h.addr_loc_type.intros[unfolded heap_independent]"], ["", "definition typeof_addr_loc :: \"'m prog \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> ty\"\nwhere \"typeof_addr_loc P = h.typeof_addr_loc P undefined\""], ["", "lemma typeof_addr_loc_conv_typeof_addr_loc [heap_independent, iff]:\n  \"h.typeof_addr_loc P h = typeof_addr_loc P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.typeof_addr_loc P h = typeof_addr_loc P", "by(simp add: typeof_addr_loc_def h.typeof_addr_loc_def[abs_def])"], ["", "definition conf :: \"'a prog \\<Rightarrow> 'addr val \\<Rightarrow> ty \\<Rightarrow> bool\"\nwhere \"conf P \\<equiv> h.conf P undefined\""], ["", "notation conf (\"_ \\<turnstile> _ :\\<le> _\"  [51,51,51] 50)"], ["", "lemma conf_conv_conf [heap_independent, iff]: \"h.conf P h = conf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.conf P h = conf P", "by(simp add: conf_def heap_base.conf_def[abs_def])"], ["", "lemmas defval_conf [simp] = h.defval_conf[unfolded heap_independent]"], ["", "definition lconf :: \"'m prog \\<Rightarrow> (vname \\<rightharpoonup> 'addr val) \\<Rightarrow> (vname \\<rightharpoonup> ty) \\<Rightarrow> bool\" \nwhere \"lconf P = h.lconf P undefined\""], ["", "notation lconf (\"_ \\<turnstile> _ '(:\\<le>') _\" [51,51,51] 50)"], ["", "lemma lconf_conv_lconf [heap_independent, iff]: \"h.lconf P h = lconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.lconf P h = lconf P", "by(simp add: lconf_def h.lconf_def[abs_def])"], ["", "definition confs :: \"'m prog \\<Rightarrow> 'addr val list \\<Rightarrow> ty list \\<Rightarrow> bool\"\nwhere \"confs P = h.confs P undefined\""], ["", "notation confs (\"_ \\<turnstile> _ [:\\<le>] _\" [51,51,51] 50)"], ["", "lemma confs_conv_confs [heap_independent, iff]: \"h.confs P h = confs P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.confs P h = confs P", "by(simp add: confs_def)"], ["", "definition tconf :: \"'m prog \\<Rightarrow> 'thread_id \\<Rightarrow> bool\" \nwhere \"tconf P = h.tconf P undefined\""], ["", "notation tconf (\"_ \\<turnstile> _ \\<surd>t\" [51,51] 50)"], ["", "lemma tconf_conv_tconf [heap_independent, iff]: \"h.tconf P h = tconf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.tconf P h = tconf P", "by(simp add: tconf_def h.tconf_def[abs_def])"], ["", "definition vs_conf :: \"'m prog \\<Rightarrow> ('addr \\<times> addr_loc \\<Rightarrow> 'addr val set) \\<Rightarrow> bool\"\nwhere \"vs_conf P = h.vs_conf P undefined\""], ["", "lemma vs_conf_conv_vs_conf [heap_independent, iff]: \"h.vs_conf P h = vs_conf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.vs_conf P h = vs_conf P", "by(simp add: vs_conf_def h.vs_conf_def[abs_def])"], ["", "lemmas vs_confI = h.vs_confI[unfolded heap_independent]"], ["", "lemmas vs_confD = h.vs_confD[unfolded heap_independent]"], ["", "text \\<open>\n  use non-speculativity to express that only type-correct values are read\n\\<close>"], ["", "primrec vs_type_all :: \"'m prog \\<Rightarrow> 'addr \\<times> addr_loc \\<Rightarrow> 'addr val set\"\nwhere \"vs_type_all P (ad, al) = {v. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T}\""], ["", "lemma vs_conf_vs_type_all [simp]: \"vs_conf P (vs_type_all P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P (vs_type_all P)", "by(rule h.vs_confI[unfolded heap_independent])(simp)"], ["", "lemma w_addrs_vs_type_all: \"w_addrs (vs_type_all P) \\<subseteq> dom typeof_addr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_addrs (vs_type_all P) \\<subseteq> dom typeof_addr", "by(auto simp add: w_addrs_def h.conf_def[unfolded heap_independent])"], ["", "lemma w_addrs_vs_type_all_in_vs_type_all:\n  \"(\\<Union>ad \\<in> w_addrs (vs_type_all P). {(ad, al)|al. \\<exists>T. P \\<turnstile> ad@al : T}) \\<subseteq> {adal. vs_type_all P adal \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>ad\\<in>w_addrs (vs_type_all P).\n        {(ad, al) |al. \\<exists>T. P \\<turnstile> ad@al : T})\n    \\<subseteq> {adal. vs_type_all P adal \\<noteq> {}}", "by(auto simp add: w_addrs_def vs_type_all_def intro: defval_conf)"], ["", "declare vs_type_all.simps [simp del]"], ["", "lemmas vs_conf_insert_iff = h.vs_conf_insert_iff[unfolded heap_independent]"], ["", "end"], ["", "locale heap' =\n  h: heap\n    addr2thread_id thread_id2addr\n    spurious_wakeups\n    empty_heap allocate \"\\<lambda>_. typeof_addr\" heap_read heap_write\n    P\n  for addr2thread_id :: \"('addr :: addr) \\<Rightarrow> 'thread_id\"\n  and thread_id2addr :: \"'thread_id \\<Rightarrow> 'addr\"\n  and spurious_wakeups :: bool\n  and empty_heap :: \"'heap\"\n  and allocate :: \"'heap \\<Rightarrow> htype \\<Rightarrow> ('heap \\<times> 'addr) set\"\n  and typeof_addr :: \"'addr \\<rightharpoonup> htype\"\n  and heap_read :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\n  and heap_write :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  and P :: \"'m prog\""], ["", "sublocale heap' < heap_base'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context heap' begin"], ["", "lemma vs_conf_w_value_WriteMemD: \n  \"\\<lbrakk> vs_conf P (w_value P vs ob); ob = NormalAction (WriteMem ad al v) \\<rbrakk>\n  \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs_conf P (w_value P vs ob);\n     ob = NormalAction (WriteMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "by(auto elim: vs_confD)"], ["", "lemma vs_conf_w_values_WriteMemD:\n  \"\\<lbrakk> vs_conf P (w_values P vs obs); NormalAction (WriteMem ad al v) \\<in> set obs \\<rbrakk>\n  \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs_conf P (w_values P vs obs);\n     NormalAction (WriteMem ad al v) \\<in> set obs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "apply(induct obs arbitrary: vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>vs_conf P (w_values P vs []);\n        NormalAction (WriteMem ad al v) \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T\n 2. \\<And>a obs vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>vs_conf P (w_values P vs obs);\n                    NormalAction (WriteMem ad al v) \\<in> set obs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        vs_conf P (w_values P vs (a # obs));\n        NormalAction (WriteMem ad al v) \\<in> set (a # obs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "apply(auto 4 3 elim: vs_confD intro: w_values_mono[THEN subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma w_values_vs_type_all_start_heap_obs:\n  assumes wf: \"wf_syscls P\"\n  shows \"w_values P (vs_type_all P) (map snd (lift_start_obs h.start_tid h.start_heap_obs)) = vs_type_all P\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. w_values P (vs_type_all P)\n     (map snd (lift_start_obs h.start_tid h.start_heap_obs)) =\n    vs_type_all P", "proof(rule antisym, rule le_funI, rule subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> w_values P (vs_type_all P)\n                 (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n                 x \\<Longrightarrow>\n       xa \\<in> vs_type_all P x\n 2. vs_type_all P\n    \\<le> w_values P (vs_type_all P)\n           (map snd (lift_start_obs h.start_tid h.start_heap_obs))", "fix adal v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> w_values P (vs_type_all P)\n                 (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n                 x \\<Longrightarrow>\n       xa \\<in> vs_type_all P x\n 2. vs_type_all P\n    \\<le> w_values P (vs_type_all P)\n           (map snd (lift_start_obs h.start_tid h.start_heap_obs))", "assume v: \"v \\<in> ?lhs adal\""], ["proof (state)\nthis:\n  v \\<in> w_values P (vs_type_all P)\n           (map snd (lift_start_obs h.start_tid h.start_heap_obs)) adal\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> w_values P (vs_type_all P)\n                 (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n                 x \\<Longrightarrow>\n       xa \\<in> vs_type_all P x\n 2. vs_type_all P\n    \\<le> w_values P (vs_type_all P)\n           (map snd (lift_start_obs h.start_tid h.start_heap_obs))", "obtain ad al where adal: \"adal = (ad, al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ad al.\n        adal = (ad, al) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases adal)"], ["proof (state)\nthis:\n  adal = (ad, al)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> w_values P (vs_type_all P)\n                 (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n                 x \\<Longrightarrow>\n       xa \\<in> vs_type_all P x\n 2. vs_type_all P\n    \\<le> w_values P (vs_type_all P)\n           (map snd (lift_start_obs h.start_tid h.start_heap_obs))", "show \"v \\<in> ?rhs adal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> vs_type_all P adal", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> vs_type_all P adal \\<Longrightarrow> False", "assume v': \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  v \\<notin> vs_type_all P adal\n\ngoal (1 subgoal):\n 1. v \\<notin> vs_type_all P adal \\<Longrightarrow> False", "from in_w_valuesD[OF v[unfolded adal] this[unfolded adal]]"], ["proof (chain)\npicking this:\n  \\<exists>obs' wa obs''.\n     map snd (lift_start_obs h.start_tid h.start_heap_obs) =\n     obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and> value_written_aux P wa al = v", "obtain obs' wa obs''\n      where eq: \"map snd (lift_start_obs h.start_tid h.start_heap_obs) = obs' @ wa # obs''\"\n      and \"write\": \"is_write_action wa\"\n      and loc: \"(ad, al) \\<in> action_loc_aux P wa\"\n      and vwa: \"value_written_aux P wa al = v\""], ["proof (prove)\nusing this:\n  \\<exists>obs' wa obs''.\n     map snd (lift_start_obs h.start_tid h.start_heap_obs) =\n     obs' @ wa # obs'' \\<and>\n     is_write_action wa \\<and>\n     (ad, al) \\<in> action_loc_aux P wa \\<and> value_written_aux P wa al = v\n\ngoal (1 subgoal):\n 1. (\\<And>obs' wa obs''.\n        \\<lbrakk>map snd (lift_start_obs h.start_tid h.start_heap_obs) =\n                 obs' @ wa # obs'';\n         is_write_action wa; (ad, al) \\<in> action_loc_aux P wa;\n         value_written_aux P wa al = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  map snd (lift_start_obs h.start_tid h.start_heap_obs) = obs' @ wa # obs''\n  is_write_action wa\n  (ad, al) \\<in> action_loc_aux P wa\n  value_written_aux P wa al = v\n\ngoal (1 subgoal):\n 1. v \\<notin> vs_type_all P adal \\<Longrightarrow> False", "from \"write\""], ["proof (chain)\npicking this:\n  is_write_action wa", "show False"], ["proof (prove)\nusing this:\n  is_write_action wa\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ad hT.\n       wa = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> False\n 2. \\<And>ad al v.\n       wa = NormalAction (WriteMem ad al v) \\<Longrightarrow> False", "case (WriteMem ad' al' v')"], ["proof (state)\nthis:\n  wa = NormalAction (WriteMem ad' al' v')\n\ngoal (2 subgoals):\n 1. \\<And>ad hT.\n       wa = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> False\n 2. \\<And>ad al v.\n       wa = NormalAction (WriteMem ad al v) \\<Longrightarrow> False", "with vwa loc eq"], ["proof (chain)\npicking this:\n  value_written_aux P wa al = v\n  (ad, al) \\<in> action_loc_aux P wa\n  map snd (lift_start_obs h.start_tid h.start_heap_obs) = obs' @ wa # obs''\n  wa = NormalAction (WriteMem ad' al' v')", "have \"WriteMem ad al v \\<in> set h.start_heap_obs\""], ["proof (prove)\nusing this:\n  value_written_aux P wa al = v\n  (ad, al) \\<in> action_loc_aux P wa\n  map snd (lift_start_obs h.start_tid h.start_heap_obs) = obs' @ wa # obs''\n  wa = NormalAction (WriteMem ad' al' v')\n\ngoal (1 subgoal):\n 1. WriteMem ad al v \\<in> set h.start_heap_obs", "by(auto simp add: map_eq_append_conv Cons_eq_append_conv lift_start_obs_def)"], ["proof (state)\nthis:\n  WriteMem ad al v \\<in> set h.start_heap_obs\n\ngoal (2 subgoals):\n 1. \\<And>ad hT.\n       wa = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> False\n 2. \\<And>ad al v.\n       wa = NormalAction (WriteMem ad al v) \\<Longrightarrow> False", "from h.start_heap_write_typeable[OF this] v' adal"], ["proof (chain)\npicking this:\n  \\<exists>T.\n     h.addr_loc_type P h.start_heap ad al T \\<and> h.conf P h.start_heap v T\n  v \\<notin> vs_type_all P adal\n  adal = (ad, al)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>T.\n     h.addr_loc_type P h.start_heap ad al T \\<and> h.conf P h.start_heap v T\n  v \\<notin> vs_type_all P adal\n  adal = (ad, al)\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: vs_type_all_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>ad hT.\n       wa = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ad hT.\n       wa = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> False", "case (NewHeapElem ad' hT)"], ["proof (state)\nthis:\n  wa = NormalAction (NewHeapElem ad' hT)\n\ngoal (1 subgoal):\n 1. \\<And>ad hT.\n       wa = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> False", "with vwa loc eq"], ["proof (chain)\npicking this:\n  value_written_aux P wa al = v\n  (ad, al) \\<in> action_loc_aux P wa\n  map snd (lift_start_obs h.start_tid h.start_heap_obs) = obs' @ wa # obs''\n  wa = NormalAction (NewHeapElem ad' hT)", "have \"NewHeapElem ad hT \\<in> set h.start_heap_obs\""], ["proof (prove)\nusing this:\n  value_written_aux P wa al = v\n  (ad, al) \\<in> action_loc_aux P wa\n  map snd (lift_start_obs h.start_tid h.start_heap_obs) = obs' @ wa # obs''\n  wa = NormalAction (NewHeapElem ad' hT)\n\ngoal (1 subgoal):\n 1. NewHeapElem ad hT \\<in> set h.start_heap_obs", "by(auto simp add: map_eq_append_conv Cons_eq_append_conv lift_start_obs_def)"], ["proof (state)\nthis:\n  NewHeapElem ad hT \\<in> set h.start_heap_obs\n\ngoal (1 subgoal):\n 1. \\<And>ad hT.\n       wa = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> False", "hence \"typeof_addr ad = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\nusing this:\n  NewHeapElem ad hT \\<in> set h.start_heap_obs\n\ngoal (1 subgoal):\n 1. typeof_addr ad = \\<lfloor>hT\\<rfloor>", "by(rule h.NewHeapElem_start_heap_obsD[OF wf])"], ["proof (state)\nthis:\n  typeof_addr ad = \\<lfloor>hT\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>ad hT.\n       wa = NormalAction (NewHeapElem ad hT) \\<Longrightarrow> False", "with v' adal loc vwa NewHeapElem"], ["proof (chain)\npicking this:\n  v \\<notin> vs_type_all P adal\n  adal = (ad, al)\n  (ad, al) \\<in> action_loc_aux P wa\n  value_written_aux P wa al = v\n  wa = NormalAction (NewHeapElem ad' hT)\n  typeof_addr ad = \\<lfloor>hT\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> vs_type_all P adal\n  adal = (ad, al)\n  (ad, al) \\<in> action_loc_aux P wa\n  value_written_aux P wa al = v\n  wa = NormalAction (NewHeapElem ad' hT)\n  typeof_addr ad = \\<lfloor>hT\\<rfloor>\n\ngoal (1 subgoal):\n 1. False", "by(auto  simp add: vs_type_all_def intro: addr_loc_type_intros h.addr_loc_default_conf[unfolded heap_independent])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> vs_type_all P adal\n\ngoal (1 subgoal):\n 1. vs_type_all P\n    \\<le> w_values P (vs_type_all P)\n           (map snd (lift_start_obs h.start_tid h.start_heap_obs))", "qed(rule w_values_greater)"], ["", "end"], ["", "lemma lprefix_lappend2I: \"lprefix xs ys \\<Longrightarrow> lprefix xs (lappend ys zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix xs ys \\<Longrightarrow> lprefix xs (lappend ys zs)", "by(auto simp add: lappend_assoc lprefix_conv_lappend)"], ["", "locale known_addrs_typing' =\n  h: known_addrs_typing\n    addr2thread_id thread_id2addr\n    spurious_wakeups\n    empty_heap allocate \"\\<lambda>_. typeof_addr\" heap_read heap_write \n    allocated known_addrs \n    final r wfx\n    P\n  for addr2thread_id :: \"('addr :: addr) \\<Rightarrow> 'thread_id\"\n  and thread_id2addr :: \"'thread_id \\<Rightarrow> 'addr\"\n  and spurious_wakeups :: bool\n  and empty_heap :: \"'heap\"\n  and allocate :: \"'heap \\<Rightarrow> htype \\<Rightarrow> ('heap \\<times> 'addr) set\"\n  and typeof_addr :: \"'addr \\<rightharpoonup> htype\"\n  and heap_read :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\n  and heap_write :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> 'heap \\<Rightarrow> bool\" \n  and allocated :: \"'heap \\<Rightarrow> 'addr set\"\n  and known_addrs :: \"'thread_id \\<Rightarrow> 'x \\<Rightarrow> 'addr set\"\n  and final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"('addr, 'thread_id, 'x, 'heap, 'addr, ('addr, 'thread_id) obs_event) semantics\" (\"_ \\<turnstile> _ -_\\<rightarrow> _\" [50,0,0,50] 80) \n  and wfx :: \"'thread_id \\<Rightarrow> 'x \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  and P :: \"'md prog\"\n  +\n  assumes NewHeapElem_typed: \\<comment> \\<open>Should this be moved to known\\_addrs\\_typing?\\<close>\n  \"\\<lbrakk> t \\<turnstile> (x, h) -ta\\<rightarrow> (x', h'); NewHeapElem ad CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["", "sublocale known_addrs_typing' < heap'"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap' addr2thread_id thread_id2addr allocate typeof_addr heap_write P", "by unfold_locales"], ["", "context known_addrs_typing' begin"], ["", "lemma known_addrs_typeable_in_vs_type_all:\n  \"h.if.known_addrs_state s \\<subseteq> dom typeof_addr \n  \\<Longrightarrow> (\\<Union>a \\<in> h.if.known_addrs_state s. {(a, al)|al. \\<exists>T. P \\<turnstile> a@al : T}) \\<subseteq> {adal. vs_type_all P adal \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.if.known_addrs_state s \\<subseteq> dom typeof_addr \\<Longrightarrow>\n    (\\<Union>a\\<in>h.if.known_addrs_state s.\n        {(a, al) |al. \\<exists>T. P \\<turnstile> a@al : T})\n    \\<subseteq> {adal. vs_type_all P adal \\<noteq> {}}", "by(auto 4 4 dest: subsetD simp add: vs_type_all.simps intro: defval_conf)"], ["", "lemma if_NewHeapElem_typed: \n  \"\\<lbrakk> t \\<turnstile> xh -ta\\<rightarrow>i x'h'; NormalAction (NewHeapElem ad CTn) \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<turnstile> xh -ta\\<rightarrow>i x'h';\n     NormalAction (NewHeapElem ad CTn)\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     typeof_addr ad \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(cases rule: h.mthr.init_fin.cases)(auto dest: NewHeapElem_typed)"], ["", "lemma if_redT_NewHeapElem_typed:\n  \"\\<lbrakk> h.mthr.if.redT s (t, ta) s'; NormalAction (NewHeapElem ad CTn) \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h.mthr.if.redT_syntax1 s t ta s';\n     NormalAction (NewHeapElem ad CTn)\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     typeof_addr ad \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(cases rule: h.mthr.if.redT.cases)(auto dest: if_NewHeapElem_typed)"], ["", "lemma non_speculative_written_value_typeable:\n  assumes wfx_start: \"ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\" \n  and wfP: \"wf_syscls P\"\n  and E: \"E \\<in> h.\\<E>_start f P C M vs status\"\n  and \"write\": \"w \\<in> write_actions E\"\n  and adal: \"(ad, al) \\<in> action_loc P E w\"\n  and ns: \"non_speculative P (vs_type_all P) (lmap snd (ltake (enat w) E))\"\n  shows \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> value_written P E w (ad, al) :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "let ?start_state = \"init_fin_lift_state status (h.start_state f P C M vs)\"\n    and ?start_obs = \"lift_start_obs h.start_tid h.start_heap_obs\"\n    and ?v = \"value_written P E w (ad, al)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from \"write\""], ["proof (chain)\npicking this:\n  w \\<in> write_actions E", "have iwa: \"is_write_action (action_obs E w)\""], ["proof (prove)\nusing this:\n  w \\<in> write_actions E\n\ngoal (1 subgoal):\n 1. is_write_action (action_obs E w)", "by cases"], ["proof (state)\nthis:\n  is_write_action (action_obs E w)\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from E"], ["proof (chain)\npicking this:\n  E \\<in> h.\\<E>_start f P C M vs status", "obtain E' where E': \"E = lappend (llist_of ?start_obs) E'\"\n    and \\<E>: \"E' \\<in> h.mthr.if.\\<E> ?start_state\""], ["proof (prove)\nusing this:\n  E \\<in> h.\\<E>_start f P C M vs status\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E =\n                 lappend\n                  (llist_of (lift_start_obs h.start_tid h.start_heap_obs))\n                  E';\n         E' \\<in> h.mthr.if.\\<E>\n                   (init_fin_lift_state status\n                     (h.start_state f P C M vs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E = lappend (llist_of (lift_start_obs h.start_tid h.start_heap_obs)) E'\n  E' \\<in> h.mthr.if.\\<E>\n            (init_fin_lift_state status (h.start_state f P C M vs))\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from \\<E>"], ["proof (chain)\npicking this:\n  E' \\<in> h.mthr.if.\\<E>\n            (init_fin_lift_state status (h.start_state f P C M vs))", "obtain E'' where E'': \"E' = lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) E'')\"\n    and Runs: \"h.mthr.if.mthr.Runs ?start_state E''\""], ["proof (prove)\nusing this:\n  E' \\<in> h.mthr.if.\\<E>\n            (init_fin_lift_state status (h.start_state f P C M vs))\n\ngoal (1 subgoal):\n 1. (\\<And>E''.\n        \\<lbrakk>E' =\n                 lconcat\n                  (lmap\n                    (\\<lambda>(t, ta).\n                        llist_of\n                         (map (Pair t)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    E'');\n         h.mthr.if.mthr.Runs\n          (init_fin_lift_state status (h.start_state f P C M vs))\n          E''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by-(rule h.mthr.if.\\<E>.cases[OF \\<E>])"], ["proof (state)\nthis:\n  E' =\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     E'')\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have wfx': \"ts_ok (init_fin_lift wfx) (thr ?start_state) (shr ?start_state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ok (init_fin_lift wfx)\n     (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n     (shr (init_fin_lift_state status (h.start_state f P C M vs)))", "using wfx_start"], ["proof (prove)\nusing this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n\ngoal (1 subgoal):\n 1. ts_ok (init_fin_lift wfx)\n     (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n     (shr (init_fin_lift_state status (h.start_state f P C M vs)))", "by(simp add: h.shr_start_state)"], ["proof (state)\nthis:\n  ts_ok (init_fin_lift wfx)\n   (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n   (shr (init_fin_lift_state status (h.start_state f P C M vs)))\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from ns E'"], ["proof (chain)\npicking this:\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat w) E))\n  E = lappend (llist_of (lift_start_obs h.start_tid h.start_heap_obs)) E'", "have ns: \"non_speculative P (vs_type_all P) (lmap snd (ldropn (length (lift_start_obs h.start_tid h.start_heap_obs)) (ltake (enat w) E)))\""], ["proof (prove)\nusing this:\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat w) E))\n  E = lappend (llist_of (lift_start_obs h.start_tid h.start_heap_obs)) E'\n\ngoal (1 subgoal):\n 1. non_speculative P (vs_type_all P)\n     (lmap snd\n       (ldropn (length (lift_start_obs h.start_tid h.start_heap_obs))\n         (ltake (enat w) E)))", "by(subst (asm) lappend_ltake_ldrop[where n=\"enat (length (lift_start_obs h.start_tid h.start_heap_obs))\", symmetric])(simp add: non_speculative_lappend min_def ltake_lappend1 w_values_vs_type_all_start_heap_obs[OF wfP] ldrop_enat split: if_split_asm)"], ["proof (state)\nthis:\n  non_speculative P (vs_type_all P)\n   (lmap snd\n     (ldropn (length (lift_start_obs h.start_tid h.start_heap_obs))\n       (ltake (enat w) E)))\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "proof(cases \"w < length ?start_obs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w < length\n         (lift_start_obs h.start_tid h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n 2. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "case True"], ["proof (state)\nthis:\n  w < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (2 subgoals):\n 1. w < length\n         (lift_start_obs h.start_tid h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n 2. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "hence in_start: \"action_obs E w \\<in> set (map snd ?start_obs)\""], ["proof (prove)\nusing this:\n  w < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. action_obs E w\n    \\<in> set (map snd (lift_start_obs h.start_tid h.start_heap_obs))", "unfolding in_set_conv_nth E'"], ["proof (prove)\nusing this:\n  w < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length\n                (map snd (lift_start_obs h.start_tid h.start_heap_obs)).\n       map snd (lift_start_obs h.start_tid h.start_heap_obs) ! i =\n       action_obs\n        (lappend (llist_of (lift_start_obs h.start_tid h.start_heap_obs))\n          E')\n        w", "by(simp add: lnth_lappend action_obs_def map_nth exI[where x=\"w\"])"], ["proof (state)\nthis:\n  action_obs E w\n  \\<in> set (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n\ngoal (2 subgoals):\n 1. w < length\n         (lift_start_obs h.start_tid h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n 2. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from iwa"], ["proof (chain)\npicking this:\n  is_write_action (action_obs E w)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_write_action (action_obs E w)\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n 2. \\<And>ada ala v.\n       action_obs E w = NormalAction (WriteMem ada ala v) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "case (WriteMem ad' al' v')"], ["proof (state)\nthis:\n  action_obs E w = NormalAction (WriteMem ad' al' v')\n\ngoal (2 subgoals):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n 2. \\<And>ada ala v.\n       action_obs E w = NormalAction (WriteMem ada ala v) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with adal"], ["proof (chain)\npicking this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (WriteMem ad' al' v')", "have \"ad' = ad\" \"al' = al\" \"?v = v'\""], ["proof (prove)\nusing this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (WriteMem ad' al' v')\n\ngoal (1 subgoal):\n 1. ad' = ad &&& al' = al &&& value_written P E w (ad, al) = v'", "by(simp_all add: value_written.simps)"], ["proof (state)\nthis:\n  ad' = ad\n  al' = al\n  value_written P E w (ad, al) = v'\n\ngoal (2 subgoals):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n 2. \\<And>ada ala v.\n       action_obs E w = NormalAction (WriteMem ada ala v) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with WriteMem in_start"], ["proof (chain)\npicking this:\n  action_obs E w = NormalAction (WriteMem ad' al' v')\n  action_obs E w\n  \\<in> set (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n  ad' = ad\n  al' = al\n  value_written P E w (ad, al) = v'", "have \"WriteMem ad al ?v \\<in> set h.start_heap_obs\""], ["proof (prove)\nusing this:\n  action_obs E w = NormalAction (WriteMem ad' al' v')\n  action_obs E w\n  \\<in> set (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n  ad' = ad\n  al' = al\n  value_written P E w (ad, al) = v'\n\ngoal (1 subgoal):\n 1. WriteMem ad al (value_written P E w (ad, al)) \\<in> set h.start_heap_obs", "by auto"], ["proof (state)\nthis:\n  WriteMem ad al (value_written P E w (ad, al)) \\<in> set h.start_heap_obs\n\ngoal (2 subgoals):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n 2. \\<And>ada ala v.\n       action_obs E w = NormalAction (WriteMem ada ala v) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  WriteMem ad al (value_written P E w (ad, al)) \\<in> set h.start_heap_obs\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "by(rule h.start_heap_write_typeable[unfolded heap_independent])"], ["proof (state)\nthis:\n  \\<exists>T.\n     P \\<turnstile> ad@al : T \\<and>\n     P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "case (NewHeapElem ad' CTn)"], ["proof (state)\nthis:\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with adal"], ["proof (chain)\npicking this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)", "have [simp]: \"ad' = ad\""], ["proof (prove)\nusing this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n\ngoal (1 subgoal):\n 1. ad' = ad", "by auto"], ["proof (state)\nthis:\n  ad' = ad\n\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with NewHeapElem in_start"], ["proof (chain)\npicking this:\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n  action_obs E w\n  \\<in> set (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n  ad' = ad", "have \"NewHeapElem ad CTn \\<in> set h.start_heap_obs\""], ["proof (prove)\nusing this:\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n  action_obs E w\n  \\<in> set (map snd (lift_start_obs h.start_tid h.start_heap_obs))\n  ad' = ad\n\ngoal (1 subgoal):\n 1. NewHeapElem ad CTn \\<in> set h.start_heap_obs", "by auto"], ["proof (state)\nthis:\n  NewHeapElem ad CTn \\<in> set h.start_heap_obs\n\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with wfP"], ["proof (chain)\npicking this:\n  wf_syscls P\n  NewHeapElem ad CTn \\<in> set h.start_heap_obs", "have \"typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\nusing this:\n  wf_syscls P\n  NewHeapElem ad CTn \\<in> set h.start_heap_obs\n\ngoal (1 subgoal):\n 1. typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(rule h.NewHeapElem_start_heap_obsD)"], ["proof (state)\nthis:\n  typeof_addr ad = \\<lfloor>CTn\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       \\<exists>T.\n          P \\<turnstile> ad@al : T \\<and>\n          P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with adal NewHeapElem"], ["proof (chain)\npicking this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n  typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n  typeof_addr ad = \\<lfloor>CTn\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "by(cases al)(auto simp add: value_written.simps intro: addr_loc_type_intros h.addr_loc_default_conf[unfolded heap_independent])"], ["proof (state)\nthis:\n  \\<exists>T.\n     P \\<turnstile> ad@al : T \\<and>\n     P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>T.\n     P \\<turnstile> ad@al : T \\<and>\n     P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "case False"], ["proof (state)\nthis:\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "define w' where \"w' = w - length ?start_obs\""], ["proof (state)\nthis:\n  w' = w - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with \"write\" False"], ["proof (chain)\npicking this:\n  w \\<in> write_actions E\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)\n  w' = w - length (lift_start_obs h.start_tid h.start_heap_obs)", "have w'_len: \"enat w' < llength E'\""], ["proof (prove)\nusing this:\n  w \\<in> write_actions E\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)\n  w' = w - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. enat w' < llength E'", "by(cases \"llength E'\")(auto simp add: actions_def E' elim: write_actions.cases)"], ["proof (state)\nthis:\n  enat w' < llength E'\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with Runs"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat w' < llength E'", "obtain m_w n_w t_w ta_w \n      where E'_w: \"lnth E' w' = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)\"\n      and n_w: \"n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\"\n      and m_w: \"enat m_w < llength E''\"\n      and w_sum: \"w' = (\\<Sum>i<m_w. length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) + n_w\"\n      and E''_m_w: \"lnth E'' m_w = (t_w, ta_w)\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat w' < llength E'\n\ngoal (1 subgoal):\n 1. (\\<And>t_w ta_w n_w m_w.\n        \\<lbrakk>lnth E' w' =\n                 (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w);\n         n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n         enat m_w < llength E'';\n         w' =\n         (\\<Sum>i<m_w.\n             length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n         n_w;\n         lnth E'' m_w = (t_w, ta_w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding E''"], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat w'\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))\n\ngoal (1 subgoal):\n 1. (\\<And>t_w ta_w n_w m_w.\n        \\<lbrakk>lnth\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      E''))\n                  w' =\n                 (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w);\n         n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n         enat m_w < llength E'';\n         w' =\n         (\\<Sum>i<m_w.\n             length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n         n_w;\n         lnth E'' m_w = (t_w, ta_w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule h.mthr.if.actions_\\<E>E_aux)"], ["proof (state)\nthis:\n  lnth E' w' = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)\n  n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n  enat m_w < llength E''\n  w' =\n  (\\<Sum>i<m_w.\n      length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n  n_w\n  lnth E'' m_w = (t_w, ta_w)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from E'_w"], ["proof (chain)\npicking this:\n  lnth E' w' = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)", "have obs_w: \"action_obs E w = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w\""], ["proof (prove)\nusing this:\n  lnth E' w' = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)\n\ngoal (1 subgoal):\n 1. action_obs E w = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w", "using False E' w'_def"], ["proof (prove)\nusing this:\n  lnth E' w' = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)\n  E = lappend (llist_of (lift_start_obs h.start_tid h.start_heap_obs)) E'\n  w' = w - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. action_obs E w = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w", "by(simp add: action_obs_def lnth_lappend)"], ["proof (state)\nthis:\n  action_obs E w = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "let ?E'' = \"ldropn (Suc m_w) E''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "let ?m_E'' = \"ltake (enat m_w) E''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have E'_unfold: \"E'' = lappend ?m_E'' (LCons (lnth E'' m_w) ?E'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E'' =\n    lappend (ltake (enat m_w) E'')\n     (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))", "unfolding ldropn_Suc_conv_ldropn[OF m_w]"], ["proof (prove)\ngoal (1 subgoal):\n 1. E'' = lappend (ltake (enat m_w) E'') (ldropn m_w E'')", "by simp"], ["proof (state)\nthis:\n  E'' =\n  lappend (ltake (enat m_w) E'')\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "hence \"h.mthr.if.mthr.Runs ?start_state (lappend ?m_E'' (LCons (lnth E'' m_w) ?E''))\""], ["proof (prove)\nusing this:\n  E'' =\n  lappend (ltake (enat m_w) E'')\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. h.mthr.if.mthr.Runs\n     (init_fin_lift_state status (h.start_state f P C M vs))\n     (lappend (ltake (enat m_w) E'')\n       (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))", "using Runs"], ["proof (prove)\nusing this:\n  E'' =\n  lappend (ltake (enat m_w) E'')\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n\ngoal (1 subgoal):\n 1. h.mthr.if.mthr.Runs\n     (init_fin_lift_state status (h.start_state f P C M vs))\n     (lappend (ltake (enat m_w) E'')\n       (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))", "by simp"], ["proof (state)\nthis:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_w) E'')\n     (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "then"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_w) E'')\n     (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))", "obtain \\<sigma>' where \\<sigma>_\\<sigma>': \"h.mthr.if.mthr.Trsys ?start_state (list_of ?m_E'') \\<sigma>'\"\n      and Runs': \"h.mthr.if.mthr.Runs \\<sigma>' (LCons (lnth E'' m_w) ?E'')\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_w) E'')\n     (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>h.mthr.if.mthr.Trsys\n                  (init_fin_lift_state status (h.start_state f P C M vs))\n                  (list_of (ltake (enat m_w) E'')) \\<sigma>';\n         h.mthr.if.mthr.Runs \\<sigma>'\n          (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule h.mthr.if.mthr.Runs_lappendE) simp"], ["proof (state)\nthis:\n  h.mthr.if.mthr.Trsys\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (list_of (ltake (enat m_w) E'')) \\<sigma>'\n  h.mthr.if.mthr.Runs \\<sigma>'\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from Runs'"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs \\<sigma>'\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))", "obtain \\<sigma>''' where red_w: \"h.mthr.if.redT \\<sigma>' (t_w, ta_w) \\<sigma>'''\"\n      and Runs'': \"h.mthr.if.mthr.Runs \\<sigma>''' ?E''\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs \\<sigma>'\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'''.\n        \\<lbrakk>h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>''';\n         h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_w) E'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding E''_m_w"], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs \\<sigma>' (LCons (t_w, ta_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'''.\n        \\<lbrakk>h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>''';\n         h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_w) E'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>'''\n  h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_w) E'')\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "let ?EE'' = \"lmap snd (lappend (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) ?m_E'')) (llist_of (map (Pair t_w) (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have len_EE'': \"llength ?EE'' = enat (w' + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))) =\n    enat (w' + 1)", "using n_w m_w"], ["proof (prove)\nusing this:\n  n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n  enat m_w < llength E''\n\ngoal (1 subgoal):\n 1. llength\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))) =\n    enat (w' + 1)", "apply(simp add: w_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n     enat m_w < llength E''\\<rbrakk>\n    \\<Longrightarrow> llength\n                       (lconcat\n                         (lmap\n                           (\\<lambda>(t, ta).\n                               llist_of\n                                (map (Pair t)\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                           (ltake (enat m_w) E''))) +\n                      enat\n                       (min (length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (Suc n_w)) =\n                      enat\n                       (Suc ((\\<Sum>i<m_w.\n                                 length\n                                  \\<lbrace>snd\n      (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n                             n_w))", "apply(subst llength_lconcat_lfinite_conv_sum)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n     enat m_w < llength E''\\<rbrakk>\n    \\<Longrightarrow> lfinite\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of\n                              (map (Pair t)\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                         (ltake (enat m_w) E''))\n 2. \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n     enat m_w < llength E''\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i | enat i\n                                 < llength\n                                    (lmap\n(\\<lambda>(t, ta).\n    llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n(ltake (enat m_w) E'')).\n                         llength\n                          (lnth\n                            (lmap\n                              (\\<lambda>(t, ta).\n                                  llist_of\n                                   (map (Pair t)\n                                     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                              (ltake (enat m_w) E''))\n                            i)) +\n                      enat\n                       (min (length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (Suc n_w)) =\n                      enat\n                       (Suc ((\\<Sum>i<m_w.\n                                 length\n                                  \\<lbrace>snd\n      (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n                             n_w))", "apply(simp_all add: split_beta plus_enat_simps(1)[symmetric] add_Suc_right[symmetric] del: plus_enat_simps(1) add_Suc_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n     enat m_w < llength E''\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i | i < m_w \\<and> enat i < llength E''.\n                         enat\n                          (length\n                            \\<lbrace>snd\n(lnth (ltake (enat m_w) E'') i)\\<rbrace>\\<^bsub>o\\<^esub>)) +\n                      enat\n                       (min (length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (Suc n_w)) =\n                      enat\n                       (\\<Sum>i<m_w.\n                           length\n                            \\<lbrace>snd\n(lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n                      enat (Suc n_w)", "apply(subst sum_hom[symmetric, where f=enat])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n        enat m_w < llength E''\\<rbrakk>\n       \\<Longrightarrow> enat (a + b) = enat a + enat b\n 2. \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n     enat m_w < llength E''\\<rbrakk>\n    \\<Longrightarrow> enat 0 = 0\n 3. \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n     enat m_w < llength E''\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i | i < m_w \\<and> enat i < llength E''.\n                         enat\n                          (length\n                            \\<lbrace>snd\n(lnth (ltake (enat m_w) E'') i)\\<rbrace>\\<^bsub>o\\<^esub>)) +\n                      enat\n                       (min (length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (Suc n_w)) =\n                      sum (enat \\<circ>\n                           (\\<lambda>i.\n                               length\n                                \\<lbrace>snd\n    (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>))\n                       {..<m_w} +\n                      enat (Suc n_w)", "apply(simp_all add: zero_enat_def min_def le_Suc_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n     enat m_w < llength E''\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i | i < m_w \\<and> enat i < llength E''.\n                         enat\n                          (length\n                            \\<lbrace>snd\n(lnth (ltake (enat m_w) E'') i)\\<rbrace>\\<^bsub>o\\<^esub>)) =\n                      (\\<Sum>x<m_w.\n                          enat\n                           (length\n                             \\<lbrace>snd\n (lnth E'' x)\\<rbrace>\\<^bsub>o\\<^esub>))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n     enat m_w < llength E''\\<rbrakk>\n    \\<Longrightarrow> {i. i < m_w \\<and> enat i < llength E''} = {..<m_w}\n 2. \\<And>x.\n       \\<lbrakk>n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n        enat m_w < llength E''; x \\<in> {..<m_w}\\<rbrakk>\n       \\<Longrightarrow> enat\n                          (length\n                            \\<lbrace>snd\n(lnth (ltake (enat m_w) E'') x)\\<rbrace>\\<^bsub>o\\<^esub>) =\n                         enat\n                          (length\n                            \\<lbrace>snd\n(lnth E'' x)\\<rbrace>\\<^bsub>o\\<^esub>)", "apply(auto simp add: lnth_ltake less_trans[where y=\"enat m_w\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  llength\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))) =\n  enat (w' + 1)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have prefix: \"lprefix ?EE'' (lmap snd E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n     (lmap snd E')", "unfolding E''"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n     (lmap snd\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           E'')))", "by(subst (2) E'_unfold)(rule lmap_lprefix, clarsimp simp add: lmap_lappend_distrib E''_m_w lprefix_lappend2I[OF lprefix_llist_ofI[OF exI[where x=\"map (Pair t_w) (drop (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\"]]] map_append[symmetric])"], ["proof (state)\nthis:\n  lprefix\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   (lmap snd E')\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from iwa False"], ["proof (chain)\npicking this:\n  is_write_action (action_obs E w)\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)", "have iwa': \"is_write_action (action_obs E' w')\""], ["proof (prove)\nusing this:\n  is_write_action (action_obs E w)\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. is_write_action (action_obs E' w')", "by(simp add: E' action_obs_def lnth_lappend w'_def)"], ["proof (state)\nthis:\n  is_write_action (action_obs E' w')\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from ns False"], ["proof (chain)\npicking this:\n  non_speculative P (vs_type_all P)\n   (lmap snd\n     (ldropn (length (lift_start_obs h.start_tid h.start_heap_obs))\n       (ltake (enat w) E)))\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)", "have \"non_speculative P (vs_type_all P) (lmap snd (ltake (enat w') E'))\""], ["proof (prove)\nusing this:\n  non_speculative P (vs_type_all P)\n   (lmap snd\n     (ldropn (length (lift_start_obs h.start_tid h.start_heap_obs))\n       (ltake (enat w) E)))\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. non_speculative P (vs_type_all P) (lmap snd (ltake (enat w') E'))", "by(simp add: E' ltake_lappend lmap_lappend_distrib non_speculative_lappend ldropn_lappend2 w'_def)"], ["proof (state)\nthis:\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat w') E'))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with iwa'"], ["proof (chain)\npicking this:\n  is_write_action (action_obs E' w')\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat w') E'))", "have \"non_speculative P (vs_type_all P) (lappend (lmap snd (ltake (enat w') E')) (LCons (action_obs E' w') LNil))\""], ["proof (prove)\nusing this:\n  is_write_action (action_obs E' w')\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat w') E'))\n\ngoal (1 subgoal):\n 1. non_speculative P (vs_type_all P)\n     (lappend (lmap snd (ltake (enat w') E'))\n       (LCons (action_obs E' w') LNil))", "by cases(simp_all add: non_speculative_lappend)"], ["proof (state)\nthis:\n  non_speculative P (vs_type_all P)\n   (lappend (lmap snd (ltake (enat w') E')) (LCons (action_obs E' w') LNil))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "also"], ["proof (state)\nthis:\n  non_speculative P (vs_type_all P)\n   (lappend (lmap snd (ltake (enat w') E')) (LCons (action_obs E' w') LNil))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have \"lappend (lmap snd (ltake (enat w') E')) (LCons (action_obs E' w') LNil) = lmap snd (ltake (enat (w' + 1)) E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (lmap snd (ltake (enat w') E'))\n     (LCons (action_obs E' w') LNil) =\n    lmap snd (ltake (enat (w' + 1)) E')", "using w'_len"], ["proof (prove)\nusing this:\n  enat w' < llength E'\n\ngoal (1 subgoal):\n 1. lappend (lmap snd (ltake (enat w') E'))\n     (LCons (action_obs E' w') LNil) =\n    lmap snd (ltake (enat (w' + 1)) E')", "by(simp add: ltake_Suc_conv_snoc_lnth lmap_lappend_distrib action_obs_def)"], ["proof (state)\nthis:\n  lappend (lmap snd (ltake (enat w') E')) (LCons (action_obs E' w') LNil) =\n  lmap snd (ltake (enat (w' + 1)) E')\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "also"], ["proof (state)\nthis:\n  lappend (lmap snd (ltake (enat w') E')) (LCons (action_obs E' w') LNil) =\n  lmap snd (ltake (enat (w' + 1)) E')\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "{"], ["proof (state)\nthis:\n  lappend (lmap snd (ltake (enat w') E')) (LCons (action_obs E' w') LNil) =\n  lmap snd (ltake (enat (w' + 1)) E')\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have \"lprefix (lmap snd (ltake (enat (w' + 1)) E')) (lmap snd E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lmap snd (ltake (enat (w' + 1)) E')) (lmap snd E')", "by(rule lmap_lprefix) simp"], ["proof (state)\nthis:\n  lprefix (lmap snd (ltake (enat (w' + 1)) E')) (lmap snd E')\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with prefix"], ["proof (chain)\npicking this:\n  lprefix\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   (lmap snd E')\n  lprefix (lmap snd (ltake (enat (w' + 1)) E')) (lmap snd E')", "have \"lprefix ?EE'' (lmap snd (ltake (enat (w' + 1)) E')) \\<or> \n        lprefix (lmap snd (ltake (enat (w' + 1)) E')) ?EE''\""], ["proof (prove)\nusing this:\n  lprefix\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   (lmap snd E')\n  lprefix (lmap snd (ltake (enat (w' + 1)) E')) (lmap snd E')\n\ngoal (1 subgoal):\n 1. lprefix\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n     (lmap snd (ltake (enat (w' + 1)) E')) \\<or>\n    lprefix (lmap snd (ltake (enat (w' + 1)) E'))\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))", "by(rule lprefix_down_linear)"], ["proof (state)\nthis:\n  lprefix\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   (lmap snd (ltake (enat (w' + 1)) E')) \\<or>\n  lprefix (lmap snd (ltake (enat (w' + 1)) E'))\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "moreover"], ["proof (state)\nthis:\n  lprefix\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   (lmap snd (ltake (enat (w' + 1)) E')) \\<or>\n  lprefix (lmap snd (ltake (enat (w' + 1)) E'))\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have \"llength (lmap snd (ltake (enat (w' + 1)) E')) = enat (w' + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lmap snd (ltake (enat (w' + 1)) E')) = enat (w' + 1)", "using w'_len"], ["proof (prove)\nusing this:\n  enat w' < llength E'\n\ngoal (1 subgoal):\n 1. llength (lmap snd (ltake (enat (w' + 1)) E')) = enat (w' + 1)", "by(cases \"llength E'\") simp_all"], ["proof (state)\nthis:\n  llength (lmap snd (ltake (enat (w' + 1)) E')) = enat (w' + 1)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "ultimately"], ["proof (chain)\npicking this:\n  lprefix\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   (lmap snd (ltake (enat (w' + 1)) E')) \\<or>\n  lprefix (lmap snd (ltake (enat (w' + 1)) E'))\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n  llength (lmap snd (ltake (enat (w' + 1)) E')) = enat (w' + 1)", "have \"lmap snd (ltake (enat (w' + 1)) E') = ?EE''\""], ["proof (prove)\nusing this:\n  lprefix\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   (lmap snd (ltake (enat (w' + 1)) E')) \\<or>\n  lprefix (lmap snd (ltake (enat (w' + 1)) E'))\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n  llength (lmap snd (ltake (enat (w' + 1)) E')) = enat (w' + 1)\n\ngoal (1 subgoal):\n 1. lmap snd (ltake (enat (w' + 1)) E') =\n    lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))", "using len_EE''"], ["proof (prove)\nusing this:\n  lprefix\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   (lmap snd (ltake (enat (w' + 1)) E')) \\<or>\n  lprefix (lmap snd (ltake (enat (w' + 1)) E'))\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n  llength (lmap snd (ltake (enat (w' + 1)) E')) = enat (w' + 1)\n  llength\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))) =\n  enat (w' + 1)\n\ngoal (1 subgoal):\n 1. lmap snd (ltake (enat (w' + 1)) E') =\n    lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))", "by(auto dest: lprefix_llength_eq_imp_eq)"], ["proof (state)\nthis:\n  lmap snd (ltake (enat (w' + 1)) E') =\n  lmap snd\n   (lappend\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         (ltake (enat m_w) E'')))\n     (llist_of\n       (map (Pair t_w)\n         (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "}"], ["proof (state)\nthis:\n  lmap snd (ltake (enat (w' + 1)) E') =\n  lmap snd\n   (lappend\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         (ltake (enat m_w) E'')))\n     (llist_of\n       (map (Pair t_w)\n         (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "finally"], ["proof (chain)\npicking this:\n  non_speculative P (vs_type_all P)\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))", "have ns1: \"non_speculative P (vs_type_all P) (llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (list_of ?m_E''))))\"\n      and ns2: \"non_speculative P (w_values P (vs_type_all P) (map snd (list_of (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) ?m_E''))))) (llist_of (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))\""], ["proof (prove)\nusing this:\n  non_speculative P (vs_type_all P)\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. non_speculative P (vs_type_all P)\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_w) E''))))) &&&\n    non_speculative P\n     (w_values P (vs_type_all P)\n       (map snd\n         (list_of\n           (lconcat\n             (lmap\n               (\\<lambda>(t, ta).\n                   llist_of\n                    (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n               (ltake (enat m_w) E''))))))\n     (llist_of (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))", "by(simp_all add: lmap_lappend_distrib non_speculative_lappend split_beta lconcat_llist_of[symmetric] lmap_lconcat llist.map_comp o_def split_def list_of_lmap[symmetric] del: list_of_lmap)"], ["proof (state)\nthis:\n  non_speculative P (vs_type_all P)\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_w) E'')))))\n  non_speculative P\n   (w_values P (vs_type_all P)\n     (map snd\n       (list_of\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E''))))))\n   (llist_of (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have \"vs_conf P (vs_type_all P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P (vs_type_all P)", "by simp"], ["proof (state)\nthis:\n  vs_conf P (vs_type_all P)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with \\<sigma>_\\<sigma>' wfx' ns1"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Trsys\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (list_of (ltake (enat m_w) E'')) \\<sigma>'\n  ts_ok (init_fin_lift wfx)\n   (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n   (shr (init_fin_lift_state status (h.start_state f P C M vs)))\n  non_speculative P (vs_type_all P)\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_w) E'')))))\n  vs_conf P (vs_type_all P)", "have wfx': \"ts_ok (init_fin_lift wfx) (thr \\<sigma>') (shr \\<sigma>')\"\n      and vs_conf: \"vs_conf P (w_values P (vs_type_all P) (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (list_of ?m_E''))))\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Trsys\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (list_of (ltake (enat m_w) E'')) \\<sigma>'\n  ts_ok (init_fin_lift wfx)\n   (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n   (shr (init_fin_lift_state status (h.start_state f P C M vs)))\n  non_speculative P (vs_type_all P)\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_w) E'')))))\n  vs_conf P (vs_type_all P)\n\ngoal (1 subgoal):\n 1. ts_ok (init_fin_lift wfx) (thr \\<sigma>') (shr \\<sigma>') &&&\n    vs_conf P\n     (w_values P (vs_type_all P)\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_w) E'')))))", "by(rule h.if_RedT_non_speculative_invar[unfolded h.mthr.if.RedT_def heap_independent])+"], ["proof (state)\nthis:\n  ts_ok (init_fin_lift wfx) (thr \\<sigma>') (shr \\<sigma>')\n  vs_conf P\n   (w_values P (vs_type_all P)\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_w) E'')))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have \"concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (list_of ?m_E'')) = map snd (list_of (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) ?m_E'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n       (list_of (ltake (enat m_w) E''))) =\n    map snd\n     (list_of\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E''))))", "by(simp add: split_def lmap_lconcat llist.map_comp o_def list_of_lconcat map_concat)"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (list_of (ltake (enat m_w) E''))) =\n  map snd\n   (list_of\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         (ltake (enat m_w) E''))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with vs_conf"], ["proof (chain)\npicking this:\n  vs_conf P\n   (w_values P (vs_type_all P)\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_w) E'')))))\n  concat\n   (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (list_of (ltake (enat m_w) E''))) =\n  map snd\n   (list_of\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         (ltake (enat m_w) E''))))", "have \"vs_conf P (w_values P (vs_type_all P) \\<dots>)\""], ["proof (prove)\nusing this:\n  vs_conf P\n   (w_values P (vs_type_all P)\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_w) E'')))))\n  concat\n   (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n     (list_of (ltake (enat m_w) E''))) =\n  map snd\n   (list_of\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         (ltake (enat m_w) E''))))\n\ngoal (1 subgoal):\n 1. vs_conf P\n     (w_values P (vs_type_all P)\n       (map snd\n         (list_of\n           (lconcat\n             (lmap\n               (\\<lambda>(t, ta).\n                   llist_of\n                    (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n               (ltake (enat m_w) E''))))))", "by simp"], ["proof (state)\nthis:\n  vs_conf P\n   (w_values P (vs_type_all P)\n     (map snd\n       (list_of\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E''))))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with red_w wfx' ns2"], ["proof (chain)\npicking this:\n  h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>'''\n  ts_ok (init_fin_lift wfx) (thr \\<sigma>') (shr \\<sigma>')\n  non_speculative P\n   (w_values P (vs_type_all P)\n     (map snd\n       (list_of\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E''))))))\n   (llist_of (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))\n  vs_conf P\n   (w_values P (vs_type_all P)\n     (map snd\n       (list_of\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E''))))))", "have vs_conf': \"vs_conf P (w_values P (w_values P (vs_type_all P) (map snd (list_of (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) ?m_E''))))) (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))\"\n      (is \"vs_conf _ ?vs'\")"], ["proof (prove)\nusing this:\n  h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>'''\n  ts_ok (init_fin_lift wfx) (thr \\<sigma>') (shr \\<sigma>')\n  non_speculative P\n   (w_values P (vs_type_all P)\n     (map snd\n       (list_of\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E''))))))\n   (llist_of (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))\n  vs_conf P\n   (w_values P (vs_type_all P)\n     (map snd\n       (list_of\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E''))))))\n\ngoal (1 subgoal):\n 1. vs_conf P\n     (w_values P\n       (w_values P (vs_type_all P)\n         (map snd\n           (list_of\n             (lconcat\n               (lmap\n                 (\\<lambda>(t, ta).\n                     llist_of\n                      (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                 (ltake (enat m_w) E''))))))\n       (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))", "by(rule h.if_redT_non_speculative_vs_conf[unfolded heap_independent])"], ["proof (state)\nthis:\n  vs_conf P\n   (w_values P\n     (w_values P (vs_type_all P)\n       (map snd\n         (list_of\n           (lconcat\n             (lmap\n               (\\<lambda>(t, ta).\n                   llist_of\n                    (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n               (ltake (enat m_w) E''))))))\n     (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from len_EE''"], ["proof (chain)\npicking this:\n  llength\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))) =\n  enat (w' + 1)", "have \"enat w' < llength ?EE''\""], ["proof (prove)\nusing this:\n  llength\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))))) =\n  enat (w' + 1)\n\ngoal (1 subgoal):\n 1. enat w'\n    < llength\n       (lmap snd\n         (lappend\n           (lconcat\n             (lmap\n               (\\<lambda>(t, ta).\n                   llist_of\n                    (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n               (ltake (enat m_w) E'')))\n           (llist_of\n             (map (Pair t_w)\n               (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))", "by simp"], ["proof (state)\nthis:\n  enat w'\n  < llength\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from w'_len"], ["proof (chain)\npicking this:\n  enat w' < llength E'", "have \"lnth ?EE'' w' = action_obs E' w'\""], ["proof (prove)\nusing this:\n  enat w' < llength E'\n\ngoal (1 subgoal):\n 1. lnth\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n     w' =\n    action_obs E' w'", "using lprefix_lnthD[OF prefix \\<open>enat w' < llength ?EE''\\<close>]"], ["proof (prove)\nusing this:\n  enat w' < llength E'\n  lnth\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   w' =\n  lnth (lmap snd E') w'\n\ngoal (1 subgoal):\n 1. lnth\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n     w' =\n    action_obs E' w'", "by(simp add: action_obs_def)"], ["proof (state)\nthis:\n  lnth\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   w' =\n  action_obs E' w'\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "hence \"\\<dots> \\<in> lset ?EE''\""], ["proof (prove)\nusing this:\n  lnth\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   w' =\n  action_obs E' w'\n\ngoal (1 subgoal):\n 1. action_obs E' w'\n    \\<in> lset\n           (lmap snd\n             (lappend\n               (lconcat\n                 (lmap\n                   (\\<lambda>(t, ta).\n                       llist_of\n                        (map (Pair t)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                   (ltake (enat m_w) E'')))\n               (llist_of\n                 (map (Pair t_w)\n                   (take (n_w + 1)\n                     \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))", "using \\<open>enat w' < llength ?EE''\\<close>"], ["proof (prove)\nusing this:\n  lnth\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   w' =\n  action_obs E' w'\n  enat w'\n  < llength\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. action_obs E' w'\n    \\<in> lset\n           (lmap snd\n             (lappend\n               (lconcat\n                 (lmap\n                   (\\<lambda>(t, ta).\n                       llist_of\n                        (map (Pair t)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                   (ltake (enat m_w) E'')))\n               (llist_of\n                 (map (Pair t_w)\n                   (take (n_w + 1)\n                     \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))", "unfolding lset_conv_lnth"], ["proof (prove)\nusing this:\n  lnth\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n   w' =\n  action_obs E' w'\n  enat w'\n  < llength\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. action_obs E' w'\n    \\<in> {lnth\n            (lmap snd\n              (lappend\n                (lconcat\n                  (lmap\n                    (\\<lambda>(t, ta).\n                        llist_of\n                         (map (Pair t)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (ltake (enat m_w) E'')))\n                (llist_of\n                  (map (Pair t_w)\n                    (take (n_w + 1)\n                      \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n            n |\n           n. enat n\n              < llength\n                 (lmap snd\n                   (lappend\n                     (lconcat\n                       (lmap\n                         (\\<lambda>(t, ta).\n                             llist_of\n                              (map (Pair t)\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                         (ltake (enat m_w) E'')))\n                     (llist_of\n                       (map (Pair t_w)\n                         (take (n_w + 1)\n                           \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))}", "by(auto intro!: exI)"], ["proof (state)\nthis:\n  action_obs E' w'\n  \\<in> lset\n         (lmap snd\n           (lappend\n             (lconcat\n               (lmap\n                 (\\<lambda>(t, ta).\n                     llist_of\n                      (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                 (ltake (enat m_w) E'')))\n             (llist_of\n               (map (Pair t_w)\n                 (take (n_w + 1)\n                   \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "also"], ["proof (state)\nthis:\n  action_obs E' w'\n  \\<in> lset\n         (lmap snd\n           (lappend\n             (lconcat\n               (lmap\n                 (\\<lambda>(t, ta).\n                     llist_of\n                      (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                 (ltake (enat m_w) E'')))\n             (llist_of\n               (map (Pair t_w)\n                 (take (n_w + 1)\n                   \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have \"\\<dots> \\<subseteq> set (map snd (list_of (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) ?m_E''))) @ take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset\n     (lmap snd\n       (lappend\n         (lconcat\n           (lmap\n             (\\<lambda>(t, ta).\n                 llist_of\n                  (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n             (ltake (enat m_w) E'')))\n         (llist_of\n           (map (Pair t_w)\n             (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n    \\<subseteq> set (map snd\n                      (list_of\n                        (lconcat\n                          (lmap\n                            (\\<lambda>(t, ta).\n                                llist_of\n                                 (map (Pair t)\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                            (ltake (enat m_w) E'')))) @\n                     take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)", "by(auto 4 4 intro: rev_image_eqI rev_bexI simp add: split_beta lset_lconcat_lfinite dest: lset_lappend[THEN subsetD])"], ["proof (state)\nthis:\n  lset\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n  \\<subseteq> set (map snd\n                    (list_of\n                      (lconcat\n                        (lmap\n                          (\\<lambda>(t, ta).\n                              llist_of\n                               (map (Pair t)\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                          (ltake (enat m_w) E'')))) @\n                   take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "also"], ["proof (state)\nthis:\n  lset\n   (lmap snd\n     (lappend\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           (ltake (enat m_w) E'')))\n       (llist_of\n         (map (Pair t_w)\n           (take (n_w + 1) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)))))\n  \\<subseteq> set (map snd\n                    (list_of\n                      (lconcat\n                        (lmap\n                          (\\<lambda>(t, ta).\n                              llist_of\n                               (map (Pair t)\n                                 \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                          (ltake (enat m_w) E'')))) @\n                   take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "have \"action_obs E' w' = action_obs E w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action_obs E' w' = action_obs E w", "using False"], ["proof (prove)\nusing this:\n  \\<not> w < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. action_obs E' w' = action_obs E w", "by(simp add: E' w'_def lnth_lappend action_obs_def)"], ["proof (state)\nthis:\n  action_obs E' w' = action_obs E w\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "also"], ["proof (state)\nthis:\n  action_obs E' w' = action_obs E w\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "note obs_w_in_set = calculation and calculation = nothing"], ["proof (state)\nthis:\n  action_obs E w\n  \\<in> set (map snd\n              (list_of\n                (lconcat\n                  (lmap\n                    (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (ltake (enat m_w) E'')))) @\n             take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "from iwa"], ["proof (chain)\npicking this:\n  is_write_action (action_obs E w)", "have \"?v \\<in> w_values P (vs_type_all P) (map snd (list_of (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) ?m_E''))) @ take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>) (ad, al)\""], ["proof (prove)\nusing this:\n  is_write_action (action_obs E w)\n\ngoal (1 subgoal):\n 1. value_written P E w (ad, al)\n    \\<in> w_values P (vs_type_all P)\n           (map snd\n             (list_of\n               (lconcat\n                 (lmap\n                   (\\<lambda>(t, ta).\n                       llist_of\n                        (map (Pair t)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                   (ltake (enat m_w) E'')))) @\n            take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ad, al)", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)\n 2. \\<And>ada ala v.\n       action_obs E w = NormalAction (WriteMem ada ala v) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)", "case (WriteMem ad' al' v')"], ["proof (state)\nthis:\n  action_obs E w = NormalAction (WriteMem ad' al' v')\n\ngoal (2 subgoals):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)\n 2. \\<And>ada ala v.\n       action_obs E w = NormalAction (WriteMem ada ala v) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)", "with adal"], ["proof (chain)\npicking this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (WriteMem ad' al' v')", "have \"ad' = ad\" \"al' = al\" \"?v = v'\""], ["proof (prove)\nusing this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (WriteMem ad' al' v')\n\ngoal (1 subgoal):\n 1. ad' = ad &&& al' = al &&& value_written P E w (ad, al) = v'", "by(simp_all add: value_written.simps)"], ["proof (state)\nthis:\n  ad' = ad\n  al' = al\n  value_written P E w (ad, al) = v'\n\ngoal (2 subgoals):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)\n 2. \\<And>ada ala v.\n       action_obs E w = NormalAction (WriteMem ada ala v) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)", "with obs_w_in_set WriteMem"], ["proof (chain)\npicking this:\n  action_obs E w\n  \\<in> set (map snd\n              (list_of\n                (lconcat\n                  (lmap\n                    (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (ltake (enat m_w) E'')))) @\n             take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n  action_obs E w = NormalAction (WriteMem ad' al' v')\n  ad' = ad\n  al' = al\n  value_written P E w (ad, al) = v'", "show ?thesis"], ["proof (prove)\nusing this:\n  action_obs E w\n  \\<in> set (map snd\n              (list_of\n                (lconcat\n                  (lmap\n                    (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (ltake (enat m_w) E'')))) @\n             take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n  action_obs E w = NormalAction (WriteMem ad' al' v')\n  ad' = ad\n  al' = al\n  value_written P E w (ad, al) = v'\n\ngoal (1 subgoal):\n 1. value_written P E w (ad, al)\n    \\<in> w_values P (vs_type_all P)\n           (map snd\n             (list_of\n               (lconcat\n                 (lmap\n                   (\\<lambda>(t, ta).\n                       llist_of\n                        (map (Pair t)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                   (ltake (enat m_w) E'')))) @\n            take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ad, al)", "by -(rule w_values_WriteMemD, simp)"], ["proof (state)\nthis:\n  value_written P E w (ad, al)\n  \\<in> w_values P (vs_type_all P)\n         (map snd\n           (list_of\n             (lconcat\n               (lmap\n                 (\\<lambda>(t, ta).\n                     llist_of\n                      (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                 (ltake (enat m_w) E'')))) @\n          take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)", "case (NewHeapElem ad' CTn)"], ["proof (state)\nthis:\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)", "with adal"], ["proof (chain)\npicking this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)", "have [simp]: \"ad' = ad\" and v: \"?v = addr_loc_default P CTn al\""], ["proof (prove)\nusing this:\n  (ad, al) \\<in> action_loc P E w\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n\ngoal (1 subgoal):\n 1. ad' = ad &&& value_written P E w (ad, al) = addr_loc_default P CTn al", "by(auto simp add: value_written.simps)"], ["proof (state)\nthis:\n  ad' = ad\n  value_written P E w (ad, al) = addr_loc_default P CTn al\n\ngoal (1 subgoal):\n 1. \\<And>ada hT.\n       action_obs E w = NormalAction (NewHeapElem ada hT) \\<Longrightarrow>\n       value_written P E w (ad, al)\n       \\<in> w_values P (vs_type_all P)\n              (map snd\n                (list_of\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      (ltake (enat m_w) E'')))) @\n               take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n              (ad, al)", "with obs_w_in_set NewHeapElem adal"], ["proof (chain)\npicking this:\n  action_obs E w\n  \\<in> set (map snd\n              (list_of\n                (lconcat\n                  (lmap\n                    (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (ltake (enat m_w) E'')))) @\n             take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n  (ad, al) \\<in> action_loc P E w\n  ad' = ad\n  value_written P E w (ad, al) = addr_loc_default P CTn al", "show ?thesis"], ["proof (prove)\nusing this:\n  action_obs E w\n  \\<in> set (map snd\n              (list_of\n                (lconcat\n                  (lmap\n                    (\\<lambda>a.\n                        case a of\n                        (t, ta) \\<Rightarrow>\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    (ltake (enat m_w) E'')))) @\n             take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n  action_obs E w = NormalAction (NewHeapElem ad' CTn)\n  (ad, al) \\<in> action_loc P E w\n  ad' = ad\n  value_written P E w (ad, al) = addr_loc_default P CTn al\n\ngoal (1 subgoal):\n 1. value_written P E w (ad, al)\n    \\<in> w_values P (vs_type_all P)\n           (map snd\n             (list_of\n               (lconcat\n                 (lmap\n                   (\\<lambda>(t, ta).\n                       llist_of\n                        (map (Pair t)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                   (ltake (enat m_w) E'')))) @\n            take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n           (ad, al)", "by(unfold v)(rule w_values_new_actionD, simp_all)"], ["proof (state)\nthis:\n  value_written P E w (ad, al)\n  \\<in> w_values P (vs_type_all P)\n         (map snd\n           (list_of\n             (lconcat\n               (lmap\n                 (\\<lambda>(t, ta).\n                     llist_of\n                      (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                 (ltake (enat m_w) E'')))) @\n          take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ad, al)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  value_written P E w (ad, al)\n  \\<in> w_values P (vs_type_all P)\n         (map snd\n           (list_of\n             (lconcat\n               (lmap\n                 (\\<lambda>(t, ta).\n                     llist_of\n                      (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                 (ltake (enat m_w) E'')))) @\n          take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ad, al)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "hence \"?v \\<in> ?vs' (ad, al)\""], ["proof (prove)\nusing this:\n  value_written P E w (ad, al)\n  \\<in> w_values P (vs_type_all P)\n         (map snd\n           (list_of\n             (lconcat\n               (lmap\n                 (\\<lambda>(t, ta).\n                     llist_of\n                      (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                 (ltake (enat m_w) E'')))) @\n          take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>)\n         (ad, al)\n\ngoal (1 subgoal):\n 1. value_written P E w (ad, al)\n    \\<in> w_values P\n           (w_values P (vs_type_all P)\n             (map snd\n               (list_of\n                 (lconcat\n                   (lmap\n                     (\\<lambda>(t, ta).\n                         llist_of\n                          (map (Pair t)\n                            \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                     (ltake (enat m_w) E''))))))\n           (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>) (ad, al)", "by simp"], ["proof (state)\nthis:\n  value_written P E w (ad, al)\n  \\<in> w_values P\n         (w_values P (vs_type_all P)\n           (map snd\n             (list_of\n               (lconcat\n                 (lmap\n                   (\\<lambda>(t, ta).\n                       llist_of\n                        (map (Pair t)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                   (ltake (enat m_w) E''))))))\n         (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<not> w < length\n                (lift_start_obs h.start_tid\n                  h.start_heap_obs) \\<Longrightarrow>\n    \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "with vs_conf'"], ["proof (chain)\npicking this:\n  vs_conf P\n   (w_values P\n     (w_values P (vs_type_all P)\n       (map snd\n         (list_of\n           (lconcat\n             (lmap\n               (\\<lambda>(t, ta).\n                   llist_of\n                    (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n               (ltake (enat m_w) E''))))))\n     (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))\n  value_written P E w (ad, al)\n  \\<in> w_values P\n         (w_values P (vs_type_all P)\n           (map snd\n             (list_of\n               (lconcat\n                 (lmap\n                   (\\<lambda>(t, ta).\n                       llist_of\n                        (map (Pair t)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                   (ltake (enat m_w) E''))))))\n         (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>) (ad, al)", "show \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> ?v :\\<le> T\""], ["proof (prove)\nusing this:\n  vs_conf P\n   (w_values P\n     (w_values P (vs_type_all P)\n       (map snd\n         (list_of\n           (lconcat\n             (lmap\n               (\\<lambda>(t, ta).\n                   llist_of\n                    (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n               (ltake (enat m_w) E''))))))\n     (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>))\n  value_written P E w (ad, al)\n  \\<in> w_values P\n         (w_values P (vs_type_all P)\n           (map snd\n             (list_of\n               (lconcat\n                 (lmap\n                   (\\<lambda>(t, ta).\n                       llist_of\n                        (map (Pair t)\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                   (ltake (enat m_w) E''))))))\n         (take (Suc n_w) \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>) (ad, al)\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E w (ad, al) :\\<le> T", "by(rule h.vs_confD[unfolded heap_independent])"], ["proof (state)\nthis:\n  \\<exists>T.\n     P \\<turnstile> ad@al : T \\<and>\n     P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>T.\n     P \\<turnstile> ad@al : T \\<and>\n     P \\<turnstile> value_written P E w (ad, al) :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hb_read_value_typeable:\n  assumes wfx_start: \"ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\" \n    (is \"ts_ok wfx (thr ?start_state) _\")\n  and wfP: \"wf_syscls P\"\n  and E: \"E \\<in> h.\\<E>_start f P C M vs status\"\n  and wf: \"P \\<turnstile> (E, ws) \\<surd>\"\n  and races: \"\\<And>a ad al v. \\<lbrakk> enat a < llength E; action_obs E a = NormalAction (ReadMem ad al v); \\<not> P,E \\<turnstile> ws a \\<le>hb a \\<rbrakk>\n              \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\"\n  and r: \"enat a < llength E\"\n  and read: \"action_obs E a = NormalAction (ReadMem ad al v)\"\n  shows \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "using r read"], ["proof (prove)\nusing this:\n  enat a < llength E\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "proof(induction a arbitrary: ad al v rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ad al v.\n       \\<lbrakk>\\<And>y ad al v.\n                   \\<lbrakk>y < x; enat y < llength E;\n                    action_obs E y = NormalAction (ReadMem ad al v)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat x < llength E;\n        action_obs E x = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "case (less a)"], ["proof (state)\nthis:\n  \\<lbrakk>?y17 < a; enat ?y17 < llength E;\n   action_obs E ?y17 = NormalAction (ReadMem ?ad17 ?al17 ?v17)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       P \\<turnstile> ?ad17@?al17 : T \\<and>\n                       P \\<turnstile> ?v17 :\\<le> T\n  enat a < llength E\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<And>x ad al v.\n       \\<lbrakk>\\<And>y ad al v.\n                   \\<lbrakk>y < x; enat y < llength E;\n                    action_obs E y = NormalAction (ReadMem ad al v)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat x < llength E;\n        action_obs E x = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "note r = \\<open>enat a < llength E\\<close>\n    and read = \\<open>action_obs E a = NormalAction (ReadMem ad al v)\\<close>"], ["proof (state)\nthis:\n  enat a < llength E\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<And>x ad al v.\n       \\<lbrakk>\\<And>y ad al v.\n                   \\<lbrakk>y < x; enat y < llength E;\n                    action_obs E y = NormalAction (ReadMem ad al v)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat x < llength E;\n        action_obs E x = NormalAction (ReadMem ad al v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "proof(cases \"P,E \\<turnstile> ws a \\<le>hb a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n 2. \\<not> P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "case False"], ["proof (state)\nthis:\n  \\<not> P,E \\<turnstile> ws a \\<le>hb a\n\ngoal (2 subgoals):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n 2. \\<not> P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with r read"], ["proof (chain)\npicking this:\n  enat a < llength E\n  action_obs E a = NormalAction (ReadMem ad al v)\n  \\<not> P,E \\<turnstile> ws a \\<le>hb a", "show ?thesis"], ["proof (prove)\nusing this:\n  enat a < llength E\n  action_obs E a = NormalAction (ReadMem ad al v)\n  \\<not> P,E \\<turnstile> ws a \\<le>hb a\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "by(rule races)"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "case True"], ["proof (state)\nthis:\n  P,E \\<turnstile> ws a \\<le>hb a\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "note hb = this"], ["proof (state)\nthis:\n  P,E \\<turnstile> ws a \\<le>hb a\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "hence ao: \"E \\<turnstile> ws a \\<le>a a\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> ws a \\<le>hb a\n\ngoal (1 subgoal):\n 1. E \\<turnstile> ws a \\<le>a a", "by(rule happens_before_into_action_order)"], ["proof (state)\nthis:\n  E \\<turnstile> ws a \\<le>a a\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) \\<surd>", "have ws: \"is_write_seen P E ws\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) \\<surd>\n\ngoal (1 subgoal):\n 1. is_write_seen P E ws", "by(rule wf_exec_is_write_seenD)"], ["proof (state)\nthis:\n  is_write_seen P E ws\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from r"], ["proof (chain)\npicking this:\n  enat a < llength E", "have \"a \\<in> actions E\""], ["proof (prove)\nusing this:\n  enat a < llength E\n\ngoal (1 subgoal):\n 1. a \\<in> actions E", "by(simp add: actions_def)"], ["proof (state)\nthis:\n  a \\<in> actions E\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "hence \"a \\<in> read_actions E\""], ["proof (prove)\nusing this:\n  a \\<in> actions E\n\ngoal (1 subgoal):\n 1. a \\<in> read_actions E", "using read"], ["proof (prove)\nusing this:\n  a \\<in> actions E\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. a \\<in> read_actions E", ".."], ["proof (state)\nthis:\n  a \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from is_write_seenD[OF ws this read]"], ["proof (chain)\npicking this:\n  ws a \\<in> write_actions E \\<and>\n  (ad, al) \\<in> action_loc P E (ws a) \\<and>\n  value_written P E (ws a) (ad, al) = v \\<and>\n  \\<not> P,E \\<turnstile> a \\<le>hb ws a \\<and>\n  (is_volatile P al \\<longrightarrow>\n   \\<not> P,E \\<turnstile> a \\<le>so ws a) \\<and>\n  (\\<forall>a'\\<in>write_actions E.\n      (ad, al) \\<in> action_loc P E a' \\<and>\n      (P,E \\<turnstile> ws a \\<le>hb a' \\<and>\n       P,E \\<turnstile> a' \\<le>hb a \\<or>\n       is_volatile P al \\<and>\n       P,E \\<turnstile> ws a \\<le>so a' \\<and>\n       P,E \\<turnstile> a' \\<le>so a) \\<longrightarrow>\n      a' = ws a)", "have \"write\": \"ws a \\<in> write_actions E\" \n      and adal_w: \"(ad, al) \\<in> action_loc P E (ws a)\"\n      and written: \"value_written P E (ws a) (ad, al) = v\""], ["proof (prove)\nusing this:\n  ws a \\<in> write_actions E \\<and>\n  (ad, al) \\<in> action_loc P E (ws a) \\<and>\n  value_written P E (ws a) (ad, al) = v \\<and>\n  \\<not> P,E \\<turnstile> a \\<le>hb ws a \\<and>\n  (is_volatile P al \\<longrightarrow>\n   \\<not> P,E \\<turnstile> a \\<le>so ws a) \\<and>\n  (\\<forall>a'\\<in>write_actions E.\n      (ad, al) \\<in> action_loc P E a' \\<and>\n      (P,E \\<turnstile> ws a \\<le>hb a' \\<and>\n       P,E \\<turnstile> a' \\<le>hb a \\<or>\n       is_volatile P al \\<and>\n       P,E \\<turnstile> ws a \\<le>so a' \\<and>\n       P,E \\<turnstile> a' \\<le>so a) \\<longrightarrow>\n      a' = ws a)\n\ngoal (1 subgoal):\n 1. ws a \\<in> write_actions E &&&\n    (ad, al) \\<in> action_loc P E (ws a) &&&\n    value_written P E (ws a) (ad, al) = v", "by simp_all"], ["proof (state)\nthis:\n  ws a \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws a)\n  value_written P E (ws a) (ad, al) = v\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from \"write\""], ["proof (chain)\npicking this:\n  ws a \\<in> write_actions E", "have iwa: \"is_write_action (action_obs E (ws a))\""], ["proof (prove)\nusing this:\n  ws a \\<in> write_actions E\n\ngoal (1 subgoal):\n 1. is_write_action (action_obs E (ws a))", "by cases"], ["proof (state)\nthis:\n  is_write_action (action_obs E (ws a))\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "let ?start_state = \"init_fin_lift_state status (h.start_state f P C M vs)\"\n      and ?start_obs = \"lift_start_obs h.start_tid h.start_heap_obs\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> ws a \\<le>hb a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "proof(cases \"ws a < a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n 2. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "case True"], ["proof (state)\nthis:\n  ws a < a\n\ngoal (2 subgoals):\n 1. ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n 2. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "let ?EE'' = \"lmap snd (ltake (enat (ws a)) E)\""], ["proof (state)\ngoal (2 subgoals):\n 1. ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n 2. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have \"non_speculative P (vs_type_all P) ?EE''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_speculative P (vs_type_all P) (lmap snd (ltake (enat (ws a)) E))", "proof(rule non_speculative_nthI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "fix i ad' al' v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "assume i: \"enat i < llength ?EE''\"\n          and nth_i: \"lnth ?EE'' i = NormalAction (ReadMem ad' al' v')\""], ["proof (state)\nthis:\n  enat i < llength (lmap snd (ltake (enat (ws a)) E))\n  lnth (lmap snd (ltake (enat (ws a)) E)) i =\n  NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "from i"], ["proof (chain)\npicking this:\n  enat i < llength (lmap snd (ltake (enat (ws a)) E))", "have \"i < ws a\""], ["proof (prove)\nusing this:\n  enat i < llength (lmap snd (ltake (enat (ws a)) E))\n\ngoal (1 subgoal):\n 1. i < ws a", "by simp"], ["proof (state)\nthis:\n  i < ws a\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "hence i': \"i < a\""], ["proof (prove)\nusing this:\n  i < ws a\n\ngoal (1 subgoal):\n 1. i < a", "using True"], ["proof (prove)\nusing this:\n  i < ws a\n  ws a < a\n\ngoal (1 subgoal):\n 1. i < a", "by(simp)"], ["proof (state)\nthis:\n  i < a\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "moreover"], ["proof (state)\nthis:\n  i < a\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "with r"], ["proof (chain)\npicking this:\n  enat a < llength E\n  i < a", "have \"enat i < llength E\""], ["proof (prove)\nusing this:\n  enat a < llength E\n  i < a\n\ngoal (1 subgoal):\n 1. enat i < llength E", "by(metis enat_ord_code(2) order_less_trans)"], ["proof (state)\nthis:\n  enat i < llength E\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "moreover"], ["proof (state)\nthis:\n  enat i < llength E\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "with nth_i i \\<open>i < ws a\\<close>"], ["proof (chain)\npicking this:\n  lnth (lmap snd (ltake (enat (ws a)) E)) i =\n  NormalAction (ReadMem ad' al' v')\n  enat i < llength (lmap snd (ltake (enat (ws a)) E))\n  i < ws a\n  enat i < llength E", "have \"action_obs E i = NormalAction (ReadMem ad' al' v')\""], ["proof (prove)\nusing this:\n  lnth (lmap snd (ltake (enat (ws a)) E)) i =\n  NormalAction (ReadMem ad' al' v')\n  enat i < llength (lmap snd (ltake (enat (ws a)) E))\n  i < ws a\n  enat i < llength E\n\ngoal (1 subgoal):\n 1. action_obs E i = NormalAction (ReadMem ad' al' v')", "by(simp add: action_obs_def lnth_ltake ac_simps)"], ["proof (state)\nthis:\n  action_obs E i = NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "ultimately"], ["proof (chain)\npicking this:\n  i < a\n  enat i < llength E\n  action_obs E i = NormalAction (ReadMem ad' al' v')", "have \"\\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T\""], ["proof (prove)\nusing this:\n  i < a\n  enat i < llength E\n  action_obs E i = NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T", "by(rule less.IH)"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "hence \"v' \\<in> vs_type_all P (ad', al')\""], ["proof (prove)\nusing this:\n  \\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T\n\ngoal (1 subgoal):\n 1. v' \\<in> vs_type_all P (ad', al')", "by(simp add: vs_type_all.simps)"], ["proof (state)\nthis:\n  v' \\<in> vs_type_all P (ad', al')\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i < llength (lmap snd (ltake (enat (ws a)) E));\n        lnth (lmap snd (ltake (enat (ws a)) E)) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i) (lmap snd (ltake (enat (ws a)) E)))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat (ws a)) E))))\n                                  (ad, al)", "thus \"v' \\<in> w_values P (vs_type_all P) (list_of (ltake (enat i) ?EE'')) (ad', al')\""], ["proof (prove)\nusing this:\n  v' \\<in> vs_type_all P (ad', al')\n\ngoal (1 subgoal):\n 1. v' \\<in> w_values P (vs_type_all P)\n              (list_of (ltake (enat i) (lmap snd (ltake (enat (ws a)) E))))\n              (ad', al')", "by(rule w_values_mono[THEN subsetD])"], ["proof (state)\nthis:\n  v' \\<in> w_values P (vs_type_all P)\n            (list_of (ltake (enat i) (lmap snd (ltake (enat (ws a)) E))))\n            (ad', al')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat (ws a)) E))\n\ngoal (2 subgoals):\n 1. ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n 2. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with wfx_start wfP E \"write\" adal_w"], ["proof (chain)\npicking this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  E \\<in> h.\\<E>_start f P C M vs status\n  ws a \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws a)\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat (ws a)) E))", "show ?thesis"], ["proof (prove)\nusing this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  E \\<in> h.\\<E>_start f P C M vs status\n  ws a \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws a)\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat (ws a)) E))\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "unfolding written[symmetric]"], ["proof (prove)\nusing this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  E \\<in> h.\\<E>_start f P C M vs status\n  ws a \\<in> write_actions E\n  (ad, al) \\<in> action_loc P E (ws a)\n  non_speculative P (vs_type_all P) (lmap snd (ltake (enat (ws a)) E))\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad@al : T \\<and>\n       P \\<turnstile> value_written P E (ws a) (ad, al) :\\<le> T", "by(rule non_speculative_written_value_typeable)"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "case False"], ["proof (state)\nthis:\n  \\<not> ws a < a\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from E"], ["proof (chain)\npicking this:\n  E \\<in> h.\\<E>_start f P C M vs status", "obtain E' where E': \"E = lappend (llist_of ?start_obs) E'\"\n        and \\<E>: \"E' \\<in> h.mthr.if.\\<E> ?start_state\""], ["proof (prove)\nusing this:\n  E \\<in> h.\\<E>_start f P C M vs status\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E =\n                 lappend\n                  (llist_of (lift_start_obs h.start_tid h.start_heap_obs))\n                  E';\n         E' \\<in> h.mthr.if.\\<E>\n                   (init_fin_lift_state status\n                     (h.start_state f P C M vs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E = lappend (llist_of (lift_start_obs h.start_tid h.start_heap_obs)) E'\n  E' \\<in> h.mthr.if.\\<E>\n            (init_fin_lift_state status (h.start_state f P C M vs))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from \\<E>"], ["proof (chain)\npicking this:\n  E' \\<in> h.mthr.if.\\<E>\n            (init_fin_lift_state status (h.start_state f P C M vs))", "obtain E'' where E'': \"E' = lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) E'')\"\n        and Runs: \"h.mthr.if.mthr.Runs ?start_state E''\""], ["proof (prove)\nusing this:\n  E' \\<in> h.mthr.if.\\<E>\n            (init_fin_lift_state status (h.start_state f P C M vs))\n\ngoal (1 subgoal):\n 1. (\\<And>E''.\n        \\<lbrakk>E' =\n                 lconcat\n                  (lmap\n                    (\\<lambda>(t, ta).\n                        llist_of\n                         (map (Pair t)\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                    E'');\n         h.mthr.if.mthr.Runs\n          (init_fin_lift_state status (h.start_state f P C M vs))\n          E''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by-(rule h.mthr.if.\\<E>.cases[OF \\<E>])"], ["proof (state)\nthis:\n  E' =\n  lconcat\n   (lmap\n     (\\<lambda>(t, ta).\n         llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n     E'')\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have wfx': \"ts_ok (init_fin_lift wfx) (thr ?start_state) (shr ?start_state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ok (init_fin_lift wfx)\n     (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n     (shr (init_fin_lift_state status (h.start_state f P C M vs)))", "using wfx_start"], ["proof (prove)\nusing this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n\ngoal (1 subgoal):\n 1. ts_ok (init_fin_lift wfx)\n     (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n     (shr (init_fin_lift_state status (h.start_state f P C M vs)))", "by(simp add: h.shr_start_state)"], ["proof (state)\nthis:\n  ts_ok (init_fin_lift wfx)\n   (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n   (shr (init_fin_lift_state status (h.start_state f P C M vs)))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have a_start: \"\\<not> a < length ?start_obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a < length (lift_start_obs h.start_tid h.start_heap_obs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a < length\n         (lift_start_obs h.start_tid h.start_heap_obs) \\<Longrightarrow>\n    False", "assume \"a < length ?start_obs\""], ["proof (state)\nthis:\n  a < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. a < length\n         (lift_start_obs h.start_tid h.start_heap_obs) \\<Longrightarrow>\n    False", "with read"], ["proof (chain)\npicking this:\n  action_obs E a = NormalAction (ReadMem ad al v)\n  a < length (lift_start_obs h.start_tid h.start_heap_obs)", "have \"NormalAction (ReadMem ad al v) \\<in> snd ` set ?start_obs\""], ["proof (prove)\nusing this:\n  action_obs E a = NormalAction (ReadMem ad al v)\n  a < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. NormalAction (ReadMem ad al v)\n    \\<in> snd ` set (lift_start_obs h.start_tid h.start_heap_obs)", "unfolding set_map[symmetric] in_set_conv_nth"], ["proof (prove)\nusing this:\n  action_obs E a = NormalAction (ReadMem ad al v)\n  a < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length\n                (map snd (lift_start_obs h.start_tid h.start_heap_obs)).\n       map snd (lift_start_obs h.start_tid h.start_heap_obs) ! i =\n       NormalAction (ReadMem ad al v)", "by(auto simp add: E' lnth_lappend action_obs_def)"], ["proof (state)\nthis:\n  NormalAction (ReadMem ad al v)\n  \\<in> snd ` set (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. a < length\n         (lift_start_obs h.start_tid h.start_heap_obs) \\<Longrightarrow>\n    False", "hence \"ReadMem ad al v \\<in> set h.start_heap_obs\""], ["proof (prove)\nusing this:\n  NormalAction (ReadMem ad al v)\n  \\<in> snd ` set (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. ReadMem ad al v \\<in> set h.start_heap_obs", "by auto"], ["proof (state)\nthis:\n  ReadMem ad al v \\<in> set h.start_heap_obs\n\ngoal (1 subgoal):\n 1. a < length\n         (lift_start_obs h.start_tid h.start_heap_obs) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  ReadMem ad al v \\<in> set h.start_heap_obs\n\ngoal (1 subgoal):\n 1. False", "by(simp add: h.start_heap_obs_not_Read)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> a < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "hence ws_a_not_le: \"\\<not> ws a < length ?start_obs\""], ["proof (prove)\nusing this:\n  \\<not> a < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < length (lift_start_obs h.start_tid h.start_heap_obs)", "using False"], ["proof (prove)\nusing this:\n  \\<not> a < length (lift_start_obs h.start_tid h.start_heap_obs)\n  \\<not> ws a < a\n\ngoal (1 subgoal):\n 1. \\<not> ws a < length (lift_start_obs h.start_tid h.start_heap_obs)", "by simp"], ["proof (state)\nthis:\n  \\<not> ws a < length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "define w where \"w = ws a - length ?start_obs\""], ["proof (state)\nthis:\n  w = ws a - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from \"write\" ws_a_not_le w_def"], ["proof (chain)\npicking this:\n  ws a \\<in> write_actions E\n  \\<not> ws a < length (lift_start_obs h.start_tid h.start_heap_obs)\n  w = ws a - length (lift_start_obs h.start_tid h.start_heap_obs)", "have \"enat w < llength (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) E''))\""], ["proof (prove)\nusing this:\n  ws a \\<in> write_actions E\n  \\<not> ws a < length (lift_start_obs h.start_tid h.start_heap_obs)\n  w = ws a - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. enat w\n    < llength\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           E''))", "by(cases \"llength (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) E''))\")(auto simp add: actions_def E' E'' elim: write_actions.cases)"], ["proof (state)\nthis:\n  enat w\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with Runs"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat w\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))", "obtain m_w n_w t_w ta_w \n        where E'_w: \"lnth E' w = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)\"\n        and n_w: \"n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\"\n        and m_w: \"enat m_w < llength E''\"\n        and w_sum: \"w = (\\<Sum>i<m_w. length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) + n_w\"\n        and E''_m_w: \"lnth E'' m_w = (t_w, ta_w)\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat w\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))\n\ngoal (1 subgoal):\n 1. (\\<And>t_w ta_w n_w m_w.\n        \\<lbrakk>lnth E' w =\n                 (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w);\n         n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n         enat m_w < llength E'';\n         w =\n         (\\<Sum>i<m_w.\n             length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n         n_w;\n         lnth E'' m_w = (t_w, ta_w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding E''"], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat w\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))\n\ngoal (1 subgoal):\n 1. (\\<And>t_w ta_w n_w m_w.\n        \\<lbrakk>lnth\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      E''))\n                  w =\n                 (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w);\n         n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>;\n         enat m_w < llength E'';\n         w =\n         (\\<Sum>i<m_w.\n             length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n         n_w;\n         lnth E'' m_w = (t_w, ta_w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule h.mthr.if.actions_\\<E>E_aux)"], ["proof (state)\nthis:\n  lnth E' w = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)\n  n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n  enat m_w < llength E''\n  w =\n  (\\<Sum>i<m_w.\n      length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n  n_w\n  lnth E'' m_w = (t_w, ta_w)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from E'_w"], ["proof (chain)\npicking this:\n  lnth E' w = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)", "have obs_w: \"action_obs E (ws a) = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w\""], ["proof (prove)\nusing this:\n  lnth E' w = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)\n\ngoal (1 subgoal):\n 1. action_obs E (ws a) = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w", "using ws_a_not_le E' w_def"], ["proof (prove)\nusing this:\n  lnth E' w = (t_w, \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w)\n  \\<not> ws a < length (lift_start_obs h.start_tid h.start_heap_obs)\n  E = lappend (llist_of (lift_start_obs h.start_tid h.start_heap_obs)) E'\n  w = ws a - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. action_obs E (ws a) = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w", "by(simp add: action_obs_def lnth_lappend)"], ["proof (state)\nthis:\n  action_obs E (ws a) = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "let ?E'' = \"ldropn (Suc m_w) E''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "let ?m_E'' = \"ltake (enat m_w) E''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have E'_unfold: \"E'' = lappend ?m_E'' (LCons (lnth E'' m_w) ?E'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E'' =\n    lappend (ltake (enat m_w) E'')\n     (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))", "unfolding ldropn_Suc_conv_ldropn[OF m_w]"], ["proof (prove)\ngoal (1 subgoal):\n 1. E'' = lappend (ltake (enat m_w) E'') (ldropn m_w E'')", "by simp"], ["proof (state)\nthis:\n  E'' =\n  lappend (ltake (enat m_w) E'')\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "hence \"h.mthr.if.mthr.Runs ?start_state (lappend ?m_E'' (LCons (lnth E'' m_w) ?E''))\""], ["proof (prove)\nusing this:\n  E'' =\n  lappend (ltake (enat m_w) E'')\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. h.mthr.if.mthr.Runs\n     (init_fin_lift_state status (h.start_state f P C M vs))\n     (lappend (ltake (enat m_w) E'')\n       (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))", "using Runs"], ["proof (prove)\nusing this:\n  E'' =\n  lappend (ltake (enat m_w) E'')\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n\ngoal (1 subgoal):\n 1. h.mthr.if.mthr.Runs\n     (init_fin_lift_state status (h.start_state f P C M vs))\n     (lappend (ltake (enat m_w) E'')\n       (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))", "by simp"], ["proof (state)\nthis:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_w) E'')\n     (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_w) E'')\n     (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))", "obtain \\<sigma>' where \\<sigma>_\\<sigma>': \"h.mthr.if.mthr.Trsys ?start_state (list_of ?m_E'') \\<sigma>'\"\n        and Runs': \"h.mthr.if.mthr.Runs \\<sigma>' (LCons (lnth E'' m_w) ?E'')\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_w) E'')\n     (LCons (lnth E'' m_w) (ldropn (Suc m_w) E'')))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>h.mthr.if.mthr.Trsys\n                  (init_fin_lift_state status (h.start_state f P C M vs))\n                  (list_of (ltake (enat m_w) E'')) \\<sigma>';\n         h.mthr.if.mthr.Runs \\<sigma>'\n          (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule h.mthr.if.mthr.Runs_lappendE) simp"], ["proof (state)\nthis:\n  h.mthr.if.mthr.Trsys\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (list_of (ltake (enat m_w) E'')) \\<sigma>'\n  h.mthr.if.mthr.Runs \\<sigma>'\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from Runs'"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs \\<sigma>'\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))", "obtain \\<sigma>''' where red_w: \"h.mthr.if.redT \\<sigma>' (t_w, ta_w) \\<sigma>'''\"\n        and Runs'': \"h.mthr.if.mthr.Runs \\<sigma>''' ?E''\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs \\<sigma>'\n   (LCons (lnth E'' m_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'''.\n        \\<lbrakk>h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>''';\n         h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_w) E'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding E''_m_w"], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs \\<sigma>' (LCons (t_w, ta_w) (ldropn (Suc m_w) E''))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'''.\n        \\<lbrakk>h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>''';\n         h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_w) E'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>'''\n  h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_w) E'')\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from \"write\" \\<open>a \\<in> read_actions E\\<close>"], ["proof (chain)\npicking this:\n  ws a \\<in> write_actions E\n  a \\<in> read_actions E", "have \"ws a \\<noteq> a\""], ["proof (prove)\nusing this:\n  ws a \\<in> write_actions E\n  a \\<in> read_actions E\n\ngoal (1 subgoal):\n 1. ws a \\<noteq> a", "by(auto dest: read_actions_not_write_actions)"], ["proof (state)\nthis:\n  ws a \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with False"], ["proof (chain)\npicking this:\n  \\<not> ws a < a\n  ws a \\<noteq> a", "have \"ws a > a\""], ["proof (prove)\nusing this:\n  \\<not> ws a < a\n  ws a \\<noteq> a\n\ngoal (1 subgoal):\n 1. a < ws a", "by simp"], ["proof (state)\nthis:\n  a < ws a\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with ao"], ["proof (chain)\npicking this:\n  E \\<turnstile> ws a \\<le>a a\n  a < ws a", "have new: \"is_new_action (action_obs E (ws a))\""], ["proof (prove)\nusing this:\n  E \\<turnstile> ws a \\<le>a a\n  a < ws a\n\ngoal (1 subgoal):\n 1. is_new_action (action_obs E (ws a))", "by(simp add: action_order_def split: if_split_asm)"], ["proof (state)\nthis:\n  is_new_action (action_obs E (ws a))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  is_new_action (action_obs E (ws a))", "obtain CTn where obs_w': \"action_obs E (ws a) = NormalAction (NewHeapElem ad CTn)\""], ["proof (prove)\nusing this:\n  is_new_action (action_obs E (ws a))\n\ngoal (1 subgoal):\n 1. (\\<And>CTn.\n        action_obs E (ws a) =\n        NormalAction (NewHeapElem ad CTn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using adal_w"], ["proof (prove)\nusing this:\n  is_new_action (action_obs E (ws a))\n  (ad, al) \\<in> action_loc P E (ws a)\n\ngoal (1 subgoal):\n 1. (\\<And>CTn.\n        action_obs E (ws a) =\n        NormalAction (NewHeapElem ad CTn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  action_obs E (ws a) = NormalAction (NewHeapElem ad CTn)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "define a' where \"a' = a - length ?start_obs\""], ["proof (state)\nthis:\n  a' = a - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with False w_def"], ["proof (chain)\npicking this:\n  \\<not> ws a < a\n  w = ws a - length (lift_start_obs h.start_tid h.start_heap_obs)\n  a' = a - length (lift_start_obs h.start_tid h.start_heap_obs)", "have \"enat a' < llength (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) E''))\""], ["proof (prove)\nusing this:\n  \\<not> ws a < a\n  w = ws a - length (lift_start_obs h.start_tid h.start_heap_obs)\n  a' = a - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. enat a'\n    < llength\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           E''))", "by(simp add: le_less_trans[OF _ \\<open>enat w < llength (lconcat (lmap (\\<lambda>(t, ta). llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) E''))\\<close>])"], ["proof (state)\nthis:\n  enat a'\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with Runs"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat a'\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))", "obtain m_a n_a t_a ta_a \n        where E'_a: \"lnth E' a' = (t_a, \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a)\"\n        and n_a: \"n_a < length \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\"\n        and m_a: \"enat m_a < llength E''\"\n        and a_sum: \"a' = (\\<Sum>i<m_a. length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) + n_a\"\n        and E''_m_a: \"lnth E'' m_a = (t_a, ta_a)\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat a'\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))\n\ngoal (1 subgoal):\n 1. (\\<And>t_a ta_a n_a m_a.\n        \\<lbrakk>lnth E' a' =\n                 (t_a, \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a);\n         n_a < length \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>;\n         enat m_a < llength E'';\n         a' =\n         (\\<Sum>i<m_a.\n             length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n         n_a;\n         lnth E'' m_a = (t_a, ta_a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding E''"], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n  enat a'\n  < llength\n     (lconcat\n       (lmap\n         (\\<lambda>(t, ta).\n             llist_of (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n         E''))\n\ngoal (1 subgoal):\n 1. (\\<And>t_a ta_a n_a m_a.\n        \\<lbrakk>lnth\n                  (lconcat\n                    (lmap\n                      (\\<lambda>(t, ta).\n                          llist_of\n                           (map (Pair t)\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n                      E''))\n                  a' =\n                 (t_a, \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a);\n         n_a < length \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>;\n         enat m_a < llength E'';\n         a' =\n         (\\<Sum>i<m_a.\n             length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n         n_a;\n         lnth E'' m_a = (t_a, ta_a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule h.mthr.if.actions_\\<E>E_aux)"], ["proof (state)\nthis:\n  lnth E' a' = (t_a, \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a)\n  n_a < length \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\n  enat m_a < llength E''\n  a' =\n  (\\<Sum>i<m_a.\n      length \\<lbrace>snd (lnth E'' i)\\<rbrace>\\<^bsub>o\\<^esub>) +\n  n_a\n  lnth E'' m_a = (t_a, ta_a)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from a_start E'_a read"], ["proof (chain)\npicking this:\n  \\<not> a < length (lift_start_obs h.start_tid h.start_heap_obs)\n  lnth E' a' = (t_a, \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a)\n  action_obs E a = NormalAction (ReadMem ad al v)", "have obs_a: \"\\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a = NormalAction (ReadMem ad al v)\""], ["proof (prove)\nusing this:\n  \\<not> a < length (lift_start_obs h.start_tid h.start_heap_obs)\n  lnth E' a' = (t_a, \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a)\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a =\n    NormalAction (ReadMem ad al v)", "using E' w_def"], ["proof (prove)\nusing this:\n  \\<not> a < length (lift_start_obs h.start_tid h.start_heap_obs)\n  lnth E' a' = (t_a, \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a)\n  action_obs E a = NormalAction (ReadMem ad al v)\n  E = lappend (llist_of (lift_start_obs h.start_tid h.start_heap_obs)) E'\n  w = ws a - length (lift_start_obs h.start_tid h.start_heap_obs)\n\ngoal (1 subgoal):\n 1. \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a =\n    NormalAction (ReadMem ad al v)", "by(simp add: action_obs_def lnth_lappend a'_def)"], ["proof (state)\nthis:\n  \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a =\n  NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "let ?E'' = \"ldropn (Suc m_a) E''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "let ?m_E'' = \"ltake (enat m_a) E''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have E'_unfold: \"E'' = lappend ?m_E'' (LCons (lnth E'' m_a) ?E'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E'' =\n    lappend (ltake (enat m_a) E'')\n     (LCons (lnth E'' m_a) (ldropn (Suc m_a) E''))", "unfolding ldropn_Suc_conv_ldropn[OF m_a]"], ["proof (prove)\ngoal (1 subgoal):\n 1. E'' = lappend (ltake (enat m_a) E'') (ldropn m_a E'')", "by simp"], ["proof (state)\nthis:\n  E'' =\n  lappend (ltake (enat m_a) E'')\n   (LCons (lnth E'' m_a) (ldropn (Suc m_a) E''))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "hence \"h.mthr.if.mthr.Runs ?start_state (lappend ?m_E'' (LCons (lnth E'' m_a) ?E''))\""], ["proof (prove)\nusing this:\n  E'' =\n  lappend (ltake (enat m_a) E'')\n   (LCons (lnth E'' m_a) (ldropn (Suc m_a) E''))\n\ngoal (1 subgoal):\n 1. h.mthr.if.mthr.Runs\n     (init_fin_lift_state status (h.start_state f P C M vs))\n     (lappend (ltake (enat m_a) E'')\n       (LCons (lnth E'' m_a) (ldropn (Suc m_a) E'')))", "using Runs"], ["proof (prove)\nusing this:\n  E'' =\n  lappend (ltake (enat m_a) E'')\n   (LCons (lnth E'' m_a) (ldropn (Suc m_a) E''))\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs)) E''\n\ngoal (1 subgoal):\n 1. h.mthr.if.mthr.Runs\n     (init_fin_lift_state status (h.start_state f P C M vs))\n     (lappend (ltake (enat m_a) E'')\n       (LCons (lnth E'' m_a) (ldropn (Suc m_a) E'')))", "by simp"], ["proof (state)\nthis:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_a) E'')\n     (LCons (lnth E'' m_a) (ldropn (Suc m_a) E'')))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_a) E'')\n     (LCons (lnth E'' m_a) (ldropn (Suc m_a) E'')))", "obtain \\<sigma>'' where \\<sigma>_\\<sigma>'': \"h.mthr.if.mthr.Trsys ?start_state (list_of ?m_E'') \\<sigma>''\"\n        and Runs'': \"h.mthr.if.mthr.Runs \\<sigma>'' (LCons (lnth E'' m_a) ?E'')\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (lappend (ltake (enat m_a) E'')\n     (LCons (lnth E'' m_a) (ldropn (Suc m_a) E'')))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''.\n        \\<lbrakk>h.mthr.if.mthr.Trsys\n                  (init_fin_lift_state status (h.start_state f P C M vs))\n                  (list_of (ltake (enat m_a) E'')) \\<sigma>'';\n         h.mthr.if.mthr.Runs \\<sigma>''\n          (LCons (lnth E'' m_a) (ldropn (Suc m_a) E''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule h.mthr.if.mthr.Runs_lappendE) simp"], ["proof (state)\nthis:\n  h.mthr.if.mthr.Trsys\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (list_of (ltake (enat m_a) E'')) \\<sigma>''\n  h.mthr.if.mthr.Runs \\<sigma>''\n   (LCons (lnth E'' m_a) (ldropn (Suc m_a) E''))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from Runs''"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Runs \\<sigma>''\n   (LCons (lnth E'' m_a) (ldropn (Suc m_a) E''))", "obtain \\<sigma>''' where red_a: \"h.mthr.if.redT \\<sigma>'' (t_a, ta_a) \\<sigma>'''\"\n        and Runs'': \"h.mthr.if.mthr.Runs \\<sigma>''' ?E''\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs \\<sigma>''\n   (LCons (lnth E'' m_a) (ldropn (Suc m_a) E''))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'''.\n        \\<lbrakk>h.mthr.if.redT_syntax1 \\<sigma>'' t_a ta_a \\<sigma>''';\n         h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_a) E'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding E''_m_a"], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Runs \\<sigma>'' (LCons (t_a, ta_a) (ldropn (Suc m_a) E''))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'''.\n        \\<lbrakk>h.mthr.if.redT_syntax1 \\<sigma>'' t_a ta_a \\<sigma>''';\n         h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_a) E'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  h.mthr.if.redT_syntax1 \\<sigma>'' t_a ta_a \\<sigma>'''\n  h.mthr.if.mthr.Runs \\<sigma>''' (ldropn (Suc m_a) E'')\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "let ?EE'' = \"llist_of (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (list_of ?m_E'')))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from m_a"], ["proof (chain)\npicking this:\n  enat m_a < llength E''", "have \"enat m_a \\<le> llength E''\""], ["proof (prove)\nusing this:\n  enat m_a < llength E''\n\ngoal (1 subgoal):\n 1. enat m_a \\<le> llength E''", "by simp"], ["proof (state)\nthis:\n  enat m_a \\<le> llength E''\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "hence len_EE'': \"llength ?EE'' = enat (a' - n_a)\""], ["proof (prove)\nusing this:\n  enat m_a \\<le> llength E''\n\ngoal (1 subgoal):\n 1. llength\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E''))))) =\n    enat (a' - n_a)", "by(simp add: a_sum length_concat sum_list_sum_nth atLeast0LessThan length_list_of_conv_the_enat min_def split_beta lnth_ltake)"], ["proof (state)\nthis:\n  llength\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E''))))) =\n  enat (a' - n_a)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have prefix: \"lprefix ?EE'' (lmap snd E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E'')))))\n     (lmap snd E')", "unfolding E''"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E'')))))\n     (lmap snd\n       (lconcat\n         (lmap\n           (\\<lambda>(t, ta).\n               llist_of\n                (map (Pair t) \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n           E'')))", "by(subst (2) E'_unfold)(simp add: lmap_lappend_distrib  lmap_lconcat llist.map_comp o_def split_def lconcat_llist_of[symmetric] lmap_llist_of[symmetric] lprefix_lappend2I del: lmap_llist_of)"], ["proof (state)\nthis:\n  lprefix\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n   (lmap snd E')\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have ns: \"non_speculative P (vs_type_all P) ?EE''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_speculative P (vs_type_all P)\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E'')))))", "proof(rule non_speculative_nthI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "fix i ad' al' v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "assume i: \"enat i < llength ?EE''\"\n          and lnth_i: \"lnth ?EE'' i = NormalAction (ReadMem ad' al' v')\"\n          and \"non_speculative P (vs_type_all P) (ltake (enat i) ?EE'')\""], ["proof (state)\nthis:\n  enat i\n  < llength\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E'')))))\n  lnth\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n   i =\n  NormalAction (ReadMem ad' al' v')\n  non_speculative P (vs_type_all P)\n   (ltake (enat i)\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E''))))))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "let ?i = \"i + length ?start_obs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "from i len_EE''"], ["proof (chain)\npicking this:\n  enat i\n  < llength\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E'')))))\n  llength\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E''))))) =\n  enat (a' - n_a)", "have \"i < a'\""], ["proof (prove)\nusing this:\n  enat i\n  < llength\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E'')))))\n  llength\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E''))))) =\n  enat (a' - n_a)\n\ngoal (1 subgoal):\n 1. i < a'", "by simp"], ["proof (state)\nthis:\n  i < a'\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "hence i': \"?i < a\""], ["proof (prove)\nusing this:\n  i < a'\n\ngoal (1 subgoal):\n 1. i + length (lift_start_obs h.start_tid h.start_heap_obs) < a", "by(simp add: a'_def)"], ["proof (state)\nthis:\n  i + length (lift_start_obs h.start_tid h.start_heap_obs) < a\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "moreover"], ["proof (state)\nthis:\n  i + length (lift_start_obs h.start_tid h.start_heap_obs) < a\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "hence \"enat ?i < llength E\""], ["proof (prove)\nusing this:\n  i + length (lift_start_obs h.start_tid h.start_heap_obs) < a\n\ngoal (1 subgoal):\n 1. enat (i + length (lift_start_obs h.start_tid h.start_heap_obs))\n    < llength E", "using \\<open>enat a < llength E\\<close>"], ["proof (prove)\nusing this:\n  i + length (lift_start_obs h.start_tid h.start_heap_obs) < a\n  enat a < llength E\n\ngoal (1 subgoal):\n 1. enat (i + length (lift_start_obs h.start_tid h.start_heap_obs))\n    < llength E", "by(simp add: less_trans[where y=\"enat a\"])"], ["proof (state)\nthis:\n  enat (i + length (lift_start_obs h.start_tid h.start_heap_obs))\n  < llength E\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "moreover"], ["proof (state)\nthis:\n  enat (i + length (lift_start_obs h.start_tid h.start_heap_obs))\n  < llength E\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "have \"enat i < llength E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < llength E'", "using i"], ["proof (prove)\nusing this:\n  enat i\n  < llength\n     (llist_of\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E'')))))\n\ngoal (1 subgoal):\n 1. enat i < llength E'", "by -(rule less_le_trans[OF _ lprefix_llength_le[OF prefix], simplified], simp)"], ["proof (state)\nthis:\n  enat i < llength E'\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "from lprefix_lnthD[OF prefix i] lnth_i"], ["proof (chain)\npicking this:\n  lnth\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n   i =\n  lnth (lmap snd E') i\n  lnth\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n   i =\n  NormalAction (ReadMem ad' al' v')", "have \"lnth (lmap snd E') i = NormalAction (ReadMem ad' al' v')\""], ["proof (prove)\nusing this:\n  lnth\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n   i =\n  lnth (lmap snd E') i\n  lnth\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n   i =\n  NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. lnth (lmap snd E') i = NormalAction (ReadMem ad' al' v')", "by simp"], ["proof (state)\nthis:\n  lnth (lmap snd E') i = NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "hence \"action_obs E ?i = NormalAction (ReadMem ad' al' v')\""], ["proof (prove)\nusing this:\n  lnth (lmap snd E') i = NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. action_obs E\n     (i + length (lift_start_obs h.start_tid h.start_heap_obs)) =\n    NormalAction (ReadMem ad' al' v')", "using \\<open>enat i < llength E'\\<close>"], ["proof (prove)\nusing this:\n  lnth (lmap snd E') i = NormalAction (ReadMem ad' al' v')\n  enat i < llength E'\n\ngoal (1 subgoal):\n 1. action_obs E\n     (i + length (lift_start_obs h.start_tid h.start_heap_obs)) =\n    NormalAction (ReadMem ad' al' v')", "by(simp add: E' action_obs_def lnth_lappend E'')"], ["proof (state)\nthis:\n  action_obs E (i + length (lift_start_obs h.start_tid h.start_heap_obs)) =\n  NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "ultimately"], ["proof (chain)\npicking this:\n  i + length (lift_start_obs h.start_tid h.start_heap_obs) < a\n  enat (i + length (lift_start_obs h.start_tid h.start_heap_obs))\n  < llength E\n  action_obs E (i + length (lift_start_obs h.start_tid h.start_heap_obs)) =\n  NormalAction (ReadMem ad' al' v')", "have \"\\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T\""], ["proof (prove)\nusing this:\n  i + length (lift_start_obs h.start_tid h.start_heap_obs) < a\n  enat (i + length (lift_start_obs h.start_tid h.start_heap_obs))\n  < llength E\n  action_obs E (i + length (lift_start_obs h.start_tid h.start_heap_obs)) =\n  NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T", "by(rule less.IH)"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "hence \"v' \\<in> vs_type_all P (ad', al')\""], ["proof (prove)\nusing this:\n  \\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T\n\ngoal (1 subgoal):\n 1. v' \\<in> vs_type_all P (ad', al')", "by(simp add: vs_type_all.simps)"], ["proof (state)\nthis:\n  v' \\<in> vs_type_all P (ad', al')\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (llist_of\n                     (concat\n                       (map (\\<lambda>(t, ta).\n                                \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                         (list_of (ltake (enat m_a) E'')))));\n        lnth\n         (llist_of\n           (concat\n             (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n               (list_of (ltake (enat m_a) E'')))))\n         i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (llist_of\n             (concat\n               (map (\\<lambda>(t, ta).\n                        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                 (list_of (ltake (enat m_a) E''))))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(llist_of\n  (concat\n    (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n      (list_of (ltake (enat m_a) E'')))))))\n                                  (ad, al)", "thus \"v' \\<in> w_values P (vs_type_all P) (list_of (ltake (enat i) ?EE'')) (ad', al')\""], ["proof (prove)\nusing this:\n  v' \\<in> vs_type_all P (ad', al')\n\ngoal (1 subgoal):\n 1. v' \\<in> w_values P (vs_type_all P)\n              (list_of\n                (ltake (enat i)\n                  (llist_of\n                    (concat\n                      (map (\\<lambda>(t, ta).\n                               \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                        (list_of (ltake (enat m_a) E'')))))))\n              (ad', al')", "by(rule w_values_mono[THEN subsetD])"], ["proof (state)\nthis:\n  v' \\<in> w_values P (vs_type_all P)\n            (list_of\n              (ltake (enat i)\n                (llist_of\n                  (concat\n                    (map (\\<lambda>(t, ta).\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n                      (list_of (ltake (enat m_a) E'')))))))\n            (ad', al')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  non_speculative P (vs_type_all P)\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have \"vs_conf P (vs_type_all P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P (vs_type_all P)", "by simp"], ["proof (state)\nthis:\n  vs_conf P (vs_type_all P)\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with \\<sigma>_\\<sigma>'' wfx' ns"], ["proof (chain)\npicking this:\n  h.mthr.if.mthr.Trsys\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (list_of (ltake (enat m_a) E'')) \\<sigma>''\n  ts_ok (init_fin_lift wfx)\n   (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n   (shr (init_fin_lift_state status (h.start_state f P C M vs)))\n  non_speculative P (vs_type_all P)\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n  vs_conf P (vs_type_all P)", "have wfx'': \"ts_ok (init_fin_lift wfx) (thr \\<sigma>'') (shr \\<sigma>'')\" \n        and vs'': \"vs_conf P (w_values P (vs_type_all P) (concat (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>) (list_of ?m_E''))))\""], ["proof (prove)\nusing this:\n  h.mthr.if.mthr.Trsys\n   (init_fin_lift_state status (h.start_state f P C M vs))\n   (list_of (ltake (enat m_a) E'')) \\<sigma>''\n  ts_ok (init_fin_lift wfx)\n   (thr (init_fin_lift_state status (h.start_state f P C M vs)))\n   (shr (init_fin_lift_state status (h.start_state f P C M vs)))\n  non_speculative P (vs_type_all P)\n   (llist_of\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n  vs_conf P (vs_type_all P)\n\ngoal (1 subgoal):\n 1. ts_ok (init_fin_lift wfx) (thr \\<sigma>'') (shr \\<sigma>'') &&&\n    vs_conf P\n     (w_values P (vs_type_all P)\n       (concat\n         (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n           (list_of (ltake (enat m_a) E'')))))", "by(rule h.if_RedT_non_speculative_invar[unfolded heap_independent h.mthr.if.RedT_def])+"], ["proof (state)\nthis:\n  ts_ok (init_fin_lift wfx) (thr \\<sigma>'') (shr \\<sigma>'')\n  vs_conf P\n   (w_values P (vs_type_all P)\n     (concat\n       (map (\\<lambda>(t, ta). \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\n         (list_of (ltake (enat m_a) E'')))))\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "note red_w"], ["proof (state)\nthis:\n  h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>'''__\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "moreover"], ["proof (state)\nthis:\n  h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>'''__\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from n_w obs_w obs_w'"], ["proof (chain)\npicking this:\n  n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n  action_obs E (ws a) = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w\n  action_obs E (ws a) = NormalAction (NewHeapElem ad CTn)", "have \"NormalAction (NewHeapElem ad CTn) \\<in> set \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\nusing this:\n  n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n  action_obs E (ws a) = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w\n  action_obs E (ws a) = NormalAction (NewHeapElem ad CTn)\n\ngoal (1 subgoal):\n 1. NormalAction (NewHeapElem ad CTn)\n    \\<in> set \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  n_w < length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n  action_obs E (ws a) = \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! n_w\n  action_obs E (ws a) = NormalAction (NewHeapElem ad CTn)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>.\n       \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n       NormalAction (NewHeapElem ad CTn)", "by auto"], ["proof (state)\nthis:\n  NormalAction (NewHeapElem ad CTn)\n  \\<in> set \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "moreover"], ["proof (state)\nthis:\n  NormalAction (NewHeapElem ad CTn)\n  \\<in> set \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "have ta_a_read: \"NormalAction (ReadMem ad al v) \\<in> set \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NormalAction (ReadMem ad al v)\n    \\<in> set \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>", "using n_a obs_a"], ["proof (prove)\nusing this:\n  n_a < length \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\n  \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a =\n  NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. NormalAction (ReadMem ad al v)\n    \\<in> set \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  n_a < length \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\n  \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a =\n  NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>.\n       \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n       NormalAction (ReadMem ad al v)", "by blast"], ["proof (state)\nthis:\n  NormalAction (ReadMem ad al v)\n  \\<in> set \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from red_a"], ["proof (chain)\npicking this:\n  h.mthr.if.redT_syntax1 \\<sigma>'' t_a ta_a \\<sigma>'''", "have \"\\<exists>T. P \\<turnstile> ad@al : T\""], ["proof (prove)\nusing this:\n  h.mthr.if.redT_syntax1 \\<sigma>'' t_a ta_a \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>h.mthr.if.r_syntax t_a x (shr \\<sigma>'') ta_a x' m';\n        thr \\<sigma>'' t_a = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        h.mthr.if.actions_ok \\<sigma>'' t_a ta_a;\n        redT_upd \\<sigma>'' t_a ta_a x' m' \\<sigma>'''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T\n 2. \\<And>x n ln.\n       \\<lbrakk>ta_a =\n                (K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr \\<sigma>'' t_a = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset \\<sigma>'' t_a);\n        may_acquire_all (locks \\<sigma>'') t_a ln; 0 < ln $ n;\n        \\<sigma>''' =\n        (acquire_all (locks \\<sigma>'') t_a ln,\n         (thr \\<sigma>''(t_a \\<mapsto> (x, no_wait_locks)), shr \\<sigma>''),\n         wset \\<sigma>'', interrupts \\<sigma>'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T", "case (redT_normal x x' h')"], ["proof (state)\nthis:\n  h.mthr.if.r_syntax t_a x (shr \\<sigma>'') ta_a x' h'\n  thr \\<sigma>'' t_a = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  h.mthr.if.actions_ok \\<sigma>'' t_a ta_a\n  redT_upd \\<sigma>'' t_a ta_a x' h' \\<sigma>'''\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>h.mthr.if.r_syntax t_a x (shr \\<sigma>'') ta_a x' m';\n        thr \\<sigma>'' t_a = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        h.mthr.if.actions_ok \\<sigma>'' t_a ta_a;\n        redT_upd \\<sigma>'' t_a ta_a x' m' \\<sigma>'''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T\n 2. \\<And>x n ln.\n       \\<lbrakk>ta_a =\n                (K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr \\<sigma>'' t_a = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset \\<sigma>'' t_a);\n        may_acquire_all (locks \\<sigma>'') t_a ln; 0 < ln $ n;\n        \\<sigma>''' =\n        (acquire_all (locks \\<sigma>'') t_a ln,\n         (thr \\<sigma>''(t_a \\<mapsto> (x, no_wait_locks)), shr \\<sigma>''),\n         wset \\<sigma>'', interrupts \\<sigma>'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T", "from wfx'' \\<open>thr \\<sigma>'' t_a = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  ts_ok (init_fin_lift wfx) (thr \\<sigma>'') (shr \\<sigma>'')\n  thr \\<sigma>'' t_a = \\<lfloor>(x, no_wait_locks)\\<rfloor>", "have \"init_fin_lift wfx t_a x (shr \\<sigma>'')\""], ["proof (prove)\nusing this:\n  ts_ok (init_fin_lift wfx) (thr \\<sigma>'') (shr \\<sigma>'')\n  thr \\<sigma>'' t_a = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. init_fin_lift wfx t_a x (shr \\<sigma>'')", "by(rule ts_okD)"], ["proof (state)\nthis:\n  init_fin_lift wfx t_a x (shr \\<sigma>'')\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>h.mthr.if.r_syntax t_a x (shr \\<sigma>'') ta_a x' m';\n        thr \\<sigma>'' t_a = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        h.mthr.if.actions_ok \\<sigma>'' t_a ta_a;\n        redT_upd \\<sigma>'' t_a ta_a x' m' \\<sigma>'''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T\n 2. \\<And>x n ln.\n       \\<lbrakk>ta_a =\n                (K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr \\<sigma>'' t_a = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset \\<sigma>'' t_a);\n        may_acquire_all (locks \\<sigma>'') t_a ln; 0 < ln $ n;\n        \\<sigma>''' =\n        (acquire_all (locks \\<sigma>'') t_a ln,\n         (thr \\<sigma>''(t_a \\<mapsto> (x, no_wait_locks)), shr \\<sigma>''),\n         wset \\<sigma>'', interrupts \\<sigma>'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T", "with \\<open>t_a \\<turnstile> (x, shr \\<sigma>'') -ta_a\\<rightarrow>i (x', h')\\<close>"], ["proof (chain)\npicking this:\n  h.mthr.if.r_syntax t_a x (shr \\<sigma>'') ta_a x' h'\n  init_fin_lift wfx t_a x (shr \\<sigma>'')", "show ?thesis"], ["proof (prove)\nusing this:\n  h.mthr.if.r_syntax t_a x (shr \\<sigma>'') ta_a x' h'\n  init_fin_lift wfx t_a x (shr \\<sigma>'')\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T", "using ta_a_read"], ["proof (prove)\nusing this:\n  h.mthr.if.r_syntax t_a x (shr \\<sigma>'') ta_a x' h'\n  init_fin_lift wfx t_a x (shr \\<sigma>'')\n  NormalAction (ReadMem ad al v)\n  \\<in> set \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T", "by(rule h.init_fin_red_read_typeable[unfolded heap_independent])"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta_a =\n                (K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr \\<sigma>'' t_a = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset \\<sigma>'' t_a);\n        may_acquire_all (locks \\<sigma>'') t_a ln; 0 < ln $ n;\n        \\<sigma>''' =\n        (acquire_all (locks \\<sigma>'') t_a ln,\n         (thr \\<sigma>''(t_a \\<mapsto> (x, no_wait_locks)), shr \\<sigma>''),\n         wset \\<sigma>'', interrupts \\<sigma>'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta_a =\n                (K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr \\<sigma>'' t_a = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset \\<sigma>'' t_a);\n        may_acquire_all (locks \\<sigma>'') t_a ln; 0 < ln $ n;\n        \\<sigma>''' =\n        (acquire_all (locks \\<sigma>'') t_a ln,\n         (thr \\<sigma>''(t_a \\<mapsto> (x, no_wait_locks)), shr \\<sigma>''),\n         wset \\<sigma>'', interrupts \\<sigma>'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T", "case redT_acquire"], ["proof (state)\nthis:\n  ta_a = (K$ [], [], [], [], [], (map NormalAction \\<circ> convert_RA) ln_)\n  thr \\<sigma>'' t_a = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset \\<sigma>'' t_a)\n  may_acquire_all (locks \\<sigma>'') t_a ln_\n  0 < ln_ $ n_\n  \\<sigma>''' =\n  (acquire_all (locks \\<sigma>'') t_a ln_,\n   (thr \\<sigma>''(t_a \\<mapsto> (x_, no_wait_locks)), shr \\<sigma>''),\n   wset \\<sigma>'', interrupts \\<sigma>'')\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta_a =\n                (K$ [], [], [], [], [],\n                 (map NormalAction \\<circ> convert_RA) ln);\n        thr \\<sigma>'' t_a = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset \\<sigma>'' t_a);\n        may_acquire_all (locks \\<sigma>'') t_a ln; 0 < ln $ n;\n        \\<sigma>''' =\n        (acquire_all (locks \\<sigma>'') t_a ln,\n         (thr \\<sigma>''(t_a \\<mapsto> (x, no_wait_locks)), shr \\<sigma>''),\n         wset \\<sigma>'', interrupts \\<sigma>'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T", "thus ?thesis"], ["proof (prove)\nusing this:\n  ta_a = (K$ [], [], [], [], [], (map NormalAction \\<circ> convert_RA) ln_)\n  thr \\<sigma>'' t_a = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset \\<sigma>'' t_a)\n  may_acquire_all (locks \\<sigma>'') t_a ln_\n  0 < ln_ $ n_\n  \\<sigma>''' =\n  (acquire_all (locks \\<sigma>'') t_a ln_,\n   (thr \\<sigma>''(t_a \\<mapsto> (x_, no_wait_locks)), shr \\<sigma>''),\n   wset \\<sigma>'', interrupts \\<sigma>'')\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T", "using n_a obs_a ta_a_read"], ["proof (prove)\nusing this:\n  ta_a = (K$ [], [], [], [], [], (map NormalAction \\<circ> convert_RA) ln_)\n  thr \\<sigma>'' t_a = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset \\<sigma>'' t_a)\n  may_acquire_all (locks \\<sigma>'') t_a ln_\n  0 < ln_ $ n_\n  \\<sigma>''' =\n  (acquire_all (locks \\<sigma>'') t_a ln_,\n   (thr \\<sigma>''(t_a \\<mapsto> (x_, no_wait_locks)), shr \\<sigma>''),\n   wset \\<sigma>'', interrupts \\<sigma>'')\n  n_a < length \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\n  \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub> ! n_a =\n  NormalAction (ReadMem ad al v)\n  NormalAction (ReadMem ad al v)\n  \\<in> set \\<lbrace>ta_a\\<rbrace>\\<^bsub>o\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T", "by auto"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "hence \"typeof_addr ad \\<noteq> None\""], ["proof (prove)\nusing this:\n  \\<exists>T. P \\<turnstile> ad@al : T\n\ngoal (1 subgoal):\n 1. typeof_addr ad \\<noteq> None", "by(auto elim: addr_loc_type_cases)"], ["proof (state)\nthis:\n  typeof_addr ad \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "ultimately"], ["proof (chain)\npicking this:\n  h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>'''__\n  NormalAction (NewHeapElem ad CTn)\n  \\<in> set \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n  typeof_addr ad \\<noteq> None", "have \"typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\nusing this:\n  h.mthr.if.redT_syntax1 \\<sigma>' t_w ta_w \\<sigma>'''__\n  NormalAction (NewHeapElem ad CTn)\n  \\<in> set \\<lbrace>ta_w\\<rbrace>\\<^bsub>o\\<^esub>\n  typeof_addr ad \\<noteq> None\n\ngoal (1 subgoal):\n 1. typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(rule if_redT_NewHeapElem_typed)"], ["proof (state)\nthis:\n  typeof_addr ad = \\<lfloor>CTn\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> ws a < a \\<Longrightarrow>\n    \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with written adal_w obs_w'"], ["proof (chain)\npicking this:\n  value_written P E (ws a) (ad, al) = v\n  (ad, al) \\<in> action_loc P E (ws a)\n  action_obs E (ws a) = NormalAction (NewHeapElem ad CTn)\n  typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  value_written P E (ws a) (ad, al) = v\n  (ad, al) \\<in> action_loc P E (ws a)\n  action_obs E (ws a) = NormalAction (NewHeapElem ad CTn)\n  typeof_addr ad = \\<lfloor>CTn\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "by(cases al)(auto simp add: value_written.simps intro: addr_loc_type_intros h.addr_loc_default_conf[unfolded heap_independent])"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem \n  assumes wfx_start: \"ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\" \n  and wfP: \"wf_syscls P\"\n  and justified: \"P \\<turnstile> (E, ws) weakly_justified_by J\"\n  and J: \"range (justifying_exec \\<circ> J) \\<subseteq> h.\\<E>_start f P C M vs status\"\n  shows read_value_typeable_justifying:\n    \"\\<lbrakk> 0 < n; enat a < llength (justifying_exec (J n));\n      action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\" \n  and read_value_typeable_justifed:\n    \"\\<lbrakk> E \\<in> h.\\<E>_start f P C M vs status; P \\<turnstile> (E, ws) \\<surd>;\n       enat a < llength E; action_obs E a = NormalAction (ReadMem ad al v) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 < n; enat a < llength (justifying_exec (J n));\n      action_obs (justifying_exec (J n)) a =\n      NormalAction (ReadMem ad al v)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>T.\n                          P \\<turnstile> ad@al : T \\<and>\n                          P \\<turnstile> v :\\<le> T) &&&\n    (\\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n      P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n      action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>T.\n                          P \\<turnstile> ad@al : T \\<and>\n                          P \\<turnstile> v :\\<le> T)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; enat a < llength (justifying_exec (J n));\n     action_obs (justifying_exec (J n)) a =\n     NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T\n 2. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "let ?E = \"\\<lambda>n. justifying_exec (J n)\"\n    and ?\\<phi> = \"\\<lambda>n. action_translation (J n)\"\n    and ?C = \"\\<lambda>n. committed (J n)\"\n    and ?ws = \"\\<lambda>n. justifying_ws (J n)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; enat a < llength (justifying_exec (J n));\n     action_obs (justifying_exec (J n)) a =\n     NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T\n 2. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "let ?\\<E> = \"h.\\<E>_start f P C M vs status\"\n    and ?start_obs = \"lift_start_obs h.start_tid h.start_heap_obs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; enat a < llength (justifying_exec (J n));\n     action_obs (justifying_exec (J n)) a =\n     NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T\n 2. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; enat a < llength (justifying_exec (J n));\n     action_obs (justifying_exec (J n)) a =\n     NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T\n 2. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "fix a n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; enat a < llength (justifying_exec (J n));\n     action_obs (justifying_exec (J n)) a =\n     NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T\n 2. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "assume \"enat a < llength (justifying_exec (J n))\"\n      and \"action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v)\"\n      and \"n > 0\""], ["proof (state)\nthis:\n  enat a < llength (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v)\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; enat a < llength (justifying_exec (J n));\n     action_obs (justifying_exec (J n)) a =\n     NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T\n 2. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "thus \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  enat a < llength (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v)\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "proof(induction n arbitrary: a ad al v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J 0));\n        action_obs (justifying_exec (J 0)) a =\n        NormalAction (ReadMem ad al v);\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T\n 2. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "case 0"], ["proof (state)\nthis:\n  enat a < llength (justifying_exec (J 0))\n  action_obs (justifying_exec (J 0)) a = NormalAction (ReadMem ad al v)\n  0 < 0\n\ngoal (2 subgoals):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J 0));\n        action_obs (justifying_exec (J 0)) a =\n        NormalAction (ReadMem ad al v);\n        0 < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T\n 2. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "thus ?case"], ["proof (prove)\nusing this:\n  enat a < llength (justifying_exec (J 0))\n  action_obs (justifying_exec (J 0)) a = NormalAction (ReadMem ad al v)\n  0 < 0\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "by simp"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "case (Suc n')"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?a17 < llength (justifying_exec (J n'));\n   action_obs (justifying_exec (J n')) ?a17 =\n   NormalAction (ReadMem ?ad17 ?al17 ?v17);\n   0 < n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       P \\<turnstile> ?ad17@?al17 : T \\<and>\n                       P \\<turnstile> ?v17 :\\<le> T\n  enat a < llength (justifying_exec (J (Suc n')))\n  action_obs (justifying_exec (J (Suc n'))) a =\n  NormalAction (ReadMem ad al v)\n  0 < Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "define n where \"n = Suc n'\""], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>enat ?a17 < llength (justifying_exec (J n'));\n   action_obs (justifying_exec (J n')) ?a17 =\n   NormalAction (ReadMem ?ad17 ?al17 ?v17);\n   0 < n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       P \\<turnstile> ?ad17@?al17 : T \\<and>\n                       P \\<turnstile> ?v17 :\\<le> T\n  enat a < llength (justifying_exec (J (Suc n')))\n  action_obs (justifying_exec (J (Suc n'))) a =\n  NormalAction (ReadMem ad al v)\n  0 < Suc n'\n  n = Suc n'", "have n: \"0 < n\" and a: \"enat a < llength (?E n)\"\n        and a_obs: \"action_obs (?E n) a = NormalAction (ReadMem ad al v)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>enat ?a17 < llength (justifying_exec (J n'));\n   action_obs (justifying_exec (J n')) ?a17 =\n   NormalAction (ReadMem ?ad17 ?al17 ?v17);\n   0 < n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       P \\<turnstile> ?ad17@?al17 : T \\<and>\n                       P \\<turnstile> ?v17 :\\<le> T\n  enat a < llength (justifying_exec (J (Suc n')))\n  action_obs (justifying_exec (J (Suc n'))) a =\n  NormalAction (ReadMem ad al v)\n  0 < Suc n'\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. 0 < n &&&\n    enat a < llength (justifying_exec (J n)) &&&\n    action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v)", "by simp_all"], ["proof (state)\nthis:\n  0 < n\n  enat a < llength (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "have wf_n: \"P \\<turnstile> (?E n, ?ws n) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (justifying_exec (J n), justifying_ws (J n)) \\<surd>", "using justified"], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (justifying_exec (J n), justifying_ws (J n)) \\<surd>", "by(simp add: justification_well_formed_def)"], ["proof (state)\nthis:\n  P \\<turnstile> (justifying_exec (J n), justifying_ws (J n)) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from J"], ["proof (chain)\npicking this:\n  range (justifying_exec \\<circ> J)\n  \\<subseteq> h.\\<E>_start f P C M vs status", "have E: \"?E n \\<in> ?\\<E>\" \n        and E': \"?E n' \\<in> ?\\<E>\""], ["proof (prove)\nusing this:\n  range (justifying_exec \\<circ> J)\n  \\<subseteq> h.\\<E>_start f P C M vs status\n\ngoal (1 subgoal):\n 1. justifying_exec (J n) \\<in> h.\\<E>_start f P C M vs status &&&\n    justifying_exec (J n') \\<in> h.\\<E>_start f P C M vs status", "by auto"], ["proof (state)\nthis:\n  justifying_exec (J n) \\<in> h.\\<E>_start f P C M vs status\n  justifying_exec (J n') \\<in> h.\\<E>_start f P C M vs status\n\ngoal (1 subgoal):\n 1. \\<And>n a ad al v.\n       \\<lbrakk>\\<And>a ad al v.\n                   \\<lbrakk>enat a < llength (justifying_exec (J n));\n                    action_obs (justifying_exec (J n)) a =\n                    NormalAction (ReadMem ad al v);\n                    0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T.\n  P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T;\n        enat a < llength (justifying_exec (J (Suc n)));\n        action_obs (justifying_exec (J (Suc n))) a =\n        NormalAction (ReadMem ad al v);\n        0 < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from a a_obs wfx_start wfP E wf_n"], ["proof (chain)\npicking this:\n  enat a < llength (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v)\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  justifying_exec (J n) \\<in> h.\\<E>_start f P C M vs status\n  P \\<turnstile> (justifying_exec (J n), justifying_ws (J n)) \\<surd>", "show ?case"], ["proof (prove)\nusing this:\n  enat a < llength (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a = NormalAction (ReadMem ad al v)\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  justifying_exec (J n) \\<in> h.\\<E>_start f P C M vs status\n  P \\<turnstile> (justifying_exec (J n), justifying_ws (J n)) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "proof(rule hb_read_value_typeable[rotated -2])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "fix a' ad' al' v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "assume a': \"enat a' < llength (?E n)\"\n          and a'_obs: \"action_obs (?E n) a' = NormalAction (ReadMem ad' al' v')\"\n          and nhb: \"\\<not> P,?E n \\<turnstile> ?ws n a' \\<le>hb a'\""], ["proof (state)\nthis:\n  enat a' < llength (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a' = NormalAction (ReadMem ad' al' v')\n  \\<not> P,justifying_exec\n            (J n) \\<turnstile> justifying_ws (J n) a' \\<le>hb a'\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from a'"], ["proof (chain)\npicking this:\n  enat a' < llength (justifying_exec (J n))", "have \"a' \\<in> actions (?E n)\""], ["proof (prove)\nusing this:\n  enat a' < llength (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. a' \\<in> actions (justifying_exec (J n))", "by(simp add: actions_def)"], ["proof (state)\nthis:\n  a' \\<in> actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "hence read_a': \"a' \\<in> read_actions (?E n)\""], ["proof (prove)\nusing this:\n  a' \\<in> actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. a' \\<in> read_actions (justifying_exec (J n))", "using a'_obs"], ["proof (prove)\nusing this:\n  a' \\<in> actions (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a' = NormalAction (ReadMem ad' al' v')\n\ngoal (1 subgoal):\n 1. a' \\<in> read_actions (justifying_exec (J n))", ".."], ["proof (state)\nthis:\n  a' \\<in> read_actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with justified nhb"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  \\<not> P,justifying_exec\n            (J n) \\<turnstile> justifying_ws (J n) a' \\<le>hb a'\n  a' \\<in> read_actions (justifying_exec (J n))", "have committed': \"?\\<phi> n a' \\<in> ?\\<phi> n' ` ?C n'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  \\<not> P,justifying_exec\n            (J n) \\<turnstile> justifying_ws (J n) a' \\<le>hb a'\n  a' \\<in> read_actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. action_translation (J n) a'\n    \\<in> action_translation (J n') ` committed (J n')", "unfolding is_weakly_justified_by.simps n_def uncommitted_reads_see_hb_def"], ["proof (prove)\nusing this:\n  is_commit_sequence E J \\<and>\n  justification_well_formed P J \\<and>\n  committed_subset_actions J \\<and>\n  happens_before_committed_weak P E ws J \\<and>\n  value_written_committed P E J \\<and>\n  write_seen_committed ws J \\<and>\n  (\\<forall>n.\n      \\<forall>r'\\<in>read_actions (justifying_exec (J (Suc n))).\n         action_translation (J (Suc n)) r'\n         \\<in> action_translation (J n) ` committed (J n) \\<or>\n         P,justifying_exec\n            (J (Suc n)) \\<turnstile> justifying_ws (J (Suc n))\nr' \\<le>hb r') \\<and>\n  committed_reads_see_committed_writes_weak ws J \\<and>\n  wf_action_translations E J\n  \\<not> P,justifying_exec\n            (J (Suc n')) \\<turnstile> justifying_ws (J (Suc n'))\n a' \\<le>hb a'\n  a' \\<in> read_actions (justifying_exec (J (Suc n')))\n\ngoal (1 subgoal):\n 1. action_translation (J (Suc n')) a'\n    \\<in> action_translation (J n') ` committed (J n')", "by blast"], ["proof (state)\nthis:\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have wfa_n: \"wf_action_translation E (J n)\"\n          and wfa_n': \"wf_action_translation E (J n')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. wf_action_translation E (J n) &&& wf_action_translation E (J n')", "by(simp_all add: wf_action_translations_def)"], ["proof (state)\nthis:\n  wf_action_translation E (J n)\n  wf_action_translation E (J n')\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "hence inj_n: \"inj_on (?\\<phi> n) (actions (?E n))\"\n          and inj_n': \"inj_on (?\\<phi> n') (actions (?E n'))\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J n)\n  wf_action_translation E (J n')\n\ngoal (1 subgoal):\n 1. inj_on (action_translation (J n)) (actions (justifying_exec (J n))) &&&\n    inj_on (action_translation (J n')) (actions (justifying_exec (J n')))", "by(blast dest: wf_action_translation_on_inj_onD)+"], ["proof (state)\nthis:\n  inj_on (action_translation (J n)) (actions (justifying_exec (J n)))\n  inj_on (action_translation (J n')) (actions (justifying_exec (J n')))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have C_n: \"?C n \\<subseteq> actions (?E n)\"\n          and C_n': \"?C n' \\<subseteq> actions (?E n')\"\n          and wf_n': \"P \\<turnstile> (?E n', ?ws n') \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. committed (J n) \\<subseteq> actions (justifying_exec (J n)) &&&\n    committed (J n') \\<subseteq> actions (justifying_exec (J n')) &&&\n    P \\<turnstile> (justifying_exec (J n'), justifying_ws (J n')) \\<surd>", "by(simp_all add: committed_subset_actions_def justification_well_formed_def)"], ["proof (state)\nthis:\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n  P \\<turnstile> (justifying_exec (J n'), justifying_ws (J n')) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have \"?\\<phi> n' ` ?C n' \\<subseteq> ?\\<phi> n ` ?C n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. action_translation (J n') ` committed (J n')\n    \\<subseteq> action_translation (J n) ` committed (J n)", "unfolding n_def"], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. action_translation (J n') ` committed (J n')\n    \\<subseteq> action_translation (J (Suc n')) ` committed (J (Suc n'))", "by(simp add: is_commit_sequence_def)"], ["proof (state)\nthis:\n  action_translation (J n') ` committed (J n')\n  \\<subseteq> action_translation (J n) ` committed (J n)\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with n_def committed'"], ["proof (chain)\npicking this:\n  n = Suc n'\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')\n  action_translation (J n') ` committed (J n')\n  \\<subseteq> action_translation (J n) ` committed (J n)", "have \"?\\<phi> n a' \\<in> ?\\<phi> n ` ?C n\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')\n  action_translation (J n') ` committed (J n')\n  \\<subseteq> action_translation (J n) ` committed (J n)\n\ngoal (1 subgoal):\n 1. action_translation (J n) a'\n    \\<in> action_translation (J n) ` committed (J n)", "by auto"], ["proof (state)\nthis:\n  action_translation (J n) a'\n  \\<in> action_translation (J n) ` committed (J n)\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with inj_n C_n"], ["proof (chain)\npicking this:\n  inj_on (action_translation (J n)) (actions (justifying_exec (J n)))\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))\n  action_translation (J n) a'\n  \\<in> action_translation (J n) ` committed (J n)", "have committed: \"a' \\<in> ?C n\""], ["proof (prove)\nusing this:\n  inj_on (action_translation (J n)) (actions (justifying_exec (J n)))\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))\n  action_translation (J n) a'\n  \\<in> action_translation (J n) ` committed (J n)\n\ngoal (1 subgoal):\n 1. a' \\<in> committed (J n)", "using \\<open>a' \\<in> actions (?E n)\\<close>"], ["proof (prove)\nusing this:\n  inj_on (action_translation (J n)) (actions (justifying_exec (J n)))\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))\n  action_translation (J n) a'\n  \\<in> action_translation (J n) ` committed (J n)\n  a' \\<in> actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. a' \\<in> committed (J n)", "by(auto dest: inj_onD)"], ["proof (state)\nthis:\n  a' \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with justified read_a'"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a' \\<in> read_actions (justifying_exec (J n))\n  a' \\<in> committed (J n)", "have ws_committed: \"ws (?\\<phi> n a') \\<in> ?\\<phi> n ` ?C n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a' \\<in> read_actions (justifying_exec (J n))\n  a' \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. ws (action_translation (J n) a')\n    \\<in> action_translation (J n) ` committed (J n)", "by(rule weakly_justified_write_seen_hb_read_committed)"], ["proof (state)\nthis:\n  ws (action_translation (J n) a')\n  \\<in> action_translation (J n) ` committed (J n)\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from wf_n"], ["proof (chain)\npicking this:\n  P \\<turnstile> (justifying_exec (J n), justifying_ws (J n)) \\<surd>", "have ws_n: \"is_write_seen P (?E n) (?ws n)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (justifying_exec (J n), justifying_ws (J n)) \\<surd>\n\ngoal (1 subgoal):\n 1. is_write_seen P (justifying_exec (J n)) (justifying_ws (J n))", "by(rule wf_exec_is_write_seenD)"], ["proof (state)\nthis:\n  is_write_seen P (justifying_exec (J n)) (justifying_ws (J n))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from is_write_seenD[OF this read_a' a'_obs]"], ["proof (chain)\npicking this:\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n)) \\<and>\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a') \\<and>\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  v' \\<and>\n  \\<not> P,justifying_exec\n            (J n) \\<turnstile> a' \\<le>hb justifying_ws (J n) a' \\<and>\n  (is_volatile P al' \\<longrightarrow>\n   \\<not> P,justifying_exec\n             (J n) \\<turnstile> a' \\<le>so justifying_ws (J n) a') \\<and>\n  (\\<forall>a'a\\<in>write_actions (justifying_exec (J n)).\n      (ad', al') \\<in> action_loc P (justifying_exec (J n)) a'a \\<and>\n      (P,justifying_exec\n          (J n) \\<turnstile> justifying_ws (J n) a' \\<le>hb a'a \\<and>\n       P,justifying_exec (J n) \\<turnstile> a'a \\<le>hb a' \\<or>\n       is_volatile P al' \\<and>\n       P,justifying_exec\n          (J n) \\<turnstile> justifying_ws (J n) a' \\<le>so a'a \\<and>\n       P,justifying_exec\n          (J n) \\<turnstile> a'a \\<le>so a') \\<longrightarrow>\n      a'a = justifying_ws (J n) a')", "have ws_write: \"?ws n a' \\<in> write_actions (?E n)\"\n          and adal: \"(ad', al') \\<in> action_loc P (?E n) (?ws n a')\"\n          and written: \"value_written P (?E n) (?ws n a') (ad', al') = v'\""], ["proof (prove)\nusing this:\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n)) \\<and>\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a') \\<and>\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  v' \\<and>\n  \\<not> P,justifying_exec\n            (J n) \\<turnstile> a' \\<le>hb justifying_ws (J n) a' \\<and>\n  (is_volatile P al' \\<longrightarrow>\n   \\<not> P,justifying_exec\n             (J n) \\<turnstile> a' \\<le>so justifying_ws (J n) a') \\<and>\n  (\\<forall>a'a\\<in>write_actions (justifying_exec (J n)).\n      (ad', al') \\<in> action_loc P (justifying_exec (J n)) a'a \\<and>\n      (P,justifying_exec\n          (J n) \\<turnstile> justifying_ws (J n) a' \\<le>hb a'a \\<and>\n       P,justifying_exec (J n) \\<turnstile> a'a \\<le>hb a' \\<or>\n       is_volatile P al' \\<and>\n       P,justifying_exec\n          (J n) \\<turnstile> justifying_ws (J n) a' \\<le>so a'a \\<and>\n       P,justifying_exec\n          (J n) \\<turnstile> a'a \\<le>so a') \\<longrightarrow>\n      a'a = justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n)) &&&\n    (ad', al')\n    \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a') &&&\n    value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n     (ad', al') =\n    v'", "by simp_all"], ["proof (state)\nthis:\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  v'\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "define a'' where \"a'' = inv_into (actions (?E n')) (?\\<phi> n') (?\\<phi> n a')\""], ["proof (state)\nthis:\n  a'' =\n  inv_into (actions (justifying_exec (J n'))) (action_translation (J n'))\n   (action_translation (J n) a')\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from C_n' n committed'"], ["proof (chain)\npicking this:\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n  0 < n\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')", "have \"?\\<phi> n a' \\<in> ?\\<phi> n' ` actions (?E n')\""], ["proof (prove)\nusing this:\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n  0 < n\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')\n\ngoal (1 subgoal):\n 1. action_translation (J n) a'\n    \\<in> action_translation (J n') ` actions (justifying_exec (J n'))", "by auto"], ["proof (state)\nthis:\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "hence a'': \"?\\<phi> n' a'' = ?\\<phi> n a'\"\n          and a''_action: \"a'' \\<in> actions (?E n')\""], ["proof (prove)\nusing this:\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. action_translation (J n') a'' = action_translation (J n) a' &&&\n    a'' \\<in> actions (justifying_exec (J n'))", "using inj_n' committed' n"], ["proof (prove)\nusing this:\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` actions (justifying_exec (J n'))\n  inj_on (action_translation (J n')) (actions (justifying_exec (J n')))\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')\n  0 < n\n\ngoal (1 subgoal):\n 1. action_translation (J n') a'' = action_translation (J n) a' &&&\n    a'' \\<in> actions (justifying_exec (J n'))", "by(simp_all add: a''_def f_inv_into_f inv_into_into)"], ["proof (state)\nthis:\n  action_translation (J n') a'' = action_translation (J n) a'\n  a'' \\<in> actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "hence committed'': \"a'' \\<in> ?C n'\""], ["proof (prove)\nusing this:\n  action_translation (J n') a'' = action_translation (J n) a'\n  a'' \\<in> actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. a'' \\<in> committed (J n')", "using committed' n inj_n' C_n'"], ["proof (prove)\nusing this:\n  action_translation (J n') a'' = action_translation (J n) a'\n  a'' \\<in> actions (justifying_exec (J n'))\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')\n  0 < n\n  inj_on (action_translation (J n')) (actions (justifying_exec (J n')))\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. a'' \\<in> committed (J n')", "by(fastforce dest: inj_onD)"], ["proof (state)\nthis:\n  a'' \\<in> committed (J n')\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from committed committed'' wfa_n wfa_n' a''"], ["proof (chain)\npicking this:\n  a' \\<in> committed (J n)\n  a'' \\<in> committed (J n')\n  wf_action_translation E (J n)\n  wf_action_translation E (J n')\n  action_translation (J n') a'' = action_translation (J n) a'", "have \"action_obs (?E n') a'' \\<approx> action_obs (?E n) a'\""], ["proof (prove)\nusing this:\n  a' \\<in> committed (J n)\n  a'' \\<in> committed (J n')\n  wf_action_translation E (J n)\n  wf_action_translation E (J n')\n  action_translation (J n') a'' = action_translation (J n) a'\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n'))\n     a'' \\<approx> action_obs (justifying_exec (J n)) a'", "by(auto dest!: wf_action_translation_on_actionD intro: sim_action_trans sim_action_sym)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n'))\n   a'' \\<approx> action_obs (justifying_exec (J n)) a'\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with a'_obs committed'' C_n'"], ["proof (chain)\npicking this:\n  action_obs (justifying_exec (J n)) a' = NormalAction (ReadMem ad' al' v')\n  a'' \\<in> committed (J n')\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n  action_obs (justifying_exec (J n'))\n   a'' \\<approx> action_obs (justifying_exec (J n)) a'", "have read_a'': \"a'' \\<in> read_actions (?E n')\""], ["proof (prove)\nusing this:\n  action_obs (justifying_exec (J n)) a' = NormalAction (ReadMem ad' al' v')\n  a'' \\<in> committed (J n')\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n  action_obs (justifying_exec (J n'))\n   a'' \\<approx> action_obs (justifying_exec (J n)) a'\n\ngoal (1 subgoal):\n 1. a'' \\<in> read_actions (justifying_exec (J n'))", "by(auto intro: read_actions.intros)"], ["proof (state)\nthis:\n  a'' \\<in> read_actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  a'' \\<in> read_actions (justifying_exec (J n'))", "obtain ad'' al'' v'' \n          where a''_obs: \"action_obs (?E n') a'' = NormalAction (ReadMem ad'' al'' v'')\""], ["proof (prove)\nusing this:\n  a'' \\<in> read_actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. (\\<And>ad'' al'' v''.\n        action_obs (justifying_exec (J n')) a'' =\n        NormalAction (ReadMem ad'' al'' v'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n')) a'' =\n  NormalAction (ReadMem ad'' al'' v'')\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from committed''"], ["proof (chain)\npicking this:\n  a'' \\<in> committed (J n')", "have \"n' > 0\""], ["proof (prove)\nusing this:\n  a'' \\<in> committed (J n')\n\ngoal (1 subgoal):\n 1. 0 < n'", "using justified"], ["proof (prove)\nusing this:\n  a'' \\<in> committed (J n')\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. 0 < n'", "by(cases n')(simp_all add: is_commit_sequence_def)"], ["proof (state)\nthis:\n  0 < n'\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  0 < n'", "obtain n'' where n'': \"n' = Suc n''\""], ["proof (prove)\nusing this:\n  0 < n'\n\ngoal (1 subgoal):\n 1. (\\<And>n''. n' = Suc n'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n') simp_all"], ["proof (state)\nthis:\n  n' = Suc n''\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have wfa_n'': \"wf_action_translation E (J n'')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. wf_action_translation E (J n'')", "by(simp add: wf_action_translations_def)"], ["proof (state)\nthis:\n  wf_action_translation E (J n'')\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "hence inj_n'': \"inj_on (?\\<phi> n'') (actions (?E n''))\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J n'')\n\ngoal (1 subgoal):\n 1. inj_on (action_translation (J n'')) (actions (justifying_exec (J n'')))", "by(blast dest: wf_action_translation_on_inj_onD)+"], ["proof (state)\nthis:\n  inj_on (action_translation (J n'')) (actions (justifying_exec (J n'')))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have C_n'': \"?C n'' \\<subseteq> actions (?E n'')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. committed (J n'') \\<subseteq> actions (justifying_exec (J n''))", "by(simp add: committed_subset_actions_def)"], ["proof (state)\nthis:\n  committed (J n'') \\<subseteq> actions (justifying_exec (J n''))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from justified committed' committed'' n_def read_a' read_a'' n"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')\n  a'' \\<in> committed (J n')\n  n = Suc n'\n  a' \\<in> read_actions (justifying_exec (J n))\n  a'' \\<in> read_actions (justifying_exec (J n'))\n  0 < n", "have \"?\\<phi> n (?ws n (inv_into (actions (?E n)) (?\\<phi> n) (?\\<phi> n' a''))) = ws (?\\<phi> n' a'')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  action_translation (J n) a'\n  \\<in> action_translation (J n') ` committed (J n')\n  a'' \\<in> committed (J n')\n  n = Suc n'\n  a' \\<in> read_actions (justifying_exec (J n))\n  a'' \\<in> read_actions (justifying_exec (J n'))\n  0 < n\n\ngoal (1 subgoal):\n 1. action_translation (J n)\n     (justifying_ws (J n)\n       (inv_into (actions (justifying_exec (J n)))\n         (action_translation (J n)) (action_translation (J n') a''))) =\n    ws (action_translation (J n') a'')", "by(simp add: write_seen_committed_def)"], ["proof (state)\nthis:\n  action_translation (J n)\n   (justifying_ws (J n)\n     (inv_into (actions (justifying_exec (J n))) (action_translation (J n))\n       (action_translation (J n') a''))) =\n  ws (action_translation (J n') a'')\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "hence \"?\\<phi> n (?ws n a') = ws (?\\<phi> n a')\""], ["proof (prove)\nusing this:\n  action_translation (J n)\n   (justifying_ws (J n)\n     (inv_into (actions (justifying_exec (J n))) (action_translation (J n))\n       (action_translation (J n') a''))) =\n  ws (action_translation (J n') a'')\n\ngoal (1 subgoal):\n 1. action_translation (J n) (justifying_ws (J n) a') =\n    ws (action_translation (J n) a')", "using inj_n \\<open>a' \\<in> actions (?E n)\\<close>"], ["proof (prove)\nusing this:\n  action_translation (J n)\n   (justifying_ws (J n)\n     (inv_into (actions (justifying_exec (J n))) (action_translation (J n))\n       (action_translation (J n') a''))) =\n  ws (action_translation (J n') a'')\n  inj_on (action_translation (J n)) (actions (justifying_exec (J n)))\n  a' \\<in> actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. action_translation (J n) (justifying_ws (J n) a') =\n    ws (action_translation (J n) a')", "by(simp add: a'')"], ["proof (state)\nthis:\n  action_translation (J n) (justifying_ws (J n) a') =\n  ws (action_translation (J n) a')\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from ws_committed"], ["proof (chain)\npicking this:\n  ws (action_translation (J n) a')\n  \\<in> action_translation (J n) ` committed (J n)", "obtain w where w: \"ws (?\\<phi> n a') = ?\\<phi> n w\" \n          and committed_w: \"w \\<in> ?C n\""], ["proof (prove)\nusing this:\n  ws (action_translation (J n) a')\n  \\<in> action_translation (J n) ` committed (J n)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>ws (action_translation (J n) a') =\n                 action_translation (J n) w;\n         w \\<in> committed (J n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ws (action_translation (J n) a') = action_translation (J n) w\n  w \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from committed_w C_n"], ["proof (chain)\npicking this:\n  w \\<in> committed (J n)\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))", "have \"w \\<in> actions (?E n)\""], ["proof (prove)\nusing this:\n  w \\<in> committed (J n)\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. w \\<in> actions (justifying_exec (J n))", "by blast"], ["proof (state)\nthis:\n  w \\<in> actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "hence w_def: \"w = ?ws n a'\""], ["proof (prove)\nusing this:\n  w \\<in> actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. w = justifying_ws (J n) a'", "using \\<open>?\\<phi> n (?ws n a') = ws (?\\<phi> n a')\\<close> inj_n ws_write"], ["proof (prove)\nusing this:\n  w \\<in> actions (justifying_exec (J n))\n  action_translation (J n) (justifying_ws (J n) a') =\n  ws (action_translation (J n) a')\n  inj_on (action_translation (J n)) (actions (justifying_exec (J n)))\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. w = justifying_ws (J n) a'", "unfolding w"], ["proof (prove)\nusing this:\n  w \\<in> actions (justifying_exec (J n))\n  action_translation (J n) (justifying_ws (J n) a') =\n  action_translation (J n) w\n  inj_on (action_translation (J n)) (actions (justifying_exec (J n)))\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. w = justifying_ws (J n) a'", "by(auto dest: inj_onD)"], ["proof (state)\nthis:\n  w = justifying_ws (J n) a'\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "have committed_ws: \"?ws n a' \\<in> ?C n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. justifying_ws (J n) a' \\<in> committed (J n)", "using committed_w"], ["proof (prove)\nusing this:\n  w \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. justifying_ws (J n) a' \\<in> committed (J n)", "by(simp add: w_def)"], ["proof (state)\nthis:\n  justifying_ws (J n) a' \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with wfa_n"], ["proof (chain)\npicking this:\n  wf_action_translation E (J n)\n  justifying_ws (J n) a' \\<in> committed (J n)", "have sim_ws: \"action_obs (?E n) (?ws n a') \\<approx> action_obs E (?\\<phi> n (?ws n a'))\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J n)\n  justifying_ws (J n) a' \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n))\n     (justifying_ws (J n)\n       a') \\<approx> action_obs E\n                      (action_translation (J n) (justifying_ws (J n) a'))", "by(blast dest: wf_action_translation_on_actionD)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n))\n   (justifying_ws (J n)\n     a') \\<approx> action_obs E\n                    (action_translation (J n) (justifying_ws (J n) a'))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from wfa_n committed_ws"], ["proof (chain)\npicking this:\n  wf_action_translation E (J n)\n  justifying_ws (J n) a' \\<in> committed (J n)", "have sim_ws: \"action_obs (?E n) (?ws n a') \\<approx> action_obs E (?\\<phi> n (?ws n a'))\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J n)\n  justifying_ws (J n) a' \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n))\n     (justifying_ws (J n)\n       a') \\<approx> action_obs E\n                      (action_translation (J n) (justifying_ws (J n) a'))", "by(blast dest: wf_action_translation_on_actionD)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n))\n   (justifying_ws (J n)\n     a') \\<approx> action_obs E\n                    (action_translation (J n) (justifying_ws (J n) a'))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with adal"], ["proof (chain)\npicking this:\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')\n  action_obs (justifying_exec (J n))\n   (justifying_ws (J n)\n     a') \\<approx> action_obs E\n                    (action_translation (J n) (justifying_ws (J n) a'))", "have adal_E: \"(ad', al') \\<in> action_loc P E (?\\<phi> n (?ws n a'))\""], ["proof (prove)\nusing this:\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')\n  action_obs (justifying_exec (J n))\n   (justifying_ws (J n)\n     a') \\<approx> action_obs E\n                    (action_translation (J n) (justifying_ws (J n) a'))\n\ngoal (1 subgoal):\n 1. (ad', al')\n    \\<in> action_loc P E (action_translation (J n) (justifying_ws (J n) a'))", "by(simp add: action_loc_aux_sim_action)"], ["proof (state)\nthis:\n  (ad', al')\n  \\<in> action_loc P E (action_translation (J n) (justifying_ws (J n) a'))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "have \"\\<exists>w \\<in> write_actions (?E n'). (ad', al') \\<in> action_loc P (?E n') w \\<and> value_written P (?E n') w (ad', al') = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "proof(cases \"?\\<phi> n' a'' \\<in> ?\\<phi> n'' ` ?C n''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "case True"], ["proof (state)\nthis:\n  action_translation (J n') a''\n  \\<in> action_translation (J n'') ` committed (J n'')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "then"], ["proof (chain)\npicking this:\n  action_translation (J n') a''\n  \\<in> action_translation (J n'') ` committed (J n'')", "obtain a''' where a''': \"?\\<phi> n'' a''' = ?\\<phi> n' a''\" \n            and committed''': \"a''' \\<in> ?C n''\""], ["proof (prove)\nusing this:\n  action_translation (J n') a''\n  \\<in> action_translation (J n'') ` committed (J n'')\n\ngoal (1 subgoal):\n 1. (\\<And>a'''.\n        \\<lbrakk>action_translation (J n'') a''' =\n                 action_translation (J n') a'';\n         a''' \\<in> committed (J n'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  action_translation (J n'') a''' = action_translation (J n') a''\n  a''' \\<in> committed (J n'')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from committed''' C_n''"], ["proof (chain)\npicking this:\n  a''' \\<in> committed (J n'')\n  committed (J n'') \\<subseteq> actions (justifying_exec (J n''))", "have a'''_action: \"a''' \\<in> actions (?E n'')\""], ["proof (prove)\nusing this:\n  a''' \\<in> committed (J n'')\n  committed (J n'') \\<subseteq> actions (justifying_exec (J n''))\n\ngoal (1 subgoal):\n 1. a''' \\<in> actions (justifying_exec (J n''))", "by auto"], ["proof (state)\nthis:\n  a''' \\<in> actions (justifying_exec (J n''))\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from committed'' committed''' wfa_n' wfa_n'' a'''"], ["proof (chain)\npicking this:\n  a'' \\<in> committed (J n')\n  a''' \\<in> committed (J n'')\n  wf_action_translation E (J n')\n  wf_action_translation E (J n'')\n  action_translation (J n'') a''' = action_translation (J n') a''", "have \"action_obs (?E n'') a''' \\<approx> action_obs (?E n') a''\""], ["proof (prove)\nusing this:\n  a'' \\<in> committed (J n')\n  a''' \\<in> committed (J n'')\n  wf_action_translation E (J n')\n  wf_action_translation E (J n'')\n  action_translation (J n'') a''' = action_translation (J n') a''\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n''))\n     a''' \\<approx> action_obs (justifying_exec (J n')) a''", "by(auto dest!: wf_action_translation_on_actionD intro: sim_action_trans sim_action_sym)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n''))\n   a''' \\<approx> action_obs (justifying_exec (J n')) a''\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with read_a'' committed''' C_n''"], ["proof (chain)\npicking this:\n  a'' \\<in> read_actions (justifying_exec (J n'))\n  a''' \\<in> committed (J n'')\n  committed (J n'') \\<subseteq> actions (justifying_exec (J n''))\n  action_obs (justifying_exec (J n''))\n   a''' \\<approx> action_obs (justifying_exec (J n')) a''", "have read_a''': \"a''' \\<in> read_actions (?E n'')\""], ["proof (prove)\nusing this:\n  a'' \\<in> read_actions (justifying_exec (J n'))\n  a''' \\<in> committed (J n'')\n  committed (J n'') \\<subseteq> actions (justifying_exec (J n''))\n  action_obs (justifying_exec (J n''))\n   a''' \\<approx> action_obs (justifying_exec (J n')) a''\n\ngoal (1 subgoal):\n 1. a''' \\<in> read_actions (justifying_exec (J n''))", "by cases(auto intro: read_actions.intros)"], ["proof (state)\nthis:\n  a''' \\<in> read_actions (justifying_exec (J n''))\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "hence \"?\\<phi> n' (?ws n' (inv_into (actions (?E n')) (?\\<phi> n') (?\\<phi> n'' a'''))) = ws (?\\<phi> n'' a''')\""], ["proof (prove)\nusing this:\n  a''' \\<in> read_actions (justifying_exec (J n''))\n\ngoal (1 subgoal):\n 1. action_translation (J n')\n     (justifying_ws (J n')\n       (inv_into (actions (justifying_exec (J n')))\n         (action_translation (J n')) (action_translation (J n'') a'''))) =\n    ws (action_translation (J n'') a''')", "using justified committed'''"], ["proof (prove)\nusing this:\n  a''' \\<in> read_actions (justifying_exec (J n''))\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a''' \\<in> committed (J n'')\n\ngoal (1 subgoal):\n 1. action_translation (J n')\n     (justifying_ws (J n')\n       (inv_into (actions (justifying_exec (J n')))\n         (action_translation (J n')) (action_translation (J n'') a'''))) =\n    ws (action_translation (J n'') a''')", "unfolding is_weakly_justified_by.simps n'' Let_def write_seen_committed_def"], ["proof (prove)\nusing this:\n  a''' \\<in> read_actions (justifying_exec (J n''))\n  is_commit_sequence E J \\<and>\n  justification_well_formed P J \\<and>\n  committed_subset_actions J \\<and>\n  happens_before_committed_weak P E ws J \\<and>\n  value_written_committed P E J \\<and>\n  (\\<forall>n.\n      \\<forall>r'\\<in>read_actions (justifying_exec (J n)) \\<inter>\n                      committed (J n).\n         action_translation (J (Suc n))\n          (justifying_ws (J (Suc n))\n            (inv_into (actions (justifying_exec (J (Suc n))))\n              (action_translation (J (Suc n)))\n              (action_translation (J n) r'))) =\n         ws (action_translation (J n) r')) \\<and>\n  uncommitted_reads_see_hb P J \\<and>\n  committed_reads_see_committed_writes_weak ws J \\<and>\n  wf_action_translations E J\n  a''' \\<in> committed (J n'')\n\ngoal (1 subgoal):\n 1. action_translation (J (Suc n''))\n     (justifying_ws (J (Suc n''))\n       (inv_into (actions (justifying_exec (J (Suc n''))))\n         (action_translation (J (Suc n'')))\n         (action_translation (J n'') a'''))) =\n    ws (action_translation (J n'') a''')", "by blast"], ["proof (state)\nthis:\n  action_translation (J n')\n   (justifying_ws (J n')\n     (inv_into (actions (justifying_exec (J n')))\n       (action_translation (J n')) (action_translation (J n'') a'''))) =\n  ws (action_translation (J n'') a''')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  action_translation (J n')\n   (justifying_ws (J n')\n     (inv_into (actions (justifying_exec (J n')))\n       (action_translation (J n')) (action_translation (J n'') a'''))) =\n  ws (action_translation (J n'') a''')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "have \"inv_into (actions (?E n')) (?\\<phi> n') (?\\<phi> n'' a''') = a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into (actions (justifying_exec (J n'))) (action_translation (J n'))\n     (action_translation (J n'') a''') =\n    a''", "using a''' inj_n' a''_action"], ["proof (prove)\nusing this:\n  action_translation (J n'') a''' = action_translation (J n') a''\n  inj_on (action_translation (J n')) (actions (justifying_exec (J n')))\n  a'' \\<in> actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. inv_into (actions (justifying_exec (J n'))) (action_translation (J n'))\n     (action_translation (J n'') a''') =\n    a''", "by(simp)"], ["proof (state)\nthis:\n  inv_into (actions (justifying_exec (J n'))) (action_translation (J n'))\n   (action_translation (J n'') a''') =\n  a''\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  inv_into (actions (justifying_exec (J n'))) (action_translation (J n'))\n   (action_translation (J n'') a''') =\n  a''\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "note a'''"], ["proof (state)\nthis:\n  action_translation (J n'') a''' = action_translation (J n') a''\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  action_translation (J n'') a''' = action_translation (J n') a''\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "note a''"], ["proof (state)\nthis:\n  action_translation (J n') a'' = action_translation (J n) a'\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "finally"], ["proof (chain)\npicking this:\n  action_translation (J n') (justifying_ws (J n') a'') =\n  ws (action_translation (J n) a')", "have \\<phi>_n': \"?\\<phi> n' (?ws n' a'') = ws (?\\<phi> n a')\""], ["proof (prove)\nusing this:\n  action_translation (J n') (justifying_ws (J n') a'') =\n  ws (action_translation (J n) a')\n\ngoal (1 subgoal):\n 1. action_translation (J n') (justifying_ws (J n') a'') =\n    ws (action_translation (J n) a')", "."], ["proof (state)\nthis:\n  action_translation (J n') (justifying_ws (J n') a'') =\n  ws (action_translation (J n) a')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "then"], ["proof (chain)\npicking this:\n  action_translation (J n') (justifying_ws (J n') a'') =\n  ws (action_translation (J n) a')", "have \"ws (?\\<phi> n a') = ?\\<phi> n' (?ws n' a'')\""], ["proof (prove)\nusing this:\n  action_translation (J n') (justifying_ws (J n') a'') =\n  ws (action_translation (J n) a')\n\ngoal (1 subgoal):\n 1. ws (action_translation (J n) a') =\n    action_translation (J n') (justifying_ws (J n') a'')", ".."], ["proof (state)\nthis:\n  ws (action_translation (J n) a') =\n  action_translation (J n') (justifying_ws (J n') a'')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with \\<open>?\\<phi> n (?ws n a') = ws (?\\<phi> n a')\\<close>[symmetric]"], ["proof (chain)\npicking this:\n  ws (action_translation (J n) a') =\n  action_translation (J n) (justifying_ws (J n) a')\n  ws (action_translation (J n) a') =\n  action_translation (J n') (justifying_ws (J n') a'')", "have eq_ws: \"?\\<phi> n' (?ws n' a'') = ?\\<phi> n (?ws n a')\""], ["proof (prove)\nusing this:\n  ws (action_translation (J n) a') =\n  action_translation (J n) (justifying_ws (J n) a')\n  ws (action_translation (J n) a') =\n  action_translation (J n') (justifying_ws (J n') a'')\n\ngoal (1 subgoal):\n 1. action_translation (J n') (justifying_ws (J n') a'') =\n    action_translation (J n) (justifying_ws (J n) a')", "by simp"], ["proof (state)\nthis:\n  action_translation (J n') (justifying_ws (J n') a'') =\n  action_translation (J n) (justifying_ws (J n) a')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from wf_n'[THEN wf_exec_is_write_seenD, THEN is_write_seenD, OF read_a'' a''_obs]"], ["proof (chain)\npicking this:\n  justifying_ws (J n') a''\n  \\<in> write_actions (justifying_exec (J n')) \\<and>\n  (ad'', al'')\n  \\<in> action_loc P (justifying_exec (J n'))\n         (justifying_ws (J n') a'') \\<and>\n  value_written P (justifying_exec (J n')) (justifying_ws (J n') a'')\n   (ad'', al'') =\n  v'' \\<and>\n  \\<not> P,justifying_exec\n            (J n') \\<turnstile> a'' \\<le>hb justifying_ws (J n') a'' \\<and>\n  (is_volatile P al'' \\<longrightarrow>\n   \\<not> P,justifying_exec\n             (J n') \\<turnstile> a'' \\<le>so justifying_ws (J n')\n        a'') \\<and>\n  (\\<forall>a'\\<in>write_actions (justifying_exec (J n')).\n      (ad'', al'') \\<in> action_loc P (justifying_exec (J n')) a' \\<and>\n      (P,justifying_exec\n          (J n') \\<turnstile> justifying_ws (J n') a'' \\<le>hb a' \\<and>\n       P,justifying_exec (J n') \\<turnstile> a' \\<le>hb a'' \\<or>\n       is_volatile P al'' \\<and>\n       P,justifying_exec\n          (J n') \\<turnstile> justifying_ws (J n') a'' \\<le>so a' \\<and>\n       P,justifying_exec\n          (J n') \\<turnstile> a' \\<le>so a'') \\<longrightarrow>\n      a' = justifying_ws (J n') a'')", "have ws_write': \"?ws n' a'' \\<in> write_actions (?E n')\""], ["proof (prove)\nusing this:\n  justifying_ws (J n') a''\n  \\<in> write_actions (justifying_exec (J n')) \\<and>\n  (ad'', al'')\n  \\<in> action_loc P (justifying_exec (J n'))\n         (justifying_ws (J n') a'') \\<and>\n  value_written P (justifying_exec (J n')) (justifying_ws (J n') a'')\n   (ad'', al'') =\n  v'' \\<and>\n  \\<not> P,justifying_exec\n            (J n') \\<turnstile> a'' \\<le>hb justifying_ws (J n') a'' \\<and>\n  (is_volatile P al'' \\<longrightarrow>\n   \\<not> P,justifying_exec\n             (J n') \\<turnstile> a'' \\<le>so justifying_ws (J n')\n        a'') \\<and>\n  (\\<forall>a'\\<in>write_actions (justifying_exec (J n')).\n      (ad'', al'') \\<in> action_loc P (justifying_exec (J n')) a' \\<and>\n      (P,justifying_exec\n          (J n') \\<turnstile> justifying_ws (J n') a'' \\<le>hb a' \\<and>\n       P,justifying_exec (J n') \\<turnstile> a' \\<le>hb a'' \\<or>\n       is_volatile P al'' \\<and>\n       P,justifying_exec\n          (J n') \\<turnstile> justifying_ws (J n') a'' \\<le>so a' \\<and>\n       P,justifying_exec\n          (J n') \\<turnstile> a' \\<le>so a'') \\<longrightarrow>\n      a' = justifying_ws (J n') a'')\n\ngoal (1 subgoal):\n 1. justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))", "by simp"], ["proof (state)\nthis:\n  justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from justified read_a'' committed''"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a'' \\<in> read_actions (justifying_exec (J n'))\n  a'' \\<in> committed (J n')", "have \"ws (?\\<phi> n' a'') \\<in> ?\\<phi> n' ` ?C n'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a'' \\<in> read_actions (justifying_exec (J n'))\n  a'' \\<in> committed (J n')\n\ngoal (1 subgoal):\n 1. ws (action_translation (J n') a'')\n    \\<in> action_translation (J n') ` committed (J n')", "by(rule weakly_justified_write_seen_hb_read_committed)"], ["proof (state)\nthis:\n  ws (action_translation (J n') a'')\n  \\<in> action_translation (J n') ` committed (J n')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "then"], ["proof (chain)\npicking this:\n  ws (action_translation (J n') a'')\n  \\<in> action_translation (J n') ` committed (J n')", "obtain w' where w': \"ws (?\\<phi> n' a'') = ?\\<phi> n' w'\"\n            and committed_w': \"w' \\<in> ?C n'\""], ["proof (prove)\nusing this:\n  ws (action_translation (J n') a'')\n  \\<in> action_translation (J n') ` committed (J n')\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        \\<lbrakk>ws (action_translation (J n') a'') =\n                 action_translation (J n') w';\n         w' \\<in> committed (J n')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ws (action_translation (J n') a'') = action_translation (J n') w'\n  w' \\<in> committed (J n')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from committed_w' C_n'"], ["proof (chain)\npicking this:\n  w' \\<in> committed (J n')\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))", "have \"w' \\<in> actions (?E n')\""], ["proof (prove)\nusing this:\n  w' \\<in> committed (J n')\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. w' \\<in> actions (justifying_exec (J n'))", "by blast"], ["proof (state)\nthis:\n  w' \\<in> actions (justifying_exec (J n'))\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "hence w'_def: \"w' = ?ws n' a''\""], ["proof (prove)\nusing this:\n  w' \\<in> actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. w' = justifying_ws (J n') a''", "using \\<phi>_n' inj_n' ws_write'"], ["proof (prove)\nusing this:\n  w' \\<in> actions (justifying_exec (J n'))\n  action_translation (J n') (justifying_ws (J n') a'') =\n  ws (action_translation (J n) a')\n  inj_on (action_translation (J n')) (actions (justifying_exec (J n')))\n  justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. w' = justifying_ws (J n') a''", "unfolding w' a''[symmetric]"], ["proof (prove)\nusing this:\n  w' \\<in> actions (justifying_exec (J n'))\n  action_translation (J n') (justifying_ws (J n') a'') =\n  action_translation (J n') w'\n  inj_on (action_translation (J n')) (actions (justifying_exec (J n')))\n  justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. w' = justifying_ws (J n') a''", "by(auto dest: inj_onD)"], ["proof (state)\nthis:\n  w' = justifying_ws (J n') a''\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with committed_w'"], ["proof (chain)\npicking this:\n  w' \\<in> committed (J n')\n  w' = justifying_ws (J n') a''", "have committed_ws'': \"?ws n' a'' \\<in> committed (J n')\""], ["proof (prove)\nusing this:\n  w' \\<in> committed (J n')\n  w' = justifying_ws (J n') a''\n\ngoal (1 subgoal):\n 1. justifying_ws (J n') a'' \\<in> committed (J n')", "by simp"], ["proof (state)\nthis:\n  justifying_ws (J n') a'' \\<in> committed (J n')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with committed_ws wfa_n wfa_n' eq_ws"], ["proof (chain)\npicking this:\n  justifying_ws (J n) a' \\<in> committed (J n)\n  wf_action_translation E (J n)\n  wf_action_translation E (J n')\n  action_translation (J n') (justifying_ws (J n') a'') =\n  action_translation (J n) (justifying_ws (J n) a')\n  justifying_ws (J n') a'' \\<in> committed (J n')", "have \"action_obs (?E n') (?ws n' a'') \\<approx> action_obs (?E n) (?ws n a')\""], ["proof (prove)\nusing this:\n  justifying_ws (J n) a' \\<in> committed (J n)\n  wf_action_translation E (J n)\n  wf_action_translation E (J n')\n  action_translation (J n') (justifying_ws (J n') a'') =\n  action_translation (J n) (justifying_ws (J n) a')\n  justifying_ws (J n') a'' \\<in> committed (J n')\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n'))\n     (justifying_ws (J n')\n       a'') \\<approx> action_obs (justifying_exec (J n))\n                       (justifying_ws (J n) a')", "by(auto dest!: wf_action_translation_on_actionD intro: sim_action_trans sim_action_sym)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n'))\n   (justifying_ws (J n')\n     a'') \\<approx> action_obs (justifying_exec (J n))\n                     (justifying_ws (J n) a')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "hence adal_eq: \"action_loc P (?E n') (?ws n' a'') = action_loc P (?E n) (?ws n a')\""], ["proof (prove)\nusing this:\n  action_obs (justifying_exec (J n'))\n   (justifying_ws (J n')\n     a'') \\<approx> action_obs (justifying_exec (J n))\n                     (justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'') =\n    action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')", "by(simp add: action_loc_aux_sim_action)"], ["proof (state)\nthis:\n  action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'') =\n  action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with adal"], ["proof (chain)\npicking this:\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')\n  action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'') =\n  action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')", "have adal': \"(ad', al') \\<in> action_loc P (?E n') (?ws n' a'')\""], ["proof (prove)\nusing this:\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')\n  action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'') =\n  action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. (ad', al')\n    \\<in> action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'')", "by(simp add: action_loc_aux_sim_action)"], ["proof (state)\nthis:\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from committed_ws''"], ["proof (chain)\npicking this:\n  justifying_ws (J n') a'' \\<in> committed (J n')", "have \"?ws n' a'' \\<in> actions (?E n')\""], ["proof (prove)\nusing this:\n  justifying_ws (J n') a'' \\<in> committed (J n')\n\ngoal (1 subgoal):\n 1. justifying_ws (J n') a'' \\<in> actions (justifying_exec (J n'))", "using C_n'"], ["proof (prove)\nusing this:\n  justifying_ws (J n') a'' \\<in> committed (J n')\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. justifying_ws (J n') a'' \\<in> actions (justifying_exec (J n'))", "by blast"], ["proof (state)\nthis:\n  justifying_ws (J n') a'' \\<in> actions (justifying_exec (J n'))\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with ws_write \\<open>action_obs (?E n') (?ws n' a'') \\<approx> action_obs (?E n) (?ws n a')\\<close>"], ["proof (chain)\npicking this:\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  action_obs (justifying_exec (J n'))\n   (justifying_ws (J n')\n     a'') \\<approx> action_obs (justifying_exec (J n))\n                     (justifying_ws (J n) a')\n  justifying_ws (J n') a'' \\<in> actions (justifying_exec (J n'))", "have ws_write'': \"?ws n' a'' \\<in> write_actions (?E n')\""], ["proof (prove)\nusing this:\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  action_obs (justifying_exec (J n'))\n   (justifying_ws (J n')\n     a'') \\<approx> action_obs (justifying_exec (J n))\n                     (justifying_ws (J n) a')\n  justifying_ws (J n') a'' \\<in> actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))", "by(cases)(auto intro: write_actions.intros simp add: sim_action_is_write_action_eq)"], ["proof (state)\nthis:\n  justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from wfa_n' committed_ws''"], ["proof (chain)\npicking this:\n  wf_action_translation E (J n')\n  justifying_ws (J n') a'' \\<in> committed (J n')", "have sim_ws': \"action_obs (?E n') (?ws n' a'') \\<approx> action_obs E (?\\<phi> n' (?ws n' a''))\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J n')\n  justifying_ws (J n') a'' \\<in> committed (J n')\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n'))\n     (justifying_ws (J n')\n       a'') \\<approx> action_obs E\n                       (action_translation (J n')\n                         (justifying_ws (J n') a''))", "by(blast dest: wf_action_translation_on_actionD)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n'))\n   (justifying_ws (J n')\n     a'') \\<approx> action_obs E\n                     (action_translation (J n') (justifying_ws (J n') a''))\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with adal'"], ["proof (chain)\npicking this:\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'')\n  action_obs (justifying_exec (J n'))\n   (justifying_ws (J n')\n     a'') \\<approx> action_obs E\n                     (action_translation (J n') (justifying_ws (J n') a''))", "have adal'_E: \"(ad', al') \\<in> action_loc P E (?\\<phi> n' (?ws n' a''))\""], ["proof (prove)\nusing this:\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'')\n  action_obs (justifying_exec (J n'))\n   (justifying_ws (J n')\n     a'') \\<approx> action_obs E\n                     (action_translation (J n') (justifying_ws (J n') a''))\n\ngoal (1 subgoal):\n 1. (ad', al')\n    \\<in> action_loc P E\n           (action_translation (J n') (justifying_ws (J n') a''))", "by(simp add: action_loc_aux_sim_action)"], ["proof (state)\nthis:\n  (ad', al')\n  \\<in> action_loc P E\n         (action_translation (J n') (justifying_ws (J n') a''))\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from justified committed_ws ws_write adal_E"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  justifying_ws (J n) a' \\<in> committed (J n)\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  (ad', al')\n  \\<in> action_loc P E (action_translation (J n) (justifying_ws (J n) a'))", "have \"value_written P (?E n) (?ws n a') (ad', al') = value_written P E (?\\<phi> n (?ws n a')) (ad', al')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  justifying_ws (J n) a' \\<in> committed (J n)\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  (ad', al')\n  \\<in> action_loc P E (action_translation (J n) (justifying_ws (J n) a'))\n\ngoal (1 subgoal):\n 1. value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n     (ad', al') =\n    value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n     (ad', al')", "unfolding is_weakly_justified_by.simps Let_def value_written_committed_def"], ["proof (prove)\nusing this:\n  is_commit_sequence E J \\<and>\n  justification_well_formed P J \\<and>\n  committed_subset_actions J \\<and>\n  happens_before_committed_weak P E ws J \\<and>\n  (\\<forall>n.\n      \\<forall>w\\<in>write_actions (justifying_exec (J n)) \\<inter>\n                     committed (J n).\n         \\<forall>adal\\<in>action_loc P E (action_translation (J n) w).\n            value_written P (justifying_exec (J n)) w adal =\n            value_written P E (action_translation (J n) w) adal) \\<and>\n  write_seen_committed ws J \\<and>\n  uncommitted_reads_see_hb P J \\<and>\n  committed_reads_see_committed_writes_weak ws J \\<and>\n  wf_action_translations E J\n  justifying_ws (J n) a' \\<in> committed (J n)\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  (ad', al')\n  \\<in> action_loc P E (action_translation (J n) (justifying_ws (J n) a'))\n\ngoal (1 subgoal):\n 1. value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n     (ad', al') =\n    value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n     (ad', al')", "by blast"], ["proof (state)\nthis:\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n   (ad', al')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n   (ad', al')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "note eq_ws[symmetric]"], ["proof (state)\nthis:\n  action_translation (J n) (justifying_ws (J n) a') =\n  action_translation (J n') (justifying_ws (J n') a'')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  action_translation (J n) (justifying_ws (J n) a') =\n  action_translation (J n') (justifying_ws (J n') a'')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from justified committed_ws'' ws_write'' adal'_E"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  justifying_ws (J n') a'' \\<in> committed (J n')\n  justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))\n  (ad', al')\n  \\<in> action_loc P E\n         (action_translation (J n') (justifying_ws (J n') a''))", "have \"value_written P E (?\\<phi> n' (?ws n' a'')) (ad', al') = value_written P (?E n') (?ws n' a'') (ad', al')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  justifying_ws (J n') a'' \\<in> committed (J n')\n  justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))\n  (ad', al')\n  \\<in> action_loc P E\n         (action_translation (J n') (justifying_ws (J n') a''))\n\ngoal (1 subgoal):\n 1. value_written P E (action_translation (J n') (justifying_ws (J n') a''))\n     (ad', al') =\n    value_written P (justifying_exec (J n')) (justifying_ws (J n') a'')\n     (ad', al')", "unfolding is_weakly_justified_by.simps Let_def value_written_committed_def"], ["proof (prove)\nusing this:\n  is_commit_sequence E J \\<and>\n  justification_well_formed P J \\<and>\n  committed_subset_actions J \\<and>\n  happens_before_committed_weak P E ws J \\<and>\n  (\\<forall>n.\n      \\<forall>w\\<in>write_actions (justifying_exec (J n)) \\<inter>\n                     committed (J n).\n         \\<forall>adal\\<in>action_loc P E (action_translation (J n) w).\n            value_written P (justifying_exec (J n)) w adal =\n            value_written P E (action_translation (J n) w) adal) \\<and>\n  write_seen_committed ws J \\<and>\n  uncommitted_reads_see_hb P J \\<and>\n  committed_reads_see_committed_writes_weak ws J \\<and>\n  wf_action_translations E J\n  justifying_ws (J n') a'' \\<in> committed (J n')\n  justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))\n  (ad', al')\n  \\<in> action_loc P E\n         (action_translation (J n') (justifying_ws (J n') a''))\n\ngoal (1 subgoal):\n 1. value_written P E (action_translation (J n') (justifying_ws (J n') a''))\n     (ad', al') =\n    value_written P (justifying_exec (J n')) (justifying_ws (J n') a'')\n     (ad', al')", "by(blast dest: sym)"], ["proof (state)\nthis:\n  value_written P E (action_translation (J n') (justifying_ws (J n') a''))\n   (ad', al') =\n  value_written P (justifying_exec (J n')) (justifying_ws (J n') a'')\n   (ad', al')\n\ngoal (2 subgoals):\n 1. action_translation (J n') a''\n    \\<in> action_translation (J n'') ` committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'\n 2. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "finally"], ["proof (chain)\npicking this:\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  value_written P (justifying_exec (J n')) (justifying_ws (J n') a'')\n   (ad', al')", "show ?thesis"], ["proof (prove)\nusing this:\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  value_written P (justifying_exec (J n')) (justifying_ws (J n') a'')\n   (ad', al')\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "using written ws_write'' adal'"], ["proof (prove)\nusing this:\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  value_written P (justifying_exec (J n')) (justifying_ws (J n') a'')\n   (ad', al')\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  v'\n  justifying_ws (J n') a'' \\<in> write_actions (justifying_exec (J n'))\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n')) (justifying_ws (J n') a'')\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n     (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n     value_written P (justifying_exec (J n')) w (ad', al') = v'\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "case False"], ["proof (state)\nthis:\n  action_translation (J n') a''\n  \\<notin> action_translation (J n'') ` committed (J n'')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with justified read_a'' committed''"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a'' \\<in> read_actions (justifying_exec (J n'))\n  a'' \\<in> committed (J n')\n  action_translation (J n') a''\n  \\<notin> action_translation (J n'') ` committed (J n'')", "have \"ws (?\\<phi> n' a'') \\<in> ?\\<phi> n'' ` ?C n''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a'' \\<in> read_actions (justifying_exec (J n'))\n  a'' \\<in> committed (J n')\n  action_translation (J n') a''\n  \\<notin> action_translation (J n'') ` committed (J n'')\n\ngoal (1 subgoal):\n 1. ws (action_translation (J n') a'')\n    \\<in> action_translation (J n'') ` committed (J n'')", "unfolding is_weakly_justified_by.simps Let_def n'' committed_reads_see_committed_writes_weak_def"], ["proof (prove)\nusing this:\n  is_commit_sequence E J \\<and>\n  justification_well_formed P J \\<and>\n  committed_subset_actions J \\<and>\n  happens_before_committed_weak P E ws J \\<and>\n  value_written_committed P E J \\<and>\n  write_seen_committed ws J \\<and>\n  uncommitted_reads_see_hb P J \\<and>\n  (\\<forall>n.\n      \\<forall>r'\\<in>read_actions (justifying_exec (J (Suc n))) \\<inter>\n                      committed (J (Suc n)).\n         action_translation (J (Suc n)) r'\n         \\<in> action_translation (J n) ` committed (J n) \\<or>\n         ws (action_translation (J (Suc n)) r')\n         \\<in> action_translation (J n) ` committed (J n)) \\<and>\n  wf_action_translations E J\n  a'' \\<in> read_actions (justifying_exec (J (Suc n'')))\n  a'' \\<in> committed (J (Suc n''))\n  action_translation (J (Suc n'')) a''\n  \\<notin> action_translation (J n'') ` committed (J n'')\n\ngoal (1 subgoal):\n 1. ws (action_translation (J (Suc n'')) a'')\n    \\<in> action_translation (J n'') ` committed (J n'')", "by blast"], ["proof (state)\nthis:\n  ws (action_translation (J n') a'')\n  \\<in> action_translation (J n'') ` committed (J n'')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with a''"], ["proof (chain)\npicking this:\n  action_translation (J n') a'' = action_translation (J n) a'\n  ws (action_translation (J n') a'')\n  \\<in> action_translation (J n'') ` committed (J n'')", "obtain w where w: \"?\\<phi> n'' w = ws (?\\<phi> n a')\"\n            and committed_w: \"w \\<in> ?C n''\""], ["proof (prove)\nusing this:\n  action_translation (J n') a'' = action_translation (J n) a'\n  ws (action_translation (J n') a'')\n  \\<in> action_translation (J n'') ` committed (J n'')\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>action_translation (J n'') w =\n                 ws (action_translation (J n) a');\n         w \\<in> committed (J n'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  action_translation (J n'') w = ws (action_translation (J n) a')\n  w \\<in> committed (J n'')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have \"?\\<phi> n'' ` ?C n'' \\<subseteq> ?\\<phi> n' ` ?C n'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. action_translation (J n'') ` committed (J n'')\n    \\<subseteq> action_translation (J n') ` committed (J n')", "by(simp add: is_commit_sequence_def n'')"], ["proof (state)\nthis:\n  action_translation (J n'') ` committed (J n'')\n  \\<subseteq> action_translation (J n') ` committed (J n')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with committed_w w[symmetric]"], ["proof (chain)\npicking this:\n  w \\<in> committed (J n'')\n  ws (action_translation (J n) a') = action_translation (J n'') w\n  action_translation (J n'') ` committed (J n'')\n  \\<subseteq> action_translation (J n') ` committed (J n')", "have \"ws (?\\<phi> n a') \\<in> ?\\<phi> n' ` ?C n'\""], ["proof (prove)\nusing this:\n  w \\<in> committed (J n'')\n  ws (action_translation (J n) a') = action_translation (J n'') w\n  action_translation (J n'') ` committed (J n'')\n  \\<subseteq> action_translation (J n') ` committed (J n')\n\ngoal (1 subgoal):\n 1. ws (action_translation (J n) a')\n    \\<in> action_translation (J n') ` committed (J n')", "by(auto)"], ["proof (state)\nthis:\n  ws (action_translation (J n) a')\n  \\<in> action_translation (J n') ` committed (J n')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "then"], ["proof (chain)\npicking this:\n  ws (action_translation (J n) a')\n  \\<in> action_translation (J n') ` committed (J n')", "obtain w' where w': \"ws (?\\<phi> n a') = ?\\<phi> n' w'\" and committed_w': \"w' \\<in> ?C n'\""], ["proof (prove)\nusing this:\n  ws (action_translation (J n) a')\n  \\<in> action_translation (J n') ` committed (J n')\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        \\<lbrakk>ws (action_translation (J n) a') =\n                 action_translation (J n') w';\n         w' \\<in> committed (J n')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ws (action_translation (J n) a') = action_translation (J n') w'\n  w' \\<in> committed (J n')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from wfa_n' committed_w'"], ["proof (chain)\npicking this:\n  wf_action_translation E (J n')\n  w' \\<in> committed (J n')", "have \"action_obs (?E n') w' \\<approx> action_obs E (?\\<phi> n' w')\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J n')\n  w' \\<in> committed (J n')\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n'))\n     w' \\<approx> action_obs E (action_translation (J n') w')", "by(blast dest: wf_action_translation_on_actionD)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n'))\n   w' \\<approx> action_obs E (action_translation (J n') w')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "from this[folded w', folded \\<open>?\\<phi> n (?ws n a') = ws (?\\<phi> n a')\\<close>] sim_ws[symmetric]"], ["proof (chain)\npicking this:\n  action_obs (justifying_exec (J n'))\n   w' \\<approx> action_obs E\n                 (action_translation (J n) (justifying_ws (J n) a'))\n  action_obs E\n   (action_translation (J n)\n     (justifying_ws (J n)\n       a')) \\<approx> action_obs (justifying_exec (J n))\n                       (justifying_ws (J n) a')", "have sim_w': \"action_obs (?E n') w' \\<approx> action_obs (?E n) (?ws n a')\""], ["proof (prove)\nusing this:\n  action_obs (justifying_exec (J n'))\n   w' \\<approx> action_obs E\n                 (action_translation (J n) (justifying_ws (J n) a'))\n  action_obs E\n   (action_translation (J n)\n     (justifying_ws (J n)\n       a')) \\<approx> action_obs (justifying_exec (J n))\n                       (justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n'))\n     w' \\<approx> action_obs (justifying_exec (J n))\n                   (justifying_ws (J n) a')", "by(rule sim_action_trans)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n'))\n   w' \\<approx> action_obs (justifying_exec (J n)) (justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "with ws_write committed_w' C_n'"], ["proof (chain)\npicking this:\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  w' \\<in> committed (J n')\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n  action_obs (justifying_exec (J n'))\n   w' \\<approx> action_obs (justifying_exec (J n)) (justifying_ws (J n) a')", "have write_w': \"w' \\<in> write_actions (?E n')\""], ["proof (prove)\nusing this:\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  w' \\<in> committed (J n')\n  committed (J n') \\<subseteq> actions (justifying_exec (J n'))\n  action_obs (justifying_exec (J n'))\n   w' \\<approx> action_obs (justifying_exec (J n)) (justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. w' \\<in> write_actions (justifying_exec (J n'))", "by(cases)(auto intro!: write_actions.intros simp add: sim_action_is_write_action_eq)"], ["proof (state)\nthis:\n  w' \\<in> write_actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "hence \"value_written P (?E n') w' (ad', al') = value_written P E (?\\<phi> n' w') (ad', al')\""], ["proof (prove)\nusing this:\n  w' \\<in> write_actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. value_written P (justifying_exec (J n')) w' (ad', al') =\n    value_written P E (action_translation (J n') w') (ad', al')", "using adal_E committed_w' justified"], ["proof (prove)\nusing this:\n  w' \\<in> write_actions (justifying_exec (J n'))\n  (ad', al')\n  \\<in> action_loc P E (action_translation (J n) (justifying_ws (J n) a'))\n  w' \\<in> committed (J n')\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. value_written P (justifying_exec (J n')) w' (ad', al') =\n    value_written P E (action_translation (J n') w') (ad', al')", "unfolding \\<open>?\\<phi> n (?ws n a') = ws (?\\<phi> n a')\\<close> w' is_weakly_justified_by.simps Let_def value_written_committed_def"], ["proof (prove)\nusing this:\n  w' \\<in> write_actions (justifying_exec (J n'))\n  (ad', al') \\<in> action_loc P E (action_translation (J n') w')\n  w' \\<in> committed (J n')\n  is_commit_sequence E J \\<and>\n  justification_well_formed P J \\<and>\n  committed_subset_actions J \\<and>\n  happens_before_committed_weak P E ws J \\<and>\n  (\\<forall>n.\n      \\<forall>w\\<in>write_actions (justifying_exec (J n)) \\<inter>\n                     committed (J n).\n         \\<forall>adal\\<in>action_loc P E (action_translation (J n) w).\n            value_written P (justifying_exec (J n)) w adal =\n            value_written P E (action_translation (J n) w) adal) \\<and>\n  write_seen_committed ws J \\<and>\n  uncommitted_reads_see_hb P J \\<and>\n  committed_reads_see_committed_writes_weak ws J \\<and>\n  wf_action_translations E J\n\ngoal (1 subgoal):\n 1. value_written P (justifying_exec (J n')) w' (ad', al') =\n    value_written P E (action_translation (J n') w') (ad', al')", "by blast"], ["proof (state)\nthis:\n  value_written P (justifying_exec (J n')) w' (ad', al') =\n  value_written P E (action_translation (J n') w') (ad', al')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  value_written P (justifying_exec (J n')) w' (ad', al') =\n  value_written P E (action_translation (J n') w') (ad', al')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "note w'[symmetric]"], ["proof (state)\nthis:\n  action_translation (J n') w' = ws (action_translation (J n) a')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  action_translation (J n') w' = ws (action_translation (J n) a')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "note \\<open>?\\<phi> n (?ws n a') = ws (?\\<phi> n a')\\<close>[symmetric]"], ["proof (state)\nthis:\n  ws (action_translation (J n) a') =\n  action_translation (J n) (justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  ws (action_translation (J n) a') =\n  action_translation (J n) (justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "have \"value_written P E (?\\<phi> n (?ws n a')) (ad', al') = value_written P (?E n) (?ws n a') (ad', al')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n     (ad', al') =\n    value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n     (ad', al')", "using justified committed_ws ws_write adal_E"], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  justifying_ws (J n) a' \\<in> committed (J n)\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  (ad', al')\n  \\<in> action_loc P E (action_translation (J n) (justifying_ws (J n) a'))\n\ngoal (1 subgoal):\n 1. value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n     (ad', al') =\n    value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n     (ad', al')", "unfolding is_weakly_justified_by.simps Let_def value_written_committed_def"], ["proof (prove)\nusing this:\n  is_commit_sequence E J \\<and>\n  justification_well_formed P J \\<and>\n  committed_subset_actions J \\<and>\n  happens_before_committed_weak P E ws J \\<and>\n  (\\<forall>n.\n      \\<forall>w\\<in>write_actions (justifying_exec (J n)) \\<inter>\n                     committed (J n).\n         \\<forall>adal\\<in>action_loc P E (action_translation (J n) w).\n            value_written P (justifying_exec (J n)) w adal =\n            value_written P E (action_translation (J n) w) adal) \\<and>\n  write_seen_committed ws J \\<and>\n  uncommitted_reads_see_hb P J \\<and>\n  committed_reads_see_committed_writes_weak ws J \\<and>\n  wf_action_translations E J\n  justifying_ws (J n) a' \\<in> committed (J n)\n  justifying_ws (J n) a' \\<in> write_actions (justifying_exec (J n))\n  (ad', al')\n  \\<in> action_loc P E (action_translation (J n) (justifying_ws (J n) a'))\n\ngoal (1 subgoal):\n 1. value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n     (ad', al') =\n    value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n     (ad', al')", "by(blast dest: sym)"], ["proof (state)\nthis:\n  value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n   (ad', al') =\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "also"], ["proof (state)\nthis:\n  value_written P E (action_translation (J n) (justifying_ws (J n) a'))\n   (ad', al') =\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al')\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "have \"(ad', al') \\<in> action_loc P (?E n') w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ad', al') \\<in> action_loc P (justifying_exec (J n')) w'", "using sim_w' adal"], ["proof (prove)\nusing this:\n  action_obs (justifying_exec (J n'))\n   w' \\<approx> action_obs (justifying_exec (J n)) (justifying_ws (J n) a')\n  (ad', al')\n  \\<in> action_loc P (justifying_exec (J n)) (justifying_ws (J n) a')\n\ngoal (1 subgoal):\n 1. (ad', al') \\<in> action_loc P (justifying_exec (J n')) w'", "by(simp add: action_loc_aux_sim_action)"], ["proof (state)\nthis:\n  (ad', al') \\<in> action_loc P (justifying_exec (J n')) w'\n\ngoal (1 subgoal):\n 1. action_translation (J n') a''\n    \\<notin> action_translation (J n'') `\n             committed (J n'') \\<Longrightarrow>\n    \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "ultimately"], ["proof (chain)\npicking this:\n  value_written P (justifying_exec (J n')) w' (ad', al') =\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al')\n  (ad', al') \\<in> action_loc P (justifying_exec (J n')) w'", "show ?thesis"], ["proof (prove)\nusing this:\n  value_written P (justifying_exec (J n')) w' (ad', al') =\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al')\n  (ad', al') \\<in> action_loc P (justifying_exec (J n')) w'\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "using written write_w'"], ["proof (prove)\nusing this:\n  value_written P (justifying_exec (J n')) w' (ad', al') =\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al')\n  (ad', al') \\<in> action_loc P (justifying_exec (J n')) w'\n  value_written P (justifying_exec (J n)) (justifying_ws (J n) a')\n   (ad', al') =\n  v'\n  w' \\<in> write_actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n       (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n       value_written P (justifying_exec (J n')) w (ad', al') = v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n     (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n     value_written P (justifying_exec (J n')) w (ad', al') = v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n     (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n     value_written P (justifying_exec (J n')) w (ad', al') = v'\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n     (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n     value_written P (justifying_exec (J n')) w (ad', al') = v'", "obtain w where w: \"w \\<in> write_actions (?E n')\"\n          and adal: \"(ad', al') \\<in> action_loc P (?E n') w\"\n          and written: \"value_written P (?E n') w (ad', al') = v'\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>write_actions (justifying_exec (J n')).\n     (ad', al') \\<in> action_loc P (justifying_exec (J n')) w \\<and>\n     value_written P (justifying_exec (J n')) w (ad', al') = v'\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> write_actions (justifying_exec (J n'));\n         (ad', al') \\<in> action_loc P (justifying_exec (J n')) w;\n         value_written P (justifying_exec (J n')) w (ad', al') = v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<in> write_actions (justifying_exec (J n'))\n  (ad', al') \\<in> action_loc P (justifying_exec (J n')) w\n  value_written P (justifying_exec (J n')) w (ad', al') = v'\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "from w"], ["proof (chain)\npicking this:\n  w \\<in> write_actions (justifying_exec (J n'))", "have w_len: \"enat w < llength (?E n')\""], ["proof (prove)\nusing this:\n  w \\<in> write_actions (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. enat w < llength (justifying_exec (J n'))", "by(cases)(simp add: actions_def)"], ["proof (state)\nthis:\n  enat w < llength (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "let ?EE'' = \"lmap snd (ltake (enat w) (?E n'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "have \"non_speculative P (vs_type_all P) ?EE''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_speculative P (vs_type_all P)\n     (lmap snd (ltake (enat w) (justifying_exec (J n'))))", "proof(rule non_speculative_nthI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "fix i ad al v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "assume i: \"enat i < llength ?EE''\"\n            and i_nth: \"lnth ?EE'' i = NormalAction (ReadMem ad al v)\"\n            and ns: \"non_speculative P (vs_type_all P) (ltake (enat i) ?EE'')\""], ["proof (state)\nthis:\n  enat i < llength (lmap snd (ltake (enat w) (justifying_exec (J n'))))\n  lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n  NormalAction (ReadMem ad al v)\n  non_speculative P (vs_type_all P)\n   (ltake (enat i) (lmap snd (ltake (enat w) (justifying_exec (J n')))))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "from i w_len"], ["proof (chain)\npicking this:\n  enat i < llength (lmap snd (ltake (enat w) (justifying_exec (J n'))))\n  enat w < llength (justifying_exec (J n'))", "have \"i < w\""], ["proof (prove)\nusing this:\n  enat i < llength (lmap snd (ltake (enat w) (justifying_exec (J n'))))\n  enat w < llength (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. i < w", "by(simp add: min_def not_le split: if_split_asm)"], ["proof (state)\nthis:\n  i < w\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "with w_len"], ["proof (chain)\npicking this:\n  enat w < llength (justifying_exec (J n'))\n  i < w", "have \"enat i < llength (?E n')\""], ["proof (prove)\nusing this:\n  enat w < llength (justifying_exec (J n'))\n  i < w\n\ngoal (1 subgoal):\n 1. enat i < llength (justifying_exec (J n'))", "by(simp add: less_trans[where y=\"enat w\"])"], ["proof (state)\nthis:\n  enat i < llength (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "moreover"], ["proof (state)\nthis:\n  enat i < llength (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "from i_nth i \\<open>i < w\\<close> w_len"], ["proof (chain)\npicking this:\n  lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n  NormalAction (ReadMem ad al v)\n  enat i < llength (lmap snd (ltake (enat w) (justifying_exec (J n'))))\n  i < w\n  enat w < llength (justifying_exec (J n'))", "have \"action_obs (?E n') i = NormalAction (ReadMem ad al v)\""], ["proof (prove)\nusing this:\n  lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n  NormalAction (ReadMem ad al v)\n  enat i < llength (lmap snd (ltake (enat w) (justifying_exec (J n'))))\n  i < w\n  enat w < llength (justifying_exec (J n'))\n\ngoal (1 subgoal):\n 1. action_obs (justifying_exec (J n')) i = NormalAction (ReadMem ad al v)", "by(simp add: action_obs_def ac_simps less_trans[where y=\"enat w\"] lnth_ltake)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n')) i = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "moreover"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n')) i = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "from n''"], ["proof (chain)\npicking this:\n  n' = Suc n''", "have \"0 < n'\""], ["proof (prove)\nusing this:\n  n' = Suc n''\n\ngoal (1 subgoal):\n 1. 0 < n'", "by simp"], ["proof (state)\nthis:\n  0 < n'\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "ultimately"], ["proof (chain)\npicking this:\n  enat i < llength (justifying_exec (J n'))\n  action_obs (justifying_exec (J n')) i = NormalAction (ReadMem ad al v)\n  0 < n'", "have \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  enat i < llength (justifying_exec (J n'))\n  action_obs (justifying_exec (J n')) i = NormalAction (ReadMem ad al v)\n  0 < n'\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "by(rule Suc.IH)"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "hence \"v \\<in> vs_type_all P (ad, al)\""], ["proof (prove)\nusing this:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. v \\<in> vs_type_all P (ad, al)", "by(simp add: vs_type_all.simps)"], ["proof (state)\nthis:\n  v \\<in> vs_type_all P (ad, al)\n\ngoal (1 subgoal):\n 1. \\<And>i ad al v.\n       \\<lbrakk>enat i\n                < llength\n                   (lmap snd (ltake (enat w) (justifying_exec (J n'))));\n        lnth (lmap snd (ltake (enat w) (justifying_exec (J n')))) i =\n        NormalAction (ReadMem ad al v);\n        non_speculative P (vs_type_all P)\n         (ltake (enat i)\n           (lmap snd (ltake (enat w) (justifying_exec (J n')))))\\<rbrakk>\n       \\<Longrightarrow> v \\<in> w_values P (vs_type_all P)\n                                  (list_of\n                                    (ltake (enat i)\n(lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n                                  (ad, al)", "thus \"v \\<in> w_values P (vs_type_all P) (list_of (ltake (enat i) ?EE'')) (ad, al)\""], ["proof (prove)\nusing this:\n  v \\<in> vs_type_all P (ad, al)\n\ngoal (1 subgoal):\n 1. v \\<in> w_values P (vs_type_all P)\n             (list_of\n               (ltake (enat i)\n                 (lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n             (ad, al)", "by(rule w_values_mono[THEN subsetD])"], ["proof (state)\nthis:\n  v \\<in> w_values P (vs_type_all P)\n           (list_of\n             (ltake (enat i)\n               (lmap snd (ltake (enat w) (justifying_exec (J n'))))))\n           (ad, al)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  non_speculative P (vs_type_all P)\n   (lmap snd (ltake (enat w) (justifying_exec (J n'))))\n\ngoal (1 subgoal):\n 1. \\<And>a ad al v.\n       \\<lbrakk>enat a < llength (justifying_exec (J n));\n        action_obs (justifying_exec (J n)) a =\n        NormalAction (ReadMem ad al v);\n        \\<not> P,justifying_exec\n                  (J n) \\<turnstile> justifying_ws (J n)\na \\<le>hb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            P \\<turnstile> ad@al : T \\<and>\n                            P \\<turnstile> v :\\<le> T", "with wfx_start wfP E' w adal"], ["proof (chain)\npicking this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  justifying_exec (J n') \\<in> h.\\<E>_start f P C M vs status\n  w \\<in> write_actions (justifying_exec (J n'))\n  (ad', al') \\<in> action_loc P (justifying_exec (J n')) w\n  non_speculative P (vs_type_all P)\n   (lmap snd (ltake (enat w) (justifying_exec (J n'))))", "show \"\\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T\""], ["proof (prove)\nusing this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  justifying_exec (J n') \\<in> h.\\<E>_start f P C M vs status\n  w \\<in> write_actions (justifying_exec (J n'))\n  (ad', al') \\<in> action_loc P (justifying_exec (J n')) w\n  non_speculative P (vs_type_all P)\n   (lmap snd (ltake (enat w) (justifying_exec (J n'))))\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T", "unfolding written[symmetric]"], ["proof (prove)\nusing this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  justifying_exec (J n') \\<in> h.\\<E>_start f P C M vs status\n  w \\<in> write_actions (justifying_exec (J n'))\n  (ad', al') \\<in> action_loc P (justifying_exec (J n')) w\n  non_speculative P (vs_type_all P)\n   (lmap snd (ltake (enat w) (justifying_exec (J n'))))\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       P \\<turnstile> ad'@al' : T \\<and>\n       P \\<turnstile> value_written P (justifying_exec (J n')) w\n                       (ad', al') :\\<le> T", "by(rule non_speculative_written_value_typeable)"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad'@al' : T \\<and> P \\<turnstile> v' :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "}"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?aa19 < llength (justifying_exec (J ?na19));\n   action_obs (justifying_exec (J ?na19)) ?aa19 =\n   NormalAction (ReadMem ad al v);\n   0 < ?na19\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       P \\<turnstile> ad@al : T \\<and>\n                       P \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "note justifying = this"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?aa19 < llength (justifying_exec (J ?na19));\n   action_obs (justifying_exec (J ?na19)) ?aa19 =\n   NormalAction (ReadMem ad al v);\n   0 < ?na19\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       P \\<turnstile> ad@al : T \\<and>\n                       P \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "assume a: \"enat a < llength E\"\n    and read: \"action_obs E a = NormalAction (ReadMem ad al v)\"\n    and E: \"E \\<in> h.\\<E>_start f P C M vs status\"\n    and wf: \"P \\<turnstile> (E, ws) \\<surd>\""], ["proof (state)\nthis:\n  enat a < llength E\n  action_obs E a = NormalAction (ReadMem ad al v)\n  E \\<in> h.\\<E>_start f P C M vs status\n  P \\<turnstile> (E, ws) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from a"], ["proof (chain)\npicking this:\n  enat a < llength E", "have action: \"a \\<in> actions E\""], ["proof (prove)\nusing this:\n  enat a < llength E\n\ngoal (1 subgoal):\n 1. a \\<in> actions E", "by(auto simp add: actions_def action_obs_def)"], ["proof (state)\nthis:\n  a \\<in> actions E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a \\<in> actions E", "obtain n a' where a': \"a = ?\\<phi> n a'\"\n    and committed': \"a' \\<in> ?C n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a \\<in> actions E\n\ngoal (1 subgoal):\n 1. (\\<And>n a'.\n        \\<lbrakk>a = action_translation (J n) a';\n         a' \\<in> committed (J n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: is_commit_sequence_def)"], ["proof (state)\nthis:\n  a = action_translation (J n) a'\n  a' \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have C_n: \"?C n \\<subseteq> actions (?E n)\"\n    and C_Sn: \"?C (Suc n) \\<subseteq> actions (?E (Suc n))\"\n    and wf_tr: \"wf_action_translation E (J n)\" \n    and wf_tr': \"wf_action_translation E (J (Suc n))\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. (committed (J n) \\<subseteq> actions (justifying_exec (J n)) &&&\n     committed (J (Suc n))\n     \\<subseteq> actions (justifying_exec (J (Suc n)))) &&&\n    wf_action_translation E (J n) &&& wf_action_translation E (J (Suc n))", "by(auto simp add: committed_subset_actions_def wf_action_translations_def)"], ["proof (state)\nthis:\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))\n  committed (J (Suc n)) \\<subseteq> actions (justifying_exec (J (Suc n)))\n  wf_action_translation E (J n)\n  wf_action_translation E (J (Suc n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from C_n committed'"], ["proof (chain)\npicking this:\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))\n  a' \\<in> committed (J n)", "have action': \"a' \\<in> actions (?E n)\""], ["proof (prove)\nusing this:\n  committed (J n) \\<subseteq> actions (justifying_exec (J n))\n  a' \\<in> committed (J n)\n\ngoal (1 subgoal):\n 1. a' \\<in> actions (justifying_exec (J n))", "by blast"], ["proof (state)\nthis:\n  a' \\<in> actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from wf_tr committed' a'"], ["proof (chain)\npicking this:\n  wf_action_translation E (J n)\n  a' \\<in> committed (J n)\n  a = action_translation (J n) a'", "have \"action_tid E a = action_tid (?E n) a'\" \"action_obs E a \\<approx> action_obs (?E n) a'\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J n)\n  a' \\<in> committed (J n)\n  a = action_translation (J n) a'\n\ngoal (1 subgoal):\n 1. action_tid E a = action_tid (justifying_exec (J n)) a' &&&\n    action_obs E a \\<approx> action_obs (justifying_exec (J n)) a'", "by(auto simp add: wf_action_translation_on_def intro: sim_action_sym)"], ["proof (state)\nthis:\n  action_tid E a = action_tid (justifying_exec (J n)) a'\n  action_obs E a \\<approx> action_obs (justifying_exec (J n)) a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with read"], ["proof (chain)\npicking this:\n  action_obs E a = NormalAction (ReadMem ad al v)\n  action_tid E a = action_tid (justifying_exec (J n)) a'\n  action_obs E a \\<approx> action_obs (justifying_exec (J n)) a'", "obtain v'\n    where \"action_obs (?E n) a' = NormalAction (ReadMem ad al v')\""], ["proof (prove)\nusing this:\n  action_obs E a = NormalAction (ReadMem ad al v)\n  action_tid E a = action_tid (justifying_exec (J n)) a'\n  action_obs E a \\<approx> action_obs (justifying_exec (J n)) a'\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        action_obs (justifying_exec (J n)) a' =\n        NormalAction (ReadMem ad al v') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: action_obs_def)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J n)) a' = NormalAction (ReadMem ad al v')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with action'"], ["proof (chain)\npicking this:\n  a' \\<in> actions (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a' = NormalAction (ReadMem ad al v')", "have read': \"a' \\<in> read_actions (?E n)\""], ["proof (prove)\nusing this:\n  a' \\<in> actions (justifying_exec (J n))\n  action_obs (justifying_exec (J n)) a' = NormalAction (ReadMem ad al v')\n\ngoal (1 subgoal):\n 1. a' \\<in> read_actions (justifying_exec (J n))", ".."], ["proof (state)\nthis:\n  a' \\<in> read_actions (justifying_exec (J n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have \"?\\<phi> n ` ?C n \\<subseteq> ?\\<phi> (Suc n) ` ?C (Suc n)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. action_translation (J n) ` committed (J n)\n    \\<subseteq> action_translation (J (Suc n)) ` committed (J (Suc n))", "by(simp add: is_commit_sequence_def)"], ["proof (state)\nthis:\n  action_translation (J n) ` committed (J n)\n  \\<subseteq> action_translation (J (Suc n)) ` committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with committed' a'"], ["proof (chain)\npicking this:\n  a' \\<in> committed (J n)\n  a = action_translation (J n) a'\n  action_translation (J n) ` committed (J n)\n  \\<subseteq> action_translation (J (Suc n)) ` committed (J (Suc n))", "have \"a \\<in> \\<dots>\""], ["proof (prove)\nusing this:\n  a' \\<in> committed (J n)\n  a = action_translation (J n) a'\n  action_translation (J n) ` committed (J n)\n  \\<subseteq> action_translation (J (Suc n)) ` committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. a \\<in> action_translation (J (Suc n)) ` committed (J (Suc n))", "by auto"], ["proof (state)\nthis:\n  a \\<in> action_translation (J (Suc n)) ` committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  a \\<in> action_translation (J (Suc n)) ` committed (J (Suc n))", "obtain a'' where a'': \"a = ?\\<phi> (Suc n) a''\"\n    and committed'': \"a'' \\<in> ?C (Suc n)\""], ["proof (prove)\nusing this:\n  a \\<in> action_translation (J (Suc n)) ` committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>a = action_translation (J (Suc n)) a'';\n         a'' \\<in> committed (J (Suc n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = action_translation (J (Suc n)) a''\n  a'' \\<in> committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from committed'' C_Sn"], ["proof (chain)\npicking this:\n  a'' \\<in> committed (J (Suc n))\n  committed (J (Suc n)) \\<subseteq> actions (justifying_exec (J (Suc n)))", "have action'': \"a'' \\<in> actions (?E (Suc n))\""], ["proof (prove)\nusing this:\n  a'' \\<in> committed (J (Suc n))\n  committed (J (Suc n)) \\<subseteq> actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. a'' \\<in> actions (justifying_exec (J (Suc n)))", "by blast"], ["proof (state)\nthis:\n  a'' \\<in> actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with wf_tr'"], ["proof (chain)\npicking this:\n  wf_action_translation E (J (Suc n))\n  a'' \\<in> actions (justifying_exec (J (Suc n)))", "have \"a'' = inv_into (actions (?E (Suc n))) (?\\<phi> (Suc n)) a\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J (Suc n))\n  a'' \\<in> actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. a'' =\n    inv_into (actions (justifying_exec (J (Suc n))))\n     (action_translation (J (Suc n))) a", "by(simp add: a'' wf_action_translation_on_def)"], ["proof (state)\nthis:\n  a'' =\n  inv_into (actions (justifying_exec (J (Suc n))))\n   (action_translation (J (Suc n))) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with justified read' committed' a'"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a' \\<in> read_actions (justifying_exec (J n))\n  a' \\<in> committed (J n)\n  a = action_translation (J n) a'\n  a'' =\n  inv_into (actions (justifying_exec (J (Suc n))))\n   (action_translation (J (Suc n))) a", "have ws_a: \"ws a = ?\\<phi> (Suc n) (?ws (Suc n) a'')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a' \\<in> read_actions (justifying_exec (J n))\n  a' \\<in> committed (J n)\n  a = action_translation (J n) a'\n  a'' =\n  inv_into (actions (justifying_exec (J (Suc n))))\n   (action_translation (J (Suc n))) a\n\ngoal (1 subgoal):\n 1. ws a = action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')", "by(simp add: write_seen_committed_def)"], ["proof (state)\nthis:\n  ws a = action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from wf_tr' committed'' a''"], ["proof (chain)\npicking this:\n  wf_action_translation E (J (Suc n))\n  a'' \\<in> committed (J (Suc n))\n  a = action_translation (J (Suc n)) a''", "have \"action_tid E a = action_tid (?E (Suc n)) a''\"\n    and \"action_obs E a \\<approx> action_obs (?E (Suc n)) a''\""], ["proof (prove)\nusing this:\n  wf_action_translation E (J (Suc n))\n  a'' \\<in> committed (J (Suc n))\n  a = action_translation (J (Suc n)) a''\n\ngoal (1 subgoal):\n 1. action_tid E a = action_tid (justifying_exec (J (Suc n))) a'' &&&\n    action_obs E a \\<approx> action_obs (justifying_exec (J (Suc n))) a''", "by(auto simp add: wf_action_translation_on_def intro: sim_action_sym)"], ["proof (state)\nthis:\n  action_tid E a = action_tid (justifying_exec (J (Suc n))) a''\n  action_obs E a \\<approx> action_obs (justifying_exec (J (Suc n))) a''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with read"], ["proof (chain)\npicking this:\n  action_obs E a = NormalAction (ReadMem ad al v)\n  action_tid E a = action_tid (justifying_exec (J (Suc n))) a''\n  action_obs E a \\<approx> action_obs (justifying_exec (J (Suc n))) a''", "obtain v''\n    where a_obs'': \"action_obs (?E (Suc n)) a'' = NormalAction (ReadMem ad al v'')\""], ["proof (prove)\nusing this:\n  action_obs E a = NormalAction (ReadMem ad al v)\n  action_tid E a = action_tid (justifying_exec (J (Suc n))) a''\n  action_obs E a \\<approx> action_obs (justifying_exec (J (Suc n))) a''\n\ngoal (1 subgoal):\n 1. (\\<And>v''.\n        action_obs (justifying_exec (J (Suc n))) a'' =\n        NormalAction (ReadMem ad al v'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: action_obs_def)"], ["proof (state)\nthis:\n  action_obs (justifying_exec (J (Suc n))) a'' =\n  NormalAction (ReadMem ad al v'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with action''"], ["proof (chain)\npicking this:\n  a'' \\<in> actions (justifying_exec (J (Suc n)))\n  action_obs (justifying_exec (J (Suc n))) a'' =\n  NormalAction (ReadMem ad al v'')", "have read'': \"a'' \\<in> read_actions (?E (Suc n))\""], ["proof (prove)\nusing this:\n  a'' \\<in> actions (justifying_exec (J (Suc n)))\n  action_obs (justifying_exec (J (Suc n))) a'' =\n  NormalAction (ReadMem ad al v'')\n\ngoal (1 subgoal):\n 1. a'' \\<in> read_actions (justifying_exec (J (Suc n)))", "by(auto intro: read_actions.intros simp add: action_obs_def)"], ["proof (state)\nthis:\n  a'' \\<in> read_actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "have \"a \\<in> read_actions E\" \"action_obs E a = NormalAction (ReadMem ad al v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> read_actions E &&&\n    action_obs E a = NormalAction (ReadMem ad al v)", "using action read"], ["proof (prove)\nusing this:\n  a \\<in> actions E\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. a \\<in> read_actions E &&&\n    action_obs E a = NormalAction (ReadMem ad al v)", "by(auto intro: read_actions.intros simp add: action_obs_def read)"], ["proof (state)\nthis:\n  a \\<in> read_actions E\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from is_write_seenD[OF wf_exec_is_write_seenD[OF wf] this]"], ["proof (chain)\npicking this:\n  ws a \\<in> write_actions E \\<and>\n  (ad, al) \\<in> action_loc P E (ws a) \\<and>\n  value_written P E (ws a) (ad, al) = v \\<and>\n  \\<not> P,E \\<turnstile> a \\<le>hb ws a \\<and>\n  (is_volatile P al \\<longrightarrow>\n   \\<not> P,E \\<turnstile> a \\<le>so ws a) \\<and>\n  (\\<forall>a'\\<in>write_actions E.\n      (ad, al) \\<in> action_loc P E a' \\<and>\n      (P,E \\<turnstile> ws a \\<le>hb a' \\<and>\n       P,E \\<turnstile> a' \\<le>hb a \\<or>\n       is_volatile P al \\<and>\n       P,E \\<turnstile> ws a \\<le>so a' \\<and>\n       P,E \\<turnstile> a' \\<le>so a) \\<longrightarrow>\n      a' = ws a)", "have v_eq: \"v = value_written P E (ws a) (ad, al)\" \n    and adal: \"(ad, al) \\<in> action_loc P E (ws a)\""], ["proof (prove)\nusing this:\n  ws a \\<in> write_actions E \\<and>\n  (ad, al) \\<in> action_loc P E (ws a) \\<and>\n  value_written P E (ws a) (ad, al) = v \\<and>\n  \\<not> P,E \\<turnstile> a \\<le>hb ws a \\<and>\n  (is_volatile P al \\<longrightarrow>\n   \\<not> P,E \\<turnstile> a \\<le>so ws a) \\<and>\n  (\\<forall>a'\\<in>write_actions E.\n      (ad, al) \\<in> action_loc P E a' \\<and>\n      (P,E \\<turnstile> ws a \\<le>hb a' \\<and>\n       P,E \\<turnstile> a' \\<le>hb a \\<or>\n       is_volatile P al \\<and>\n       P,E \\<turnstile> ws a \\<le>so a' \\<and>\n       P,E \\<turnstile> a' \\<le>so a) \\<longrightarrow>\n      a' = ws a)\n\ngoal (1 subgoal):\n 1. v = value_written P E (ws a) (ad, al) &&&\n    (ad, al) \\<in> action_loc P E (ws a)", "by simp_all"], ["proof (state)\nthis:\n  v = value_written P E (ws a) (ad, al)\n  (ad, al) \\<in> action_loc P E (ws a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from justified"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J", "have \"P \\<turnstile> (?E (Suc n), ?ws (Suc n)) \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (justifying_exec (J (Suc n)),\n                    justifying_ws (J (Suc n))) \\<surd>", "by(simp add: justification_well_formed_def)"], ["proof (state)\nthis:\n  P \\<turnstile> (justifying_exec (J (Suc n)),\n                  justifying_ws (J (Suc n))) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from is_write_seenD[OF wf_exec_is_write_seenD[OF this] read'' a_obs'']"], ["proof (chain)\npicking this:\n  justifying_ws (J (Suc n)) a''\n  \\<in> write_actions (justifying_exec (J (Suc n))) \\<and>\n  (ad, al)\n  \\<in> action_loc P (justifying_exec (J (Suc n)))\n         (justifying_ws (J (Suc n)) a'') \\<and>\n  value_written P (justifying_exec (J (Suc n)))\n   (justifying_ws (J (Suc n)) a'') (ad, al) =\n  v'' \\<and>\n  \\<not> P,justifying_exec\n            (J (Suc n)) \\<turnstile> a'' \\<le>hb justifying_ws (J (Suc n))\n            a'' \\<and>\n  (is_volatile P al \\<longrightarrow>\n   \\<not> P,justifying_exec\n             (J (Suc n)) \\<turnstile> a'' \\<le>so justifying_ws (J (Suc n))\n             a'') \\<and>\n  (\\<forall>a'\\<in>write_actions (justifying_exec (J (Suc n))).\n      (ad, al) \\<in> action_loc P (justifying_exec (J (Suc n))) a' \\<and>\n      (P,justifying_exec\n          (J (Suc n)) \\<turnstile> justifying_ws (J (Suc n))\n                                    a'' \\<le>hb a' \\<and>\n       P,justifying_exec (J (Suc n)) \\<turnstile> a' \\<le>hb a'' \\<or>\n       is_volatile P al \\<and>\n       P,justifying_exec\n          (J (Suc n)) \\<turnstile> justifying_ws (J (Suc n))\n                                    a'' \\<le>so a' \\<and>\n       P,justifying_exec\n          (J (Suc n)) \\<turnstile> a' \\<le>so a'') \\<longrightarrow>\n      a' = justifying_ws (J (Suc n)) a'')", "have write'': \"?ws (Suc n) a'' \\<in> write_actions (?E (Suc n))\" \n    and written'': \"value_written P (?E (Suc n)) (?ws (Suc n) a'') (ad, al) = v''\""], ["proof (prove)\nusing this:\n  justifying_ws (J (Suc n)) a''\n  \\<in> write_actions (justifying_exec (J (Suc n))) \\<and>\n  (ad, al)\n  \\<in> action_loc P (justifying_exec (J (Suc n)))\n         (justifying_ws (J (Suc n)) a'') \\<and>\n  value_written P (justifying_exec (J (Suc n)))\n   (justifying_ws (J (Suc n)) a'') (ad, al) =\n  v'' \\<and>\n  \\<not> P,justifying_exec\n            (J (Suc n)) \\<turnstile> a'' \\<le>hb justifying_ws (J (Suc n))\n            a'' \\<and>\n  (is_volatile P al \\<longrightarrow>\n   \\<not> P,justifying_exec\n             (J (Suc n)) \\<turnstile> a'' \\<le>so justifying_ws (J (Suc n))\n             a'') \\<and>\n  (\\<forall>a'\\<in>write_actions (justifying_exec (J (Suc n))).\n      (ad, al) \\<in> action_loc P (justifying_exec (J (Suc n))) a' \\<and>\n      (P,justifying_exec\n          (J (Suc n)) \\<turnstile> justifying_ws (J (Suc n))\n                                    a'' \\<le>hb a' \\<and>\n       P,justifying_exec (J (Suc n)) \\<turnstile> a' \\<le>hb a'' \\<or>\n       is_volatile P al \\<and>\n       P,justifying_exec\n          (J (Suc n)) \\<turnstile> justifying_ws (J (Suc n))\n                                    a'' \\<le>so a' \\<and>\n       P,justifying_exec\n          (J (Suc n)) \\<turnstile> a' \\<le>so a'') \\<longrightarrow>\n      a' = justifying_ws (J (Suc n)) a'')\n\ngoal (1 subgoal):\n 1. justifying_ws (J (Suc n)) a''\n    \\<in> write_actions (justifying_exec (J (Suc n))) &&&\n    value_written P (justifying_exec (J (Suc n)))\n     (justifying_ws (J (Suc n)) a'') (ad, al) =\n    v''", "by simp_all"], ["proof (state)\nthis:\n  justifying_ws (J (Suc n)) a''\n  \\<in> write_actions (justifying_exec (J (Suc n)))\n  value_written P (justifying_exec (J (Suc n)))\n   (justifying_ws (J (Suc n)) a'') (ad, al) =\n  v''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from justified read'' committed''"], ["proof (chain)\npicking this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a'' \\<in> read_actions (justifying_exec (J (Suc n)))\n  a'' \\<in> committed (J (Suc n))", "have \"ws (?\\<phi> (Suc n) a'') \\<in> ?\\<phi> (Suc n) ` ?C (Suc n)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  a'' \\<in> read_actions (justifying_exec (J (Suc n)))\n  a'' \\<in> committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. ws (action_translation (J (Suc n)) a'')\n    \\<in> action_translation (J (Suc n)) ` committed (J (Suc n))", "by(rule weakly_justified_write_seen_hb_read_committed)"], ["proof (state)\nthis:\n  ws (action_translation (J (Suc n)) a'')\n  \\<in> action_translation (J (Suc n)) ` committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  ws (action_translation (J (Suc n)) a'')\n  \\<in> action_translation (J (Suc n)) ` committed (J (Suc n))", "obtain w where w: \"ws (?\\<phi> (Suc n) a'') = ?\\<phi> (Suc n) w\"\n    and committed_w: \"w \\<in> ?C (Suc n)\""], ["proof (prove)\nusing this:\n  ws (action_translation (J (Suc n)) a'')\n  \\<in> action_translation (J (Suc n)) ` committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>ws (action_translation (J (Suc n)) a'') =\n                 action_translation (J (Suc n)) w;\n         w \\<in> committed (J (Suc n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ws (action_translation (J (Suc n)) a'') = action_translation (J (Suc n)) w\n  w \\<in> committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with C_Sn"], ["proof (chain)\npicking this:\n  committed (J (Suc n)) \\<subseteq> actions (justifying_exec (J (Suc n)))\n  ws (action_translation (J (Suc n)) a'') = action_translation (J (Suc n)) w\n  w \\<in> committed (J (Suc n))", "have \"w \\<in> actions (?E (Suc n))\""], ["proof (prove)\nusing this:\n  committed (J (Suc n)) \\<subseteq> actions (justifying_exec (J (Suc n)))\n  ws (action_translation (J (Suc n)) a'') = action_translation (J (Suc n)) w\n  w \\<in> committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. w \\<in> actions (justifying_exec (J (Suc n)))", "by blast"], ["proof (state)\nthis:\n  w \\<in> actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "moreover"], ["proof (state)\nthis:\n  w \\<in> actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "have \"ws (?\\<phi> (Suc n) a'') = ?\\<phi> (Suc n) (?ws (Suc n) a'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws (action_translation (J (Suc n)) a'') =\n    action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')", "using ws_a a''"], ["proof (prove)\nusing this:\n  ws a = action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')\n  a = action_translation (J (Suc n)) a''\n\ngoal (1 subgoal):\n 1. ws (action_translation (J (Suc n)) a'') =\n    action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')", "by simp"], ["proof (state)\nthis:\n  ws (action_translation (J (Suc n)) a'') =\n  action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "ultimately"], ["proof (chain)\npicking this:\n  w \\<in> actions (justifying_exec (J (Suc n)))\n  ws (action_translation (J (Suc n)) a'') =\n  action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')", "have w_def: \"w = ?ws (Suc n) a''\""], ["proof (prove)\nusing this:\n  w \\<in> actions (justifying_exec (J (Suc n)))\n  ws (action_translation (J (Suc n)) a'') =\n  action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')\n\ngoal (1 subgoal):\n 1. w = justifying_ws (J (Suc n)) a''", "using wf_action_translation_on_inj_onD[OF wf_tr'] write''"], ["proof (prove)\nusing this:\n  w \\<in> actions (justifying_exec (J (Suc n)))\n  ws (action_translation (J (Suc n)) a'') =\n  action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')\n  inj_on (action_translation (J (Suc n)))\n   (actions (justifying_exec (J (Suc n))))\n  justifying_ws (J (Suc n)) a''\n  \\<in> write_actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. w = justifying_ws (J (Suc n)) a''", "unfolding w"], ["proof (prove)\nusing this:\n  w \\<in> actions (justifying_exec (J (Suc n)))\n  action_translation (J (Suc n)) w =\n  action_translation (J (Suc n)) (justifying_ws (J (Suc n)) a'')\n  inj_on (action_translation (J (Suc n)))\n   (actions (justifying_exec (J (Suc n))))\n  justifying_ws (J (Suc n)) a''\n  \\<in> write_actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. w = justifying_ws (J (Suc n)) a''", "by(auto dest: inj_onD)"], ["proof (state)\nthis:\n  w = justifying_ws (J (Suc n)) a''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with committed_w"], ["proof (chain)\npicking this:\n  w \\<in> committed (J (Suc n))\n  w = justifying_ws (J (Suc n)) a''", "have \"?ws (Suc n) a'' \\<in> ?C (Suc n)\""], ["proof (prove)\nusing this:\n  w \\<in> committed (J (Suc n))\n  w = justifying_ws (J (Suc n)) a''\n\ngoal (1 subgoal):\n 1. justifying_ws (J (Suc n)) a'' \\<in> committed (J (Suc n))", "by simp"], ["proof (state)\nthis:\n  justifying_ws (J (Suc n)) a'' \\<in> committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "hence \"value_written P E (ws a) (ad, al) = value_written P (?E (Suc n)) (?ws (Suc n) a'') (ad, al)\""], ["proof (prove)\nusing this:\n  justifying_ws (J (Suc n)) a'' \\<in> committed (J (Suc n))\n\ngoal (1 subgoal):\n 1. value_written P E (ws a) (ad, al) =\n    value_written P (justifying_exec (J (Suc n)))\n     (justifying_ws (J (Suc n)) a'') (ad, al)", "using adal justified write''"], ["proof (prove)\nusing this:\n  justifying_ws (J (Suc n)) a'' \\<in> committed (J (Suc n))\n  (ad, al) \\<in> action_loc P E (ws a)\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  justifying_ws (J (Suc n)) a''\n  \\<in> write_actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. value_written P E (ws a) (ad, al) =\n    value_written P (justifying_exec (J (Suc n)))\n     (justifying_ws (J (Suc n)) a'') (ad, al)", "by(simp add: value_written_committed_def ws_a)"], ["proof (state)\nthis:\n  value_written P E (ws a) (ad, al) =\n  value_written P (justifying_exec (J (Suc n)))\n   (justifying_ws (J (Suc n)) a'') (ad, al)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "with v_eq written''"], ["proof (chain)\npicking this:\n  v = value_written P E (ws a) (ad, al)\n  value_written P (justifying_exec (J (Suc n)))\n   (justifying_ws (J (Suc n)) a'') (ad, al) =\n  v''\n  value_written P E (ws a) (ad, al) =\n  value_written P (justifying_exec (J (Suc n)))\n   (justifying_ws (J (Suc n)) a'') (ad, al)", "have \"v = v''\""], ["proof (prove)\nusing this:\n  v = value_written P E (ws a) (ad, al)\n  value_written P (justifying_exec (J (Suc n)))\n   (justifying_ws (J (Suc n)) a'') (ad, al) =\n  v''\n  value_written P E (ws a) (ad, al) =\n  value_written P (justifying_exec (J (Suc n)))\n   (justifying_ws (J (Suc n)) a'') (ad, al)\n\ngoal (1 subgoal):\n 1. v = v''", "by simp"], ["proof (state)\nthis:\n  v = v''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "from read''"], ["proof (chain)\npicking this:\n  a'' \\<in> read_actions (justifying_exec (J (Suc n)))", "have \"enat a'' < llength (?E (Suc n))\""], ["proof (prove)\nusing this:\n  a'' \\<in> read_actions (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. enat a'' < llength (justifying_exec (J (Suc n)))", "by(cases)(simp add: actions_def)"], ["proof (state)\nthis:\n  enat a'' < llength (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> h.\\<E>_start f P C M vs status;\n     P \\<turnstile> (E, ws) \\<surd>; enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "thus \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  enat a'' < llength (justifying_exec (J (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "by(rule justifying)(simp_all add: a_obs'' \\<open>v = v''\\<close>)"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary weakly_legal_read_value_typeable:\n  assumes wfx_start: \"ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\" \n  and wfP: \"wf_syscls P\"\n  and legal: \"weakly_legal_execution P (h.\\<E>_start f P C M vs status) (E, ws)\"\n  and a: \"enat a < llength E\"\n  and read: \"action_obs E a = NormalAction (ReadMem ad al v)\"\n  shows \"\\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "from legal"], ["proof (chain)\npicking this:\n  weakly_legal_execution P (h.\\<E>_start f P C M vs status) (E, ws)", "obtain J \n    where \"P \\<turnstile> (E, ws) weakly_justified_by J\"\n    and \"range (justifying_exec \\<circ> J) \\<subseteq> h.\\<E>_start f P C M vs status\"\n    and \"E \\<in> h.\\<E>_start f P C M vs status\"\n    and \"P \\<turnstile> (E, ws) \\<surd>\""], ["proof (prove)\nusing this:\n  weakly_legal_execution P (h.\\<E>_start f P C M vs status) (E, ws)\n\ngoal (1 subgoal):\n 1. (\\<And>J.\n        \\<lbrakk>P \\<turnstile> (E, ws) weakly_justified_by J;\n         range (justifying_exec \\<circ> J)\n         \\<subseteq> h.\\<E>_start f P C M vs status;\n         E \\<in> h.\\<E>_start f P C M vs status;\n         P \\<turnstile> (E, ws) \\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule legal_executionE)"], ["proof (state)\nthis:\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  range (justifying_exec \\<circ> J)\n  \\<subseteq> h.\\<E>_start f P C M vs status\n  E \\<in> h.\\<E>_start f P C M vs status\n  P \\<turnstile> (E, ws) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "with wfx_start wfP"], ["proof (chain)\npicking this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  range (justifying_exec \\<circ> J)\n  \\<subseteq> h.\\<E>_start f P C M vs status\n  E \\<in> h.\\<E>_start f P C M vs status\n  P \\<turnstile> (E, ws) \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  range (justifying_exec \\<circ> J)\n  \\<subseteq> h.\\<E>_start f P C M vs status\n  E \\<in> h.\\<E>_start f P C M vs status\n  P \\<turnstile> (E, ws) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "using a read"], ["proof (prove)\nusing this:\n  ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap\n  wf_syscls P\n  P \\<turnstile> (E, ws) weakly_justified_by J\n  range (justifying_exec \\<circ> J)\n  \\<subseteq> h.\\<E>_start f P C M vs status\n  E \\<in> h.\\<E>_start f P C M vs status\n  P \\<turnstile> (E, ws) \\<surd>\n  enat a < llength E\n  action_obs E a = NormalAction (ReadMem ad al v)\n\ngoal (1 subgoal):\n 1. \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T", "by(rule read_value_typeable_justifed)"], ["proof (state)\nthis:\n  \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary legal_read_value_typeable:\n  \"\\<lbrakk> ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap; wf_syscls P;\n     legal_execution P (h.\\<E>_start f P C M vs status) (E, ws);\n     enat a < llength E; action_obs E a = NormalAction (ReadMem ad al v) \\<rbrakk>\n  \\<Longrightarrow> \\<exists>T. P \\<turnstile> ad@al : T \\<and> P \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts_ok wfx (thr (h.start_state f P C M vs)) h.start_heap;\n     wf_syscls P;\n     legal_execution P (h.\\<E>_start f P C M vs status) (E, ws);\n     enat a < llength E;\n     action_obs E a = NormalAction (ReadMem ad al v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         P \\<turnstile> ad@al : T \\<and>\n                         P \\<turnstile> v :\\<le> T", "by(erule (1) weakly_legal_read_value_typeable)(rule legal_imp_weakly_legal_execution)"], ["", "end"], ["", "end"]]}