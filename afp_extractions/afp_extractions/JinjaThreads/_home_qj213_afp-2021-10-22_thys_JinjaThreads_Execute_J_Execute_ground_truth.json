{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/J_Execute.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma eval_sc_red_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o:\n  \"(\\<lambda>t xm ta x'm'. Predicate.eval (sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P t xm) (ta, x'm')) =\n  (\\<lambda>t ((e, xs), h) ta ((e', xs'), h'). extTA2J P,P,t \\<turnstile>sc \\<langle>e, (h, xs)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', xs')\\<rangle>)\"", "lemma sc_J_start_state_invar: \"(\\<lambda>_. True) (sc_state_\\<alpha> (sc_J_start_state_refine P C M vs))\""], "translations": [["", "lemma eval_sc_red_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o:\n  \"(\\<lambda>t xm ta x'm'. Predicate.eval (sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P t xm) (ta, x'm')) =\n  (\\<lambda>t ((e, xs), h) ta ((e', xs'), h'). extTA2J P,P,t \\<turnstile>sc \\<langle>e, (h, xs)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', xs')\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t xm ta x'm'.\n        pred.eval\n         (sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P t xm)\n         (ta, x'm')) =\n    (\\<lambda>t ((e, xs), h) ta ((e', xs'), h').\n        extTA2J\n         P,P,t \\<turnstile>sc \\<langle>e,(h, xs)\\<rangle> -ta\\<rightarrow>\n                              \\<langle>e',(h', xs')\\<rangle>)", "by(auto elim!: red_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_oE intro!: red_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_oI ext SUP1_I simp add: eval_sc_heap_write_i_i_i_i_o eval_sc_heap_read_i_i_i_o)"], ["", "lemma sc_J_start_state_invar: \"(\\<lambda>_. True) (sc_state_\\<alpha> (sc_J_start_state_refine P C M vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "by simp"], ["", "subsection \\<open>Round-robin scheduler\\<close>"], ["", "interpretation J_rr:\n  sc_round_robin_base\n    final_expr \"sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P\" convert_RA Jinja_output\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition sc_rr_J_start_state :: \"nat \\<Rightarrow> 'm prog \\<Rightarrow> thread_id fifo round_robin\"\nwhere \"sc_rr_J_start_state n0 P = J_rr.round_robin_start n0 (sc_start_tid P)\""], ["", "definition exec_J_rr ::\n  \"nat \\<Rightarrow> addr J_prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow>\n  (thread_id \\<times> (addr, thread_id) obs_event list,\n   (addr, thread_id) locks \\<times> ((thread_id, (addr expr \\<times> addr locals) \\<times> addr released_locks) rm \\<times> heap) \\<times>\n   (thread_id, addr wait_set_status) rm \\<times> thread_id rs) tllist\"\nwhere\n  \"exec_J_rr n0 P C M vs = J_rr.exec P n0 (sc_rr_J_start_state n0 P) (sc_J_start_state_refine P C M vs)\""], ["", "interpretation J_rr:\n  sc_round_robin\n    final_expr \"sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P\" convert_RA Jinja_output\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_round_robin TYPE(nat) TYPE(nat) TYPE(nat)\n     TYPE(nat expr \\<times> (String.literal \\<Rightarrow> nat val option))", "by(unfold_locales)"], ["", "interpretation J_rr:\n  sc_scheduler\n    final_expr \"sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P\" convert_RA\n    \"J_rr.round_robin P n0\" Jinja_output \"pick_wakeup_via_sel (\\<lambda>s P. rm_sel s (\\<lambda>(k,v). P k v))\" J_rr.round_robin_invar\n    UNIV\n  for P n0"], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_scheduler final_expr\n     (sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P)\n     convert_RA (J_rr.round_robin P n0)\n     (pick_wakeup_via_sel (\\<lambda>s P. rm.sel s (\\<lambda>(k, v). P k v)))\n     J_rr.round_robin_invar UNIV", "unfolding sc_scheduler_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler final_expr\n     (sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P)\n     convert_RA (J_rr.round_robin P n0)\n     (pick_wakeup_via_sel (\\<lambda>s P. rm.sel s (\\<lambda>(x, y). P x y)))\n     J_rr.round_robin_invar rm.\\<alpha> rm.invar rm.lookup rm.update\n     rm.\\<alpha> rm.invar rm.lookup rm.update rm.delete rm.iteratei\n     rs.\\<alpha> rs.invar rs.memb rs.ins rs.delete UNIV", "apply(rule J_rr.round_robin_scheduler)"], ["proof (prove)\ngoal (1 subgoal):\n 1. J_rr.\\<alpha>.deterministic P UNIV", "apply(unfold eval_sc_red_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o)"], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded_base.deterministic final_expr\n     (\\<lambda>t ((e, xs), h) ta ((e', xs'), h').\n         extTA2J\n          P,P,t \\<turnstile>sc \\<langle>e,(h, xs)\\<rangle> -ta\\<rightarrow>\n                               \\<langle>e',(h', xs')\\<rangle>)\n     convert_RA UNIV", "apply(rule sc.red_mthr_deterministic[OF sc_deterministic_heap_ops])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sc_spurious_wakeups", "apply(simp add: sc_spurious_wakeups)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Random scheduler\\<close>"], ["", "interpretation J_rnd:\n  sc_random_scheduler_base\n    final_expr \"sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P\" convert_RA Jinja_output\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition sc_rnd_J_start_state :: \"Random.seed \\<Rightarrow> random_scheduler\"\nwhere \"sc_rnd_J_start_state seed = seed\""], ["", "definition exec_J_rnd ::\n  \"Random.seed \\<Rightarrow> addr J_prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow>\n  (thread_id \\<times> (addr, thread_id) obs_event list,\n   (addr, thread_id) locks \\<times> ((thread_id, (addr expr \\<times> addr locals) \\<times> addr released_locks) rm \\<times> heap) \\<times>\n   (thread_id, addr wait_set_status) rm \\<times> thread_id rs) tllist\"\nwhere\n  \"exec_J_rnd seed P C M vs = J_rnd.exec P (sc_rnd_J_start_state seed) (sc_J_start_state_refine P C M vs)\""], ["", "interpretation J_rnd:\n  sc_random_scheduler\n    final_expr \"sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P\" convert_RA Jinja_output\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_random_scheduler TYPE(nat) TYPE(nat) TYPE(nat)\n     TYPE(nat expr \\<times> (String.literal \\<Rightarrow> nat val option))", "by(unfold_locales)"], ["", "interpretation J_rnd:\n  sc_scheduler\n    final_expr \"sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P\" convert_RA\n    \"J_rnd.random_scheduler P\" Jinja_output \"pick_wakeup_via_sel (\\<lambda>s P. rm_sel s (\\<lambda>(k,v). P k v))\" \"\\<lambda>_ _. True\"\n    UNIV\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_scheduler final_expr\n     (sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P)\n     convert_RA (J_rnd.random_scheduler P) J_rnd.pick_wakeup\n     (\\<lambda>_ _. True) UNIV", "unfolding sc_scheduler_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler final_expr\n     (sc_red_i_i_i_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o P)\n     convert_RA (J_rnd.random_scheduler P) J_rnd.pick_wakeup\n     (\\<lambda>_ _. True) rm.\\<alpha> rm.invar rm.lookup rm.update\n     rm.\\<alpha> rm.invar rm.lookup rm.update rm.delete rm.iteratei\n     rs.\\<alpha> rs.invar rs.memb rs.ins rs.delete UNIV", "apply(rule J_rnd.random_scheduler_scheduler)"], ["proof (prove)\ngoal (1 subgoal):\n 1. J_rr.\\<alpha>.deterministic P UNIV", "apply(unfold eval_sc_red_i_i_i_i_i_Fii_i_oB_Fii_i_i_oB_i_i_i_i_i_o_o_o)"], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded_base.deterministic final_expr\n     (\\<lambda>t ((e, xs), h) ta ((e', xs'), h').\n         extTA2J\n          P,P,t \\<turnstile>sc \\<langle>e,(h, xs)\\<rangle> -ta\\<rightarrow>\n                               \\<langle>e',(h', xs')\\<rangle>)\n     convert_RA UNIV", "apply(rule sc.red_mthr_deterministic[OF sc_deterministic_heap_ops])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sc_spurious_wakeups", "apply(simp add: sc_spurious_wakeups)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "ML_val \\<open>@{code exec_J_rr}\\<close>"], ["", "ML_val \\<open>@{code exec_J_rnd}\\<close>"], ["", "end"]]}