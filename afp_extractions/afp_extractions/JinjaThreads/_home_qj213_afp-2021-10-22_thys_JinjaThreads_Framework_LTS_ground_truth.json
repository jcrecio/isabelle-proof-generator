{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/LTS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma rel_option_mono:\n  \"\\<lbrakk> rel_option R x y; \\<And>x y. R x y \\<Longrightarrow> R' x y \\<rbrakk> \\<Longrightarrow> rel_option R' x y\"", "lemma nth_concat_conv:\n  \"n < length (concat xss) \n   \\<Longrightarrow> \\<exists>m n'. concat xss ! n = (xss ! m) ! n' \\<and> n' < length (xss ! m) \\<and> \n             m < length xss \\<and> n = (\\<Sum>i<m. length (xss ! i)) + n'\"", "lemma flip_conv [flip_simps]: \"flip f b a = f a b\"", "lemma flip_flip [flip_simps, simp]: \"flip (flip f) = f\"", "lemma list_all2_flip [flip_simps]: \"list_all2 (flip P) xs ys = list_all2 P ys xs\"", "lemma llist_all2_flip [flip_simps]: \"llist_all2 (flip P) xs ys = llist_all2 P ys xs\"", "lemma rtranclp_flipD:\n  assumes \"(flip r)^** x y\"\n  shows \"r^** y x\"", "lemma rtranclp_flip [flip_simps]:\n  \"(flip r)^** = flip r^**\"", "lemma rel_prod_flip [flip_simps]:\n  \"rel_prod (flip R) (flip S) = flip (rel_prod R S)\"", "lemma rel_option_flip [flip_simps]:\n  \"rel_option (flip R) = flip (rel_option R)\"", "lemma tllist_all2_flip [flip_simps]:\n  \"tllist_all2 (flip P) (flip Q) xs ys \\<longleftrightarrow> tllist_all2 P Q ys xs\"", "lemma inf_step_not_finite_llist:\n  assumes r: \"s -bs\\<rightarrow>* \\<infinity>\"\n  shows \"\\<not> lfinite bs\"", "lemma inf_step2inf_step_table_LNil [simp]: \"inf_step2inf_step_table s LNil = LNil\"", "lemma inf_step2inf_step_table_LCons [simp]:\n  fixes tl shows\n  \"inf_step2inf_step_table s (LCons tl tls) =\n   LCons (s, tl, SOME s'. trsys s tl s' \\<and> s' -tls\\<rightarrow>* \\<infinity>) \n         (inf_step2inf_step_table (SOME s'. trsys s tl s' \\<and> s' -tls\\<rightarrow>* \\<infinity>) tls)\"", "lemma lnull_inf_step2inf_step_table [simp]: \n  \"lnull (inf_step2inf_step_table s tls) \\<longleftrightarrow> lnull tls\"", "lemma inf_step2inf_step_table_eq_LNil: \n  \"inf_step2inf_step_table s tls = LNil \\<longleftrightarrow> tls = LNil\"", "lemma lhd_inf_step2inf_step_table [simp]:\n  \"\\<not> lnull tls\n  \\<Longrightarrow> lhd (inf_step2inf_step_table s tls) =\n      (s, lhd tls, SOME s'. trsys s (lhd tls) s' \\<and> s' -ltl tls\\<rightarrow>* \\<infinity>)\"", "lemma ltl_inf_step2inf_step_table [simp]:\n  \"ltl (inf_step2inf_step_table s tls) =\n   inf_step2inf_step_table (SOME s'. trsys s (lhd tls) s' \\<and> s' -ltl tls\\<rightarrow>* \\<infinity>) (ltl tls)\"", "lemma lmap_inf_step2inf_step_table: \"lmap (fst \\<circ> snd) (inf_step2inf_step_table s tls) = tls\"", "lemma inf_step_imp_inf_step_table:\n  assumes \"s -tls\\<rightarrow>* \\<infinity>\"\n  shows \"\\<exists>stls. s -stls\\<rightarrow>*t \\<infinity> \\<and> tls = lmap (fst \\<circ> snd) stls\"", "lemma inf_step_table_imp_inf_step:\n  \"s-stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>s -lmap (fst \\<circ> snd) stls\\<rightarrow>* \\<infinity>\"", "lemma Runs_table_into_Runs:\n  \"Runs_table s stlss \\<Longrightarrow> Runs s (lmap (\\<lambda>(s, tl, s'). tl) stlss)\"", "lemma Runs_into_Runs_table:\n  assumes \"Runs s tls\"\n  obtains stlss\n  where \"tls = lmap (\\<lambda>(s, tl, s'). tl) stlss\"\n  and \"Runs_table s stlss\"", "lemma Runs_lappendE:\n  assumes \"Runs \\<sigma> (lappend tls tls')\"\n  and \"lfinite tls\"\n  obtains \\<sigma>' where \"\\<sigma> -list_of tls\\<rightarrow>* \\<sigma>'\"\n  and \"Runs \\<sigma>' tls'\"", "lemma Trsys_into_Runs:\n  assumes \"s -tls\\<rightarrow>* s'\"\n  and \"Runs s' tls'\"\n  shows \"Runs s (lappend (llist_of tls) tls')\"", "lemma rtrancl3p_into_Rtrancl3p:\n  \"\\<lbrakk> rtrancl3p trsys a bs a'; \\<And>b a''. \\<not> a' -b\\<rightarrow> a'' \\<rbrakk> \\<Longrightarrow> Rtrancl3p a (tllist_of_llist a' (llist_of bs))\"", "lemma Rtrancl3p_into_Runs:\n  \"Rtrancl3p s tlss \\<Longrightarrow> Runs s (llist_of_tllist tlss)\"", "lemma Runs_into_Rtrancl3p:\n  assumes \"Runs s tls\"\n  obtains tlss where \"tls = llist_of_tllist tlss\" \"Rtrancl3p s tlss\"", "lemma fixes tl\n  assumes \"Rtrancl3p s tlss\" \"tfinite tlss\"\n  shows Rtrancl3p_into_Trsys: \"Trsys s (list_of (llist_of_tllist tlss)) (terminal tlss)\"\n    and terminal_Rtrancl3p_final: \"\\<not> terminal tlss -tl\\<rightarrow> s'\"", "lemma silent_move_iff: \"silent_move = (\\<lambda>s s'. (\\<exists>tl. trsys s tl s' \\<and> \\<tau>move s tl s'))\"", "lemma inf_step_table_all_\\<tau>_into_\\<tau>diverge:\n  \"\\<lbrakk> s -stls\\<rightarrow>*t \\<infinity>; \\<forall>(s, tl, s') \\<in> lset stls. \\<tau>move s tl s' \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\"", "lemma inf_step_table_lappend_llist_ofD:\n  \"s -lappend (llist_of stls) (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\n  \\<Longrightarrow> (s -map (fst \\<circ> snd) stls\\<rightarrow>* x) \\<and> (x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>)\"", "lemma inf_step_table_lappend_llist_of_\\<tau>_into_\\<tau>moves:\n  assumes \"lfinite stls\"\n  shows \"\\<lbrakk> s -lappend stls (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>; \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s' \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x\"", "lemma inf_step_table_into_\\<tau>inf_step:\n  \"s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow> s -\\<tau>-lmap (fst \\<circ> snd) (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls)\\<rightarrow>* \\<infinity>\"", "lemma inf_step_into_\\<tau>inf_step:\n  assumes \"s -tls\\<rightarrow>* \\<infinity>\"\n  shows \"\\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>\"", "lemma silent_moves_into_\\<tau>rtrancl3p:\n  \"s -\\<tau>\\<rightarrow>* s' \\<Longrightarrow> s -\\<tau>-[]\\<rightarrow>* s'\"", "lemma \\<tau>rtrancl3p_into_silent_moves:\n  \"s -\\<tau>-[]\\<rightarrow>* s' \\<Longrightarrow> s -\\<tau>\\<rightarrow>* s'\"", "lemma \\<tau>rtrancl3p_Nil_eq_\\<tau>moves:\n  \"s -\\<tau>-[]\\<rightarrow>* s' \\<longleftrightarrow> s -\\<tau>\\<rightarrow>* s'\"", "lemma \\<tau>rtrancl3p_trans [trans]:\n  \"\\<lbrakk> s -\\<tau>-tls\\<rightarrow>* s'; s' -\\<tau>-tls'\\<rightarrow>* s'' \\<rbrakk> \\<Longrightarrow> s -\\<tau>-tls @ tls'\\<rightarrow>* s''\"", "lemma \\<tau>rtrancl3p_SingletonE:\n  fixes tl\n  assumes red: \"s -\\<tau>-[tl]\\<rightarrow>* s'''\"\n  obtains s' s'' where \"s -\\<tau>\\<rightarrow>* s'\" \"s' -tl\\<rightarrow> s''\" \"\\<not> \\<tau>move s' tl s''\" \"s'' -\\<tau>\\<rightarrow>* s'''\"", "lemma \\<tau>rtrancl3p_snocI:\n  \"\\<And>tl. \\<lbrakk> \\<tau>rtrancl3p s tls s''; s'' -\\<tau>\\<rightarrow>* s'''; s''' -tl\\<rightarrow> s'; \\<not> \\<tau>move s''' tl s' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>rtrancl3p s (tls @ [tl]) s'\"", "lemma \\<tau>diverge_rtranclp_silent_move:\n  \"\\<lbrakk> silent_move^** s s'; s' -\\<tau>\\<rightarrow> \\<infinity> \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\"", "lemma \\<tau>diverge_trancl_coinduct [consumes 1, case_names \\<tau>diverge]:\n  assumes X: \"X s\"\n  and step: \"\\<And>s. X s \\<Longrightarrow> \\<exists>s'. silent_move^++ s s' \\<and> (X s' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\"\n  shows \"s -\\<tau>\\<rightarrow> \\<infinity>\"", "lemma \\<tau>diverge_trancl_measure_coinduct [consumes 2, case_names \\<tau>diverge]:\n  assumes major: \"X s t\" \"wfP \\<mu>\"\n  and step: \"\\<And>s t. X s t \\<Longrightarrow> \\<exists>s' t'. (\\<mu> t' t \\<and> s' = s \\<or> silent_move^++ s s') \\<and> (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\"\n  shows \"s -\\<tau>\\<rightarrow> \\<infinity>\"", "lemma \\<tau>inf_step2\\<tau>inf_step_table_LNil [simp]: \"\\<tau>inf_step2\\<tau>inf_step_table s LNil = LNil\"", "lemma \\<tau>inf_step2\\<tau>inf_step_table_LCons [simp]:\n  fixes s tl ss tls\n  defines \"ss \\<equiv> SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\"\n  shows\n  \"\\<tau>inf_step2\\<tau>inf_step_table s (LCons tl tls) =\n   LCons (s, fst ss, tl, snd ss) (\\<tau>inf_step2\\<tau>inf_step_table (snd ss) tls)\"", "lemma lnull_\\<tau>inf_step2\\<tau>inf_step_table [simp]:\n  \"lnull (\\<tau>inf_step2\\<tau>inf_step_table s tls) \\<longleftrightarrow> lnull tls\"", "lemma lhd_\\<tau>inf_step2\\<tau>inf_step_table [simp]:\n  \"\\<not> lnull tls \\<Longrightarrow> lhd (\\<tau>inf_step2\\<tau>inf_step_table s tls) = \n  (let (s', s'') = SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -lhd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (lhd tls) s'' \\<and> s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity>\n  in (s, s', lhd tls, s''))\"", "lemma ltl_\\<tau>inf_step2\\<tau>inf_step_table [simp]:\n  \"\\<not> lnull tls \\<Longrightarrow> ltl (\\<tau>inf_step2\\<tau>inf_step_table s tls) =\n  (let (s', s'') = SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -lhd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (lhd tls) s'' \\<and> s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity>\n  in \\<tau>inf_step2\\<tau>inf_step_table s'' (ltl tls))\"", "lemma lmap_\\<tau>inf_step2\\<tau>inf_step_table: \"lmap (fst \\<circ> snd \\<circ> snd) (\\<tau>inf_step2\\<tau>inf_step_table s tls) = tls\"", "lemma \\<tau>inf_step_into_\\<tau>inf_step_table:\n  \"s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow> s -\\<tau>-\\<tau>inf_step2\\<tau>inf_step_table s tls\\<rightarrow>*t \\<infinity>\"", "lemma \\<tau>inf_step_imp_\\<tau>inf_step_table:\n  assumes \"s -\\<tau>-tls\\<rightarrow>* \\<infinity>\"\n  shows \"\\<exists>sstls. s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<and> tls = lmap (fst \\<circ> snd \\<circ> snd) sstls\"", "lemma \\<tau>inf_step_table_into_\\<tau>inf_step:\n  \"s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<Longrightarrow> s -\\<tau>-lmap (fst \\<circ> snd \\<circ> snd) sstls\\<rightarrow>* \\<infinity>\"", "lemma silent_move_fromI [intro]:\n  \"\\<lbrakk> silent_moves s0 s1; silent_move s1 s2 \\<rbrakk> \\<Longrightarrow> silent_move_from s0 s1 s2\"", "lemma silent_move_fromE [elim]:\n  assumes \"silent_move_from s0 s1 s2\"\n  obtains \"silent_moves s0 s1\" \"silent_move s1 s2\"", "lemma rtranclp_silent_move_from_imp_silent_moves:\n  assumes s'x: \"silent_move\\<^sup>*\\<^sup>* s' x\"\n  shows \"(silent_move_from s')^** x z \\<Longrightarrow> silent_moves s' z\"", "lemma \\<tau>diverge_not_wfP_silent_move_from:\n  assumes \"s -\\<tau>\\<rightarrow> \\<infinity>\"\n  shows \"\\<not> wfP (flip (silent_move_from s))\"", "lemma wfP_silent_move_from_unroll:\n  assumes wfPs': \"\\<And>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow> wfP (flip (silent_move_from s'))\"\n  shows \"wfP (flip (silent_move_from s))\"", "lemma not_wfP_silent_move_from_\\<tau>diverge:\n  assumes \"\\<not> wfP (flip (silent_move_from s))\"\n  shows \"s -\\<tau>\\<rightarrow> \\<infinity>\"", "lemma \\<tau>diverge_neq_wfP_silent_move_from:\n  \"s -\\<tau>\\<rightarrow> \\<infinity> \\<noteq> wfP (flip (silent_move_from s))\"", "lemma not_\\<tau>diverge_to_no_\\<tau>move:\n  assumes \"\\<not> s -\\<tau>\\<rightarrow> \\<infinity>\"\n  shows \"\\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\"", "lemma \\<tau>diverge_conv_\\<tau>Runs:\n  \"s -\\<tau>\\<rightarrow> \\<infinity> \\<longleftrightarrow> s \\<Down> TNil None\"", "lemma \\<tau>inf_step_into_\\<tau>Runs:\n  \"s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow> s \\<Down> tllist_of_llist None tls\"", "lemma \\<tau>_into_\\<tau>Runs:\n  \"\\<lbrakk> s -\\<tau>\\<rightarrow> s'; s' \\<Down> tls \\<rbrakk> \\<Longrightarrow> s \\<Down> tls\"", "lemma \\<tau>rtrancl3p_into_\\<tau>Runs:\n  assumes \"s -\\<tau>-tls\\<rightarrow>* s'\"\n  and \"s' \\<Down> tls'\"\n  shows \"s \\<Down> lappendt (llist_of tls) tls'\"", "lemma \\<tau>Runs_table_into_\\<tau>Runs:\n  \"\\<tau>Runs_table s stlsss \\<Longrightarrow> s \\<Down> tmap fst id stlsss\"", "lemma is_TNil_\\<tau>Runs2\\<tau>Runs_table [simp]:\n  \"is_TNil (\\<tau>Runs2\\<tau>Runs_table s tls) \\<longleftrightarrow> is_TNil tls\"", "lemma thd_\\<tau>Runs2\\<tau>Runs_table [simp]:\n  \"\\<not> is_TNil tls \\<Longrightarrow>\n  thd (\\<tau>Runs2\\<tau>Runs_table s tls) =\n  (thd tls, SOME s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -thd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls)\"", "lemma ttl_\\<tau>Runs2\\<tau>Runs_table [simp]:\n  \"\\<not> is_TNil tls \\<Longrightarrow>\n  ttl (\\<tau>Runs2\\<tau>Runs_table s tls) =\n  \\<tau>Runs2\\<tau>Runs_table (SOME s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -thd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls) (ttl tls)\"", "lemma terminal_\\<tau>Runs2\\<tau>Runs_table [simp]:\n  \"is_TNil tls \\<Longrightarrow> terminal (\\<tau>Runs2\\<tau>Runs_table s tls) = terminal tls\"", "lemma \\<tau>Runs2\\<tau>Runs_table_simps [simp, nitpick_simp]:\n  \"\\<tau>Runs2\\<tau>Runs_table s (TNil so) = TNil so\"\n  \"\\<And>tl. \n   \\<tau>Runs2\\<tau>Runs_table s (TCons tl tls) =\n   (let s'' = SOME s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n    in TCons (tl, s'') (\\<tau>Runs2\\<tau>Runs_table s'' tls))\"", "lemma \\<tau>Runs2\\<tau>Runs_table_inverse:\n  \"tmap fst id (\\<tau>Runs2\\<tau>Runs_table s tls) = tls\"", "lemma \\<tau>Runs_into_\\<tau>Runs_table:\n  assumes \"s \\<Down> tls\"\n  shows \"\\<exists>stlsss. tls = tmap fst id stlsss \\<and> \\<tau>Runs_table s stlsss\"", "lemma \\<tau>Runs_lappendtE:\n  assumes \"\\<sigma> \\<Down> lappendt tls tls'\"\n  and \"lfinite tls\"\n  obtains \\<sigma>' where \"\\<sigma> -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'\"\n  and \"\\<sigma>' \\<Down> tls'\"", "lemma \\<tau>Runs_total:\n  \"\\<exists>tls. \\<sigma> \\<Down> tls\"", "lemma silent_move2_into_silent_move:\n  fixes tl\n  assumes \"silent_move2 s tl s'\"\n  shows \"s -\\<tau>\\<rightarrow> s'\"", "lemma silent_move_into_silent_move2:\n  assumes \"s -\\<tau>\\<rightarrow> s'\"\n  shows \"\\<exists>tl. silent_move2 s tl s'\"", "lemma silent_moves2_into_silent_moves:\n  assumes \"silent_moves2 s tls s'\"\n  shows \"s -\\<tau>\\<rightarrow>* s'\"", "lemma silent_moves_into_silent_moves2:\n  assumes \"s -\\<tau>\\<rightarrow>* s'\"\n  shows \"\\<exists>tls. silent_moves2 s tls s'\"", "lemma inf_step_silent_move2_into_\\<tau>diverge:\n  \"trsys.inf_step silent_move2 s tls \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\"", "lemma \\<tau>diverge_into_inf_step_silent_move2:\n  assumes \"s -\\<tau>\\<rightarrow> \\<infinity>\"\n  obtains tls where \"trsys.inf_step silent_move2 s tls\"", "lemma \\<tau>Runs_into_\\<tau>rtrancl3p:\n  assumes runs: \"s \\<Down> tlss\"\n  and fin: \"tfinite tlss\"\n  and terminal: \"terminal tlss = Some s'\"\n  shows \"\\<tau>rtrancl3p s (list_of (llist_of_tllist tlss)) s'\"", "lemma \\<tau>Runs_terminal_stuck:\n  assumes Runs: \"s \\<Down> tlss\"\n  and fin: \"tfinite tlss\"\n  and terminal: \"terminal tlss = Some s'\"\n  and proceed: \"s' -tls\\<rightarrow> s''\"\n  shows False", "lemma Runs_table_silent_diverge:\n  \"\\<lbrakk> Runs_table s stlss; \\<forall>(s, tl, s') \\<in> lset stlss. \\<tau>move s tl s'; \\<not> lfinite stlss \\<rbrakk>\n  \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\"", "lemma Runs_table_silent_rtrancl:\n  assumes \"lfinite stlss\"\n  and \"Runs_table s stlss\"\n  and \"\\<forall>(s, tl, s') \\<in> lset stlss. \\<tau>move s tl s'\"\n  shows \"s -\\<tau>\\<rightarrow>* llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\" (is ?thesis1)\n  and \"llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -tl'\\<rightarrow> s'' \\<Longrightarrow> False\" (is \"PROP ?thesis2\")", "lemma Runs_table_silent_lappendD:\n  fixes s stlss\n  defines \"s' \\<equiv> llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\"\n  assumes Runs: \"Runs_table s (lappend stlss stlss')\"\n  and fin: \"lfinite stlss\"\n  and silent: \"\\<forall>(s, tl, s') \\<in> lset stlss. \\<tau>move s tl s'\"\n  shows \"s -\\<tau>\\<rightarrow>* s'\" (is ?thesis1)\n  and \"Runs_table s' stlss'\" (is ?thesis2)\n  and \"stlss' \\<noteq> LNil \\<Longrightarrow> s' = fst (lhd stlss')\" (is \"PROP ?thesis3\")", "lemma Runs_table_into_\\<tau>Runs:\n  fixes s stlss\n  defines \"tls \\<equiv> tmap (\\<lambda>(s, tl, s'). tl) id (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') (tllist_of_llist (Some (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)))) stlss))\"\n  (is \"_ \\<equiv> ?conv s stlss\")\n  assumes \"Runs_table s stlss\"\n  shows \"\\<tau>Runs s tls\"", "lemma \\<tau>Runs_table2_into_\\<tau>Runs:\n  \"\\<tau>Runs_table2 s tlsstlss\n  \\<Longrightarrow> s \\<Down> tmap (\\<lambda>(tls, s', tl, s''). tl) (\\<lambda>x. case x of Inl (tls, s') \\<Rightarrow> Some s' | Inr _ \\<Rightarrow> None) tlsstlss\"", "lemma \\<tau>Runs_into_\\<tau>Runs_table2:\n  assumes \"s \\<Down> tls\"\n  obtains tlsstlss\n  where \"\\<tau>Runs_table2 s tlsstlss\"\n  and \"tls = tmap (\\<lambda>(tls, s', tl, s''). tl) (\\<lambda>x. case x of Inl (tls, s') \\<Rightarrow> Some s' | Inr _ \\<Rightarrow> None) tlsstlss\"", "lemma \\<tau>Runs_table2_into_Runs:\n  assumes \"\\<tau>Runs_table2 s tlsstlss\"\n  shows \"Runs s (lconcat (lappend (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl])) (llist_of_tllist tlsstlss)) (LCons (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls | Inr tls \\<Rightarrow> tls) LNil)))\"\n  (is \"Runs _ (?conv tlsstlss)\")", "lemma \\<tau>Runs_table2_silentsD:\n  fixes tl\n  assumes Runs: \"\\<tau>Runs_table2 s tlsstlss\"\n  and tset: \"(tls, s', tl', s'') \\<in> tset tlsstlss\"\n  and set: \"tl \\<in> set tls\"\n  shows \"\\<exists>s''' s''''. silent_move2 s''' tl s''''\"", "lemma \\<tau>Runs_table2_terminal_silentsD:\n  assumes Runs: \"\\<tau>Runs_table2 s tlsstlss\"\n  and fin: \"lfinite (llist_of_tllist tlsstlss)\"\n  and terminal: \"terminal tlsstlss = Inl (tls, s'')\"\n  shows \"\\<exists>s'. silent_moves2 s' tls s''\"", "lemma \\<tau>Runs_table2_terminal_inf_stepD:\n  assumes Runs: \"\\<tau>Runs_table2 s tlsstlss\"\n  and fin: \"lfinite (llist_of_tllist tlsstlss)\"\n  and terminal: \"terminal tlsstlss = Inr tls\"\n  shows \"\\<exists>s'. trsys.inf_step silent_move2 s' tls\"", "lemma \\<tau>Runs_table2_lappendtD:\n  assumes Runs: \"\\<tau>Runs_table2 s (lappendt tlsstlss tlsstlss')\"\n  and fin: \"lfinite tlsstlss\"\n  shows \"\\<exists>s'. \\<tau>Runs_table2 s' tlsstlss'\"", "lemma \\<tau>moves_False: \"\\<tau>trsys.silent_move r (\\<lambda>s ta s'. False) = (\\<lambda>s s'. False)\"", "lemma \\<tau>rtrancl3p_False_eq_rtrancl3p: \"\\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) = rtrancl3p r\"", "lemma \\<tau>diverge_empty_\\<tau>move:\n  \"\\<tau>trsys.\\<tau>diverge r (\\<lambda>s ta s'. False) = (\\<lambda>s. False)\""], "translations": [["", "lemma rel_option_mono:\n  \"\\<lbrakk> rel_option R x y; \\<And>x y. R x y \\<Longrightarrow> R' x y \\<rbrakk> \\<Longrightarrow> rel_option R' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_option R x y;\n     \\<And>x y. R x y \\<Longrightarrow> R' x y\\<rbrakk>\n    \\<Longrightarrow> rel_option R' x y", "by(cases x)(case_tac [!] y, auto)"], ["", "lemma nth_concat_conv:\n  \"n < length (concat xss) \n   \\<Longrightarrow> \\<exists>m n'. concat xss ! n = (xss ! m) ! n' \\<and> n' < length (xss ! m) \\<and> \n             m < length xss \\<and> n = (\\<Sum>i<m. length (xss ! i)) + n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length (concat xss) \\<Longrightarrow>\n    \\<exists>m n'.\n       concat xss ! n = xss ! m ! n' \\<and>\n       n' < length (xss ! m) \\<and>\n       m < length xss \\<and> n = (\\<Sum>i<m. length (xss ! i)) + n'", "using lnth_lconcat_conv[of n \"llist_of (map llist_of xss)\"]\n  sum_hom[where f = enat and h = \"\\<lambda>i. length (xss ! i)\"]"], ["proof (prove)\nusing this:\n  enat n < llength (lconcat (llist_of (map llist_of xss))) \\<Longrightarrow>\n  \\<exists>m n'.\n     lnth (lconcat (llist_of (map llist_of xss))) n =\n     lnth (lnth (llist_of (map llist_of xss)) m) n' \\<and>\n     enat n' < llength (lnth (llist_of (map llist_of xss)) m) \\<and>\n     enat m < llength (llist_of (map llist_of xss)) \\<and>\n     enat n =\n     (\\<Sum>i<m. llength (lnth (llist_of (map llist_of xss)) i)) + enat n'\n  \\<lbrakk>\\<And>a b. enat (a + b) = enat a + enat b; enat 0 = 0\\<rbrakk>\n  \\<Longrightarrow> sum (enat \\<circ> (\\<lambda>i. length (xss ! i))) ?A =\n                    enat (\\<Sum>i\\<in>?A. length (xss ! i))\n\ngoal (1 subgoal):\n 1. n < length (concat xss) \\<Longrightarrow>\n    \\<exists>m n'.\n       concat xss ! n = xss ! m ! n' \\<and>\n       n' < length (xss ! m) \\<and>\n       m < length xss \\<and> n = (\\<Sum>i<m. length (xss ! i)) + n'", "by(clarsimp simp add: lconcat_llist_of zero_enat_def[symmetric]) blast"], ["", "definition flip :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> 'b \\<Rightarrow> 'a \\<Rightarrow> 'c\"\nwhere \"flip f = (\\<lambda>b a. f a b)\""], ["", "text \\<open>Create a dynamic list \\<open>flip_simps\\<close> of theorems for flip\\<close>"], ["", "ML \\<open>\nstructure FlipSimpRules = Named_Thms\n(\n  val name = @{binding flip_simps}\n  val description = \"Simplification rules for flip in bisimulations\"\n)\n\\<close>"], ["", "setup \\<open>FlipSimpRules.setup\\<close>"], ["", "lemma flip_conv [flip_simps]: \"flip f b a = f a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip f b a = f a b", "by(simp add: flip_def)"], ["", "lemma flip_flip [flip_simps, simp]: \"flip (flip f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip (flip f) = f", "by(simp add: flip_def)"], ["", "lemma list_all2_flip [flip_simps]: \"list_all2 (flip P) xs ys = list_all2 P ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (flip P) xs ys = list_all2 P ys xs", "unfolding flip_def list_all2_conv_all_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = length ys \\<and>\n     (\\<forall>i<length xs. P (ys ! i) (xs ! i))) =\n    (length ys = length xs \\<and>\n     (\\<forall>i<length ys. P (ys ! i) (xs ! i)))", "by auto"], ["", "lemma llist_all2_flip [flip_simps]: \"llist_all2 (flip P) xs ys = llist_all2 P ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (flip P) xs ys = llist_all2 P ys xs", "unfolding flip_def llist_all2_conv_all_lnth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength xs = llength ys \\<and>\n     (\\<forall>n.\n         enat n < llength ys \\<longrightarrow> P (lnth ys n) (lnth xs n))) =\n    (llength ys = llength xs \\<and>\n     (\\<forall>n.\n         enat n < llength xs \\<longrightarrow> P (lnth ys n) (lnth xs n)))", "by auto"], ["", "lemma rtranclp_flipD:\n  assumes \"(flip r)^** x y\"\n  shows \"r^** y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>*\\<^sup>* y x", "using assms"], ["proof (prove)\nusing this:\n  (flip r)\\<^sup>*\\<^sup>* x y\n\ngoal (1 subgoal):\n 1. r\\<^sup>*\\<^sup>* y x", "by(induct rule: rtranclp_induct)(auto intro: rtranclp.rtrancl_into_rtrancl simp add: flip_conv)"], ["", "lemma rtranclp_flip [flip_simps]:\n  \"(flip r)^** = flip r^**\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (flip r)\\<^sup>*\\<^sup>* = flip r\\<^sup>*\\<^sup>*", "by(auto intro!: ext simp add: flip_conv intro: rtranclp_flipD)"], ["", "lemma rel_prod_flip [flip_simps]:\n  \"rel_prod (flip R) (flip S) = flip (rel_prod R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod (flip R) (flip S) = flip (rel_prod R S)", "by(auto intro!: ext simp add: flip_def)"], ["", "lemma rel_option_flip [flip_simps]:\n  \"rel_option (flip R) = flip (rel_option R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (flip R) = flip (rel_option R)", "by(simp add: fun_eq_iff rel_option_iff flip_def)"], ["", "lemma tllist_all2_flip [flip_simps]:\n  \"tllist_all2 (flip P) (flip Q) xs ys \\<longleftrightarrow> tllist_all2 P Q ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tllist_all2 (flip P) (flip Q) xs ys = tllist_all2 P Q ys xs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. tllist_all2 (flip P) (flip Q) xs ys \\<Longrightarrow>\n    tllist_all2 P Q ys xs\n 2. tllist_all2 P Q ys xs \\<Longrightarrow>\n    tllist_all2 (flip P) (flip Q) xs ys", "assume \"tllist_all2 (flip P) (flip Q) xs ys\""], ["proof (state)\nthis:\n  tllist_all2 (flip P) (flip Q) xs ys\n\ngoal (2 subgoals):\n 1. tllist_all2 (flip P) (flip Q) xs ys \\<Longrightarrow>\n    tllist_all2 P Q ys xs\n 2. tllist_all2 P Q ys xs \\<Longrightarrow>\n    tllist_all2 (flip P) (flip Q) xs ys", "thus \"tllist_all2 P Q ys xs\""], ["proof (prove)\nusing this:\n  tllist_all2 (flip P) (flip Q) xs ys\n\ngoal (1 subgoal):\n 1. tllist_all2 P Q ys xs", "by(coinduct rule: tllist_all2_coinduct)(auto dest: tllist_all2_is_TNilD tllist_all2_tfinite2_terminalD tllist_all2_thdD intro: tllist_all2_ttlI simp add: flip_def)"], ["proof (state)\nthis:\n  tllist_all2 P Q ys xs\n\ngoal (1 subgoal):\n 1. tllist_all2 P Q ys xs \\<Longrightarrow>\n    tllist_all2 (flip P) (flip Q) xs ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tllist_all2 P Q ys xs \\<Longrightarrow>\n    tllist_all2 (flip P) (flip Q) xs ys", "assume \"tllist_all2 P Q ys xs\""], ["proof (state)\nthis:\n  tllist_all2 P Q ys xs\n\ngoal (1 subgoal):\n 1. tllist_all2 P Q ys xs \\<Longrightarrow>\n    tllist_all2 (flip P) (flip Q) xs ys", "thus \"tllist_all2 (flip P) (flip Q) xs ys\""], ["proof (prove)\nusing this:\n  tllist_all2 P Q ys xs\n\ngoal (1 subgoal):\n 1. tllist_all2 (flip P) (flip Q) xs ys", "by(coinduct rule: tllist_all2_coinduct)(auto dest: tllist_all2_is_TNilD tllist_all2_tfinite2_terminalD tllist_all2_thdD intro: tllist_all2_ttlI simp add: flip_def)"], ["proof (state)\nthis:\n  tllist_all2 (flip P) (flip Q) xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Labelled transition systems\\<close>"], ["", "type_synonym ('a, 'b) trsys = \"'a \\<Rightarrow> 'b \\<Rightarrow> 'a \\<Rightarrow> bool\""], ["", "locale trsys = \n  fixes trsys :: \"('s, 'tl) trsys\" (\"_/ -_\\<rightarrow>/ _\" [50, 0, 50] 60)\nbegin"], ["", "abbreviation Trsys :: \"('s, 'tl list) trsys\" (\"_/ -_\\<rightarrow>*/ _\" [50,0,50] 60)\nwhere \"\\<And>tl. s -tl\\<rightarrow>* s' \\<equiv> rtrancl3p trsys s tl s'\""], ["", "coinductive inf_step :: \"'s \\<Rightarrow> 'tl llist \\<Rightarrow> bool\" (\"_ -_\\<rightarrow>* \\<infinity>\" [50, 0] 80)\nwhere inf_stepI: \"\\<lbrakk> trsys a b a'; a' -bs\\<rightarrow>* \\<infinity> \\<rbrakk> \\<Longrightarrow> a -LCons b bs\\<rightarrow>* \\<infinity>\""], ["", "coinductive inf_step_table :: \"'s \\<Rightarrow> ('s \\<times> 'tl \\<times> 's) llist \\<Rightarrow> bool\" (\"_ -_\\<rightarrow>*t \\<infinity>\" [50, 0] 80)\nwhere \n  inf_step_tableI:\n  \"\\<And>tl. \\<lbrakk> trsys s tl s'; s' -stls\\<rightarrow>*t \\<infinity> \\<rbrakk> \n  \\<Longrightarrow> s -LCons (s, tl, s') stls\\<rightarrow>*t \\<infinity>\""], ["", "definition inf_step2inf_step_table :: \"'s \\<Rightarrow> 'tl llist \\<Rightarrow> ('s \\<times> 'tl \\<times> 's) llist\"\nwhere\n  \"inf_step2inf_step_table s tls =\n   unfold_llist\n     (\\<lambda>(s, tls). lnull tls)\n     (\\<lambda>(s, tls). (s, lhd tls, SOME s'. trsys s (lhd tls) s' \\<and> s' -ltl tls\\<rightarrow>* \\<infinity>)) \n     (\\<lambda>(s, tls). (SOME s'. trsys s (lhd tls) s' \\<and> s' -ltl tls\\<rightarrow>* \\<infinity>, ltl tls))\n     (s, tls)\""], ["", "coinductive Rtrancl3p :: \"'s \\<Rightarrow> ('tl, 's) tllist \\<Rightarrow> bool\"\nwhere \n  Rtrancl3p_stop: \"(\\<And>tl s'. \\<not> s -tl\\<rightarrow> s') \\<Longrightarrow>  Rtrancl3p s (TNil s)\"\n| Rtrancl3p_into_Rtrancl3p: \"\\<And>tl. \\<lbrakk> s -tl\\<rightarrow> s'; Rtrancl3p s' tlss \\<rbrakk> \\<Longrightarrow> Rtrancl3p s (TCons tl tlss)\""], ["", "inductive_simps Rtrancl3p_simps:\n  \"Rtrancl3p s (TNil s')\"\n  \"Rtrancl3p s (TCons tl' tlss)\""], ["", "inductive_cases Rtrancl3p_cases:\n  \"Rtrancl3p s (TNil s')\"\n  \"Rtrancl3p s (TCons tl' tlss)\""], ["", "coinductive Runs :: \"'s \\<Rightarrow> 'tl llist \\<Rightarrow> bool\"\nwhere\n  Stuck: \"(\\<And>tl s'. \\<not> s -tl\\<rightarrow> s') \\<Longrightarrow> Runs s LNil\"\n| Step: \"\\<And>tl. \\<lbrakk> s -tl\\<rightarrow> s'; Runs s' tls \\<rbrakk> \\<Longrightarrow> Runs s (LCons tl tls)\""], ["", "coinductive Runs_table :: \"'s \\<Rightarrow> ('s \\<times> 'tl \\<times> 's) llist \\<Rightarrow> bool\"\nwhere\n  Stuck: \"(\\<And>tl s'. \\<not> s -tl\\<rightarrow> s') \\<Longrightarrow> Runs_table s LNil\"\n| Step: \"\\<And>tl. \\<lbrakk> s -tl\\<rightarrow> s'; Runs_table s' stlss \\<rbrakk> \\<Longrightarrow> Runs_table s (LCons (s, tl, s') stlss)\""], ["", "inductive_simps Runs_table_simps:\n  \"Runs_table s LNil\"\n  \"Runs_table s (LCons stls stlss)\""], ["", "lemma inf_step_not_finite_llist:\n  assumes r: \"s -bs\\<rightarrow>* \\<infinity>\"\n  shows \"\\<not> lfinite bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite bs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite bs \\<Longrightarrow> False", "assume \"lfinite bs\""], ["proof (state)\nthis:\n  lfinite bs\n\ngoal (1 subgoal):\n 1. lfinite bs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lfinite bs\n\ngoal (1 subgoal):\n 1. False", "using r"], ["proof (prove)\nusing this:\n  lfinite bs\n  s -bs\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "by(induct arbitrary: s rule: lfinite.induct)(auto elim: inf_step.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_step2inf_step_table_LNil [simp]: \"inf_step2inf_step_table s LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_step2inf_step_table s LNil = LNil", "by(simp add: inf_step2inf_step_table_def)"], ["", "lemma inf_step2inf_step_table_LCons [simp]:\n  fixes tl shows\n  \"inf_step2inf_step_table s (LCons tl tls) =\n   LCons (s, tl, SOME s'. trsys s tl s' \\<and> s' -tls\\<rightarrow>* \\<infinity>) \n         (inf_step2inf_step_table (SOME s'. trsys s tl s' \\<and> s' -tls\\<rightarrow>* \\<infinity>) tls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_step2inf_step_table s (LCons tl tls) =\n    LCons\n     (s, tl,\n      SOME s'.\n         s -tl\\<rightarrow> s' \\<and> s' -tls\\<rightarrow>* \\<infinity>)\n     (inf_step2inf_step_table\n       (SOME s'.\n           s -tl\\<rightarrow> s' \\<and> s' -tls\\<rightarrow>* \\<infinity>)\n       tls)", "by(simp add: inf_step2inf_step_table_def)"], ["", "lemma lnull_inf_step2inf_step_table [simp]: \n  \"lnull (inf_step2inf_step_table s tls) \\<longleftrightarrow> lnull tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (inf_step2inf_step_table s tls) = lnull tls", "by(simp add: inf_step2inf_step_table_def)"], ["", "lemma inf_step2inf_step_table_eq_LNil: \n  \"inf_step2inf_step_table s tls = LNil \\<longleftrightarrow> tls = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inf_step2inf_step_table s tls = LNil) = (tls = LNil)", "using lnull_inf_step2inf_step_table"], ["proof (prove)\nusing this:\n  lnull (inf_step2inf_step_table ?s ?tls) = lnull ?tls\n\ngoal (1 subgoal):\n 1. (inf_step2inf_step_table s tls = LNil) = (tls = LNil)", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  (inf_step2inf_step_table ?s ?tls = LNil) = (?tls = LNil)\n\ngoal (1 subgoal):\n 1. (inf_step2inf_step_table s tls = LNil) = (tls = LNil)", "."], ["", "lemma lhd_inf_step2inf_step_table [simp]:\n  \"\\<not> lnull tls\n  \\<Longrightarrow> lhd (inf_step2inf_step_table s tls) =\n      (s, lhd tls, SOME s'. trsys s (lhd tls) s' \\<and> s' -ltl tls\\<rightarrow>* \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull tls \\<Longrightarrow>\n    lhd (inf_step2inf_step_table s tls) =\n    (s, lhd tls,\n     SOME s'.\n        s -lhd tls\\<rightarrow> s' \\<and>\n        s' -ltl tls\\<rightarrow>* \\<infinity>)", "by(simp add: inf_step2inf_step_table_def)"], ["", "lemma ltl_inf_step2inf_step_table [simp]:\n  \"ltl (inf_step2inf_step_table s tls) =\n   inf_step2inf_step_table (SOME s'. trsys s (lhd tls) s' \\<and> s' -ltl tls\\<rightarrow>* \\<infinity>) (ltl tls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (inf_step2inf_step_table s tls) =\n    inf_step2inf_step_table\n     (SOME s'.\n         s -lhd tls\\<rightarrow> s' \\<and>\n         s' -ltl tls\\<rightarrow>* \\<infinity>)\n     (ltl tls)", "by(cases tls) simp_all"], ["", "lemma lmap_inf_step2inf_step_table: \"lmap (fst \\<circ> snd) (inf_step2inf_step_table s tls) = tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap (fst \\<circ> snd) (inf_step2inf_step_table s tls) = tls", "by(coinduction arbitrary: s tls) auto"], ["", "lemma inf_step_imp_inf_step_table:\n  assumes \"s -tls\\<rightarrow>* \\<infinity>\"\n  shows \"\\<exists>stls. s -stls\\<rightarrow>*t \\<infinity> \\<and> tls = lmap (fst \\<circ> snd) stls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<and>\n       tls = lmap (fst \\<circ> snd) stls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<and>\n       tls = lmap (fst \\<circ> snd) stls", "from assms"], ["proof (chain)\npicking this:\n  s -tls\\<rightarrow>* \\<infinity>", "have \"s -inf_step2inf_step_table s tls\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  s -tls\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. s -inf_step2inf_step_table s tls\\<rightarrow>*t \\<infinity>", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s -tls\\<rightarrow>* \\<infinity> \\<Longrightarrow>\n       \\<exists>sa s' stls tl.\n          s = sa \\<and>\n          inf_step2inf_step_table s tls = LCons (sa, tl, s') stls \\<and>\n          sa -tl\\<rightarrow> s' \\<and>\n          ((\\<exists>s tls.\n               s' = s \\<and>\n               stls = inf_step2inf_step_table s tls \\<and>\n               s -tls\\<rightarrow>* \\<infinity>) \\<or>\n           s' -stls\\<rightarrow>*t \\<infinity>)", "case (inf_step_table s tls)"], ["proof (state)\nthis:\n  s -tls\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s -tls\\<rightarrow>* \\<infinity> \\<Longrightarrow>\n       \\<exists>sa s' stls tl.\n          s = sa \\<and>\n          inf_step2inf_step_table s tls = LCons (sa, tl, s') stls \\<and>\n          sa -tl\\<rightarrow> s' \\<and>\n          ((\\<exists>s tls.\n               s' = s \\<and>\n               stls = inf_step2inf_step_table s tls \\<and>\n               s -tls\\<rightarrow>* \\<infinity>) \\<or>\n           s' -stls\\<rightarrow>*t \\<infinity>)", "thus ?case"], ["proof (prove)\nusing this:\n  s -tls\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s s' stls tl.\n       s = s \\<and>\n       inf_step2inf_step_table s tls = LCons (s, tl, s') stls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tls.\n            s' = s \\<and>\n            stls = inf_step2inf_step_table s tls \\<and>\n            s -tls\\<rightarrow>* \\<infinity>) \\<or>\n        s' -stls\\<rightarrow>*t \\<infinity>)", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a' bs.\n       \\<lbrakk>tls = LCons b bs; s -b\\<rightarrow> a';\n        a' -bs\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s = s \\<and>\n                            inf_step2inf_step_table s tls =\n                            LCons (s, tl, s') stls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tls.\n                                 s' = s \\<and>\n                                 stls = inf_step2inf_step_table s tls \\<and>\n                                 s -tls\\<rightarrow>* \\<infinity>) \\<or>\n                             s' -stls\\<rightarrow>*t \\<infinity>)", "case (inf_stepI tl s' tls')"], ["proof (state)\nthis:\n  tls = LCons tl tls'\n  s -tl\\<rightarrow> s'\n  s' -tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>b a' bs.\n       \\<lbrakk>tls = LCons b bs; s -b\\<rightarrow> a';\n        a' -bs\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s = s \\<and>\n                            inf_step2inf_step_table s tls =\n                            LCons (s, tl, s') stls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tls.\n                                 s' = s \\<and>\n                                 stls = inf_step2inf_step_table s tls \\<and>\n                                 s -tls\\<rightarrow>* \\<infinity>) \\<or>\n                             s' -stls\\<rightarrow>*t \\<infinity>)", "let ?s' = \"SOME s'. trsys s tl s' \\<and> s' -tls'\\<rightarrow>* \\<infinity>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a' bs.\n       \\<lbrakk>tls = LCons b bs; s -b\\<rightarrow> a';\n        a' -bs\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s = s \\<and>\n                            inf_step2inf_step_table s tls =\n                            LCons (s, tl, s') stls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tls.\n                                 s' = s \\<and>\n                                 stls = inf_step2inf_step_table s tls \\<and>\n                                 s -tls\\<rightarrow>* \\<infinity>) \\<or>\n                             s' -stls\\<rightarrow>*t \\<infinity>)", "have \"trsys s tl ?s' \\<and> ?s' -tls'\\<rightarrow>* \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -tl\\<rightarrow>\n    (SOME s'.\n        s -tl\\<rightarrow> s' \\<and>\n        s' -tls'\\<rightarrow>* \\<infinity>) \\<and>\n    (SOME s'.\n        s -tl\\<rightarrow> s' \\<and>\n        s' -tls'\\<rightarrow>* \\<infinity>) -tls'\\<rightarrow>* \\<infinity>", "by(rule someI)(blast intro: inf_stepI)"], ["proof (state)\nthis:\n  s -tl\\<rightarrow>\n  (SOME s'.\n      s -tl\\<rightarrow> s' \\<and>\n      s' -tls'\\<rightarrow>* \\<infinity>) \\<and>\n  (SOME s'.\n      s -tl\\<rightarrow> s' \\<and>\n      s' -tls'\\<rightarrow>* \\<infinity>) -tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>b a' bs.\n       \\<lbrakk>tls = LCons b bs; s -b\\<rightarrow> a';\n        a' -bs\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' stls tl.\n                            s = s \\<and>\n                            inf_step2inf_step_table s tls =\n                            LCons (s, tl, s') stls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tls.\n                                 s' = s \\<and>\n                                 stls = inf_step2inf_step_table s tls \\<and>\n                                 s -tls\\<rightarrow>* \\<infinity>) \\<or>\n                             s' -stls\\<rightarrow>*t \\<infinity>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s -tl\\<rightarrow>\n  (SOME s'.\n      s -tl\\<rightarrow> s' \\<and>\n      s' -tls'\\<rightarrow>* \\<infinity>) \\<and>\n  (SOME s'.\n      s -tl\\<rightarrow> s' \\<and>\n      s' -tls'\\<rightarrow>* \\<infinity>) -tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s s' stls tl.\n       s = s \\<and>\n       inf_step2inf_step_table s tls = LCons (s, tl, s') stls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tls.\n            s' = s \\<and>\n            stls = inf_step2inf_step_table s tls \\<and>\n            s -tls\\<rightarrow>* \\<infinity>) \\<or>\n        s' -stls\\<rightarrow>*t \\<infinity>)", "using \\<open>tls = LCons tl tls'\\<close>"], ["proof (prove)\nusing this:\n  s -tl\\<rightarrow>\n  (SOME s'.\n      s -tl\\<rightarrow> s' \\<and>\n      s' -tls'\\<rightarrow>* \\<infinity>) \\<and>\n  (SOME s'.\n      s -tl\\<rightarrow> s' \\<and>\n      s' -tls'\\<rightarrow>* \\<infinity>) -tls'\\<rightarrow>* \\<infinity>\n  tls = LCons tl tls'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' stls tl.\n       s = s \\<and>\n       inf_step2inf_step_table s tls = LCons (s, tl, s') stls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tls.\n            s' = s \\<and>\n            stls = inf_step2inf_step_table s tls \\<and>\n            s -tls\\<rightarrow>* \\<infinity>) \\<or>\n        s' -stls\\<rightarrow>*t \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s s' stls tl.\n     s = s \\<and>\n     inf_step2inf_step_table s tls = LCons (s, tl, s') stls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tls.\n          s' = s \\<and>\n          stls = inf_step2inf_step_table s tls \\<and>\n          s -tls\\<rightarrow>* \\<infinity>) \\<or>\n      s' -stls\\<rightarrow>*t \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s s' stls tl.\n     s = s \\<and>\n     inf_step2inf_step_table s tls = LCons (s, tl, s') stls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tls.\n          s' = s \\<and>\n          stls = inf_step2inf_step_table s tls \\<and>\n          s -tls\\<rightarrow>* \\<infinity>) \\<or>\n      s' -stls\\<rightarrow>*t \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s -inf_step2inf_step_table s tls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<and>\n       tls = lmap (fst \\<circ> snd) stls", "moreover"], ["proof (state)\nthis:\n  s -inf_step2inf_step_table s tls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<and>\n       tls = lmap (fst \\<circ> snd) stls", "have \"tls = lmap (fst \\<circ> snd) (inf_step2inf_step_table s tls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tls = lmap (fst \\<circ> snd) (inf_step2inf_step_table s tls)", "by(simp only: lmap_inf_step2inf_step_table)"], ["proof (state)\nthis:\n  tls = lmap (fst \\<circ> snd) (inf_step2inf_step_table s tls)\n\ngoal (1 subgoal):\n 1. \\<exists>stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<and>\n       tls = lmap (fst \\<circ> snd) stls", "ultimately"], ["proof (chain)\npicking this:\n  s -inf_step2inf_step_table s tls\\<rightarrow>*t \\<infinity>\n  tls = lmap (fst \\<circ> snd) (inf_step2inf_step_table s tls)", "show ?thesis"], ["proof (prove)\nusing this:\n  s -inf_step2inf_step_table s tls\\<rightarrow>*t \\<infinity>\n  tls = lmap (fst \\<circ> snd) (inf_step2inf_step_table s tls)\n\ngoal (1 subgoal):\n 1. \\<exists>stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<and>\n       tls = lmap (fst \\<circ> snd) stls", "by blast"], ["proof (state)\nthis:\n  \\<exists>stls.\n     s -stls\\<rightarrow>*t \\<infinity> \\<and>\n     tls = lmap (fst \\<circ> snd) stls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_step_table_imp_inf_step:\n  \"s-stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>s -lmap (fst \\<circ> snd) stls\\<rightarrow>* \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n    s -lmap (fst \\<circ> snd) stls\\<rightarrow>* \\<infinity>", "proof(coinduction arbitrary: s stls rule: inf_step.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          s = a \\<and>\n          lmap (fst \\<circ> snd) stls = LCons b bs \\<and>\n          a -b\\<rightarrow> a' \\<and>\n          ((\\<exists>s stls.\n               a' = s \\<and>\n               bs = lmap (fst \\<circ> snd) stls \\<and>\n               s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n           a' -bs\\<rightarrow>* \\<infinity>)", "case (inf_step s tls)"], ["proof (state)\nthis:\n  s -tls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          s = a \\<and>\n          lmap (fst \\<circ> snd) stls = LCons b bs \\<and>\n          a -b\\<rightarrow> a' \\<and>\n          ((\\<exists>s stls.\n               a' = s \\<and>\n               bs = lmap (fst \\<circ> snd) stls \\<and>\n               s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n           a' -bs\\<rightarrow>* \\<infinity>)", "thus ?case"], ["proof (prove)\nusing this:\n  s -tls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>a b a' bs.\n       s = a \\<and>\n       lmap (fst \\<circ> snd) tls = LCons b bs \\<and>\n       a -b\\<rightarrow> a' \\<and>\n       ((\\<exists>s stls.\n            a' = s \\<and>\n            bs = lmap (fst \\<circ> snd) stls \\<and>\n            s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n        a' -bs\\<rightarrow>* \\<infinity>)", "by cases auto"], ["proof (state)\nthis:\n  \\<exists>a b a' bs.\n     s = a \\<and>\n     lmap (fst \\<circ> snd) tls = LCons b bs \\<and>\n     a -b\\<rightarrow> a' \\<and>\n     ((\\<exists>s stls.\n          a' = s \\<and>\n          bs = lmap (fst \\<circ> snd) stls \\<and>\n          s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n      a' -bs\\<rightarrow>* \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Runs_table_into_Runs:\n  \"Runs_table s stlss \\<Longrightarrow> Runs s (lmap (\\<lambda>(s, tl, s'). tl) stlss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Runs_table s stlss \\<Longrightarrow>\n    Runs s (lmap (\\<lambda>(s, tl, s'). tl) stlss)", "proof(coinduction arbitrary: s stlss)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s stlss.\n       Runs_table s stlss \\<Longrightarrow>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lmap (\\<lambda>(s, tl, s'). tl) stlss = LNil \\<and>\n           (\\<forall>x xa. \\<not> sa -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa s' tls tl.\n           s = sa \\<and>\n           lmap (\\<lambda>(s, tl, s'). tl) stlss = LCons tl tls \\<and>\n           sa -tl\\<rightarrow> s' \\<and>\n           ((\\<exists>s stlss.\n                s' = s \\<and>\n                tls = lmap (\\<lambda>(s, tl, s'). tl) stlss \\<and>\n                Runs_table s stlss) \\<or>\n            Runs s' tls))", "case (Runs s tls)"], ["proof (state)\nthis:\n  Runs_table s tls\n\ngoal (1 subgoal):\n 1. \\<And>s stlss.\n       Runs_table s stlss \\<Longrightarrow>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lmap (\\<lambda>(s, tl, s'). tl) stlss = LNil \\<and>\n           (\\<forall>x xa. \\<not> sa -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa s' tls tl.\n           s = sa \\<and>\n           lmap (\\<lambda>(s, tl, s'). tl) stlss = LCons tl tls \\<and>\n           sa -tl\\<rightarrow> s' \\<and>\n           ((\\<exists>s stlss.\n                s' = s \\<and>\n                tls = lmap (\\<lambda>(s, tl, s'). tl) stlss \\<and>\n                Runs_table s stlss) \\<or>\n            Runs s' tls))", "thus ?case"], ["proof (prove)\nusing this:\n  Runs_table s tls\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        lmap (\\<lambda>(s, tl, s'). tl) tls = LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' tlsa tl.\n        s = s \\<and>\n        lmap (\\<lambda>(s, tl, s'). tl) tls = LCons tl tlsa \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s stlss.\n             s' = s \\<and>\n             tlsa = lmap (\\<lambda>(s, tl, s'). tl) stlss \\<and>\n             Runs_table s stlss) \\<or>\n         Runs s' tlsa))", "by (cases)auto"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      lmap (\\<lambda>(s, tl, s'). tl) tls = LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' tlsa tl.\n      s = s \\<and>\n      lmap (\\<lambda>(s, tl, s'). tl) tls = LCons tl tlsa \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s stlss.\n           s' = s \\<and>\n           tlsa = lmap (\\<lambda>(s, tl, s'). tl) stlss \\<and>\n           Runs_table s stlss) \\<or>\n       Runs s' tlsa))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Runs_into_Runs_table:\n  assumes \"Runs s tls\"\n  obtains stlss\n  where \"tls = lmap (\\<lambda>(s, tl, s'). tl) stlss\"\n  and \"Runs_table s stlss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stlss.\n        \\<lbrakk>tls = lmap (\\<lambda>(s, tl, s'). tl) stlss;\n         Runs_table s stlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>stlss.\n        \\<lbrakk>tls = lmap (\\<lambda>(s, tl, s'). tl) stlss;\n         Runs_table s stlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define stlss where \"stlss s tls = unfold_llist\n    (\\<lambda>(s, tls). lnull tls)\n    (\\<lambda>(s, tls). (s, lhd tls, SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls)))\n    (\\<lambda>(s, tls). (SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls), ltl tls))\n    (s, tls)\"\n    for s tls"], ["proof (state)\nthis:\n  stlss ?s ?tls =\n  unfold_llist (\\<lambda>(s, tls). lnull tls)\n   (\\<lambda>(s, tls).\n       (s, lhd tls,\n        SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls)))\n   (\\<lambda>(s, tls).\n       (SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls),\n        ltl tls))\n   (?s, ?tls)\n\ngoal (1 subgoal):\n 1. (\\<And>stlss.\n        \\<lbrakk>tls = lmap (\\<lambda>(s, tl, s'). tl) stlss;\n         Runs_table s stlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]:\n    \"\\<And>s. stlss s LNil = LNil\"\n    \"\\<And>s tl tls. stlss s (LCons tl tls) = LCons (s, tl, SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls) (stlss (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls) tls)\"\n    \"\\<And>s tls. lnull (stlss s tls) \\<longleftrightarrow> lnull tls\"\n    \"\\<And>s tls. \\<not> lnull tls \\<Longrightarrow> lhd (stlss s tls) = (s, lhd tls, SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls))\"\n    \"\\<And>s tls. \\<not> lnull tls \\<Longrightarrow> ltl (stlss s tls) = stlss (SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls)) (ltl tls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>s. stlss s LNil = LNil) &&&\n     (\\<And>s tl tls.\n         stlss s (LCons tl tls) =\n         LCons (s, tl, SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls)\n          (stlss (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls)\n            tls))) &&&\n    (\\<And>s tls. lnull (stlss s tls) = lnull tls) &&&\n    (\\<And>s tls.\n        \\<not> lnull tls \\<Longrightarrow>\n        lhd (stlss s tls) =\n        (s, lhd tls,\n         SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls))) &&&\n    (\\<And>s tls.\n        \\<not> lnull tls \\<Longrightarrow>\n        ltl (stlss s tls) =\n        stlss (SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls))\n         (ltl tls))", "by(simp_all add: stlss_def)"], ["proof (state)\nthis:\n  stlss ?s LNil = LNil\n  stlss ?s (LCons ?tl ?tls) =\n  LCons (?s, ?tl, SOME s'. ?s -?tl\\<rightarrow> s' \\<and> Runs s' ?tls)\n   (stlss (SOME s'. ?s -?tl\\<rightarrow> s' \\<and> Runs s' ?tls) ?tls)\n  lnull (stlss ?s ?tls) = lnull ?tls\n  \\<not> lnull ?tls \\<Longrightarrow>\n  lhd (stlss ?s ?tls) =\n  (?s, lhd ?tls,\n   SOME s'. ?s -lhd ?tls\\<rightarrow> s' \\<and> Runs s' (ltl ?tls))\n  \\<not> lnull ?tls \\<Longrightarrow>\n  ltl (stlss ?s ?tls) =\n  stlss (SOME s'. ?s -lhd ?tls\\<rightarrow> s' \\<and> Runs s' (ltl ?tls))\n   (ltl ?tls)\n\ngoal (1 subgoal):\n 1. (\\<And>stlss.\n        \\<lbrakk>tls = lmap (\\<lambda>(s, tl, s'). tl) stlss;\n         Runs_table s stlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  Runs s tls", "have \"tls = lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)\""], ["proof (prove)\nusing this:\n  Runs s tls\n\ngoal (1 subgoal):\n 1. tls = lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       Runs s tls \\<Longrightarrow>\n       lnull tls =\n       lnull (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<and>\n       (\\<not> lnull tls \\<longrightarrow>\n        \\<not> lnull\n                (lmap (\\<lambda>(s, tl, s'). tl)\n                  (stlss s tls)) \\<longrightarrow>\n        lhd tls = lhd (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<and>\n        (\\<exists>sa tlsa.\n            ltl tls = tlsa \\<and>\n            ltl (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) =\n            lmap (\\<lambda>(s, tl, s'). tl) (stlss sa tlsa) \\<and>\n            Runs sa tlsa))", "case Eq_llist"], ["proof (state)\nthis:\n  Runs s tls\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       Runs s tls \\<Longrightarrow>\n       lnull tls =\n       lnull (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<and>\n       (\\<not> lnull tls \\<longrightarrow>\n        \\<not> lnull\n                (lmap (\\<lambda>(s, tl, s'). tl)\n                  (stlss s tls)) \\<longrightarrow>\n        lhd tls = lhd (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<and>\n        (\\<exists>sa tlsa.\n            ltl tls = tlsa \\<and>\n            ltl (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) =\n            lmap (\\<lambda>(s, tl, s'). tl) (stlss sa tlsa) \\<and>\n            Runs sa tlsa))", "thus ?case"], ["proof (prove)\nusing this:\n  Runs s tls\n\ngoal (1 subgoal):\n 1. lnull tls = lnull (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<and>\n    (\\<not> lnull tls \\<longrightarrow>\n     \\<not> lnull\n             (lmap (\\<lambda>(s, tl, s'). tl)\n               (stlss s tls)) \\<longrightarrow>\n     lhd tls = lhd (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<and>\n     (\\<exists>s tls.\n         ltl tls = tls \\<and>\n         ltl (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) =\n         lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls) \\<and>\n         Runs s tls))", "by cases(auto 4 3 intro: someI2)"], ["proof (state)\nthis:\n  lnull tls = lnull (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<and>\n  (\\<not> lnull tls \\<longrightarrow>\n   \\<not> lnull\n           (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<longrightarrow>\n   lhd tls = lhd (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) \\<and>\n   (\\<exists>s tls.\n       ltl tls = tls \\<and>\n       ltl (lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)) =\n       lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls) \\<and>\n       Runs s tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tls = lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)\n\ngoal (1 subgoal):\n 1. (\\<And>stlss.\n        \\<lbrakk>tls = lmap (\\<lambda>(s, tl, s'). tl) stlss;\n         Runs_table s stlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  tls = lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)\n\ngoal (1 subgoal):\n 1. (\\<And>stlss.\n        \\<lbrakk>tls = lmap (\\<lambda>(s, tl, s'). tl) stlss;\n         Runs_table s stlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  Runs s tls", "have \"Runs_table s (stlss s tls)\""], ["proof (prove)\nusing this:\n  Runs s tls\n\ngoal (1 subgoal):\n 1. Runs_table s (stlss s tls)", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       Runs s tls \\<Longrightarrow>\n       (\\<exists>sa.\n           s = sa \\<and>\n           stlss s tls = LNil \\<and>\n           (\\<forall>x xa. \\<not> sa -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa s' stlssa tl.\n           s = sa \\<and>\n           stlss s tls = LCons (sa, tl, s') stlssa \\<and>\n           sa -tl\\<rightarrow> s' \\<and>\n           ((\\<exists>s tls.\n                s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n            Runs_table s' stlssa))", "case (Runs_table s stlss')"], ["proof (state)\nthis:\n  Runs s stlss'\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       Runs s tls \\<Longrightarrow>\n       (\\<exists>sa.\n           s = sa \\<and>\n           stlss s tls = LNil \\<and>\n           (\\<forall>x xa. \\<not> sa -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa s' stlssa tl.\n           s = sa \\<and>\n           stlss s tls = LCons (sa, tl, s') stlssa \\<and>\n           sa -tl\\<rightarrow> s' \\<and>\n           ((\\<exists>s tls.\n                s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n            Runs_table s' stlssa))", "thus ?case"], ["proof (prove)\nusing this:\n  Runs s stlss'\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        stlss s stlss' = LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' stlssa tl.\n        s = s \\<and>\n        stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s tls.\n             s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n         Runs_table s' stlssa))", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>stlss' = LNil;\n     \\<And>tl s'. \\<not> s -tl\\<rightarrow> s'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          stlss s stlss' = LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' stlssa tl.\n                          s = s \\<and>\n                          stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tls.\n                               s' = s \\<and>\n                               stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n                           Runs_table s' stlssa))\n 2. \\<And>s' tls tl.\n       \\<lbrakk>stlss' = LCons tl tls; s -tl\\<rightarrow> s';\n        Runs s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             stlss s stlss' = LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' stlssa tl.\n                             s = s \\<and>\n                             stlss s stlss' =\n                             LCons (s, tl, s') stlssa \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tls.\n                                  s' = s \\<and>\n                                  stlssa = stlss s tls \\<and>\n                                  Runs s tls) \\<or>\n                              Runs_table s' stlssa))", "case (Step s' tls' tl)"], ["proof (state)\nthis:\n  stlss' = LCons tl tls'\n  s -tl\\<rightarrow> s'\n  Runs s' tls'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlss' = LNil;\n     \\<And>tl s'. \\<not> s -tl\\<rightarrow> s'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          stlss s stlss' = LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' stlssa tl.\n                          s = s \\<and>\n                          stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tls.\n                               s' = s \\<and>\n                               stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n                           Runs_table s' stlssa))\n 2. \\<And>s' tls tl.\n       \\<lbrakk>stlss' = LCons tl tls; s -tl\\<rightarrow> s';\n        Runs s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             stlss s stlss' = LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' stlssa tl.\n                             s = s \\<and>\n                             stlss s stlss' =\n                             LCons (s, tl, s') stlssa \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tls.\n                                  s' = s \\<and>\n                                  stlssa = stlss s tls \\<and>\n                                  Runs s tls) \\<or>\n                              Runs_table s' stlssa))", "let ?P = \"\\<lambda>s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>stlss' = LNil;\n     \\<And>tl s'. \\<not> s -tl\\<rightarrow> s'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          stlss s stlss' = LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' stlssa tl.\n                          s = s \\<and>\n                          stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tls.\n                               s' = s \\<and>\n                               stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n                           Runs_table s' stlssa))\n 2. \\<And>s' tls tl.\n       \\<lbrakk>stlss' = LCons tl tls; s -tl\\<rightarrow> s';\n        Runs s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             stlss s stlss' = LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' stlssa tl.\n                             s = s \\<and>\n                             stlss s stlss' =\n                             LCons (s, tl, s') stlssa \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tls.\n                                  s' = s \\<and>\n                                  stlssa = stlss s tls \\<and>\n                                  Runs s tls) \\<or>\n                              Runs_table s' stlssa))", "from \\<open>s -tl\\<rightarrow> s'\\<close> \\<open>Runs s' tls'\\<close>"], ["proof (chain)\npicking this:\n  s -tl\\<rightarrow> s'\n  Runs s' tls'", "have \"?P s'\""], ["proof (prove)\nusing this:\n  s -tl\\<rightarrow> s'\n  Runs s' tls'\n\ngoal (1 subgoal):\n 1. s -tl\\<rightarrow> s' \\<and> Runs s' tls'", ".."], ["proof (state)\nthis:\n  s -tl\\<rightarrow> s' \\<and> Runs s' tls'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlss' = LNil;\n     \\<And>tl s'. \\<not> s -tl\\<rightarrow> s'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          stlss s stlss' = LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' stlssa tl.\n                          s = s \\<and>\n                          stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tls.\n                               s' = s \\<and>\n                               stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n                           Runs_table s' stlssa))\n 2. \\<And>s' tls tl.\n       \\<lbrakk>stlss' = LCons tl tls; s -tl\\<rightarrow> s';\n        Runs s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             stlss s stlss' = LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' stlssa tl.\n                             s = s \\<and>\n                             stlss s stlss' =\n                             LCons (s, tl, s') stlssa \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tls.\n                                  s' = s \\<and>\n                                  stlssa = stlss s tls \\<and>\n                                  Runs s tls) \\<or>\n                              Runs_table s' stlssa))", "hence \"?P (Eps ?P)\""], ["proof (prove)\nusing this:\n  s -tl\\<rightarrow> s' \\<and> Runs s' tls'\n\ngoal (1 subgoal):\n 1. s -tl\\<rightarrow>\n    (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls') \\<and>\n    Runs (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls') tls'", "by(rule someI)"], ["proof (state)\nthis:\n  s -tl\\<rightarrow>\n  (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls') \\<and>\n  Runs (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls') tls'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlss' = LNil;\n     \\<And>tl s'. \\<not> s -tl\\<rightarrow> s'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          stlss s stlss' = LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' stlssa tl.\n                          s = s \\<and>\n                          stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tls.\n                               s' = s \\<and>\n                               stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n                           Runs_table s' stlssa))\n 2. \\<And>s' tls tl.\n       \\<lbrakk>stlss' = LCons tl tls; s -tl\\<rightarrow> s';\n        Runs s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             stlss s stlss' = LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' stlssa tl.\n                             s = s \\<and>\n                             stlss s stlss' =\n                             LCons (s, tl, s') stlssa \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tls.\n                                  s' = s \\<and>\n                                  stlssa = stlss s tls \\<and>\n                                  Runs s tls) \\<or>\n                              Runs_table s' stlssa))", "with Step"], ["proof (chain)\npicking this:\n  stlss' = LCons tl tls'\n  s -tl\\<rightarrow> s'\n  Runs s' tls'\n  s -tl\\<rightarrow>\n  (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls') \\<and>\n  Runs (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls') tls'", "have ?Step"], ["proof (prove)\nusing this:\n  stlss' = LCons tl tls'\n  s -tl\\<rightarrow> s'\n  Runs s' tls'\n  s -tl\\<rightarrow>\n  (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls') \\<and>\n  Runs (SOME s'. s -tl\\<rightarrow> s' \\<and> Runs s' tls') tls'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' stlssa tl.\n       s = s \\<and>\n       stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tls.\n            s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n        Runs_table s' stlssa)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s s' stlssa tl.\n     s = s \\<and>\n     stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tls.\n          s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n      Runs_table s' stlssa)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stlss' = LNil;\n     \\<And>tl s'. \\<not> s -tl\\<rightarrow> s'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          stlss s stlss' = LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' stlssa tl.\n                          s = s \\<and>\n                          stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tls.\n                               s' = s \\<and>\n                               stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n                           Runs_table s' stlssa))\n 2. \\<And>s' tls tl.\n       \\<lbrakk>stlss' = LCons tl tls; s -tl\\<rightarrow> s';\n        Runs s' tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             stlss s stlss' = LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' stlssa tl.\n                             s = s \\<and>\n                             stlss s stlss' =\n                             LCons (s, tl, s') stlssa \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tls.\n                                  s' = s \\<and>\n                                  stlssa = stlss s tls \\<and>\n                                  Runs s tls) \\<or>\n                              Runs_table s' stlssa))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' stlssa tl.\n     s = s \\<and>\n     stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tls.\n          s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n      Runs_table s' stlssa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        stlss s stlss' = LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' stlssa tl.\n        s = s \\<and>\n        stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s tls.\n             s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n         Runs_table s' stlssa))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      stlss s stlss' = LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' stlssa tl.\n      s = s \\<and>\n      stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s tls.\n           s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n       Runs_table s' stlssa))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>stlss' = LNil;\n     \\<And>tl s'. \\<not> s -tl\\<rightarrow> s'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          stlss s stlss' = LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' stlssa tl.\n                          s = s \\<and>\n                          stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tls.\n                               s' = s \\<and>\n                               stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n                           Runs_table s' stlssa))", "qed simp"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      stlss s stlss' = LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' stlssa tl.\n      s = s \\<and>\n      stlss s stlss' = LCons (s, tl, s') stlssa \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s tls.\n           s' = s \\<and> stlssa = stlss s tls \\<and> Runs s tls) \\<or>\n       Runs_table s' stlssa))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Runs_table s (stlss s tls)\n\ngoal (1 subgoal):\n 1. (\\<And>stlss.\n        \\<lbrakk>tls = lmap (\\<lambda>(s, tl, s'). tl) stlss;\n         Runs_table s stlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  tls = lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)\n  Runs_table s (stlss s tls)", "show ?thesis"], ["proof (prove)\nusing this:\n  tls = lmap (\\<lambda>(s, tl, s'). tl) (stlss s tls)\n  Runs_table s (stlss s tls)\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Runs_lappendE:\n  assumes \"Runs \\<sigma> (lappend tls tls')\"\n  and \"lfinite tls\"\n  obtains \\<sigma>' where \"\\<sigma> -list_of tls\\<rightarrow>* \\<sigma>'\"\n  and \"Runs \\<sigma>' tls'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>\\<sigma> -list_of tls\\<rightarrow>* \\<sigma>';\n         Runs \\<sigma>' tls'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       \\<sigma> -list_of tls\\<rightarrow>* \\<sigma>' \\<and>\n       Runs \\<sigma>' tls'", "from \\<open>lfinite tls\\<close> \\<open>Runs \\<sigma> (lappend tls tls')\\<close>"], ["proof (chain)\npicking this:\n  lfinite tls\n  Runs \\<sigma> (lappend tls tls')", "show \"\\<exists>\\<sigma>'. \\<sigma> -list_of tls\\<rightarrow>* \\<sigma>' \\<and> Runs \\<sigma>' tls'\""], ["proof (prove)\nusing this:\n  lfinite tls\n  Runs \\<sigma> (lappend tls tls')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       \\<sigma> -list_of tls\\<rightarrow>* \\<sigma>' \\<and>\n       Runs \\<sigma>' tls'", "proof(induct arbitrary: \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       Runs \\<sigma> (lappend LNil tls') \\<Longrightarrow>\n       \\<exists>\\<sigma>'.\n          \\<sigma> -list_of LNil\\<rightarrow>* \\<sigma>' \\<and>\n          Runs \\<sigma>' tls'\n 2. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           Runs \\<sigma> (lappend xs tls') \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              Runs \\<sigma>' tls';\n        Runs \\<sigma> (lappend (LCons x xs) tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -list_of (LCons x xs)\\<rightarrow>*\n                            \\<sigma>' \\<and> Runs \\<sigma>' tls'", "case lfinite_LNil"], ["proof (state)\nthis:\n  Runs \\<sigma> (lappend LNil tls')\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       Runs \\<sigma> (lappend LNil tls') \\<Longrightarrow>\n       \\<exists>\\<sigma>'.\n          \\<sigma> -list_of LNil\\<rightarrow>* \\<sigma>' \\<and>\n          Runs \\<sigma>' tls'\n 2. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           Runs \\<sigma> (lappend xs tls') \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              Runs \\<sigma>' tls';\n        Runs \\<sigma> (lappend (LCons x xs) tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -list_of (LCons x xs)\\<rightarrow>*\n                            \\<sigma>' \\<and> Runs \\<sigma>' tls'", "thus ?case"], ["proof (prove)\nusing this:\n  Runs \\<sigma> (lappend LNil tls')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -list_of LNil\\<rightarrow>* \\<sigma>'' \\<and>\n       Runs \\<sigma>'' tls'", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     \\<sigma> -list_of LNil\\<rightarrow>* \\<sigma>'' \\<and>\n     Runs \\<sigma>'' tls'\n\ngoal (1 subgoal):\n 1. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           Runs \\<sigma> (lappend xs tls') \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              Runs \\<sigma>' tls';\n        Runs \\<sigma> (lappend (LCons x xs) tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -list_of (LCons x xs)\\<rightarrow>*\n                            \\<sigma>' \\<and> Runs \\<sigma>' tls'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           Runs \\<sigma> (lappend xs tls') \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              Runs \\<sigma>' tls';\n        Runs \\<sigma> (lappend (LCons x xs) tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -list_of (LCons x xs)\\<rightarrow>*\n                            \\<sigma>' \\<and> Runs \\<sigma>' tls'", "case (lfinite_LConsI tls tl)"], ["proof (state)\nthis:\n  lfinite tls\n  Runs ?\\<sigma> (lappend tls tls') \\<Longrightarrow>\n  \\<exists>\\<sigma>'.\n     ?\\<sigma> -list_of tls\\<rightarrow>* \\<sigma>' \\<and>\n     Runs \\<sigma>' tls'\n  Runs \\<sigma> (lappend (LCons tl tls) tls')\n\ngoal (1 subgoal):\n 1. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           Runs \\<sigma> (lappend xs tls') \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              Runs \\<sigma>' tls';\n        Runs \\<sigma> (lappend (LCons x xs) tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -list_of (LCons x xs)\\<rightarrow>*\n                            \\<sigma>' \\<and> Runs \\<sigma>' tls'", "from \\<open>Runs \\<sigma> (lappend (LCons tl tls) tls')\\<close>"], ["proof (chain)\npicking this:\n  Runs \\<sigma> (lappend (LCons tl tls) tls')", "show ?case"], ["proof (prove)\nusing this:\n  Runs \\<sigma> (lappend (LCons tl tls) tls')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n       Runs \\<sigma>'' tls'", "unfolding lappend_code"], ["proof (prove)\nusing this:\n  Runs \\<sigma> (LCons tl (lappend tls tls'))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n       Runs \\<sigma>'' tls'", "proof(cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>\\<sigma> -tl\\<rightarrow> s';\n        Runs s' (lappend tls tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -list_of (LCons tl tls)\\<rightarrow>*\n                            \\<sigma>'' \\<and> Runs \\<sigma>'' tls'", "case (Step \\<sigma>')"], ["proof (state)\nthis:\n  \\<sigma> -tl\\<rightarrow> \\<sigma>'\n  Runs \\<sigma>' (lappend tls tls')\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>\\<sigma> -tl\\<rightarrow> s';\n        Runs s' (lappend tls tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -list_of (LCons tl tls)\\<rightarrow>*\n                            \\<sigma>'' \\<and> Runs \\<sigma>'' tls'", "from \\<open>Runs \\<sigma>' (lappend tls tls') \\<Longrightarrow> \\<exists>\\<sigma>''. \\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>'' \\<and> Runs \\<sigma>'' tls'\\<close> \\<open>Runs \\<sigma>' (lappend tls tls')\\<close>"], ["proof (chain)\npicking this:\n  Runs \\<sigma>' (lappend tls tls') \\<Longrightarrow>\n  \\<exists>\\<sigma>'''.\n     \\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>''' \\<and>\n     Runs \\<sigma>''' tls'\n  Runs \\<sigma>' (lappend tls tls')", "obtain \\<sigma>'' where \"\\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>''\" \"Runs \\<sigma>'' tls'\""], ["proof (prove)\nusing this:\n  Runs \\<sigma>' (lappend tls tls') \\<Longrightarrow>\n  \\<exists>\\<sigma>'''.\n     \\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>''' \\<and>\n     Runs \\<sigma>''' tls'\n  Runs \\<sigma>' (lappend tls tls')\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'''.\n        \\<lbrakk>\\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>''';\n         Runs \\<sigma>''' tls'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>''\n  Runs \\<sigma>'' tls'\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>\\<sigma> -tl\\<rightarrow> s';\n        Runs s' (lappend tls tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -list_of (LCons tl tls)\\<rightarrow>*\n                            \\<sigma>'' \\<and> Runs \\<sigma>'' tls'", "from \\<open>\\<sigma> -tl\\<rightarrow> \\<sigma>'\\<close> \\<open>\\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>''\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> -tl\\<rightarrow> \\<sigma>'\n  \\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>''", "have \"\\<sigma> -tl # list_of tls\\<rightarrow>* \\<sigma>''\""], ["proof (prove)\nusing this:\n  \\<sigma> -tl\\<rightarrow> \\<sigma>'\n  \\<sigma>' -list_of tls\\<rightarrow>* \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<sigma> -tl # list_of tls\\<rightarrow>* \\<sigma>''", "by(rule rtrancl3p_step_converse)"], ["proof (state)\nthis:\n  \\<sigma> -tl # list_of tls\\<rightarrow>* \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>\\<sigma> -tl\\<rightarrow> s';\n        Runs s' (lappend tls tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -list_of (LCons tl tls)\\<rightarrow>*\n                            \\<sigma>'' \\<and> Runs \\<sigma>'' tls'", "with \\<open>lfinite tls\\<close>"], ["proof (chain)\npicking this:\n  lfinite tls\n  \\<sigma> -tl # list_of tls\\<rightarrow>* \\<sigma>''", "have \"\\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>''\""], ["proof (prove)\nusing this:\n  lfinite tls\n  \\<sigma> -tl # list_of tls\\<rightarrow>* \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>''", "by(simp)"], ["proof (state)\nthis:\n  \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>\\<sigma> -tl\\<rightarrow> s';\n        Runs s' (lappend tls tls')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -list_of (LCons tl tls)\\<rightarrow>*\n                            \\<sigma>'' \\<and> Runs \\<sigma>'' tls'", "with \\<open>Runs \\<sigma>'' tls'\\<close>"], ["proof (chain)\npicking this:\n  Runs \\<sigma>'' tls'\n  \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>''", "show ?thesis"], ["proof (prove)\nusing this:\n  Runs \\<sigma>'' tls'\n  \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n       Runs \\<sigma>'' tls'", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n     Runs \\<sigma>'' tls'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     \\<sigma> -list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n     Runs \\<sigma>'' tls'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>'.\n     \\<sigma> -list_of tls\\<rightarrow>* \\<sigma>' \\<and>\n     Runs \\<sigma>' tls'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Trsys_into_Runs:\n  assumes \"s -tls\\<rightarrow>* s'\"\n  and \"Runs s' tls'\"\n  shows \"Runs s (lappend (llist_of tls) tls')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Runs s (lappend (llist_of tls) tls')", "using assms"], ["proof (prove)\nusing this:\n  s -tls\\<rightarrow>* s'\n  Runs s' tls'\n\ngoal (1 subgoal):\n 1. Runs s (lappend (llist_of tls) tls')", "by(induct rule: rtrancl3p_converse_induct)(auto intro: Runs.Step)"], ["", "lemma rtrancl3p_into_Rtrancl3p:\n  \"\\<lbrakk> rtrancl3p trsys a bs a'; \\<And>b a''. \\<not> a' -b\\<rightarrow> a'' \\<rbrakk> \\<Longrightarrow> Rtrancl3p a (tllist_of_llist a' (llist_of bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a -bs\\<rightarrow>* a';\n     \\<And>b a''. \\<not> a' -b\\<rightarrow> a''\\<rbrakk>\n    \\<Longrightarrow> Rtrancl3p a (tllist_of_llist a' (llist_of bs))", "by(induct rule: rtrancl3p_converse_induct)(auto intro: Rtrancl3p.intros)"], ["", "lemma Rtrancl3p_into_Runs:\n  \"Rtrancl3p s tlss \\<Longrightarrow> Runs s (llist_of_tllist tlss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rtrancl3p s tlss \\<Longrightarrow> Runs s (llist_of_tllist tlss)", "by(coinduction arbitrary: s tlss rule: Runs.coinduct)(auto elim: Rtrancl3p.cases)"], ["", "lemma Runs_into_Rtrancl3p:\n  assumes \"Runs s tls\"\n  obtains tlss where \"tls = llist_of_tllist tlss\" \"Rtrancl3p s tlss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    tls = llist_of_tllist ?tlss2\n 2. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    Rtrancl3p s ?tlss2", "let ?Q = \"\\<lambda>s tls s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls)\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    tls = llist_of_tllist ?tlss2\n 2. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    Rtrancl3p s ?tlss2", "define tlss where \"tlss = corec_tllist \n    (\\<lambda>(s, tls). lnull tls) (\\<lambda>(s, tls). s)\n    (\\<lambda>(s, tls). lhd tls)\n    (\\<lambda>_. False) undefined (\\<lambda>(s, tls). (SOME s'. ?Q s tls s', ltl tls))\""], ["proof (state)\nthis:\n  tlss =\n  corec_tllist (\\<lambda>(s, tls). lnull tls) (\\<lambda>(s, tls). s)\n   (\\<lambda>(s, tls). lhd tls) (\\<lambda>_. False) undefined\n   (\\<lambda>(s, tls).\n       (SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls),\n        ltl tls))\n\ngoal (2 subgoals):\n 1. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    tls = llist_of_tllist ?tlss2\n 2. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    Rtrancl3p s ?tlss2", "have [simp]:\n    \"tlss (s, LNil) = TNil s\"\n    \"tlss (s, LCons tl tls) = TCons tl (tlss (SOME s'. ?Q s (LCons tl tls) s', tls))\"\n    for s tl tls"], ["proof (prove)\ngoal (1 subgoal):\n 1. tlss (s, LNil) = TNil s &&&\n    tlss (s, LCons tl tls) =\n    TCons tl\n     (tlss\n       (SOME s'.\n           s -lhd (LCons tl tls)\\<rightarrow> s' \\<and>\n           Runs s' (ltl (LCons tl tls)),\n        tls))", "by(auto simp add: tlss_def intro: tllist.expand)"], ["proof (state)\nthis:\n  tlss (?s, LNil) = TNil ?s\n  tlss (?s, LCons ?tl ?tls) =\n  TCons ?tl\n   (tlss\n     (SOME s'.\n         ?s -lhd (LCons ?tl ?tls)\\<rightarrow> s' \\<and>\n         Runs s' (ltl (LCons ?tl ?tls)),\n      ?tls))\n\ngoal (2 subgoals):\n 1. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    tls = llist_of_tllist ?tlss2\n 2. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    Rtrancl3p s ?tlss2", "show \"tls = llist_of_tllist (tlss (s, tls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tls = llist_of_tllist (tlss (s, tls))", "using assms"], ["proof (prove)\nusing this:\n  Runs s tls\n\ngoal (1 subgoal):\n 1. tls = llist_of_tllist (tlss (s, tls))", "by(coinduction arbitrary: s tls)(erule Runs.cases; fastforce intro: someI2)"], ["proof (state)\nthis:\n  tls = llist_of_tllist (tlss (s, tls))\n\ngoal (1 subgoal):\n 1. (\\<And>tlss.\n        \\<lbrakk>tls = llist_of_tllist tlss; Rtrancl3p s tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    Rtrancl3p s\n     (corec_tllist (\\<lambda>(s, y). lnull y) (\\<lambda>(s, tls). s)\n       (\\<lambda>(s, y). lhd y) (\\<lambda>_. False) undefined\n       (\\<lambda>(s, tls).\n           (SOME s'. s -lhd tls\\<rightarrow> s' \\<and> Runs s' (ltl tls),\n            ltl tls))\n       (s, tls))", "show \"Rtrancl3p s (tlss (s, tls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rtrancl3p s (tlss (s, tls))", "using assms"], ["proof (prove)\nusing this:\n  Runs s tls\n\ngoal (1 subgoal):\n 1. Rtrancl3p s (tlss (s, tls))", "by(coinduction arbitrary: s tls)(erule Runs.cases; simp; iprover intro: someI2[where Q=\"trsys _ _\"] someI2[where Q=\"\\<lambda>s'. Runs s' _\"])"], ["proof (state)\nthis:\n  Rtrancl3p s (tlss (s, tls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixes tl\n  assumes \"Rtrancl3p s tlss\" \"tfinite tlss\"\n  shows Rtrancl3p_into_Trsys: \"Trsys s (list_of (llist_of_tllist tlss)) (terminal tlss)\"\n    and terminal_Rtrancl3p_final: \"\\<not> terminal tlss -tl\\<rightarrow> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -list_of (llist_of_tllist tlss)\\<rightarrow>* terminal tlss &&&\n    \\<not> terminal tlss -tl\\<rightarrow> s'", "using assms(2,1)"], ["proof (prove)\nusing this:\n  tfinite tlss\n  Rtrancl3p s tlss\n\ngoal (1 subgoal):\n 1. s -list_of (llist_of_tllist tlss)\\<rightarrow>* terminal tlss &&&\n    \\<not> terminal tlss -tl\\<rightarrow> s'", "by(induction arbitrary: s rule: tfinite_induct)(auto simp add: Rtrancl3p_simps intro: rtrancl3p_step_converse)"], ["", "end"], ["", "subsection \\<open>Labelled transition systems with internal actions\\<close>"], ["", "locale \\<tau>trsys = trsys +\n  constrains trsys :: \"('s, 'tl) trsys\"\n  fixes \\<tau>move :: \"('s, 'tl) trsys\"\nbegin"], ["", "inductive silent_move :: \"'s \\<Rightarrow> 's \\<Rightarrow> bool\" (\"_ -\\<tau>\\<rightarrow> _\" [50, 50] 60)\nwhere [intro]: \"!!tl. \\<lbrakk> trsys s tl s'; \\<tau>move s tl s' \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow> s'\""], ["", "declare silent_move.cases [elim]"], ["", "lemma silent_move_iff: \"silent_move = (\\<lambda>s s'. (\\<exists>tl. trsys s tl s' \\<and> \\<tau>move s tl s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. silent_move =\n    (\\<lambda>s s'.\n        \\<exists>tl. s -tl\\<rightarrow> s' \\<and> \\<tau>move s tl s')", "by(auto simp add: fun_eq_iff)"], ["", "abbreviation silent_moves :: \"'s \\<Rightarrow> 's \\<Rightarrow> bool\" (\"_ -\\<tau>\\<rightarrow>* _\" [50, 50] 60)\nwhere \"silent_moves == silent_move^**\""], ["", "abbreviation silent_movet :: \"'s \\<Rightarrow> 's \\<Rightarrow> bool\" (\"_ -\\<tau>\\<rightarrow>+ _\" [50, 50] 60)\nwhere \"silent_movet == silent_move^++\""], ["", "coinductive \\<tau>diverge :: \"'s \\<Rightarrow> bool\" (\"_ -\\<tau>\\<rightarrow> \\<infinity>\" [50] 60)\nwhere\n  \\<tau>divergeI: \"\\<lbrakk> s -\\<tau>\\<rightarrow> s'; s' -\\<tau>\\<rightarrow> \\<infinity> \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\""], ["", "coinductive \\<tau>inf_step :: \"'s \\<Rightarrow> 'tl llist \\<Rightarrow> bool\" (\"_ -\\<tau>-_\\<rightarrow>* \\<infinity>\" [50, 0] 60)\nwhere\n  \\<tau>inf_step_Cons: \"\\<And>tl. \\<lbrakk> s -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s''; s'' -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<rbrakk> \\<Longrightarrow> s -\\<tau>-LCons tl tls\\<rightarrow>* \\<infinity>\"\n| \\<tau>inf_step_Nil: \"s -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow> s -\\<tau>-LNil\\<rightarrow>* \\<infinity>\""], ["", "coinductive \\<tau>inf_step_table :: \"'s \\<Rightarrow> ('s \\<times> 's \\<times> 'tl \\<times> 's) llist \\<Rightarrow> bool\" (\"_ -\\<tau>-_\\<rightarrow>*t \\<infinity>\" [50, 0] 80)\nwhere\n  \\<tau>inf_step_table_Cons:\n  \"\\<And>tl. \\<lbrakk> s -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s''; s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity> \\<rbrakk> \\<Longrightarrow> s -\\<tau>-LCons (s, s', tl, s'') tls\\<rightarrow>*t \\<infinity>\"\n\n| \\<tau>inf_step_table_Nil:\n  \"s -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow> s -\\<tau>-LNil\\<rightarrow>*t \\<infinity>\""], ["", "definition \\<tau>inf_step2\\<tau>inf_step_table :: \"'s \\<Rightarrow> 'tl llist \\<Rightarrow> ('s \\<times> 's \\<times> 'tl \\<times> 's) llist\"\nwhere\n  \"\\<tau>inf_step2\\<tau>inf_step_table s tls =\n   unfold_llist\n     (\\<lambda>(s, tls). lnull tls)\n     (\\<lambda>(s, tls). let (s', s'') = SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -lhd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (lhd tls) s'' \\<and> s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity>\n        in (s, s', lhd tls, s''))\n     (\\<lambda>(s, tls). let (s', s'') = SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -lhd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (lhd tls) s'' \\<and> s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity>\n        in (s'', ltl tls))\n     (s, tls)\""], ["", "definition silent_move_from :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's \\<Rightarrow> bool\"\nwhere \"silent_move_from s0 s1 s2 \\<longleftrightarrow> silent_moves s0 s1 \\<and> silent_move s1 s2\""], ["", "inductive \\<tau>rtrancl3p :: \"'s \\<Rightarrow> 'tl list \\<Rightarrow> 's \\<Rightarrow> bool\" (\"_ -\\<tau>-_\\<rightarrow>* _\" [50, 0, 50] 60)\nwhere\n  \\<tau>rtrancl3p_refl: \"\\<tau>rtrancl3p s [] s\"\n| \\<tau>rtrancl3p_step: \"\\<And>tl. \\<lbrakk> s -tl\\<rightarrow> s'; \\<not> \\<tau>move s tl s'; \\<tau>rtrancl3p s' tls s'' \\<rbrakk> \\<Longrightarrow> \\<tau>rtrancl3p s (tl # tls) s''\"\n| \\<tau>rtrancl3p_\\<tau>step: \"\\<And>tl. \\<lbrakk> s -tl\\<rightarrow> s'; \\<tau>move s tl s'; \\<tau>rtrancl3p s' tls s'' \\<rbrakk> \\<Longrightarrow> \\<tau>rtrancl3p s tls s''\""], ["", "coinductive \\<tau>Runs :: \"'s \\<Rightarrow> ('tl, 's option) tllist \\<Rightarrow> bool\" (\"_ \\<Down> _\" [50, 50] 51)\nwhere\n  Terminate: \"\\<lbrakk> s -\\<tau>\\<rightarrow>* s'; \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s'' \\<rbrakk> \\<Longrightarrow> s \\<Down> TNil \\<lfloor>s'\\<rfloor>\" \n| Diverge: \"s -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow> s \\<Down> TNil None\"\n| Proceed: \"\\<And>tl. \\<lbrakk> s -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s''; s'' \\<Down> tls \\<rbrakk> \\<Longrightarrow> s \\<Down> TCons tl tls\""], ["", "inductive_simps \\<tau>Runs_simps:\n  \"s \\<Down> TNil (Some s')\"\n  \"s \\<Down> TNil None\"\n  \"s \\<Down> TCons tl' tls\""], ["", "coinductive \\<tau>Runs_table :: \"'s \\<Rightarrow> ('tl \\<times> 's, 's option) tllist \\<Rightarrow> bool\"\nwhere \n  Terminate: \"\\<lbrakk> s -\\<tau>\\<rightarrow>* s'; \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Runs_table s (TNil \\<lfloor>s'\\<rfloor>)\"\n| Diverge: \"s -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow> \\<tau>Runs_table s (TNil None)\"\n| Proceed:\n  \"\\<And>tl. \\<lbrakk> s -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table s'' tls \\<rbrakk> \n  \\<Longrightarrow> \\<tau>Runs_table s (TCons (tl, s'') tls)\""], ["", "definition silent_move2 :: \"'s \\<Rightarrow> 'tl \\<Rightarrow> 's \\<Rightarrow> bool\"\nwhere \"\\<And>tl. silent_move2 s tl s' \\<longleftrightarrow> s -tl\\<rightarrow> s' \\<and> \\<tau>move s tl s'\""], ["", "abbreviation silent_moves2 :: \"'s \\<Rightarrow> 'tl list \\<Rightarrow> 's \\<Rightarrow> bool\"\nwhere \"silent_moves2 \\<equiv> rtrancl3p silent_move2\""], ["", "coinductive \\<tau>Runs_table2 :: \"'s \\<Rightarrow> ('tl list \\<times> 's \\<times> 'tl \\<times> 's, ('tl list \\<times> 's) + 'tl llist) tllist \\<Rightarrow> bool\"\nwhere \n  Terminate: \"\\<lbrakk> silent_moves2 s tls s'; \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s'' \\<rbrakk> \\<Longrightarrow> \\<tau>Runs_table2 s (TNil (Inl (tls, s')))\"\n| Diverge: \"trsys.inf_step silent_move2 s tls \\<Longrightarrow> \\<tau>Runs_table2 s (TNil (Inr tls))\"\n| Proceed:\n  \"\\<And>tl. \\<lbrakk> silent_moves2 s tls s'; s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss \\<rbrakk> \n  \\<Longrightarrow> \\<tau>Runs_table2 s (TCons (tls, s', tl, s'') tlsstlss)\""], ["", "inductive_simps \\<tau>Runs_table2_simps:\n  \"\\<tau>Runs_table2 s (TNil tlss)\"\n  \"\\<tau>Runs_table2 s (TCons tlsstls tlsstlss)\""], ["", "lemma inf_step_table_all_\\<tau>_into_\\<tau>diverge:\n  \"\\<lbrakk> s -stls\\<rightarrow>*t \\<infinity>; \\<forall>(s, tl, s') \\<in> lset stls. \\<tau>move s tl s' \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -stls\\<rightarrow>*t \\<infinity>;\n     \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s'\\<rbrakk>\n    \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>", "proof(coinduction arbitrary: s stls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s stls.\n       \\<lbrakk>s -stls\\<rightarrow>*t \\<infinity>;\n        \\<forall>x.\n           x \\<in> lset stls \\<longrightarrow>\n           (case x of (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            sa -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s stls.\n                                 s' = s \\<and>\n                                 s -stls\\<rightarrow>*t \\<infinity> \\<and>\n                                 (\\<forall>x.\n                                     x \\<in> lset stls \\<longrightarrow>\n                                     (case x of\n(s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb))) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>diverge s)"], ["proof (state)\nthis:\n  s -stls\\<rightarrow>*t \\<infinity>\n  \\<forall>x.\n     x \\<in> lset stls \\<longrightarrow>\n     (case x of (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)\n\ngoal (1 subgoal):\n 1. \\<And>s stls.\n       \\<lbrakk>s -stls\\<rightarrow>*t \\<infinity>;\n        \\<forall>x.\n           x \\<in> lset stls \\<longrightarrow>\n           (case x of (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            sa -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s stls.\n                                 s' = s \\<and>\n                                 s -stls\\<rightarrow>*t \\<infinity> \\<and>\n                                 (\\<forall>x.\n                                     x \\<in> lset stls \\<longrightarrow>\n                                     (case x of\n(s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb))) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?case"], ["proof (prove)\nusing this:\n  s -stls\\<rightarrow>*t \\<infinity>\n  \\<forall>x.\n     x \\<in> lset stls \\<longrightarrow>\n     (case x of (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s stls.\n            s' = s \\<and>\n            s -stls\\<rightarrow>*t \\<infinity> \\<and>\n            (\\<forall>x.\n                x \\<in> lset stls \\<longrightarrow>\n                (case x of\n                 (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb))) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "by cases (auto simp add: silent_move_iff, blast)"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     ((\\<exists>s stls.\n          s' = s \\<and>\n          s -stls\\<rightarrow>*t \\<infinity> \\<and>\n          (\\<forall>x.\n              x \\<in> lset stls \\<longrightarrow>\n              (case x of\n               (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb))) \\<or>\n      s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_step_table_lappend_llist_ofD:\n  \"s -lappend (llist_of stls) (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\n  \\<Longrightarrow> (s -map (fst \\<circ> snd) stls\\<rightarrow>* x) \\<and> (x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -lappend (llist_of stls)\n        (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n    s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n    x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "proof(induct stls arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s -lappend (llist_of [])\n           (LCons (x, tl', x')\n             xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       s -map (fst \\<circ> snd) []\\<rightarrow>* x \\<and>\n       x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n 2. \\<And>a stls s.\n       \\<lbrakk>\\<And>s.\n                   s -lappend (llist_of stls)\n                       (LCons (x, tl', x')\n                         xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n                   s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n                   x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>;\n        s -lappend (llist_of (a # stls))\n            (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (a # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "case Nil"], ["proof (state)\nthis:\n  s -lappend (llist_of [])\n      (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s -lappend (llist_of [])\n           (LCons (x, tl', x')\n             xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       s -map (fst \\<circ> snd) []\\<rightarrow>* x \\<and>\n       x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n 2. \\<And>a stls s.\n       \\<lbrakk>\\<And>s.\n                   s -lappend (llist_of stls)\n                       (LCons (x, tl', x')\n                         xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n                   s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n                   x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>;\n        s -lappend (llist_of (a # stls))\n            (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (a # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "thus ?case"], ["proof (prove)\nusing this:\n  s -lappend (llist_of [])\n      (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. s -map (fst \\<circ> snd) []\\<rightarrow>* x \\<and>\n    x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "by(auto elim: inf_step_table.cases intro: inf_step_table.intros rtrancl3p_refl)"], ["proof (state)\nthis:\n  s -map (fst \\<circ> snd) []\\<rightarrow>* x \\<and>\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a stls s.\n       \\<lbrakk>\\<And>s.\n                   s -lappend (llist_of stls)\n                       (LCons (x, tl', x')\n                         xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n                   s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n                   x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>;\n        s -lappend (llist_of (a # stls))\n            (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (a # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a stls s.\n       \\<lbrakk>\\<And>s.\n                   s -lappend (llist_of stls)\n                       (LCons (x, tl', x')\n                         xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n                   s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n                   x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>;\n        s -lappend (llist_of (a # stls))\n            (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (a # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "case (Cons st stls)"], ["proof (state)\nthis:\n  ?s -lappend (llist_of stls)\n       (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n  ?s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n  s -lappend (llist_of (st # stls))\n      (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a stls s.\n       \\<lbrakk>\\<And>s.\n                   s -lappend (llist_of stls)\n                       (LCons (x, tl', x')\n                         xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n                   s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n                   x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>;\n        s -lappend (llist_of (a # stls))\n            (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (a # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "note IH = \\<open>\\<And>s. s -lappend (llist_of stls) (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n                 s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and> x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\\<close>"], ["proof (state)\nthis:\n  ?s -lappend (llist_of stls)\n       (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n  ?s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a stls s.\n       \\<lbrakk>\\<And>s.\n                   s -lappend (llist_of stls)\n                       (LCons (x, tl', x')\n                         xs)\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n                   s -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n                   x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>;\n        s -lappend (llist_of (a # stls))\n            (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (a # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "from \\<open>s -lappend (llist_of (st # stls)) (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s -lappend (llist_of (st # stls))\n      (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  s -lappend (llist_of (st # stls))\n      (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. s -map (fst \\<circ> snd) (st # stls)\\<rightarrow>* x \\<and>\n    x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (llist_of (st # stls)) (LCons (x, tl', x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (st # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "case (inf_step_tableI s' stls' tl)"], ["proof (state)\nthis:\n  lappend (llist_of (st # stls)) (LCons (x, tl', x') xs) =\n  LCons (s, tl, s') stls'\n  s -tl\\<rightarrow> s'\n  s' -stls'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (llist_of (st # stls)) (LCons (x, tl', x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (st # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "hence [simp]: \"st = (s, tl, s')\" \"stls' = lappend (llist_of stls) (LCons (x, tl', x') xs)\"\n      and \"s -tl\\<rightarrow> s'\" \"s' -lappend (llist_of stls) (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  lappend (llist_of (st # stls)) (LCons (x, tl', x') xs) =\n  LCons (s, tl, s') stls'\n  s -tl\\<rightarrow> s'\n  s' -stls'\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. (st = (s, tl, s') &&&\n     stls' = lappend (llist_of stls) (LCons (x, tl', x') xs)) &&&\n    s -tl\\<rightarrow> s' &&&\n    s' -lappend (llist_of stls)\n         (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>", "by simp_all"], ["proof (state)\nthis:\n  st = (s, tl, s')\n  stls' = lappend (llist_of stls) (LCons (x, tl', x') xs)\n  s -tl\\<rightarrow> s'\n  s' -lappend (llist_of stls)\n       (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (llist_of (st # stls)) (LCons (x, tl', x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (st # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "from IH[OF \\<open>s' -lappend (llist_of stls) (LCons (x, tl', x') xs)\\<rightarrow>*t \\<infinity>\\<close>]"], ["proof (chain)\npicking this:\n  s' -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "have \"s' -map (fst \\<circ> snd) stls\\<rightarrow>* x\" \"x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  s' -map (fst \\<circ> snd) stls\\<rightarrow>* x \\<and>\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. s' -map (fst \\<circ> snd) stls\\<rightarrow>* x &&&\n    x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "by auto"], ["proof (state)\nthis:\n  s' -map (fst \\<circ> snd) stls\\<rightarrow>* x\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (llist_of (st # stls)) (LCons (x, tl', x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -map (fst \\<circ> snd) (st # stls)\\<rightarrow>*\n                         x \\<and>\n                         x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "with \\<open>s -tl\\<rightarrow> s'\\<close>"], ["proof (chain)\npicking this:\n  s -tl\\<rightarrow> s'\n  s' -map (fst \\<circ> snd) stls\\<rightarrow>* x\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  s -tl\\<rightarrow> s'\n  s' -map (fst \\<circ> snd) stls\\<rightarrow>* x\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. s -map (fst \\<circ> snd) (st # stls)\\<rightarrow>* x \\<and>\n    x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>", "by(auto simp add: o_def intro: rtrancl3p_step_converse)"], ["proof (state)\nthis:\n  s -map (fst \\<circ> snd) (st # stls)\\<rightarrow>* x \\<and>\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s -map (fst \\<circ> snd) (st # stls)\\<rightarrow>* x \\<and>\n  x -LCons (x, tl', x') xs\\<rightarrow>*t \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_step_table_lappend_llist_of_\\<tau>_into_\\<tau>moves:\n  assumes \"lfinite stls\"\n  shows \"\\<lbrakk> s -lappend stls (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>; \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s' \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -lappend stls\n                 (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n     \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s'\\<rbrakk>\n    \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "using assms"], ["proof (prove)\nusing this:\n  lfinite stls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s -lappend stls\n                 (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n     \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s'\\<rbrakk>\n    \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "proof(induct arbitrary: s rule: lfinite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s -lappend LNil\n                    (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset LNil. \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x\n 2. \\<And>xsa xa s.\n       \\<lbrakk>lfinite xsa;\n        \\<And>s.\n           \\<lbrakk>s -lappend xsa\n                        (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n            \\<forall>(s, x, y)\\<in>lset xsa. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x;\n        s -lappend (LCons xa xsa)\n            (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset (LCons xa xsa).\n           \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "case lfinite_LNil"], ["proof (state)\nthis:\n  s -lappend LNil (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>\n  \\<forall>a\\<in>lset LNil.\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s -lappend LNil\n                    (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset LNil. \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x\n 2. \\<And>xsa xa s.\n       \\<lbrakk>lfinite xsa;\n        \\<And>s.\n           \\<lbrakk>s -lappend xsa\n                        (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n            \\<forall>(s, x, y)\\<in>lset xsa. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x;\n        s -lappend (LCons xa xsa)\n            (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset (LCons xa xsa).\n           \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "thus ?case"], ["proof (prove)\nusing this:\n  s -lappend LNil (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>\n  \\<forall>a\\<in>lset LNil.\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* x", "by(auto elim: inf_step_table.cases)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. \\<And>xsa xa s.\n       \\<lbrakk>lfinite xsa;\n        \\<And>s.\n           \\<lbrakk>s -lappend xsa\n                        (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n            \\<forall>(s, x, y)\\<in>lset xsa. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x;\n        s -lappend (LCons xa xsa)\n            (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset (LCons xa xsa).\n           \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa xa s.\n       \\<lbrakk>lfinite xsa;\n        \\<And>s.\n           \\<lbrakk>s -lappend xsa\n                        (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n            \\<forall>(s, x, y)\\<in>lset xsa. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x;\n        s -lappend (LCons xa xsa)\n            (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset (LCons xa xsa).\n           \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "case (lfinite_LConsI stls st)"], ["proof (state)\nthis:\n  lfinite stls\n  \\<lbrakk>?s -lappend stls\n                (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n   \\<forall>a\\<in>lset stls.\n      case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\\<rbrakk>\n  \\<Longrightarrow> ?s -\\<tau>\\<rightarrow>* x\n  s -lappend (LCons st stls)\n      (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>\n  \\<forall>a\\<in>lset (LCons st stls).\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (1 subgoal):\n 1. \\<And>xsa xa s.\n       \\<lbrakk>lfinite xsa;\n        \\<And>s.\n           \\<lbrakk>s -lappend xsa\n                        (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n            \\<forall>(s, x, y)\\<in>lset xsa. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x;\n        s -lappend (LCons xa xsa)\n            (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset (LCons xa xsa).\n           \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "note IH = \\<open>\\<And>s. \\<lbrakk>s -lappend stls (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>; \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s' \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?s -lappend stls\n                (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n   \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s'\\<rbrakk>\n  \\<Longrightarrow> ?s -\\<tau>\\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. \\<And>xsa xa s.\n       \\<lbrakk>lfinite xsa;\n        \\<And>s.\n           \\<lbrakk>s -lappend xsa\n                        (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n            \\<forall>(s, x, y)\\<in>lset xsa. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x;\n        s -lappend (LCons xa xsa)\n            (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset (LCons xa xsa).\n           \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "obtain s1 tl1 s1' where [simp]: \"st = (s1, tl1, s1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1 tl1 s1'.\n        st = (s1, tl1, s1') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases st)"], ["proof (state)\nthis:\n  st = (s1, tl1, s1')\n\ngoal (1 subgoal):\n 1. \\<And>xsa xa s.\n       \\<lbrakk>lfinite xsa;\n        \\<And>s.\n           \\<lbrakk>s -lappend xsa\n                        (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n            \\<forall>(s, x, y)\\<in>lset xsa. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x;\n        s -lappend (LCons xa xsa)\n            (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>;\n        \\<forall>(s, x, y)\\<in>lset (LCons xa xsa).\n           \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "from \\<open>s -lappend (LCons st stls) (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s -lappend (LCons st stls)\n      (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  s -lappend (LCons st stls)\n      (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* x", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (LCons st stls) (LCons (x, tl' x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "case (inf_step_tableI X' STLS TL)"], ["proof (state)\nthis:\n  lappend (LCons st stls) (LCons (x, tl' x') xs) = LCons (s, TL, X') STLS\n  s -TL\\<rightarrow> X'\n  X' -STLS\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (LCons st stls) (LCons (x, tl' x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "hence [simp]: \"s1 = s\" \"TL = tl1\" \"X' = s1'\" \"STLS = lappend stls (LCons (x, tl' x') xs)\"\n      and \"s -tl1\\<rightarrow> s1'\" and \"s1' -lappend stls (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  lappend (LCons st stls) (LCons (x, tl' x') xs) = LCons (s, TL, X') STLS\n  s -TL\\<rightarrow> X'\n  X' -STLS\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. ((s1 = s &&& TL = tl1) &&&\n     X' = s1' &&& STLS = lappend stls (LCons (x, tl' x') xs)) &&&\n    s -tl1\\<rightarrow> s1' &&&\n    s1' -lappend stls (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>", "by simp_all"], ["proof (state)\nthis:\n  s1 = s\n  TL = tl1\n  X' = s1'\n  STLS = lappend stls (LCons (x, tl' x') xs)\n  s -tl1\\<rightarrow> s1'\n  s1' -lappend stls (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (LCons st stls) (LCons (x, tl' x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "from \\<open>\\<forall>(s, tl, s')\\<in>lset (LCons st stls). \\<tau>move s tl s'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>(s, tl, s')\\<in>lset (LCons st stls). \\<tau>move s tl s'", "have \"\\<tau>move s tl1 s1'\""], ["proof (prove)\nusing this:\n  \\<forall>(s, tl, s')\\<in>lset (LCons st stls). \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. \\<tau>move s tl1 s1'", "by simp"], ["proof (state)\nthis:\n  \\<tau>move s tl1 s1'\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (LCons st stls) (LCons (x, tl' x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "moreover"], ["proof (state)\nthis:\n  \\<tau>move s tl1 s1'\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (LCons st stls) (LCons (x, tl' x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "from IH[OF \\<open>s1' -lappend stls (LCons (x, tl' x') xs)\\<rightarrow>*t \\<infinity>\\<close>] \\<open>\\<forall>(s, tl, s')\\<in>lset (LCons st stls). \\<tau>move s tl s'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s' \\<Longrightarrow>\n  s1' -\\<tau>\\<rightarrow>* x\n  \\<forall>(s, tl, s')\\<in>lset (LCons st stls). \\<tau>move s tl s'", "have \"s1' -\\<tau>\\<rightarrow>* x\""], ["proof (prove)\nusing this:\n  \\<forall>(s, tl, s')\\<in>lset stls. \\<tau>move s tl s' \\<Longrightarrow>\n  s1' -\\<tau>\\<rightarrow>* x\n  \\<forall>(s, tl, s')\\<in>lset (LCons st stls). \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s1' -\\<tau>\\<rightarrow>* x", "by simp"], ["proof (state)\nthis:\n  s1' -\\<tau>\\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. \\<And>s' stls tl.\n       \\<lbrakk>lappend (LCons st stls) (LCons (x, tl' x') xs) =\n                LCons (s, tl, s') stls;\n        s -tl\\<rightarrow> s'; s' -stls\\<rightarrow>*t \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* x", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau>move s tl1 s1'\n  s1' -\\<tau>\\<rightarrow>* x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau>move s tl1 s1'\n  s1' -\\<tau>\\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* x", "using \\<open>s -tl1\\<rightarrow> s1'\\<close>"], ["proof (prove)\nusing this:\n  \\<tau>move s tl1 s1'\n  s1' -\\<tau>\\<rightarrow>* x\n  s -tl1\\<rightarrow> s1'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* x", "by(auto intro: converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_step_table_into_\\<tau>inf_step:\n  \"s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow> s -\\<tau>-lmap (fst \\<circ> snd) (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls)\\<rightarrow>* \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n    s -\\<tau>-lmap (fst \\<circ> snd)\n               (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                 stls)\\<rightarrow>* \\<infinity>", "proof(coinduction arbitrary: s stls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>inf_step s stls)"], ["proof (state)\nthis:\n  s -stls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>)", "let ?P = \"\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s stls.\n       s -stls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s stls.\n             s'' = s \\<and>\n             tls =\n             lmap (fst \\<circ> snd)\n              (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                stls) \\<and>\n             s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)", "proof(cases \"lfilter ?P stls\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n    LNil \\<Longrightarrow>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s stls.\n             s'' = s \\<and>\n             tls =\n             lmap (fst \\<circ> snd)\n              (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                stls) \\<and>\n             s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "case LNil"], ["proof (state)\nthis:\n  lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls = LNil\n\ngoal (2 subgoals):\n 1. lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n    LNil \\<Longrightarrow>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s stls.\n             s'' = s \\<and>\n             tls =\n             lmap (fst \\<circ> snd)\n              (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                stls) \\<and>\n             s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "with \\<tau>inf_step"], ["proof (chain)\npicking this:\n  s -stls\\<rightarrow>*t \\<infinity>\n  lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls = LNil", "have ?\\<tau>inf_step_Nil"], ["proof (prove)\nusing this:\n  s -stls\\<rightarrow>*t \\<infinity>\n  lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls = LNil\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       lmap (fst \\<circ> snd)\n        (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n       LNil \\<and>\n       s -\\<tau>\\<rightarrow> \\<infinity>", "by(auto intro: inf_step_table_all_\\<tau>_into_\\<tau>diverge simp add: lfilter_eq_LNil)"], ["proof (state)\nthis:\n  \\<exists>s.\n     s = s \\<and>\n     lmap (fst \\<circ> snd)\n      (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n     LNil \\<and>\n     s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n    LNil \\<Longrightarrow>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s stls.\n             s'' = s \\<and>\n             tls =\n             lmap (fst \\<circ> snd)\n              (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                stls) \\<and>\n             s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s = s \\<and>\n     lmap (fst \\<circ> snd)\n      (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n     LNil \\<and>\n     s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s stls.\n             s'' = s \\<and>\n             tls =\n             lmap (fst \\<circ> snd)\n              (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                stls) \\<and>\n             s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)", ".."], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      lmap (fst \\<circ> snd)\n       (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n      LCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s stls.\n           s'' = s \\<and>\n           tls =\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) \\<and>\n           s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n       s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      lmap (fst \\<circ> snd)\n       (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n      LNil \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "case (LCons stls' xs)"], ["proof (state)\nthis:\n  lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n  LCons stls' xs\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "obtain x tl x' where \"stls' = (x, tl, x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x tl x'.\n        stls' = (x, tl, x') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases stls')"], ["proof (state)\nthis:\n  stls' = (x, tl, x')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "with LCons"], ["proof (chain)\npicking this:\n  lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n  LCons stls' xs\n  stls' = (x, tl, x')", "have stls: \"lfilter ?P stls = LCons (x, tl, x') xs\""], ["proof (prove)\nusing this:\n  lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n  LCons stls' xs\n  stls' = (x, tl, x')\n\ngoal (1 subgoal):\n 1. lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n    LCons (x, tl, x') xs", "by simp"], ["proof (state)\nthis:\n  lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n  LCons (x, tl, x') xs\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "from lfilter_eq_LConsD[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>us vs.\n     stls = lappend us (LCons (x, tl, x') vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us.\n         \\<not> (case u of\n                 (s, tl, s') \\<Rightarrow>\n                   \\<not> \\<tau>move s tl s')) \\<and>\n     (case (x, tl, x') of\n      (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s') \\<and>\n     xs = lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') vs", "obtain stls1 stls2\n      where stls1: \"stls = lappend stls1 (LCons (x, tl, x') stls2)\"\n      and \"lfinite stls1\"\n      and \\<tau>s: \"\\<forall>(s, tl, s')\\<in>lset stls1. \\<tau>move s tl s'\"\n      and n\\<tau>: \"\\<not> \\<tau>move x tl x'\" and xs: \"xs = lfilter ?P stls2\""], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     stls = lappend us (LCons (x, tl, x') vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us.\n         \\<not> (case u of\n                 (s, tl, s') \\<Rightarrow>\n                   \\<not> \\<tau>move s tl s')) \\<and>\n     (case (x, tl, x') of\n      (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s') \\<and>\n     xs = lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') vs\n\ngoal (1 subgoal):\n 1. (\\<And>stls1 stls2.\n        \\<lbrakk>stls = lappend stls1 (LCons (x, tl, x') stls2);\n         lfinite stls1;\n         \\<forall>(s, tl, s')\\<in>lset stls1. \\<tau>move s tl s';\n         \\<not> \\<tau>move x tl x';\n         xs =\n         lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n          stls2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  stls = lappend stls1 (LCons (x, tl, x') stls2)\n  lfinite stls1\n  \\<forall>(s, tl, s')\\<in>lset stls1. \\<tau>move s tl s'\n  \\<not> \\<tau>move x tl x'\n  xs = lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "from \\<open>lfinite stls1\\<close> \\<tau>inf_step \\<tau>s"], ["proof (chain)\npicking this:\n  lfinite stls1\n  s -stls\\<rightarrow>*t \\<infinity>\n  \\<forall>(s, tl, s')\\<in>lset stls1. \\<tau>move s tl s'", "have \"s -\\<tau>\\<rightarrow>* x\""], ["proof (prove)\nusing this:\n  lfinite stls1\n  s -stls\\<rightarrow>*t \\<infinity>\n  \\<forall>(s, tl, s')\\<in>lset stls1. \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* x", "unfolding stls1"], ["proof (prove)\nusing this:\n  lfinite stls1\n  s -lappend stls1 (LCons (x, tl, x') stls2)\\<rightarrow>*t \\<infinity>\n  \\<forall>(s, tl, s')\\<in>lset stls1. \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* x", "by(rule inf_step_table_lappend_llist_of_\\<tau>_into_\\<tau>moves)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "moreover"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "from \\<open>lfinite stls1\\<close>"], ["proof (chain)\npicking this:\n  lfinite stls1", "have \"llist_of (list_of stls1) = stls1\""], ["proof (prove)\nusing this:\n  lfinite stls1\n\ngoal (1 subgoal):\n 1. llist_of (list_of stls1) = stls1", "by(simp add: llist_of_list_of)"], ["proof (state)\nthis:\n  llist_of (list_of stls1) = stls1\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "with \\<tau>inf_step stls1"], ["proof (chain)\npicking this:\n  s -stls\\<rightarrow>*t \\<infinity>\n  stls = lappend stls1 (LCons (x, tl, x') stls2)\n  llist_of (list_of stls1) = stls1", "have \"s -lappend (llist_of (list_of stls1)) (LCons (x, tl, x') stls2)\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  s -stls\\<rightarrow>*t \\<infinity>\n  stls = lappend stls1 (LCons (x, tl, x') stls2)\n  llist_of (list_of stls1) = stls1\n\ngoal (1 subgoal):\n 1. s -lappend (llist_of (list_of stls1))\n        (LCons (x, tl, x') stls2)\\<rightarrow>*t \\<infinity>", "by simp"], ["proof (state)\nthis:\n  s -lappend (llist_of (list_of stls1))\n      (LCons (x, tl, x') stls2)\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "from inf_step_table_lappend_llist_ofD[OF this]"], ["proof (chain)\npicking this:\n  s -map (fst \\<circ> snd) (list_of stls1)\\<rightarrow>* x \\<and>\n  x -LCons (x, tl, x') stls2\\<rightarrow>*t \\<infinity>", "have \"x -LCons (x, tl, x') stls2\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  s -map (fst \\<circ> snd) (list_of stls1)\\<rightarrow>* x \\<and>\n  x -LCons (x, tl, x') stls2\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. x -LCons (x, tl, x') stls2\\<rightarrow>*t \\<infinity>", ".."], ["proof (state)\nthis:\n  x -LCons (x, tl, x') stls2\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "hence \"x -tl\\<rightarrow> x'\" \"x' -stls2\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\nusing this:\n  x -LCons (x, tl, x') stls2\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. x -tl\\<rightarrow> x' &&& x' -stls2\\<rightarrow>*t \\<infinity>", "by(auto elim: inf_step_table.cases)"], ["proof (state)\nthis:\n  x -tl\\<rightarrow> x'\n  x' -stls2\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "ultimately"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* x\n  x -tl\\<rightarrow> x'\n  x' -stls2\\<rightarrow>*t \\<infinity>", "have ?\\<tau>inf_step_Cons"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* x\n  x -tl\\<rightarrow> x'\n  x' -stls2\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s = s \\<and>\n       lmap (fst \\<circ> snd)\n        (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n       LCons tl tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s stls.\n            s'' = s \\<and>\n            tls =\n            lmap (fst \\<circ> snd)\n             (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n               stls) \\<and>\n            s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)", "using xs n\\<tau>"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* x\n  x -tl\\<rightarrow> x'\n  x' -stls2\\<rightarrow>*t \\<infinity>\n  xs = lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls2\n  \\<not> \\<tau>move x tl x'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s = s \\<and>\n       lmap (fst \\<circ> snd)\n        (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n       LCons tl tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s stls.\n            s'' = s \\<and>\n            tls =\n            lmap (fst \\<circ> snd)\n             (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n               stls) \\<and>\n            s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)", "by(auto simp add: stls o_def)"], ["proof (state)\nthis:\n  \\<exists>s s' s'' tls tl.\n     s = s \\<and>\n     lmap (fst \\<circ> snd)\n      (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n     LCons tl tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s stls.\n          s'' = s \\<and>\n          tls =\n          lmap (fst \\<circ> snd)\n           (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n             stls) \\<and>\n          s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n      s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls =\n       LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stls.\n                s'' = s \\<and>\n                tls =\n                lmap (fst \\<circ> snd)\n                 (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   stls) \\<and>\n                s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) =\n           LNil \\<and>\n           s -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' s'' tls tl.\n     s = s \\<and>\n     lmap (fst \\<circ> snd)\n      (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n     LCons tl tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s stls.\n          s'' = s \\<and>\n          tls =\n          lmap (fst \\<circ> snd)\n           (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n             stls) \\<and>\n          s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n      s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s stls.\n             s'' = s \\<and>\n             tls =\n             lmap (fst \\<circ> snd)\n              (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                stls) \\<and>\n             s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        lmap (fst \\<circ> snd)\n         (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n        LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)", ".."], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      lmap (fst \\<circ> snd)\n       (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n      LCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s stls.\n           s'' = s \\<and>\n           tls =\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) \\<and>\n           s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n       s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      lmap (fst \\<circ> snd)\n       (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n      LNil \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      lmap (fst \\<circ> snd)\n       (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n      LCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s stls.\n           s'' = s \\<and>\n           tls =\n           lmap (fst \\<circ> snd)\n            (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              stls) \\<and>\n           s -stls\\<rightarrow>*t \\<infinity>) \\<or>\n       s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      lmap (fst \\<circ> snd)\n       (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls) =\n      LNil \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_step_into_\\<tau>inf_step:\n  assumes \"s -tls\\<rightarrow>* \\<infinity>\"\n  shows \"\\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>", "from inf_step_imp_inf_step_table[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>stls.\n     s -stls\\<rightarrow>*t \\<infinity> \\<and>\n     tls = lmap (fst \\<circ> snd) stls", "obtain stls where \"s -stls\\<rightarrow>*t \\<infinity>\" and tls: \"tls = lmap (fst \\<circ> snd) stls\""], ["proof (prove)\nusing this:\n  \\<exists>stls.\n     s -stls\\<rightarrow>*t \\<infinity> \\<and>\n     tls = lmap (fst \\<circ> snd) stls\n\ngoal (1 subgoal):\n 1. (\\<And>stls.\n        \\<lbrakk>s -stls\\<rightarrow>*t \\<infinity>;\n         tls = lmap (fst \\<circ> snd) stls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s -stls\\<rightarrow>*t \\<infinity>\n  tls = lmap (fst \\<circ> snd) stls\n\ngoal (1 subgoal):\n 1. \\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>", "from \\<open>s -stls\\<rightarrow>*t \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s -stls\\<rightarrow>*t \\<infinity>", "have \"s -\\<tau>-lmap (fst \\<circ> snd) (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') stls)\\<rightarrow>* \\<infinity>\""], ["proof (prove)\nusing this:\n  s -stls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. s -\\<tau>-lmap (fst \\<circ> snd)\n               (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                 stls)\\<rightarrow>* \\<infinity>", "by(rule inf_step_table_into_\\<tau>inf_step)"], ["proof (state)\nthis:\n  s -\\<tau>-lmap (fst \\<circ> snd)\n             (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n               stls)\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>", "hence \"s -\\<tau>-lnths tls {n. enat n < llength stls \\<and> (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') (lnth stls n)}\\<rightarrow>* \\<infinity>\""], ["proof (prove)\nusing this:\n  s -\\<tau>-lmap (fst \\<circ> snd)\n             (lfilter (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n               stls)\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. s -\\<tau>-lnths tls\n               {n. enat n < llength stls \\<and>\n                   (case lnth stls n of\n                    (s, tl, s') \\<Rightarrow>\n                      \\<not> \\<tau>move s tl s')}\\<rightarrow>* \\<infinity>", "unfolding lfilter_conv_lnths tls"], ["proof (prove)\nusing this:\n  s -\\<tau>-lmap (fst \\<circ> snd)\n             (lnths stls\n               {n. enat n < llength stls \\<and>\n                   (case lnth stls n of\n                    (s, tl, s') \\<Rightarrow>\n                      \\<not> \\<tau>move s tl s')})\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. s -\\<tau>-lnths (lmap (fst \\<circ> snd) stls)\n               {n. enat n < llength stls \\<and>\n                   (case lnth stls n of\n                    (s, tl, s') \\<Rightarrow>\n                      \\<not> \\<tau>move s tl s')}\\<rightarrow>* \\<infinity>", "by simp"], ["proof (state)\nthis:\n  s -\\<tau>-lnths tls\n             {n. enat n < llength stls \\<and>\n                 (case lnth stls n of\n                  (s, tl, s') \\<Rightarrow>\n                    \\<not> \\<tau>move s tl s')}\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>", "thus ?thesis"], ["proof (prove)\nusing this:\n  s -\\<tau>-lnths tls\n             {n. enat n < llength stls \\<and>\n                 (case lnth stls n of\n                  (s, tl, s') \\<Rightarrow>\n                    \\<not> \\<tau>move s tl s')}\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>", "by blast"], ["proof (state)\nthis:\n  \\<exists>A. s -\\<tau>-lnths tls A\\<rightarrow>* \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_into_\\<tau>rtrancl3p:\n  \"s -\\<tau>\\<rightarrow>* s' \\<Longrightarrow> s -\\<tau>-[]\\<rightarrow>* s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s' \\<Longrightarrow>\n    s -\\<tau>-[]\\<rightarrow>* s'", "by(induct rule: converse_rtranclp_induct)(blast intro: \\<tau>rtrancl3p.intros)+"], ["", "lemma \\<tau>rtrancl3p_into_silent_moves:\n  \"s -\\<tau>-[]\\<rightarrow>* s' \\<Longrightarrow> s -\\<tau>\\<rightarrow>* s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>-[]\\<rightarrow>* s' \\<Longrightarrow>\n    s -\\<tau>\\<rightarrow>* s'", "apply(induct s tls\\<equiv>\"[] :: 'tl list\" s' rule: \\<tau>rtrancl3p.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. s -\\<tau>\\<rightarrow>* s\n 2. \\<And>s s' s'' tl.\n       \\<lbrakk>s -tl\\<rightarrow> s'; \\<tau>move s tl s';\n        s' -\\<tau>-[]\\<rightarrow>* s'';\n        s' -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* s''", "apply(auto intro: converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>rtrancl3p_Nil_eq_\\<tau>moves:\n  \"s -\\<tau>-[]\\<rightarrow>* s' \\<longleftrightarrow> s -\\<tau>\\<rightarrow>* s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>-[]\\<rightarrow>* s' = s -\\<tau>\\<rightarrow>* s'", "by(blast intro: silent_moves_into_\\<tau>rtrancl3p \\<tau>rtrancl3p_into_silent_moves)"], ["", "lemma \\<tau>rtrancl3p_trans [trans]:\n  \"\\<lbrakk> s -\\<tau>-tls\\<rightarrow>* s'; s' -\\<tau>-tls'\\<rightarrow>* s'' \\<rbrakk> \\<Longrightarrow> s -\\<tau>-tls @ tls'\\<rightarrow>* s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<tau>-tls\\<rightarrow>* s';\n     s' -\\<tau>-tls'\\<rightarrow>* s''\\<rbrakk>\n    \\<Longrightarrow> s -\\<tau>-tls @ tls'\\<rightarrow>* s''", "apply(induct rule: \\<tau>rtrancl3p.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       s -\\<tau>-tls'\\<rightarrow>* s'' \\<Longrightarrow>\n       s -\\<tau>-[] @ tls'\\<rightarrow>* s''\n 2. \\<And>s s' tls s''a tl.\n       \\<lbrakk>s -tl\\<rightarrow> s'; \\<not> \\<tau>move s tl s';\n        s' -\\<tau>-tls\\<rightarrow>* s''a;\n        s''a -\\<tau>-tls'\\<rightarrow>* s'' \\<Longrightarrow>\n        s' -\\<tau>-tls @ tls'\\<rightarrow>* s'';\n        s''a -\\<tau>-tls'\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-(tl # tls) @ tls'\\<rightarrow>* s''\n 3. \\<And>s s' tls s''a tl.\n       \\<lbrakk>s -tl\\<rightarrow> s'; \\<tau>move s tl s';\n        s' -\\<tau>-tls\\<rightarrow>* s''a;\n        s''a -\\<tau>-tls'\\<rightarrow>* s'' \\<Longrightarrow>\n        s' -\\<tau>-tls @ tls'\\<rightarrow>* s'';\n        s''a -\\<tau>-tls'\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-tls @ tls'\\<rightarrow>* s''", "apply(auto intro: \\<tau>rtrancl3p.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>rtrancl3p_SingletonE:\n  fixes tl\n  assumes red: \"s -\\<tau>-[tl]\\<rightarrow>* s'''\"\n  obtains s' s'' where \"s -\\<tau>\\<rightarrow>* s'\" \"s' -tl\\<rightarrow> s''\" \"\\<not> \\<tau>move s' tl s''\" \"s'' -\\<tau>\\<rightarrow>* s'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' s''.\n        \\<lbrakk>s -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s'';\n         \\<not> \\<tau>move s' tl s'';\n         s'' -\\<tau>\\<rightarrow>* s'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s' s''.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>\\<rightarrow>* s'''", "from red"], ["proof (chain)\npicking this:\n  s -\\<tau>-[tl]\\<rightarrow>* s'''", "show \"\\<exists>s' s''. s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>\\<rightarrow>* s'''\""], ["proof (prove)\nusing this:\n  s -\\<tau>-[tl]\\<rightarrow>* s'''\n\ngoal (1 subgoal):\n 1. \\<exists>s' s''.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>\\<rightarrow>* s'''", "proof(induct s tls\\<equiv>\"[tl]\" s''')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' s''.\n       \\<lbrakk>s -tl\\<rightarrow> s'; \\<not> \\<tau>move s tl s';\n        s' -\\<tau>-[]\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''\n 2. \\<And>s s' s'' tla.\n       \\<lbrakk>s -tla\\<rightarrow> s'; \\<tau>move s tla s';\n        s' -\\<tau>-[tl]\\<rightarrow>* s'';\n        \\<exists>s'a s''a.\n           s' -\\<tau>\\<rightarrow>* s'a \\<and>\n           s'a -tl\\<rightarrow> s''a \\<and>\n           \\<not> \\<tau>move s'a tl s''a \\<and>\n           s''a -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''", "case (\\<tau>rtrancl3p_step s s' s'')"], ["proof (state)\nthis:\n  s -tl\\<rightarrow> s'\n  \\<not> \\<tau>move s tl s'\n  s' -\\<tau>-[]\\<rightarrow>* s''\n\ngoal (2 subgoals):\n 1. \\<And>s s' s''.\n       \\<lbrakk>s -tl\\<rightarrow> s'; \\<not> \\<tau>move s tl s';\n        s' -\\<tau>-[]\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''\n 2. \\<And>s s' s'' tla.\n       \\<lbrakk>s -tla\\<rightarrow> s'; \\<tau>move s tla s';\n        s' -\\<tau>-[tl]\\<rightarrow>* s'';\n        \\<exists>s'a s''a.\n           s' -\\<tau>\\<rightarrow>* s'a \\<and>\n           s'a -tl\\<rightarrow> s''a \\<and>\n           \\<not> \\<tau>move s'a tl s''a \\<and>\n           s''a -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''", "from \\<open>s -tl\\<rightarrow> s'\\<close> \\<open>\\<not> \\<tau>move s tl s'\\<close> \\<open>s' -\\<tau>-[]\\<rightarrow>* s''\\<close>"], ["proof (chain)\npicking this:\n  s -tl\\<rightarrow> s'\n  \\<not> \\<tau>move s tl s'\n  s' -\\<tau>-[]\\<rightarrow>* s''", "show ?case"], ["proof (prove)\nusing this:\n  s -tl\\<rightarrow> s'\n  \\<not> \\<tau>move s tl s'\n  s' -\\<tau>-[]\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<exists>s' s''a.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s''a \\<and>\n       \\<not> \\<tau>move s' tl s''a \\<and> s''a -\\<tau>\\<rightarrow>* s''", "by(auto simp add: \\<tau>rtrancl3p_Nil_eq_\\<tau>moves)"], ["proof (state)\nthis:\n  \\<exists>s' s''a.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s''a \\<and>\n     \\<not> \\<tau>move s' tl s''a \\<and> s''a -\\<tau>\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<And>s s' s'' tla.\n       \\<lbrakk>s -tla\\<rightarrow> s'; \\<tau>move s tla s';\n        s' -\\<tau>-[tl]\\<rightarrow>* s'';\n        \\<exists>s'a s''a.\n           s' -\\<tau>\\<rightarrow>* s'a \\<and>\n           s'a -tl\\<rightarrow> s''a \\<and>\n           \\<not> \\<tau>move s'a tl s''a \\<and>\n           s''a -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s' s'' tla.\n       \\<lbrakk>s -tla\\<rightarrow> s'; \\<tau>move s tla s';\n        s' -\\<tau>-[tl]\\<rightarrow>* s'';\n        \\<exists>s'a s''a.\n           s' -\\<tau>\\<rightarrow>* s'a \\<and>\n           s'a -tl\\<rightarrow> s''a \\<and>\n           \\<not> \\<tau>move s'a tl s''a \\<and>\n           s''a -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''", "case (\\<tau>rtrancl3p_\\<tau>step s s' s'' tl')"], ["proof (state)\nthis:\n  s -tl'\\<rightarrow> s'\n  \\<tau>move s tl' s'\n  s' -\\<tau>-[tl]\\<rightarrow>* s''\n  \\<exists>s'a s''a.\n     s' -\\<tau>\\<rightarrow>* s'a \\<and>\n     s'a -tl\\<rightarrow> s''a \\<and>\n     \\<not> \\<tau>move s'a tl s''a \\<and> s''a -\\<tau>\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<And>s s' s'' tla.\n       \\<lbrakk>s -tla\\<rightarrow> s'; \\<tau>move s tla s';\n        s' -\\<tau>-[tl]\\<rightarrow>* s'';\n        \\<exists>s'a s''a.\n           s' -\\<tau>\\<rightarrow>* s'a \\<and>\n           s'a -tl\\<rightarrow> s''a \\<and>\n           \\<not> \\<tau>move s'a tl s''a \\<and>\n           s''a -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''", "then"], ["proof (chain)\npicking this:\n  s -tl'\\<rightarrow> s'\n  \\<tau>move s tl' s'\n  s' -\\<tau>-[tl]\\<rightarrow>* s''\n  \\<exists>s'a s''a.\n     s' -\\<tau>\\<rightarrow>* s'a \\<and>\n     s'a -tl\\<rightarrow> s''a \\<and>\n     \\<not> \\<tau>move s'a tl s''a \\<and> s''a -\\<tau>\\<rightarrow>* s''", "obtain t' t'' where \"s' -\\<tau>\\<rightarrow>* t'\" \"t' -tl\\<rightarrow> t''\" \"\\<not> \\<tau>move t' tl t''\" \"t'' -\\<tau>\\<rightarrow>* s''\""], ["proof (prove)\nusing this:\n  s -tl'\\<rightarrow> s'\n  \\<tau>move s tl' s'\n  s' -\\<tau>-[tl]\\<rightarrow>* s''\n  \\<exists>s'a s''a.\n     s' -\\<tau>\\<rightarrow>* s'a \\<and>\n     s'a -tl\\<rightarrow> s''a \\<and>\n     \\<not> \\<tau>move s'a tl s''a \\<and> s''a -\\<tau>\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. (\\<And>t' t''.\n        \\<lbrakk>s' -\\<tau>\\<rightarrow>* t'; t' -tl\\<rightarrow> t'';\n         \\<not> \\<tau>move t' tl t''; t'' -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' -\\<tau>\\<rightarrow>* t'\n  t' -tl\\<rightarrow> t''\n  \\<not> \\<tau>move t' tl t''\n  t'' -\\<tau>\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<And>s s' s'' tla.\n       \\<lbrakk>s -tla\\<rightarrow> s'; \\<tau>move s tla s';\n        s' -\\<tau>-[tl]\\<rightarrow>* s'';\n        \\<exists>s'a s''a.\n           s' -\\<tau>\\<rightarrow>* s'a \\<and>\n           s'a -tl\\<rightarrow> s''a \\<and>\n           \\<not> \\<tau>move s'a tl s''a \\<and>\n           s''a -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''", "moreover"], ["proof (state)\nthis:\n  s' -\\<tau>\\<rightarrow>* t'\n  t' -tl\\<rightarrow> t''\n  \\<not> \\<tau>move t' tl t''\n  t'' -\\<tau>\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<And>s s' s'' tla.\n       \\<lbrakk>s -tla\\<rightarrow> s'; \\<tau>move s tla s';\n        s' -\\<tau>-[tl]\\<rightarrow>* s'';\n        \\<exists>s'a s''a.\n           s' -\\<tau>\\<rightarrow>* s'a \\<and>\n           s'a -tl\\<rightarrow> s''a \\<and>\n           \\<not> \\<tau>move s'a tl s''a \\<and>\n           s''a -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''", "from \\<open>s -tl'\\<rightarrow> s'\\<close> \\<open>\\<tau>move s tl' s'\\<close>"], ["proof (chain)\npicking this:\n  s -tl'\\<rightarrow> s'\n  \\<tau>move s tl' s'", "have \"s -\\<tau>\\<rightarrow>* s'\""], ["proof (prove)\nusing this:\n  s -tl'\\<rightarrow> s'\n  \\<tau>move s tl' s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s'", "by blast"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<And>s s' s'' tla.\n       \\<lbrakk>s -tla\\<rightarrow> s'; \\<tau>move s tla s';\n        s' -\\<tau>-[tl]\\<rightarrow>* s'';\n        \\<exists>s'a s''a.\n           s' -\\<tau>\\<rightarrow>* s'a \\<and>\n           s'a -tl\\<rightarrow> s''a \\<and>\n           \\<not> \\<tau>move s'a tl s''a \\<and>\n           s''a -\\<tau>\\<rightarrow>* s''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' s''a.\n                            s -\\<tau>\\<rightarrow>* s' \\<and>\n                            s' -tl\\<rightarrow> s''a \\<and>\n                            \\<not> \\<tau>move s' tl s''a \\<and>\n                            s''a -\\<tau>\\<rightarrow>* s''", "ultimately"], ["proof (chain)\npicking this:\n  s' -\\<tau>\\<rightarrow>* t'\n  t' -tl\\<rightarrow> t''\n  \\<not> \\<tau>move t' tl t''\n  t'' -\\<tau>\\<rightarrow>* s''\n  s -\\<tau>\\<rightarrow>* s'", "show ?case"], ["proof (prove)\nusing this:\n  s' -\\<tau>\\<rightarrow>* t'\n  t' -tl\\<rightarrow> t''\n  \\<not> \\<tau>move t' tl t''\n  t'' -\\<tau>\\<rightarrow>* s''\n  s -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<exists>s' s''a.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s''a \\<and>\n       \\<not> \\<tau>move s' tl s''a \\<and> s''a -\\<tau>\\<rightarrow>* s''", "by(auto intro: rtranclp_trans)"], ["proof (state)\nthis:\n  \\<exists>s' s''a.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s''a \\<and>\n     \\<not> \\<tau>move s' tl s''a \\<and> s''a -\\<tau>\\<rightarrow>* s''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s' s''.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>\\<rightarrow>* s'''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>rtrancl3p_snocI:\n  \"\\<And>tl. \\<lbrakk> \\<tau>rtrancl3p s tls s''; s'' -\\<tau>\\<rightarrow>* s'''; s''' -tl\\<rightarrow> s'; \\<not> \\<tau>move s''' tl s' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>rtrancl3p s (tls @ [tl]) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tl.\n       \\<lbrakk>s -\\<tau>-tls\\<rightarrow>* s'';\n        s'' -\\<tau>\\<rightarrow>* s'''; s''' -tl\\<rightarrow> s';\n        \\<not> \\<tau>move s''' tl s'\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-tls @ [tl]\\<rightarrow>* s'", "apply(erule \\<tau>rtrancl3p_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tl.\n       \\<lbrakk>s'' -\\<tau>\\<rightarrow>* s'''; s''' -tl\\<rightarrow> s';\n        \\<not> \\<tau>move s''' tl s'\\<rbrakk>\n       \\<Longrightarrow> s'' -\\<tau>-[tl]\\<rightarrow>* s'", "apply(fold \\<tau>rtrancl3p_Nil_eq_\\<tau>moves)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tl.\n       \\<lbrakk>s'' -\\<tau>-[]\\<rightarrow>* s'''; s''' -tl\\<rightarrow> s';\n        \\<not> \\<tau>move s''' tl s'\\<rbrakk>\n       \\<Longrightarrow> s'' -\\<tau>-[tl]\\<rightarrow>* s'", "apply(drule \\<tau>rtrancl3p_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tl.\n       \\<lbrakk>s''' -tl\\<rightarrow> s';\n        \\<not> \\<tau>move s''' tl s'\\<rbrakk>\n       \\<Longrightarrow> s''' -\\<tau>-?tls'2 tl\\<rightarrow>* ?s''2 tl\n 2. \\<And>tl.\n       \\<lbrakk>s''' -tl\\<rightarrow> s'; \\<not> \\<tau>move s''' tl s';\n        s'' -\\<tau>-[] @ ?tls'2 tl\\<rightarrow>* ?s''2 tl\\<rbrakk>\n       \\<Longrightarrow> s'' -\\<tau>-[tl]\\<rightarrow>* s'", "apply(erule (1) \\<tau>rtrancl3p_step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tl.\n       \\<not> \\<tau>move s''' tl s' \\<Longrightarrow>\n       s' -\\<tau>-?tls5 tl\\<rightarrow>* ?s''2 tl\n 2. \\<And>tl.\n       \\<lbrakk>s''' -tl\\<rightarrow> s'; \\<not> \\<tau>move s''' tl s';\n        s'' -\\<tau>-[] @ tl # ?tls5 tl\\<rightarrow>* ?s''2 tl\\<rbrakk>\n       \\<Longrightarrow> s'' -\\<tau>-[tl]\\<rightarrow>* s'", "apply(rule \\<tau>rtrancl3p_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tl.\n       \\<lbrakk>s''' -tl\\<rightarrow> s'; \\<not> \\<tau>move s''' tl s';\n        s'' -\\<tau>-[] @ [tl]\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> s'' -\\<tau>-[tl]\\<rightarrow>* s'", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>diverge_rtranclp_silent_move:\n  \"\\<lbrakk> silent_move^** s s'; s' -\\<tau>\\<rightarrow> \\<infinity> \\<rbrakk> \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<tau>\\<rightarrow>* s';\n     s' -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>", "by(induct rule: converse_rtranclp_induct)(auto intro: \\<tau>divergeI)"], ["", "lemma \\<tau>diverge_trancl_coinduct [consumes 1, case_names \\<tau>diverge]:\n  assumes X: \"X s\"\n  and step: \"\\<And>s. X s \\<Longrightarrow> \\<exists>s'. silent_move^++ s s' \\<and> (X s' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\"\n  shows \"s -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "from X"], ["proof (chain)\npicking this:\n  X s", "have \"\\<exists>s'. silent_move^** s s' \\<and> X s'\""], ["proof (prove)\nusing this:\n  X s\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> X s'", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> X s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> X s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>s'. x -\\<tau>\\<rightarrow>* s' \\<and> X s' \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>diverge s)"], ["proof (state)\nthis:\n  \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> X s'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>s'. x -\\<tau>\\<rightarrow>* s' \\<and> X s' \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> X s'", "obtain s' where \"silent_move\\<^sup>*\\<^sup>* s s'\" \"X s'\""], ["proof (prove)\nusing this:\n  \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> X s'\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s -\\<tau>\\<rightarrow>* s'; X s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* s'\n  X s'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>s'. x -\\<tau>\\<rightarrow>* s' \\<and> X s' \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "from step[OF \\<open>X s'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s'a.\n     s' -\\<tau>\\<rightarrow>+ s'a \\<and>\n     (X s'a \\<or> s'a -\\<tau>\\<rightarrow> \\<infinity>)", "obtain s'''\n      where \"silent_move^++ s' s'''\" \"X s''' \\<or> s''' -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<exists>s'a.\n     s' -\\<tau>\\<rightarrow>+ s'a \\<and>\n     (X s'a \\<or> s'a -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. (\\<And>s'''.\n        \\<lbrakk>s' -\\<tau>\\<rightarrow>+ s''';\n         X s''' \\<or> s''' -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s' -\\<tau>\\<rightarrow>+ s'''\n  X s''' \\<or> s''' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>s'. x -\\<tau>\\<rightarrow>* s' \\<and> X s' \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "from \\<open>silent_move\\<^sup>*\\<^sup>* s s'\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* s'", "show ?case"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "proof(cases rule: converse_rtranclpE[consumes 1, case_names refl step])"], ["proof (state)\ngoal (2 subgoals):\n 1. s = s' \\<Longrightarrow>\n    \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "case refl"], ["proof (state)\nthis:\n  s = s'\n\ngoal (2 subgoals):\n 1. s = s' \\<Longrightarrow>\n    \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "moreover"], ["proof (state)\nthis:\n  s = s'\n\ngoal (2 subgoals):\n 1. s = s' \\<Longrightarrow>\n    \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "from tranclpD[OF \\<open>silent_move^++ s' s'''\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>z. s' -\\<tau>\\<rightarrow> z \\<and> z -\\<tau>\\<rightarrow>* s'''", "obtain s''\n        where \"silent_move s' s''\" \"silent_move^** s'' s'''\""], ["proof (prove)\nusing this:\n  \\<exists>z. s' -\\<tau>\\<rightarrow> z \\<and> z -\\<tau>\\<rightarrow>* s'''\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>s' -\\<tau>\\<rightarrow> s'';\n         s'' -\\<tau>\\<rightarrow>* s'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s' -\\<tau>\\<rightarrow> s''\n  s'' -\\<tau>\\<rightarrow>* s'''\n\ngoal (2 subgoals):\n 1. s = s' \\<Longrightarrow>\n    \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "ultimately"], ["proof (chain)\npicking this:\n  s = s'\n  s' -\\<tau>\\<rightarrow> s''\n  s'' -\\<tau>\\<rightarrow>* s'''", "show ?thesis"], ["proof (prove)\nusing this:\n  s = s'\n  s' -\\<tau>\\<rightarrow> s''\n  s'' -\\<tau>\\<rightarrow>* s'''\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "using \\<open>silent_move^** s'' s'''\\<close> \\<open>X s''' \\<or> s''' -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  s = s'\n  s' -\\<tau>\\<rightarrow> s''\n  s'' -\\<tau>\\<rightarrow>* s'''\n  s'' -\\<tau>\\<rightarrow>* s'''\n  X s''' \\<or> s''' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "by(auto intro: \\<tau>diverge_rtranclp_silent_move)"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n      s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "case (step S)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> S\n  S -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "moreover"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> S\n  S -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "from \\<open>silent_move\\<^sup>*\\<^sup>* S s'\\<close> \\<open>silent_move^++ s' s'''\\<close>"], ["proof (chain)\npicking this:\n  S -\\<tau>\\<rightarrow>* s'\n  s' -\\<tau>\\<rightarrow>+ s'''", "have \"silent_move^** S s'''\""], ["proof (prove)\nusing this:\n  S -\\<tau>\\<rightarrow>* s'\n  s' -\\<tau>\\<rightarrow>+ s'''\n\ngoal (1 subgoal):\n 1. S -\\<tau>\\<rightarrow>* s'''", "by(rule rtranclp_trans[OF _ tranclp_into_rtranclp])"], ["proof (state)\nthis:\n  S -\\<tau>\\<rightarrow>* s'''\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>s -\\<tau>\\<rightarrow> y;\n        y -\\<tau>\\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s'.\n                            s = s \\<and>\n                            s -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s'a.\n                                 s' -\\<tau>\\<rightarrow>* s'a \\<and>\n                                 X s'a) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "ultimately"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> S\n  S -\\<tau>\\<rightarrow>* s'\n  S -\\<tau>\\<rightarrow>* s'''", "show ?thesis"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> S\n  S -\\<tau>\\<rightarrow>* s'\n  S -\\<tau>\\<rightarrow>* s'''\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "using \\<open>X s''' \\<or> s''' -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> S\n  S -\\<tau>\\<rightarrow>* s'\n  S -\\<tau>\\<rightarrow>* s'''\n  X s''' \\<or> s''' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "by(auto intro: \\<tau>diverge_rtranclp_silent_move)"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n      s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     ((\\<exists>s'a. s' -\\<tau>\\<rightarrow>* s'a \\<and> X s'a) \\<or>\n      s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>diverge_trancl_measure_coinduct [consumes 2, case_names \\<tau>diverge]:\n  assumes major: \"X s t\" \"wfP \\<mu>\"\n  and step: \"\\<And>s t. X s t \\<Longrightarrow> \\<exists>s' t'. (\\<mu> t' t \\<and> s' = s \\<or> silent_move^++ s s') \\<and> (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\"\n  shows \"s -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "assume \"X s t\""], ["proof (state)\nthis:\n  X s t\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "with \\<open>wfP \\<mu>\\<close>"], ["proof (chain)\npicking this:\n  wfP \\<mu>\n  X s t", "have \"\\<exists>s' t'. silent_move^++ s s' \\<and> (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\""], ["proof (prove)\nusing this:\n  wfP \\<mu>\n  X s t\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "proof(induct arbitrary: s rule: wfP_induct[consumes 1])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<forall>y.\n                   \\<mu> y x \\<longrightarrow>\n                   (\\<forall>x.\n                       X x y \\<longrightarrow>\n                       (\\<exists>s' t'.\n                           x -\\<tau>\\<rightarrow>+ s' \\<and>\n                           (X s' t' \\<or>\n                            s' -\\<tau>\\<rightarrow> \\<infinity>)));\n        X s x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' t'.\n                            s -\\<tau>\\<rightarrow>+ s' \\<and>\n                            (X s' t' \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "case (1 t)"], ["proof (state)\nthis:\n  \\<forall>y.\n     \\<mu> y t \\<longrightarrow>\n     (\\<forall>x.\n         X x y \\<longrightarrow>\n         (\\<exists>s' t'.\n             x -\\<tau>\\<rightarrow>+ s' \\<and>\n             (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)))\n  X s t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<forall>y.\n                   \\<mu> y x \\<longrightarrow>\n                   (\\<forall>x.\n                       X x y \\<longrightarrow>\n                       (\\<exists>s' t'.\n                           x -\\<tau>\\<rightarrow>+ s' \\<and>\n                           (X s' t' \\<or>\n                            s' -\\<tau>\\<rightarrow> \\<infinity>)));\n        X s x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' t'.\n                            s -\\<tau>\\<rightarrow>+ s' \\<and>\n                            (X s' t' \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "hence IH: \"\\<And>s' t'. \\<lbrakk> \\<mu> t' t; X s' t' \\<rbrakk> \\<Longrightarrow>\n                 \\<exists>s'' t''. silent_move^++ s' s'' \\<and> (X s'' t'' \\<or> s'' -\\<tau>\\<rightarrow> \\<infinity>)\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     \\<mu> y t \\<longrightarrow>\n     (\\<forall>x.\n         X x y \\<longrightarrow>\n         (\\<exists>s' t'.\n             x -\\<tau>\\<rightarrow>+ s' \\<and>\n             (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)))\n  X s t\n\ngoal (1 subgoal):\n 1. \\<And>s' t'.\n       \\<lbrakk>\\<mu> t' t; X s' t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'' t''.\n                            s' -\\<tau>\\<rightarrow>+ s'' \\<and>\n                            (X s'' t'' \\<or>\n                             s'' -\\<tau>\\<rightarrow> \\<infinity>)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<mu> ?t' t; X ?s' ?t'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'' t''.\n                       ?s' -\\<tau>\\<rightarrow>+ s'' \\<and>\n                       (X s'' t'' \\<or>\n                        s'' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<forall>y.\n                   \\<mu> y x \\<longrightarrow>\n                   (\\<forall>x.\n                       X x y \\<longrightarrow>\n                       (\\<exists>s' t'.\n                           x -\\<tau>\\<rightarrow>+ s' \\<and>\n                           (X s' t' \\<or>\n                            s' -\\<tau>\\<rightarrow> \\<infinity>)));\n        X s x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' t'.\n                            s -\\<tau>\\<rightarrow>+ s' \\<and>\n                            (X s' t' \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "from step[OF \\<open>X s t\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>s' t'.\n     (\\<mu> t' t \\<and> s' = s \\<or> s -\\<tau>\\<rightarrow>+ s') \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "obtain s' t'\n        where \"\\<mu> t' t \\<and> s' = s \\<or> silent_move\\<^sup>+\\<^sup>+ s s'\" \"X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<exists>s' t'.\n     (\\<mu> t' t \\<and> s' = s \\<or> s -\\<tau>\\<rightarrow>+ s') \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. (\\<And>t' s'.\n        \\<lbrakk>\\<mu> t' t \\<and> s' = s \\<or> s -\\<tau>\\<rightarrow>+ s';\n         X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<mu> t' t \\<and> s' = s \\<or> s -\\<tau>\\<rightarrow>+ s'\n  X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<forall>y.\n                   \\<mu> y x \\<longrightarrow>\n                   (\\<forall>x.\n                       X x y \\<longrightarrow>\n                       (\\<exists>s' t'.\n                           x -\\<tau>\\<rightarrow>+ s' \\<and>\n                           (X s' t' \\<or>\n                            s' -\\<tau>\\<rightarrow> \\<infinity>)));\n        X s x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s' t'.\n                            s -\\<tau>\\<rightarrow>+ s' \\<and>\n                            (X s' t' \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "from \\<open>\\<mu> t' t \\<and> s' = s \\<or> silent_move\\<^sup>+\\<^sup>+ s s'\\<close>"], ["proof (chain)\npicking this:\n  \\<mu> t' t \\<and> s' = s \\<or> s -\\<tau>\\<rightarrow>+ s'", "show ?case"], ["proof (prove)\nusing this:\n  \\<mu> t' t \\<and> s' = s \\<or> s -\\<tau>\\<rightarrow>+ s'\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<mu> t' t \\<and> s' = s \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. s -\\<tau>\\<rightarrow>+ s' \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "assume \"\\<mu> t' t \\<and> s' = s\""], ["proof (state)\nthis:\n  \\<mu> t' t \\<and> s' = s\n\ngoal (2 subgoals):\n 1. \\<mu> t' t \\<and> s' = s \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. s -\\<tau>\\<rightarrow>+ s' \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "hence  \"\\<mu> t' t\" and [simp]: \"s' = s\""], ["proof (prove)\nusing this:\n  \\<mu> t' t \\<and> s' = s\n\ngoal (1 subgoal):\n 1. \\<mu> t' t &&& s' = s", "by simp_all"], ["proof (state)\nthis:\n  \\<mu> t' t\n  s' = s\n\ngoal (2 subgoals):\n 1. \\<mu> t' t \\<and> s' = s \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. s -\\<tau>\\<rightarrow>+ s' \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "from \\<open>X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. X s' t' \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. s' -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "assume \"X s' t'\""], ["proof (state)\nthis:\n  X s' t'\n\ngoal (2 subgoals):\n 1. X s' t' \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n 2. s' -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "from IH[OF \\<open>\\<mu> t' t\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>s'' t''.\n     s' -\\<tau>\\<rightarrow>+ s'' \\<and>\n     (X s'' t'' \\<or> s'' -\\<tau>\\<rightarrow> \\<infinity>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s'' t''.\n     s' -\\<tau>\\<rightarrow>+ s'' \\<and>\n     (X s'' t'' \\<or> s'' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "by simp"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. s' -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s' -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "assume \"s' -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (state)\nthis:\n  s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. s' -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "by cases(auto simp add: silent_move_iff)"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>+ s' \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>+ s' \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "assume \"silent_move\\<^sup>+\\<^sup>+ s s'\""], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>+ s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>+ s' \\<Longrightarrow>\n    \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>+ s'\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "using \\<open>X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>+ s'\n  X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "}"], ["proof (state)\nthis:\n  X ?sa2 ?ta2 \\<Longrightarrow>\n  \\<exists>s' t'.\n     ?sa2 -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "note X = this"], ["proof (state)\nthis:\n  X ?sa2 ?ta2 \\<Longrightarrow>\n  \\<exists>s' t'.\n     ?sa2 -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "from \\<open>X s t\\<close>"], ["proof (chain)\npicking this:\n  X s t", "have \"\\<exists>t. X s t\""], ["proof (prove)\nusing this:\n  X s t\n\ngoal (1 subgoal):\n 1. \\<exists>t. X s t", ".."], ["proof (state)\nthis:\n  \\<exists>t. X s t\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>t. X s t\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "proof(coinduct rule: \\<tau>diverge_trancl_coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<exists>t. X s t \\<Longrightarrow>\n       \\<exists>s'.\n          s -\\<tau>\\<rightarrow>+ s' \\<and>\n          ((\\<exists>t. X s' t) \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>diverge s)"], ["proof (state)\nthis:\n  \\<exists>t. X s t\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<exists>t. X s t \\<Longrightarrow>\n       \\<exists>s'.\n          s -\\<tau>\\<rightarrow>+ s' \\<and>\n          ((\\<exists>t. X s' t) \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. X s t", "obtain t where \"X s t\""], ["proof (prove)\nusing this:\n  \\<exists>t. X s t\n\ngoal (1 subgoal):\n 1. (\\<And>t. X s t \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  X s t\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<exists>t. X s t \\<Longrightarrow>\n       \\<exists>s'.\n          s -\\<tau>\\<rightarrow>+ s' \\<and>\n          ((\\<exists>t. X s' t) \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "from X[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>s' t'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>s' t'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     (X s' t' \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>+ s' \\<and>\n       ((\\<exists>t. X s' t) \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>+ s' \\<and>\n     ((\\<exists>t. X s' t) \\<or> s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>inf_step2\\<tau>inf_step_table_LNil [simp]: \"\\<tau>inf_step2\\<tau>inf_step_table s LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>inf_step2\\<tau>inf_step_table s LNil = LNil", "by(simp add: \\<tau>inf_step2\\<tau>inf_step_table_def)"], ["", "lemma \\<tau>inf_step2\\<tau>inf_step_table_LCons [simp]:\n  fixes s tl ss tls\n  defines \"ss \\<equiv> SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\"\n  shows\n  \"\\<tau>inf_step2\\<tau>inf_step_table s (LCons tl tls) =\n   LCons (s, fst ss, tl, snd ss) (\\<tau>inf_step2\\<tau>inf_step_table (snd ss) tls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>inf_step2\\<tau>inf_step_table s (LCons tl tls) =\n    LCons (s, fst ss, tl, snd ss)\n     (\\<tau>inf_step2\\<tau>inf_step_table (snd ss) tls)", "by(simp add: ss_def \\<tau>inf_step2\\<tau>inf_step_table_def split_beta)"], ["", "lemma lnull_\\<tau>inf_step2\\<tau>inf_step_table [simp]:\n  \"lnull (\\<tau>inf_step2\\<tau>inf_step_table s tls) \\<longleftrightarrow> lnull tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (\\<tau>inf_step2\\<tau>inf_step_table s tls) = lnull tls", "by(simp add: \\<tau>inf_step2\\<tau>inf_step_table_def)"], ["", "lemma lhd_\\<tau>inf_step2\\<tau>inf_step_table [simp]:\n  \"\\<not> lnull tls \\<Longrightarrow> lhd (\\<tau>inf_step2\\<tau>inf_step_table s tls) = \n  (let (s', s'') = SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -lhd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (lhd tls) s'' \\<and> s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity>\n  in (s, s', lhd tls, s''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull tls \\<Longrightarrow>\n    lhd (\\<tau>inf_step2\\<tau>inf_step_table s tls) =\n    (let (s', s'') =\n           SOME (s', s'').\n              s -\\<tau>\\<rightarrow>* s' \\<and>\n              s' -lhd tls\\<rightarrow> s'' \\<and>\n              \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n              s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity>\n     in (s, s', lhd tls, s''))", "unfolding \\<tau>inf_step2\\<tau>inf_step_table_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull tls \\<Longrightarrow>\n    lhd (unfold_llist (\\<lambda>(s, y). lnull y)\n          (\\<lambda>(s, tls).\n              case SOME (s', s'').\n                      s -\\<tau>\\<rightarrow>* s' \\<and>\n                      s' -lhd tls\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n                      s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity> of\n              (s', s'') \\<Rightarrow> (s, s', lhd tls, s''))\n          (\\<lambda>(s, tls).\n              case SOME (s', s'').\n                      s -\\<tau>\\<rightarrow>* s' \\<and>\n                      s' -lhd tls\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n                      s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity> of\n              (s', s'') \\<Rightarrow> (s'', ltl tls))\n          (s, tls)) =\n    (case SOME (s', s'').\n             s -\\<tau>\\<rightarrow>* s' \\<and>\n             s' -lhd tls\\<rightarrow> s'' \\<and>\n             \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n             s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity> of\n     (s', s'') \\<Rightarrow> (s, s', lhd tls, s''))", "by simp"], ["", "lemma ltl_\\<tau>inf_step2\\<tau>inf_step_table [simp]:\n  \"\\<not> lnull tls \\<Longrightarrow> ltl (\\<tau>inf_step2\\<tau>inf_step_table s tls) =\n  (let (s', s'') = SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -lhd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (lhd tls) s'' \\<and> s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity>\n  in \\<tau>inf_step2\\<tau>inf_step_table s'' (ltl tls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull tls \\<Longrightarrow>\n    ltl (\\<tau>inf_step2\\<tau>inf_step_table s tls) =\n    (let (s', s'') =\n           SOME (s', s'').\n              s -\\<tau>\\<rightarrow>* s' \\<and>\n              s' -lhd tls\\<rightarrow> s'' \\<and>\n              \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n              s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity>\n     in \\<tau>inf_step2\\<tau>inf_step_table s'' (ltl tls))", "unfolding \\<tau>inf_step2\\<tau>inf_step_table_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull tls \\<Longrightarrow>\n    ltl (unfold_llist (\\<lambda>(s, y). lnull y)\n          (\\<lambda>(s, tls).\n              case SOME (s', s'').\n                      s -\\<tau>\\<rightarrow>* s' \\<and>\n                      s' -lhd tls\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n                      s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity> of\n              (s', s'') \\<Rightarrow> (s, s', lhd tls, s''))\n          (\\<lambda>(s, tls).\n              case SOME (s', s'').\n                      s -\\<tau>\\<rightarrow>* s' \\<and>\n                      s' -lhd tls\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n                      s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity> of\n              (s', s'') \\<Rightarrow> (s'', ltl tls))\n          (s, tls)) =\n    (case SOME (s', s'').\n             s -\\<tau>\\<rightarrow>* s' \\<and>\n             s' -lhd tls\\<rightarrow> s'' \\<and>\n             \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n             s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity> of\n     (s', s'') \\<Rightarrow>\n       unfold_llist (\\<lambda>(s, y). lnull y)\n        (\\<lambda>(s, tls).\n            case SOME (s', s'').\n                    s -\\<tau>\\<rightarrow>* s' \\<and>\n                    s' -lhd tls\\<rightarrow> s'' \\<and>\n                    \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n                    s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity> of\n            (s', s'') \\<Rightarrow> (s, s', lhd tls, s''))\n        (\\<lambda>(s, tls).\n            case SOME (s', s'').\n                    s -\\<tau>\\<rightarrow>* s' \\<and>\n                    s' -lhd tls\\<rightarrow> s'' \\<and>\n                    \\<not> \\<tau>move s' (lhd tls) s'' \\<and>\n                    s'' -\\<tau>-ltl tls\\<rightarrow>* \\<infinity> of\n            (s', s'') \\<Rightarrow> (s'', ltl tls))\n        (s'', ltl tls))", "by(simp add: split_beta)"], ["", "lemma lmap_\\<tau>inf_step2\\<tau>inf_step_table: \"lmap (fst \\<circ> snd \\<circ> snd) (\\<tau>inf_step2\\<tau>inf_step_table s tls) = tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap (fst \\<circ> snd \\<circ> snd)\n     (\\<tau>inf_step2\\<tau>inf_step_table s tls) =\n    tls", "by(coinduction arbitrary: s tls)(auto simp add: split_beta)"], ["", "lemma \\<tau>inf_step_into_\\<tau>inf_step_table:\n  \"s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow> s -\\<tau>-\\<tau>inf_step2\\<tau>inf_step_table s tls\\<rightarrow>*t \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow>\n    s -\\<tau>-\\<tau>inf_step2\\<tau>inf_step_table s\n               tls\\<rightarrow>*t \\<infinity>", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s' s'' tlsa tl.\n           s = sa \\<and>\n           \\<tau>inf_step2\\<tau>inf_step_table s tls =\n           LCons (sa, s', tl, s'') tlsa \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tls.\n                s'' = s \\<and>\n                tlsa = \\<tau>inf_step2\\<tau>inf_step_table s tls \\<and>\n                s -\\<tau>-tls\\<rightarrow>* \\<infinity>) \\<or>\n            s'' -\\<tau>-tlsa\\<rightarrow>*t \\<infinity>)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>inf_step_table s tls)"], ["proof (state)\nthis:\n  s -\\<tau>-tls\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s' s'' tlsa tl.\n           s = sa \\<and>\n           \\<tau>inf_step2\\<tau>inf_step_table s tls =\n           LCons (sa, s', tl, s'') tlsa \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tls.\n                s'' = s \\<and>\n                tlsa = \\<tau>inf_step2\\<tau>inf_step_table s tls \\<and>\n                s -\\<tau>-tls\\<rightarrow>* \\<infinity>) \\<or>\n            s'' -\\<tau>-tlsa\\<rightarrow>*t \\<infinity>)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?case"], ["proof (prove)\nusing this:\n  s -\\<tau>-tls\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        \\<tau>inf_step2\\<tau>inf_step_table s tls =\n        LCons (s, s', tl, s'') tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa.\n             s'' = s \\<and>\n             tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n             s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = LCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>inf_step2\\<tau>inf_step_table s\n                                   tlsa \\<and>\n                                  s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                              s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LNil \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>inf_step_Cons s' s'' tls' tl)"], ["proof (state)\nthis:\n  tls = LCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = LCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>inf_step2\\<tau>inf_step_table s\n                                   tlsa \\<and>\n                                  s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                              s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LNil \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "let ?ss = \"SOME (s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = LCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>inf_step2\\<tau>inf_step_table s\n                                   tlsa \\<and>\n                                  s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                              s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LNil \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "from \\<tau>inf_step_Cons"], ["proof (chain)\npicking this:\n  tls = LCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>", "have tls: \"tls = LCons tl tls'\" and \"s -\\<tau>\\<rightarrow>* s'\" \"s' -tl\\<rightarrow> s''\"\n      \"\\<not> \\<tau>move s' tl s''\" \"s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\""], ["proof (prove)\nusing this:\n  tls = LCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. tls = LCons tl tls' &&&\n    (s -\\<tau>\\<rightarrow>* s' &&& s' -tl\\<rightarrow> s'') &&&\n    \\<not> \\<tau>move s' tl s'' &&&\n    s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>", "by simp_all"], ["proof (state)\nthis:\n  tls = LCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = LCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>inf_step2\\<tau>inf_step_table s\n                                   tlsa \\<and>\n                                  s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                              s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LNil \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "hence \"(\\<lambda>(s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>) (s', s'')\""], ["proof (prove)\nusing this:\n  tls = LCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. case (s', s'') of\n    (s', s'') \\<Rightarrow>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>", "by simp"], ["proof (state)\nthis:\n  case (s', s'') of\n  (s', s'') \\<Rightarrow>\n    s -\\<tau>\\<rightarrow>* s' \\<and>\n    s' -tl\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' tl s'' \\<and>\n    s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = LCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>inf_step2\\<tau>inf_step_table s\n                                   tlsa \\<and>\n                                  s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                              s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LNil \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "hence \"(\\<lambda>(s', s''). s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>) ?ss\""], ["proof (prove)\nusing this:\n  case (s', s'') of\n  (s', s'') \\<Rightarrow>\n    s -\\<tau>\\<rightarrow>* s' \\<and>\n    s' -tl\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' tl s'' \\<and>\n    s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. case SOME (s', s'').\n            s -\\<tau>\\<rightarrow>* s' \\<and>\n            s' -tl\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' tl s'' \\<and>\n            s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity> of\n    (s', s'') \\<Rightarrow>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (s', s'').\n          s -\\<tau>\\<rightarrow>* s' \\<and>\n          s' -tl\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' tl s'' \\<and>\n          s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity> of\n  (s', s'') \\<Rightarrow>\n    s -\\<tau>\\<rightarrow>* s' \\<and>\n    s' -tl\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' tl s'' \\<and>\n    s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = LCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>inf_step2\\<tau>inf_step_table s\n                                   tlsa \\<and>\n                                  s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                              s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LNil \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "with tls"], ["proof (chain)\npicking this:\n  tls = LCons tl tls'\n  case SOME (s', s'').\n          s -\\<tau>\\<rightarrow>* s' \\<and>\n          s' -tl\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' tl s'' \\<and>\n          s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity> of\n  (s', s'') \\<Rightarrow>\n    s -\\<tau>\\<rightarrow>* s' \\<and>\n    s' -tl\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' tl s'' \\<and>\n    s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>", "have ?\\<tau>inf_step_table_Cons"], ["proof (prove)\nusing this:\n  tls = LCons tl tls'\n  case SOME (s', s'').\n          s -\\<tau>\\<rightarrow>* s' \\<and>\n          s' -tl\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' tl s'' \\<and>\n          s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity> of\n  (s', s'') \\<Rightarrow>\n    s -\\<tau>\\<rightarrow>* s' \\<and>\n    s' -tl\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' tl s'' \\<and>\n    s'' -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s = s \\<and>\n       \\<tau>inf_step2\\<tau>inf_step_table s tls =\n       LCons (s, s', tl, s'') tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s tlsa.\n            s'' = s \\<and>\n            tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n            s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n        s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s s' s'' tls tl.\n     s = s \\<and>\n     \\<tau>inf_step2\\<tau>inf_step_table s tls =\n     LCons (s, s', tl, s'') tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s tlsa.\n          s'' = s \\<and>\n          tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n          s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n      s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = LCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LCons (s, s', tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>inf_step2\\<tau>inf_step_table s\n                                   tlsa \\<and>\n                                  s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                              s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                             LNil \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>)\n 2. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' s'' tls tl.\n     s = s \\<and>\n     \\<tau>inf_step2\\<tau>inf_step_table s tls =\n     LCons (s, s', tl, s'') tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s tlsa.\n          s'' = s \\<and>\n          tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n          s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n      s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        \\<tau>inf_step2\\<tau>inf_step_table s tls =\n        LCons (s, s', tl, s'') tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa.\n             s'' = s \\<and>\n             tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n             s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)", ".."], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      \\<tau>inf_step2\\<tau>inf_step_table s tls =\n      LCons (s, s', tl, s'') tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa.\n           s'' = s \\<and>\n           tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n           s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n       s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "case \\<tau>inf_step_Nil"], ["proof (state)\nthis:\n  tls = LNil\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  tls = LNil\n  s -\\<tau>\\<rightarrow> \\<infinity>", "have ?\\<tau>inf_step_table_Nil"], ["proof (prove)\nusing this:\n  tls = LNil\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n       s -\\<tau>\\<rightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  \\<exists>s.\n     s = s \\<and>\n     \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n     s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tls = LNil; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LCons (s, s', tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>inf_step2\\<tau>inf_step_table s\n                                tlsa \\<and>\n                               s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n                           s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>inf_step2\\<tau>inf_step_table s tls =\n                          LNil \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s = s \\<and>\n     \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n     s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        \\<tau>inf_step2\\<tau>inf_step_table s tls =\n        LCons (s, s', tl, s'') tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa.\n             s'' = s \\<and>\n             tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n             s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n         s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)", ".."], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      \\<tau>inf_step2\\<tau>inf_step_table s tls =\n      LCons (s, s', tl, s'') tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa.\n           s'' = s \\<and>\n           tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n           s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n       s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      \\<tau>inf_step2\\<tau>inf_step_table s tls =\n      LCons (s, s', tl, s'') tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa.\n           s'' = s \\<and>\n           tls = \\<tau>inf_step2\\<tau>inf_step_table s tlsa \\<and>\n           s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n       s'' -\\<tau>-tls\\<rightarrow>*t \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      \\<tau>inf_step2\\<tau>inf_step_table s tls = LNil \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>inf_step_imp_\\<tau>inf_step_table:\n  assumes \"s -\\<tau>-tls\\<rightarrow>* \\<infinity>\"\n  shows \"\\<exists>sstls. s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<and> tls = lmap (fst \\<circ> snd \\<circ> snd) sstls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sstls.\n       s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<and>\n       tls = lmap (fst \\<circ> snd \\<circ> snd) sstls", "using \\<tau>inf_step_into_\\<tau>inf_step_table[OF assms]"], ["proof (prove)\nusing this:\n  s -\\<tau>-\\<tau>inf_step2\\<tau>inf_step_table s\n             tls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>sstls.\n       s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<and>\n       tls = lmap (fst \\<circ> snd \\<circ> snd) sstls", "by(auto simp only: lmap_\\<tau>inf_step2\\<tau>inf_step_table)"], ["", "lemma \\<tau>inf_step_table_into_\\<tau>inf_step:\n  \"s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<Longrightarrow> s -\\<tau>-lmap (fst \\<circ> snd \\<circ> snd) sstls\\<rightarrow>* \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n    s -\\<tau>-lmap (fst \\<circ> snd \\<circ> snd)\n               sstls\\<rightarrow>* \\<infinity>", "proof(coinduction arbitrary: s sstls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sstls.\n       s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd \\<circ> snd) sstls = LCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s sstls.\n                s'' = s \\<and>\n                tls = lmap (fst \\<circ> snd \\<circ> snd) sstls \\<and>\n                s -\\<tau>-sstls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd \\<circ> snd) sstls = LNil \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>inf_step s tls)"], ["proof (state)\nthis:\n  s -\\<tau>-tls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s sstls.\n       s -\\<tau>-sstls\\<rightarrow>*t \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd \\<circ> snd) sstls = LCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s sstls.\n                s'' = s \\<and>\n                tls = lmap (fst \\<circ> snd \\<circ> snd) sstls \\<and>\n                s -\\<tau>-sstls\\<rightarrow>*t \\<infinity>) \\<or>\n            s'' -\\<tau>-tls\\<rightarrow>* \\<infinity>)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lmap (fst \\<circ> snd \\<circ> snd) sstls = LNil \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?case"], ["proof (prove)\nusing this:\n  s -\\<tau>-tls\\<rightarrow>*t \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s' s'' tlsa tl.\n        s = s \\<and>\n        lmap (fst \\<circ> snd \\<circ> snd) tls = LCons tl tlsa \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s sstls.\n             s'' = s \\<and>\n             tlsa = lmap (fst \\<circ> snd \\<circ> snd) sstls \\<and>\n             s -\\<tau>-sstls\\<rightarrow>*t \\<infinity>) \\<or>\n         s'' -\\<tau>-tlsa\\<rightarrow>* \\<infinity>)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        lmap (fst \\<circ> snd \\<circ> snd) tls = LNil \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>)", "by cases(auto simp add: o_def)"], ["proof (state)\nthis:\n  (\\<exists>s s' s'' tlsa tl.\n      s = s \\<and>\n      lmap (fst \\<circ> snd \\<circ> snd) tls = LCons tl tlsa \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s sstls.\n           s'' = s \\<and>\n           tlsa = lmap (fst \\<circ> snd \\<circ> snd) sstls \\<and>\n           s -\\<tau>-sstls\\<rightarrow>*t \\<infinity>) \\<or>\n       s'' -\\<tau>-tlsa\\<rightarrow>* \\<infinity>)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      lmap (fst \\<circ> snd \\<circ> snd) tls = LNil \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_move_fromI [intro]:\n  \"\\<lbrakk> silent_moves s0 s1; silent_move s1 s2 \\<rbrakk> \\<Longrightarrow> silent_move_from s0 s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s0 -\\<tau>\\<rightarrow>* s1;\n     s1 -\\<tau>\\<rightarrow> s2\\<rbrakk>\n    \\<Longrightarrow> silent_move_from s0 s1 s2", "by(simp add: silent_move_from_def)"], ["", "lemma silent_move_fromE [elim]:\n  assumes \"silent_move_from s0 s1 s2\"\n  obtains \"silent_moves s0 s1\" \"silent_move s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>s0 -\\<tau>\\<rightarrow>* s1;\n      s1 -\\<tau>\\<rightarrow> s2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  silent_move_from s0 s1 s2\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>s0 -\\<tau>\\<rightarrow>* s1;\n      s1 -\\<tau>\\<rightarrow> s2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: silent_move_from_def)"], ["", "lemma rtranclp_silent_move_from_imp_silent_moves:\n  assumes s'x: \"silent_move\\<^sup>*\\<^sup>* s' x\"\n  shows \"(silent_move_from s')^** x z \\<Longrightarrow> silent_moves s' z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (silent_move_from s')\\<^sup>*\\<^sup>* x z \\<Longrightarrow>\n    s' -\\<tau>\\<rightarrow>* z", "by(induct rule: rtranclp_induct)(auto intro: s'x)"], ["", "lemma \\<tau>diverge_not_wfP_silent_move_from:\n  assumes \"s -\\<tau>\\<rightarrow> \\<infinity>\"\n  shows \"\\<not> wfP (flip (silent_move_from s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> wfP (flip (silent_move_from s))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "assume \"wfP (flip (silent_move_from s))\""], ["proof (state)\nthis:\n  wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "define Q where \"Q = {s'. silent_moves s s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>}\""], ["proof (state)\nthis:\n  Q =\n  {s'.\n   s -\\<tau>\\<rightarrow>* s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>}\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "hence \"s \\<in> Q\""], ["proof (prove)\nusing this:\n  Q =\n  {s'.\n   s -\\<tau>\\<rightarrow>* s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>}\n\ngoal (1 subgoal):\n 1. s \\<in> Q", "using \\<open>s -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  Q =\n  {s'.\n   s -\\<tau>\\<rightarrow>* s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>}\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. s \\<in> Q", "by(auto)"], ["proof (state)\nthis:\n  s \\<in> Q\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  wfP (flip (silent_move_from s))\n  s \\<in> Q", "have \"\\<exists>z\\<in>Q. \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\""], ["proof (prove)\nusing this:\n  wfP (flip (silent_move_from s))\n  s \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "unfolding wfP_eq_minimal flip_simps"], ["proof (prove)\nusing this:\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q)\n  s \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "by blast"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q.\n     \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>Q.\n     \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "obtain z where \"z \\<in> Q\"\n    and min: \"\\<And>y. silent_move_from s z y \\<Longrightarrow> y \\<notin> Q\""], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>Q.\n     \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> Q;\n         \\<And>y.\n            silent_move_from s z y \\<Longrightarrow> y \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z \\<in> Q\n  silent_move_from s z ?y \\<Longrightarrow> ?y \\<notin> Q\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "from \\<open>z \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> Q", "have \"silent_moves s z\" \"z -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  z \\<in> Q\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* z &&& z -\\<tau>\\<rightarrow> \\<infinity>", "unfolding Q_def"], ["proof (prove)\nusing this:\n  z \\<in> {s'.\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -\\<tau>\\<rightarrow> \\<infinity>}\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* z &&& z -\\<tau>\\<rightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* z\n  z -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "from \\<open>z -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  z -\\<tau>\\<rightarrow> \\<infinity>", "obtain y where \"silent_move z y\" \"y -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  z -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>z -\\<tau>\\<rightarrow> y;\n         y -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  z -\\<tau>\\<rightarrow> y\n  y -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "from \\<open>silent_moves s z\\<close> \\<open>silent_move z y\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* z\n  z -\\<tau>\\<rightarrow> y", "have \"silent_move_from s z y\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* z\n  z -\\<tau>\\<rightarrow> y\n\ngoal (1 subgoal):\n 1. silent_move_from s z y", ".."], ["proof (state)\nthis:\n  silent_move_from s z y\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "hence \"y \\<notin> Q\""], ["proof (prove)\nusing this:\n  silent_move_from s z y\n\ngoal (1 subgoal):\n 1. y \\<notin> Q", "by(rule min)"], ["proof (state)\nthis:\n  y \\<notin> Q\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  y \\<notin> Q\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "from \\<open>silent_moves s z\\<close> \\<open>silent_move z y\\<close> \\<open>y -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* z\n  z -\\<tau>\\<rightarrow> y\n  y -\\<tau>\\<rightarrow> \\<infinity>", "have \"y \\<in> Q\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* z\n  z -\\<tau>\\<rightarrow> y\n  y -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. y \\<in> Q", "unfolding Q_def"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* z\n  z -\\<tau>\\<rightarrow> y\n  y -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. y \\<in> {s'.\n             s -\\<tau>\\<rightarrow>* s' \\<and>\n             s' -\\<tau>\\<rightarrow> \\<infinity>}", "by auto"], ["proof (state)\nthis:\n  y \\<in> Q\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  y \\<notin> Q\n  y \\<in> Q", "show False"], ["proof (prove)\nusing this:\n  y \\<notin> Q\n  y \\<in> Q\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfP_silent_move_from_unroll:\n  assumes wfPs': \"\\<And>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow> wfP (flip (silent_move_from s'))\"\n  shows \"wfP (flip (silent_move_from s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s))", "unfolding wfP_eq_minimal flip_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              silent_move_from s z y \\<longrightarrow> y \\<notin> Q)", "proof(intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "fix Q and x :: 's"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "assume \"x \\<in> Q\""], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "show \"\\<exists>z\\<in>Q. \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "proof(cases \"\\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<and> (\\<exists>x'. silent_moves s' x' \\<and> x' \\<in> Q)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\n 2. \\<nexists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "case False"], ["proof (state)\nthis:\n  \\<nexists>s'.\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     (\\<exists>x'. s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q)\n\ngoal (2 subgoals):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\n 2. \\<nexists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "hence \"\\<forall>y. silent_move_from s x y \\<longrightarrow> \\<not> y \\<in> Q\""], ["proof (prove)\nusing this:\n  \\<nexists>s'.\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     (\\<exists>x'. s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q)\n\ngoal (1 subgoal):\n 1. \\<forall>y. silent_move_from s x y \\<longrightarrow> y \\<notin> Q", "by(cases \"x=s\")(auto, blast elim: converse_rtranclpE intro: rtranclp.rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  \\<forall>y. silent_move_from s x y \\<longrightarrow> y \\<notin> Q\n\ngoal (2 subgoals):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\n 2. \\<nexists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "with \\<open>x \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> Q\n  \\<forall>y. silent_move_from s x y \\<longrightarrow> y \\<notin> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Q\n  \\<forall>y. silent_move_from s x y \\<longrightarrow> y \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "by blast"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q.\n     \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "case True"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     (\\<exists>x'. s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     (\\<exists>x'. s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q)", "obtain s' x' where \"s -\\<tau>\\<rightarrow> s'\" and \"silent_moves s' x'\" and \"x' \\<in> Q\""], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     (\\<exists>x'. s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q)\n\ngoal (1 subgoal):\n 1. (\\<And>s' x'.\n        \\<lbrakk>s -\\<tau>\\<rightarrow> s'; s' -\\<tau>\\<rightarrow>* x';\n         x' \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> s'\n  s' -\\<tau>\\<rightarrow>* x'\n  x' \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "from \\<open>s -\\<tau>\\<rightarrow> s'\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> s'", "have \"wfP (flip (silent_move_from s'))\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s'))", "by(rule wfPs')"], ["proof (state)\nthis:\n  wfP (flip (silent_move_from s'))\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "from this \\<open>x' \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  wfP (flip (silent_move_from s'))\n  x' \\<in> Q", "obtain z where \"z \\<in> Q\" and min: \"\\<And>y. silent_move_from s' z y \\<Longrightarrow> \\<not> y \\<in> Q\"\n      and \"(silent_move_from s')^** x' z\""], ["proof (prove)\nusing this:\n  wfP (flip (silent_move_from s'))\n  x' \\<in> Q\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> Q;\n         \\<And>y. silent_move_from s' z y \\<Longrightarrow> y \\<notin> Q;\n         (silent_move_from s')\\<^sup>*\\<^sup>* x' z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule wfP_minimalE) (unfold flip_simps, blast)"], ["proof (state)\nthis:\n  z \\<in> Q\n  silent_move_from s' z ?y \\<Longrightarrow> ?y \\<notin> Q\n  (silent_move_from s')\\<^sup>*\\<^sup>* x' z\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "{"], ["proof (state)\nthis:\n  z \\<in> Q\n  silent_move_from s' z ?y \\<Longrightarrow> ?y \\<notin> Q\n  (silent_move_from s')\\<^sup>*\\<^sup>* x' z\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "assume \"silent_move_from s z y\""], ["proof (state)\nthis:\n  silent_move_from s z y\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "with \\<open>(silent_move_from s')^** x' z\\<close> \\<open>silent_move^** s' x'\\<close>"], ["proof (chain)\npicking this:\n  (silent_move_from s')\\<^sup>*\\<^sup>* x' z\n  s' -\\<tau>\\<rightarrow>* x'\n  silent_move_from s z y", "have \"silent_move_from s' z y\""], ["proof (prove)\nusing this:\n  (silent_move_from s')\\<^sup>*\\<^sup>* x' z\n  s' -\\<tau>\\<rightarrow>* x'\n  silent_move_from s z y\n\ngoal (1 subgoal):\n 1. silent_move_from s' z y", "by(blast intro: rtranclp_silent_move_from_imp_silent_moves)"], ["proof (state)\nthis:\n  silent_move_from s' z y\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "hence \"\\<not> y \\<in> Q\""], ["proof (prove)\nusing this:\n  silent_move_from s' z y\n\ngoal (1 subgoal):\n 1. y \\<notin> Q", "by(rule min)"], ["proof (state)\nthis:\n  y \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "}"], ["proof (state)\nthis:\n  silent_move_from s z ?y2 \\<Longrightarrow> ?y2 \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<exists>x'.\n           s' -\\<tau>\\<rightarrow>* x' \\<and> x' \\<in> Q) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "with \\<open>z \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> Q\n  silent_move_from s z ?y2 \\<Longrightarrow> ?y2 \\<notin> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> Q\n  silent_move_from s z ?y2 \\<Longrightarrow> ?y2 \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q", "by(auto simp add: intro!: bexI)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q.\n     \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q.\n     \\<forall>y. silent_move_from s z y \\<longrightarrow> y \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_wfP_silent_move_from_\\<tau>diverge:\n  assumes \"\\<not> wfP (flip (silent_move_from s))\"\n  shows \"s -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  \\<not> wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> wfP (flip (silent_move_from x)) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          (\\<not> wfP (flip (silent_move_from s')) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>diverge s)"], ["proof (state)\nthis:\n  \\<not> wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> wfP (flip (silent_move_from x)) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          (\\<not> wfP (flip (silent_move_from s')) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "{"], ["proof (state)\nthis:\n  \\<not> wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> wfP (flip (silent_move_from x)) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          (\\<not> wfP (flip (silent_move_from s')) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "assume wfPs': \"\\<And>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow> wfP (flip (silent_move_from s'))\""], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> ?s' \\<Longrightarrow>\n  wfP (flip (silent_move_from ?s'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> wfP (flip (silent_move_from x)) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          (\\<not> wfP (flip (silent_move_from s')) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "hence \"wfP (flip (silent_move_from s))\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> ?s' \\<Longrightarrow>\n  wfP (flip (silent_move_from ?s'))\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s))", "by(rule wfP_silent_move_from_unroll)"], ["proof (state)\nthis:\n  wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> wfP (flip (silent_move_from x)) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          (\\<not> wfP (flip (silent_move_from s')) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "}"], ["proof (state)\nthis:\n  (\\<And>s'.\n      s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n      wfP (flip (silent_move_from s'))) \\<Longrightarrow>\n  wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> wfP (flip (silent_move_from x)) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          (\\<not> wfP (flip (silent_move_from s')) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "with \\<tau>diverge"], ["proof (chain)\npicking this:\n  \\<not> wfP (flip (silent_move_from s))\n  (\\<And>s'.\n      s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n      wfP (flip (silent_move_from s'))) \\<Longrightarrow>\n  wfP (flip (silent_move_from s))", "have \"\\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<and> \\<not> wfP (flip (silent_move_from s'))\""], ["proof (prove)\nusing this:\n  \\<not> wfP (flip (silent_move_from s))\n  (\\<And>s'.\n      s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n      wfP (flip (silent_move_from s'))) \\<Longrightarrow>\n  wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       \\<not> wfP (flip (silent_move_from s'))", "by auto"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     \\<not> wfP (flip (silent_move_from s'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> wfP (flip (silent_move_from x)) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          s -\\<tau>\\<rightarrow> s' \\<and>\n          (\\<not> wfP (flip (silent_move_from s')) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     \\<not> wfP (flip (silent_move_from s'))\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       (\\<not> wfP (flip (silent_move_from s')) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     (\\<not> wfP (flip (silent_move_from s')) \\<or>\n      s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>diverge_neq_wfP_silent_move_from:\n  \"s -\\<tau>\\<rightarrow> \\<infinity> \\<noteq> wfP (flip (silent_move_from s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity> \\<noteq>\n    wfP (flip (silent_move_from s))", "by(auto intro: not_wfP_silent_move_from_\\<tau>diverge dest: \\<tau>diverge_not_wfP_silent_move_from)"], ["", "lemma not_\\<tau>diverge_to_no_\\<tau>move:\n  assumes \"\\<not> s -\\<tau>\\<rightarrow> \\<infinity>\"\n  shows \"\\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "define S where \"S = s\""], ["proof (state)\nthis:\n  S = s\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "from \\<open>\\<not> \\<tau>diverge s\\<close>"], ["proof (chain)\npicking this:\n  \\<not> s -\\<tau>\\<rightarrow> \\<infinity>", "have \"wfP (flip (silent_move_from S))\""], ["proof (prove)\nusing this:\n  \\<not> s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from S))", "unfolding S_def"], ["proof (prove)\nusing this:\n  \\<not> s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s))", "using \\<tau>diverge_neq_wfP_silent_move_from[of s]"], ["proof (prove)\nusing this:\n  \\<not> s -\\<tau>\\<rightarrow> \\<infinity>\n  s -\\<tau>\\<rightarrow> \\<infinity> \\<noteq>\n  wfP (flip (silent_move_from s))\n\ngoal (1 subgoal):\n 1. wfP (flip (silent_move_from s))", "by simp"], ["proof (state)\nthis:\n  wfP (flip (silent_move_from S))\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "moreover"], ["proof (state)\nthis:\n  wfP (flip (silent_move_from S))\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "have \"silent_moves S s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S -\\<tau>\\<rightarrow>* s", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s", ".."], ["proof (state)\nthis:\n  S -\\<tau>\\<rightarrow>* s\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "ultimately"], ["proof (chain)\npicking this:\n  wfP (flip (silent_move_from S))\n  S -\\<tau>\\<rightarrow>* s", "show ?thesis"], ["proof (prove)\nusing this:\n  wfP (flip (silent_move_from S))\n  S -\\<tau>\\<rightarrow>* s\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "proof(induct rule: wfP_induct')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>flip (silent_move_from S) y x;\n                    S -\\<tau>\\<rightarrow>* y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  y -\\<tau>\\<rightarrow>* s' \\<and>\n  (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'');\n        S -\\<tau>\\<rightarrow>* x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            x -\\<tau>\\<rightarrow>* s' \\<and>\n                            (\\<forall>s''.\n                                \\<not> s' -\\<tau>\\<rightarrow> s'')", "case (wfP s)"], ["proof (state)\nthis:\n  \\<lbrakk>flip (silent_move_from S) ?y s;\n   S -\\<tau>\\<rightarrow>* ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       ?y -\\<tau>\\<rightarrow>* s' \\<and>\n                       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n  S -\\<tau>\\<rightarrow>* s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>flip (silent_move_from S) y x;\n                    S -\\<tau>\\<rightarrow>* y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  y -\\<tau>\\<rightarrow>* s' \\<and>\n  (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'');\n        S -\\<tau>\\<rightarrow>* x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            x -\\<tau>\\<rightarrow>* s' \\<and>\n                            (\\<forall>s''.\n                                \\<not> s' -\\<tau>\\<rightarrow> s'')", "note IH = \\<open>\\<And>y. \\<lbrakk>flip (silent_move_from S) y s; S -\\<tau>\\<rightarrow>* y \\<rbrakk>\n             \\<Longrightarrow> \\<exists>s'. y -\\<tau>\\<rightarrow>* s' \\<and> (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>flip (silent_move_from S) ?y s;\n   S -\\<tau>\\<rightarrow>* ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       ?y -\\<tau>\\<rightarrow>* s' \\<and>\n                       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>flip (silent_move_from S) y x;\n                    S -\\<tau>\\<rightarrow>* y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  y -\\<tau>\\<rightarrow>* s' \\<and>\n  (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'');\n        S -\\<tau>\\<rightarrow>* x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            x -\\<tau>\\<rightarrow>* s' \\<and>\n                            (\\<forall>s''.\n                                \\<not> s' -\\<tau>\\<rightarrow> s'')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "proof(cases \"\\<exists>s'. silent_move s s'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n 2. \\<nexists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "case False"], ["proof (state)\nthis:\n  \\<nexists>s'. s -\\<tau>\\<rightarrow> s'\n\ngoal (2 subgoals):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n 2. \\<nexists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>s'. s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "by auto"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "case True"], ["proof (state)\nthis:\n  \\<exists>s'. s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "then"], ["proof (chain)\npicking this:\n  \\<exists>s'. s -\\<tau>\\<rightarrow> s'", "obtain s' where \"s -\\<tau>\\<rightarrow> s'\""], ["proof (prove)\nusing this:\n  \\<exists>s'. s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "with \\<open>S -\\<tau>\\<rightarrow>* s\\<close>"], ["proof (chain)\npicking this:\n  S -\\<tau>\\<rightarrow>* s\n  s -\\<tau>\\<rightarrow> s'", "have \"flip (silent_move_from S) s' s\""], ["proof (prove)\nusing this:\n  S -\\<tau>\\<rightarrow>* s\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. flip (silent_move_from S) s' s", "unfolding flip_conv"], ["proof (prove)\nusing this:\n  S -\\<tau>\\<rightarrow>* s\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. silent_move_from S s s'", "by(rule silent_move_fromI)"], ["proof (state)\nthis:\n  flip (silent_move_from S) s' s\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "moreover"], ["proof (state)\nthis:\n  flip (silent_move_from S) s' s\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "from \\<open>S -\\<tau>\\<rightarrow>* s\\<close> \\<open>s -\\<tau>\\<rightarrow> s'\\<close>"], ["proof (chain)\npicking this:\n  S -\\<tau>\\<rightarrow>* s\n  s -\\<tau>\\<rightarrow> s'", "have \"S -\\<tau>\\<rightarrow>* s'\""], ["proof (prove)\nusing this:\n  S -\\<tau>\\<rightarrow>* s\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. S -\\<tau>\\<rightarrow>* s'", ".."], ["proof (state)\nthis:\n  S -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "ultimately"], ["proof (chain)\npicking this:\n  flip (silent_move_from S) s' s\n  S -\\<tau>\\<rightarrow>* s'", "have \"\\<exists>s''. s' -\\<tau>\\<rightarrow>* s'' \\<and> (\\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s''')\""], ["proof (prove)\nusing this:\n  flip (silent_move_from S) s' s\n  S -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<exists>s''.\n       s' -\\<tau>\\<rightarrow>* s'' \\<and>\n       (\\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s''')", "by(rule IH)"], ["proof (state)\nthis:\n  \\<exists>s''.\n     s' -\\<tau>\\<rightarrow>* s'' \\<and>\n     (\\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s''')\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "then"], ["proof (chain)\npicking this:\n  \\<exists>s''.\n     s' -\\<tau>\\<rightarrow>* s'' \\<and>\n     (\\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s''')", "obtain s'' where \"s' -\\<tau>\\<rightarrow>* s''\" \"\\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s'''\""], ["proof (prove)\nusing this:\n  \\<exists>s''.\n     s' -\\<tau>\\<rightarrow>* s'' \\<and>\n     (\\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s''')\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>s' -\\<tau>\\<rightarrow>* s'';\n         \\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s' -\\<tau>\\<rightarrow>* s''\n  \\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s'''\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "from \\<open>s -\\<tau>\\<rightarrow> s'\\<close> \\<open>s' -\\<tau>\\<rightarrow>* s''\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> s'\n  s' -\\<tau>\\<rightarrow>* s''", "have \"s -\\<tau>\\<rightarrow>* s''\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> s'\n  s' -\\<tau>\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s''", "by(rule converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<exists>s'. s -\\<tau>\\<rightarrow> s' \\<Longrightarrow>\n    \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "with \\<open>\\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s'''\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s'''\n  s -\\<tau>\\<rightarrow>* s''", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s'''. \\<not> s'' -\\<tau>\\<rightarrow> s'''\n  s -\\<tau>\\<rightarrow>* s''\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>diverge_conv_\\<tau>Runs:\n  \"s -\\<tau>\\<rightarrow> \\<infinity> \\<longleftrightarrow> s \\<Down> TNil None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity> = s \\<Down> TNil None", "by(auto intro: \\<tau>Runs.Diverge elim: \\<tau>Runs.cases)"], ["", "lemma \\<tau>inf_step_into_\\<tau>Runs:\n  \"s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow> s \\<Down> tllist_of_llist None tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow>\n    s \\<Down> tllist_of_llist None tls", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s'.\n           s = sa \\<and>\n           tllist_of_llist None tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           tllist_of_llist None tls = TNil None \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>sa s' s'' tlsa tl.\n           s = sa \\<and>\n           tllist_of_llist None tls = TCons tl tlsa \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tls.\n                s'' = s \\<and>\n                tlsa = tllist_of_llist None tls \\<and>\n                s -\\<tau>-tls\\<rightarrow>* \\<infinity>) \\<or>\n            s'' \\<Down> tlsa))", "case (\\<tau>Runs s tls')"], ["proof (state)\nthis:\n  s -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s -\\<tau>-tls\\<rightarrow>* \\<infinity> \\<Longrightarrow>\n       (\\<exists>sa s'.\n           s = sa \\<and>\n           tllist_of_llist None tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           tllist_of_llist None tls = TNil None \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>sa s' s'' tlsa tl.\n           s = sa \\<and>\n           tllist_of_llist None tls = TCons tl tlsa \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tls.\n                s'' = s \\<and>\n                tlsa = tllist_of_llist None tls \\<and>\n                s -\\<tau>-tls\\<rightarrow>* \\<infinity>) \\<or>\n            s'' \\<Down> tlsa))", "thus ?case"], ["proof (prove)\nusing this:\n  s -\\<tau>-tls'\\<rightarrow>* \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        tllist_of_llist None tls' = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tllist_of_llist None tls' = TNil None \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tllist_of_llist None tls' = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa.\n             s'' = s \\<and>\n             tls = tllist_of_llist None tlsa \\<and>\n             s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n         s'' \\<Down> tls))", "by cases(auto simp add: \\<tau>diverge_conv_\\<tau>Runs)"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      tllist_of_llist None tls' = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      tllist_of_llist None tls' = TNil None \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      tllist_of_llist None tls' = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa.\n           s'' = s \\<and>\n           tls = tllist_of_llist None tlsa \\<and>\n           s -\\<tau>-tlsa\\<rightarrow>* \\<infinity>) \\<or>\n       s'' \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>_into_\\<tau>Runs:\n  \"\\<lbrakk> s -\\<tau>\\<rightarrow> s'; s' \\<Down> tls \\<rbrakk> \\<Longrightarrow> s \\<Down> tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<tau>\\<rightarrow> s'; s' \\<Down> tls\\<rbrakk>\n    \\<Longrightarrow> s \\<Down> tls", "by(blast elim: \\<tau>Runs.cases intro: \\<tau>Runs.intros \\<tau>diverge.intros converse_rtranclp_into_rtranclp)"], ["", "lemma \\<tau>rtrancl3p_into_\\<tau>Runs:\n  assumes \"s -\\<tau>-tls\\<rightarrow>* s'\"\n  and \"s' \\<Down> tls'\"\n  shows \"s \\<Down> lappendt (llist_of tls) tls'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<Down> lappendt (llist_of tls) tls'", "using assms"], ["proof (prove)\nusing this:\n  s -\\<tau>-tls\\<rightarrow>* s'\n  s' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. s \\<Down> lappendt (llist_of tls) tls'", "by induct(auto intro: \\<tau>Runs.Proceed \\<tau>_into_\\<tau>Runs)"], ["", "lemma \\<tau>Runs_table_into_\\<tau>Runs:\n  \"\\<tau>Runs_table s stlsss \\<Longrightarrow> s \\<Down> tmap fst id stlsss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Runs_table s stlsss \\<Longrightarrow> s \\<Down> tmap fst id stlsss", "proof(coinduction arbitrary: s stlsss)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s stlsss.\n       \\<tau>Runs_table s stlsss \\<Longrightarrow>\n       (\\<exists>sa s'.\n           s = sa \\<and>\n           tmap fst id stlsss = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           tmap fst id stlsss = TNil None \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           tmap fst id stlsss = TCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stlsss.\n                s'' = s \\<and>\n                tls = tmap fst id stlsss \\<and>\n                \\<tau>Runs_table s stlsss) \\<or>\n            s'' \\<Down> tls))", "case (\\<tau>Runs s tls)"], ["proof (state)\nthis:\n  \\<tau>Runs_table s tls\n\ngoal (1 subgoal):\n 1. \\<And>s stlsss.\n       \\<tau>Runs_table s stlsss \\<Longrightarrow>\n       (\\<exists>sa s'.\n           s = sa \\<and>\n           tmap fst id stlsss = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           tmap fst id stlsss = TNil None \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           tmap fst id stlsss = TCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s stlsss.\n                s'' = s \\<and>\n                tls = tmap fst id stlsss \\<and>\n                \\<tau>Runs_table s stlsss) \\<or>\n            s'' \\<Down> tls))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<tau>Runs_table s tls\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        tmap fst id tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tmap fst id tls = TNil None \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tlsa tl.\n        s = s \\<and>\n        tmap fst id tls = TCons tl tlsa \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s stlsss.\n             s'' = s \\<and>\n             tlsa = tmap fst id stlsss \\<and>\n             \\<tau>Runs_table s stlsss) \\<or>\n         s'' \\<Down> tlsa))", "by cases(auto simp add: o_def id_def)"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      tmap fst id tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      tmap fst id tls = TNil None \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tlsa tl.\n      s = s \\<and>\n      tmap fst id tls = TCons tl tlsa \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s stlsss.\n           s'' = s \\<and>\n           tlsa = tmap fst id stlsss \\<and> \\<tau>Runs_table s stlsss) \\<or>\n       s'' \\<Down> tlsa))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \\<tau>Runs2\\<tau>Runs_table :: \"'s \\<Rightarrow> ('tl, 's option) tllist \\<Rightarrow> ('tl \\<times> 's, 's option) tllist\"\nwhere\n  \"\\<tau>Runs2\\<tau>Runs_table s tls = unfold_tllist\n     (\\<lambda>(s, tls). is_TNil tls)\n     (\\<lambda>(s, tls). terminal tls)\n     (\\<lambda>(s, tls). (thd tls, SOME s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -thd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls))\n     (\\<lambda>(s, tls). (SOME s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -thd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls, ttl tls))\n     (s, tls)\""], ["", "lemma is_TNil_\\<tau>Runs2\\<tau>Runs_table [simp]:\n  \"is_TNil (\\<tau>Runs2\\<tau>Runs_table s tls) \\<longleftrightarrow> is_TNil tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil (\\<tau>Runs2\\<tau>Runs_table s tls) = is_TNil tls", "thm unfold_tllist.disc"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil (\\<tau>Runs2\\<tau>Runs_table s tls) = is_TNil tls", "by(simp add: \\<tau>Runs2\\<tau>Runs_table_def)"], ["", "lemma thd_\\<tau>Runs2\\<tau>Runs_table [simp]:\n  \"\\<not> is_TNil tls \\<Longrightarrow>\n  thd (\\<tau>Runs2\\<tau>Runs_table s tls) =\n  (thd tls, SOME s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -thd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_TNil tls \\<Longrightarrow>\n    thd (\\<tau>Runs2\\<tau>Runs_table s tls) =\n    (thd tls,\n     SOME s''.\n        \\<exists>s'.\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -thd tls\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls)", "by(simp add: \\<tau>Runs2\\<tau>Runs_table_def)"], ["", "lemma ttl_\\<tau>Runs2\\<tau>Runs_table [simp]:\n  \"\\<not> is_TNil tls \\<Longrightarrow>\n  ttl (\\<tau>Runs2\\<tau>Runs_table s tls) =\n  \\<tau>Runs2\\<tau>Runs_table (SOME s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -thd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls) (ttl tls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_TNil tls \\<Longrightarrow>\n    ttl (\\<tau>Runs2\\<tau>Runs_table s tls) =\n    \\<tau>Runs2\\<tau>Runs_table\n     (SOME s''.\n         \\<exists>s'.\n            s -\\<tau>\\<rightarrow>* s' \\<and>\n            s' -thd tls\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls)\n     (ttl tls)", "by(simp add: \\<tau>Runs2\\<tau>Runs_table_def)"], ["", "lemma terminal_\\<tau>Runs2\\<tau>Runs_table [simp]:\n  \"is_TNil tls \\<Longrightarrow> terminal (\\<tau>Runs2\\<tau>Runs_table s tls) = terminal tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_TNil tls \\<Longrightarrow>\n    terminal (\\<tau>Runs2\\<tau>Runs_table s tls) = terminal tls", "by(simp add: \\<tau>Runs2\\<tau>Runs_table_def)"], ["", "lemma \\<tau>Runs2\\<tau>Runs_table_simps [simp, nitpick_simp]:\n  \"\\<tau>Runs2\\<tau>Runs_table s (TNil so) = TNil so\"\n  \"\\<And>tl. \n   \\<tau>Runs2\\<tau>Runs_table s (TCons tl tls) =\n   (let s'' = SOME s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n    in TCons (tl, s'') (\\<tau>Runs2\\<tau>Runs_table s'' tls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Runs2\\<tau>Runs_table s (TNil so) = TNil so &&&\n    (\\<And>tl.\n        \\<tau>Runs2\\<tau>Runs_table s (TCons tl tls) =\n        (let s'' =\n               SOME s''.\n                  \\<exists>s'.\n                     s -\\<tau>\\<rightarrow>* s' \\<and>\n                     s' -tl\\<rightarrow> s'' \\<and>\n                     \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n         in TCons (tl, s'') (\\<tau>Runs2\\<tau>Runs_table s'' tls)))", "apply(simp add: \\<tau>Runs2\\<tau>Runs_table_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tl.\n       \\<tau>Runs2\\<tau>Runs_table s (TCons tl tls) =\n       (let s'' =\n              SOME s''.\n                 \\<exists>s'.\n                    s -\\<tau>\\<rightarrow>* s' \\<and>\n                    s' -tl\\<rightarrow> s'' \\<and>\n                    \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n        in TCons (tl, s'') (\\<tau>Runs2\\<tau>Runs_table s'' tls))", "apply(rule tllist.expand)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>tl.\n       is_TNil (\\<tau>Runs2\\<tau>Runs_table s (TCons tl tls)) =\n       is_TNil\n        (let s'' =\n               SOME s''.\n                  \\<exists>s'.\n                     s -\\<tau>\\<rightarrow>* s' \\<and>\n                     s' -tl\\<rightarrow> s'' \\<and>\n                     \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n         in TCons (tl, s'') (\\<tau>Runs2\\<tau>Runs_table s'' tls))\n 2. \\<And>tl.\n       \\<lbrakk>is_TNil (\\<tau>Runs2\\<tau>Runs_table s (TCons tl tls));\n        is_TNil\n         (let s'' =\n                SOME s''.\n                   \\<exists>s'.\n                      s -\\<tau>\\<rightarrow>* s' \\<and>\n                      s' -tl\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n          in TCons (tl, s'') (\\<tau>Runs2\\<tau>Runs_table s'' tls))\\<rbrakk>\n       \\<Longrightarrow> terminal\n                          (\\<tau>Runs2\\<tau>Runs_table s (TCons tl tls)) =\n                         terminal\n                          (let s'' =\n                                 SOME s''.\n                                    \\<exists>s'.\n s -\\<tau>\\<rightarrow>* s' \\<and>\n s' -tl\\<rightarrow> s'' \\<and>\n \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n                           in TCons (tl, s'')\n                               (\\<tau>Runs2\\<tau>Runs_table s'' tls))\n 3. \\<And>tl.\n       \\<lbrakk>\\<not> is_TNil\n                        (\\<tau>Runs2\\<tau>Runs_table s (TCons tl tls));\n        \\<not> is_TNil\n                (let s'' =\n                       SOME s''.\n                          \\<exists>s'.\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             s'' \\<Down> tls\n                 in TCons (tl, s'')\n                     (\\<tau>Runs2\\<tau>Runs_table s'' tls))\\<rbrakk>\n       \\<Longrightarrow> thd (\\<tau>Runs2\\<tau>Runs_table s\n                               (TCons tl tls)) =\n                         thd (let s'' =\n                                    SOME s''.\n \\<exists>s'.\n    s -\\<tau>\\<rightarrow>* s' \\<and>\n    s' -tl\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n                              in TCons (tl, s'')\n                                  (\\<tau>Runs2\\<tau>Runs_table s''\n                                    tls)) \\<and>\n                         ttl (\\<tau>Runs2\\<tau>Runs_table s\n                               (TCons tl tls)) =\n                         ttl (let s'' =\n                                    SOME s''.\n \\<exists>s'.\n    s -\\<tau>\\<rightarrow>* s' \\<and>\n    s' -tl\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls\n                              in TCons (tl, s'')\n                                  (\\<tau>Runs2\\<tau>Runs_table s'' tls))", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Runs2\\<tau>Runs_table_inverse:\n  \"tmap fst id (\\<tau>Runs2\\<tau>Runs_table s tls) = tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tmap fst id (\\<tau>Runs2\\<tau>Runs_table s tls) = tls", "by(coinduction arbitrary: s tls) auto"], ["", "lemma \\<tau>Runs_into_\\<tau>Runs_table:\n  assumes \"s \\<Down> tls\"\n  shows \"\\<exists>stlsss. tls = tmap fst id stlsss \\<and> \\<tau>Runs_table s stlsss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stlsss.\n       tls = tmap fst id stlsss \\<and> \\<tau>Runs_table s stlsss", "proof(intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. tls = tmap fst id ?stlsss\n 2. \\<tau>Runs_table s ?stlsss", "from assms"], ["proof (chain)\npicking this:\n  s \\<Down> tls", "show \"\\<tau>Runs_table s (\\<tau>Runs2\\<tau>Runs_table s tls)\""], ["proof (prove)\nusing this:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. \\<tau>Runs_table s (\\<tau>Runs2\\<tau>Runs_table s tls)", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s \\<Down> tls \\<Longrightarrow>\n       (\\<exists>sa s'.\n           s = sa \\<and>\n           \\<tau>Runs2\\<tau>Runs_table s tls =\n           TNil \\<lfloor>s'\\<rfloor> \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>sa s' s'' tlsa tl.\n           s = sa \\<and>\n           \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tlsa \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tls.\n                s'' = s \\<and>\n                tlsa = \\<tau>Runs2\\<tau>Runs_table s tls \\<and>\n                s \\<Down> tls) \\<or>\n            \\<tau>Runs_table s'' tlsa))", "case (\\<tau>Runs_table s tls)"], ["proof (state)\nthis:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s \\<Down> tls \\<Longrightarrow>\n       (\\<exists>sa s'.\n           s = sa \\<and>\n           \\<tau>Runs2\\<tau>Runs_table s tls =\n           TNil \\<lfloor>s'\\<rfloor> \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>sa s' s'' tlsa tl.\n           s = sa \\<and>\n           \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tlsa \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tls.\n                s'' = s \\<and>\n                tlsa = \\<tau>Runs2\\<tau>Runs_table s tls \\<and>\n                s \\<Down> tls) \\<or>\n            \\<tau>Runs_table s'' tlsa))", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa.\n             s'' = s \\<and>\n             tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n             s \\<Down> tlsa) \\<or>\n         \\<tau>Runs_table s'' tls))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil None \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                               s \\<Down> tlsa) \\<or>\n                           \\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "case (Terminate s')"], ["proof (state)\nthis:\n  tls = TNil \\<lfloor>s'\\<rfloor>\n  s -\\<tau>\\<rightarrow>* s'\n  \\<not> s' -?tl\\<rightarrow> ?s''\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil None \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                               s \\<Down> tlsa) \\<or>\n                           \\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "hence ?Terminate"], ["proof (prove)\nusing this:\n  tls = TNil \\<lfloor>s'\\<rfloor>\n  s -\\<tau>\\<rightarrow>* s'\n  \\<not> s' -?tl\\<rightarrow> ?s''\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)", "by simp"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil None \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                               s \\<Down> tlsa) \\<or>\n                           \\<tau>Runs_table s'' tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s'.\n     s = s \\<and>\n     \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa.\n             s'' = s \\<and>\n             tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n             s \\<Down> tlsa) \\<or>\n         \\<tau>Runs_table s'' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa.\n           s'' = s \\<and>\n           tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n           s \\<Down> tlsa) \\<or>\n       \\<tau>Runs_table s'' tls))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil None \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                               s \\<Down> tlsa) \\<or>\n                           \\<tau>Runs_table s'' tls))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil None \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                               s \\<Down> tlsa) \\<or>\n                           \\<tau>Runs_table s'' tls))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "case Diverge"], ["proof (state)\nthis:\n  tls = TNil None\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil None \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                               s \\<Down> tlsa) \\<or>\n                           \\<tau>Runs_table s'' tls))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "hence ?Diverge"], ["proof (prove)\nusing this:\n  tls = TNil None\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n       s -\\<tau>\\<rightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  \\<exists>s.\n     s = s \\<and>\n     \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n     s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s s'.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil \\<lfloor>s'\\<rfloor> \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TNil None \\<and>\n                          s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                      (\\<exists>s s' s'' tls tl.\n                          s = s \\<and>\n                          \\<tau>Runs2\\<tau>Runs_table s tls =\n                          TCons (tl, s'') tls \\<and>\n                          s -\\<tau>\\<rightarrow>* s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tlsa.\n                               s'' = s \\<and>\n                               tls =\n                               \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                               s \\<Down> tlsa) \\<or>\n                           \\<tau>Runs_table s'' tls))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s = s \\<and>\n     \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n     s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa.\n             s'' = s \\<and>\n             tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n             s \\<Down> tlsa) \\<or>\n         \\<tau>Runs_table s'' tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa.\n           s'' = s \\<and>\n           tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n           s \\<Down> tlsa) \\<or>\n       \\<tau>Runs_table s'' tls))\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "case (Proceed s' s'' tls' tl)"], ["proof (state)\nthis:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "let ?P = \"\\<lambda>s''. \\<exists>s'. s -\\<tau>\\<rightarrow>* s' \\<and> s' -tl\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "from Proceed"], ["proof (chain)\npicking this:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'", "have \"?P s''\""], ["proof (prove)\nusing this:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "hence \"?P (Eps ?P)\""], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow>\n       (SOME s''.\n           \\<exists>s'.\n              s -\\<tau>\\<rightarrow>* s' \\<and>\n              s' -tl\\<rightarrow> s'' \\<and>\n              \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls') \\<and>\n       \\<not> \\<tau>move s' tl\n               (SOME s''.\n                   \\<exists>s'.\n                      s -\\<tau>\\<rightarrow>* s' \\<and>\n                      s' -tl\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' tl s'' \\<and>\n                      s'' \\<Down> tls') \\<and>\n       (SOME s''.\n           \\<exists>s'.\n              s -\\<tau>\\<rightarrow>* s' \\<and>\n              s' -tl\\<rightarrow> s'' \\<and>\n              \\<not> \\<tau>move s' tl s'' \\<and>\n              s'' \\<Down> tls') \\<Down> tls'", "by(rule someI)"], ["proof (state)\nthis:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow>\n     (SOME s''.\n         \\<exists>s'.\n            s -\\<tau>\\<rightarrow>* s' \\<and>\n            s' -tl\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls') \\<and>\n     \\<not> \\<tau>move s' tl\n             (SOME s''.\n                 \\<exists>s'.\n                    s -\\<tau>\\<rightarrow>* s' \\<and>\n                    s' -tl\\<rightarrow> s'' \\<and>\n                    \\<not> \\<tau>move s' tl s'' \\<and>\n                    s'' \\<Down> tls') \\<and>\n     (SOME s''.\n         \\<exists>s'.\n            s -\\<tau>\\<rightarrow>* s' \\<and>\n            s' -tl\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' tl s'' \\<and>\n            s'' \\<Down> tls') \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "hence ?Proceed"], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow>\n     (SOME s''.\n         \\<exists>s'.\n            s -\\<tau>\\<rightarrow>* s' \\<and>\n            s' -tl\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls') \\<and>\n     \\<not> \\<tau>move s' tl\n             (SOME s''.\n                 \\<exists>s'.\n                    s -\\<tau>\\<rightarrow>* s' \\<and>\n                    s' -tl\\<rightarrow> s'' \\<and>\n                    \\<not> \\<tau>move s' tl s'' \\<and>\n                    s'' \\<Down> tls') \\<and>\n     (SOME s''.\n         \\<exists>s'.\n            s -\\<tau>\\<rightarrow>* s' \\<and>\n            s' -tl\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' tl s'' \\<and>\n            s'' \\<Down> tls') \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s = s \\<and>\n       \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s tlsa.\n            s'' = s \\<and>\n            tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n            s \\<Down> tlsa) \\<or>\n        \\<tau>Runs_table s'' tls)", "using \\<open>tls = TCons tl tls'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow>\n     (SOME s''.\n         \\<exists>s'.\n            s -\\<tau>\\<rightarrow>* s' \\<and>\n            s' -tl\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' tl s'' \\<and> s'' \\<Down> tls') \\<and>\n     \\<not> \\<tau>move s' tl\n             (SOME s''.\n                 \\<exists>s'.\n                    s -\\<tau>\\<rightarrow>* s' \\<and>\n                    s' -tl\\<rightarrow> s'' \\<and>\n                    \\<not> \\<tau>move s' tl s'' \\<and>\n                    s'' \\<Down> tls') \\<and>\n     (SOME s''.\n         \\<exists>s'.\n            s -\\<tau>\\<rightarrow>* s' \\<and>\n            s' -tl\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' tl s'' \\<and>\n            s'' \\<Down> tls') \\<Down> tls'\n  tls = TCons tl tls'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s = s \\<and>\n       \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s tlsa.\n            s'' = s \\<and>\n            tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n            s \\<Down> tlsa) \\<or>\n        \\<tau>Runs_table s'' tls)", "by(auto simp add: split_beta)"], ["proof (state)\nthis:\n  \\<exists>s s' s'' tls tl.\n     s = s \\<and>\n     \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s tlsa.\n          s'' = s \\<and>\n          tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n          s \\<Down> tlsa) \\<or>\n      \\<tau>Runs_table s'' tls)\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s s'.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TNil None \\<and>\n                             s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>s s' s'' tls tl.\n                             s = s \\<and>\n                             \\<tau>Runs2\\<tau>Runs_table s tls =\n                             TCons (tl, s'') tls \\<and>\n                             s -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tlsa.\n                                  s'' = s \\<and>\n                                  tls =\n                                  \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n                                  s \\<Down> tlsa) \\<or>\n                              \\<tau>Runs_table s'' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' s'' tls tl.\n     s = s \\<and>\n     \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s tlsa.\n          s'' = s \\<and>\n          tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n          s \\<Down> tlsa) \\<or>\n      \\<tau>Runs_table s'' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa.\n             s'' = s \\<and>\n             tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n             s \\<Down> tlsa) \\<or>\n         \\<tau>Runs_table s'' tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa.\n           s'' = s \\<and>\n           tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n           s \\<Down> tlsa) \\<or>\n       \\<tau>Runs_table s'' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TNil None \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      \\<tau>Runs2\\<tau>Runs_table s tls = TCons (tl, s'') tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa.\n           s'' = s \\<and>\n           tls = \\<tau>Runs2\\<tau>Runs_table s tlsa \\<and>\n           s \\<Down> tlsa) \\<or>\n       \\<tau>Runs_table s'' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>Runs_table s (\\<tau>Runs2\\<tau>Runs_table s tls)\n\ngoal (1 subgoal):\n 1. tls = tmap fst id (\\<tau>Runs2\\<tau>Runs_table s tls)", "qed(simp add: \\<tau>Runs2\\<tau>Runs_table_inverse)"], ["", "lemma \\<tau>Runs_lappendtE:\n  assumes \"\\<sigma> \\<Down> lappendt tls tls'\"\n  and \"lfinite tls\"\n  obtains \\<sigma>' where \"\\<sigma> -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'\"\n  and \"\\<sigma>' \\<Down> tls'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>\\<sigma> -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>';\n         \\<sigma>' \\<Down> tls'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       \\<sigma> -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>' \\<and>\n       \\<sigma>' \\<Down> tls'", "from \\<open>lfinite tls\\<close> \\<open>\\<sigma> \\<Down> lappendt tls tls'\\<close>"], ["proof (chain)\npicking this:\n  lfinite tls\n  \\<sigma> \\<Down> lappendt tls tls'", "show \"\\<exists>\\<sigma>'. \\<sigma> -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>' \\<and> \\<sigma>' \\<Down> tls'\""], ["proof (prove)\nusing this:\n  lfinite tls\n  \\<sigma> \\<Down> lappendt tls tls'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       \\<sigma> -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>' \\<and>\n       \\<sigma>' \\<Down> tls'", "proof(induct arbitrary: \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<Down> lappendt LNil tls' \\<Longrightarrow>\n       \\<exists>\\<sigma>'.\n          \\<sigma> -\\<tau>-list_of LNil\\<rightarrow>* \\<sigma>' \\<and>\n          \\<sigma>' \\<Down> tls'\n 2. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           \\<sigma> \\<Down> lappendt xs tls' \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -\\<tau>-list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              \\<sigma>' \\<Down> tls';\n        \\<sigma> \\<Down> lappendt (LCons x xs) tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons x xs)\\<rightarrow>* \\<sigma>' \\<and>\n                            \\<sigma>' \\<Down> tls'", "case lfinite_LNil"], ["proof (state)\nthis:\n  \\<sigma> \\<Down> lappendt LNil tls'\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<Down> lappendt LNil tls' \\<Longrightarrow>\n       \\<exists>\\<sigma>'.\n          \\<sigma> -\\<tau>-list_of LNil\\<rightarrow>* \\<sigma>' \\<and>\n          \\<sigma>' \\<Down> tls'\n 2. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           \\<sigma> \\<Down> lappendt xs tls' \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -\\<tau>-list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              \\<sigma>' \\<Down> tls';\n        \\<sigma> \\<Down> lappendt (LCons x xs) tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons x xs)\\<rightarrow>* \\<sigma>' \\<and>\n                            \\<sigma>' \\<Down> tls'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<sigma> \\<Down> lappendt LNil tls'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -\\<tau>-list_of LNil\\<rightarrow>* \\<sigma>'' \\<and>\n       \\<sigma>'' \\<Down> tls'", "by(auto intro: \\<tau>rtrancl3p_refl)"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     \\<sigma> -\\<tau>-list_of LNil\\<rightarrow>* \\<sigma>'' \\<and>\n     \\<sigma>'' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           \\<sigma> \\<Down> lappendt xs tls' \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -\\<tau>-list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              \\<sigma>' \\<Down> tls';\n        \\<sigma> \\<Down> lappendt (LCons x xs) tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons x xs)\\<rightarrow>* \\<sigma>' \\<and>\n                            \\<sigma>' \\<Down> tls'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           \\<sigma> \\<Down> lappendt xs tls' \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -\\<tau>-list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              \\<sigma>' \\<Down> tls';\n        \\<sigma> \\<Down> lappendt (LCons x xs) tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons x xs)\\<rightarrow>* \\<sigma>' \\<and>\n                            \\<sigma>' \\<Down> tls'", "case (lfinite_LConsI tls tl)"], ["proof (state)\nthis:\n  lfinite tls\n  ?\\<sigma> \\<Down> lappendt tls tls' \\<Longrightarrow>\n  \\<exists>\\<sigma>'.\n     ?\\<sigma> -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>' \\<and>\n     \\<sigma>' \\<Down> tls'\n  \\<sigma> \\<Down> lappendt (LCons tl tls) tls'\n\ngoal (1 subgoal):\n 1. \\<And>xs x \\<sigma>.\n       \\<lbrakk>lfinite xs;\n        \\<And>\\<sigma>.\n           \\<sigma> \\<Down> lappendt xs tls' \\<Longrightarrow>\n           \\<exists>\\<sigma>'.\n              \\<sigma> -\\<tau>-list_of xs\\<rightarrow>* \\<sigma>' \\<and>\n              \\<sigma>' \\<Down> tls';\n        \\<sigma> \\<Down> lappendt (LCons x xs) tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons x xs)\\<rightarrow>* \\<sigma>' \\<and>\n                            \\<sigma>' \\<Down> tls'", "from \\<open>\\<sigma> \\<Down> lappendt (LCons tl tls) tls'\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<Down> lappendt (LCons tl tls) tls'", "show ?case"], ["proof (prove)\nusing this:\n  \\<sigma> \\<Down> lappendt (LCons tl tls) tls'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -\\<tau>-list_of\n                         (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n       \\<sigma>'' \\<Down> tls'", "unfolding lappendt_LCons"], ["proof (prove)\nusing this:\n  \\<sigma> \\<Down> TCons tl (lappendt tls tls')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -\\<tau>-list_of\n                         (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n       \\<sigma>'' \\<Down> tls'", "proof(cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' s''.\n       \\<lbrakk>\\<sigma> -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; s'' \\<Down> lappendt tls tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n                            \\<sigma>'' \\<Down> tls'", "case (Proceed \\<sigma>' \\<sigma>'')"], ["proof (state)\nthis:\n  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n  \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\n  \\<sigma>'' \\<Down> lappendt tls tls'\n\ngoal (1 subgoal):\n 1. \\<And>s' s''.\n       \\<lbrakk>\\<sigma> -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; s'' \\<Down> lappendt tls tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n                            \\<sigma>'' \\<Down> tls'", "from \\<open>\\<sigma>'' \\<Down> lappendt tls tls' \\<Longrightarrow> \\<exists>\\<sigma>'''. \\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>''' \\<and> \\<sigma>''' \\<Down> tls'\\<close> \\<open>\\<sigma>'' \\<Down> lappendt tls tls'\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma>'' \\<Down> lappendt tls tls' \\<Longrightarrow>\n  \\<exists>\\<sigma>''''.\n     \\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'''' \\<and>\n     \\<sigma>'''' \\<Down> tls'\n  \\<sigma>'' \\<Down> lappendt tls tls'", "obtain \\<sigma>''' where \"\\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'''\" \"\\<sigma>''' \\<Down> tls'\""], ["proof (prove)\nusing this:\n  \\<sigma>'' \\<Down> lappendt tls tls' \\<Longrightarrow>\n  \\<exists>\\<sigma>''''.\n     \\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'''' \\<and>\n     \\<sigma>'''' \\<Down> tls'\n  \\<sigma>'' \\<Down> lappendt tls tls'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''''.\n        \\<lbrakk>\\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'''';\n         \\<sigma>'''' \\<Down> tls'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'''\n  \\<sigma>''' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<And>s' s''.\n       \\<lbrakk>\\<sigma> -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; s'' \\<Down> lappendt tls tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n                            \\<sigma>'' \\<Down> tls'", "from \\<open>\\<sigma>' -tl\\<rightarrow> \\<sigma>''\\<close> \\<open>\\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\\<close> \\<open>\\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'''\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n  \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\n  \\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'''", "have \"\\<sigma>' -\\<tau>-tl # list_of tls\\<rightarrow>* \\<sigma>'''\""], ["proof (prove)\nusing this:\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n  \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\n  \\<sigma>'' -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<sigma>' -\\<tau>-tl # list_of tls\\<rightarrow>* \\<sigma>'''", "by(rule \\<tau>rtrancl3p_step)"], ["proof (state)\nthis:\n  \\<sigma>' -\\<tau>-tl # list_of tls\\<rightarrow>* \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<And>s' s''.\n       \\<lbrakk>\\<sigma> -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; s'' \\<Down> lappendt tls tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n                            \\<sigma>'' \\<Down> tls'", "with \\<open>\\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\n  \\<sigma>' -\\<tau>-tl # list_of tls\\<rightarrow>* \\<sigma>'''", "have \"\\<sigma> -\\<tau>-[] @ (tl # list_of tls)\\<rightarrow>* \\<sigma>'''\""], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\n  \\<sigma>' -\\<tau>-tl # list_of tls\\<rightarrow>* \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<sigma> -\\<tau>-[] @ tl # list_of tls\\<rightarrow>* \\<sigma>'''", "unfolding \\<tau>rtrancl3p_Nil_eq_\\<tau>moves[symmetric]"], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>-[]\\<rightarrow>* \\<sigma>'\n  \\<sigma>' -\\<tau>-tl # list_of tls\\<rightarrow>* \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<sigma> -\\<tau>-[] @ tl # list_of tls\\<rightarrow>* \\<sigma>'''", "by(rule \\<tau>rtrancl3p_trans)"], ["proof (state)\nthis:\n  \\<sigma> -\\<tau>-[] @ tl # list_of tls\\<rightarrow>* \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<And>s' s''.\n       \\<lbrakk>\\<sigma> -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; s'' \\<Down> lappendt tls tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n                            \\<sigma>'' \\<Down> tls'", "with \\<open>lfinite tls\\<close>"], ["proof (chain)\npicking this:\n  lfinite tls\n  \\<sigma> -\\<tau>-[] @ tl # list_of tls\\<rightarrow>* \\<sigma>'''", "have \"\\<sigma> -\\<tau>-list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'''\""], ["proof (prove)\nusing this:\n  lfinite tls\n  \\<sigma> -\\<tau>-[] @ tl # list_of tls\\<rightarrow>* \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<sigma> -\\<tau>-list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'''", "by(simp add: list_of_LCons)"], ["proof (state)\nthis:\n  \\<sigma> -\\<tau>-list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<And>s' s''.\n       \\<lbrakk>\\<sigma> -\\<tau>\\<rightarrow>* s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; s'' \\<Down> lappendt tls tls'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            \\<sigma> -\\<tau>-list_of\n        (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n                            \\<sigma>'' \\<Down> tls'", "with \\<open>\\<sigma>''' \\<Down> tls'\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma>''' \\<Down> tls'\n  \\<sigma> -\\<tau>-list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'''", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>''' \\<Down> tls'\n  \\<sigma> -\\<tau>-list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'''\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -\\<tau>-list_of\n                         (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n       \\<sigma>'' \\<Down> tls'", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     \\<sigma> -\\<tau>-list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n     \\<sigma>'' \\<Down> tls'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     \\<sigma> -\\<tau>-list_of (LCons tl tls)\\<rightarrow>* \\<sigma>'' \\<and>\n     \\<sigma>'' \\<Down> tls'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>'.\n     \\<sigma> -\\<tau>-list_of tls\\<rightarrow>* \\<sigma>' \\<and>\n     \\<sigma>' \\<Down> tls'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_total:\n  \"\\<exists>tls. \\<sigma> \\<Down> tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tls. \\<sigma> \\<Down> tls", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> \\<Down> ?tls", "let ?\\<tau>halt = \"\\<lambda>\\<sigma> \\<sigma>'. \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and> (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow> \\<sigma>'')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> \\<Down> ?tls", "let ?\\<tau>diverge = \"\\<lambda>\\<sigma>. \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> \\<Down> ?tls", "let ?proceed = \"\\<lambda>\\<sigma> (tl, \\<sigma>''). \\<exists>\\<sigma>'. \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and> \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and> \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> \\<Down> ?tls", "define tls where \"tls = unfold_tllist\n     (\\<lambda>\\<sigma>. (\\<exists>\\<sigma>'. ?\\<tau>halt \\<sigma> \\<sigma>') \\<or> ?\\<tau>diverge \\<sigma>)\n     (\\<lambda>\\<sigma>. if \\<exists>\\<sigma>'. ?\\<tau>halt \\<sigma> \\<sigma>' then Some (SOME \\<sigma>'. ?\\<tau>halt \\<sigma> \\<sigma>') else None)\n     (\\<lambda>\\<sigma>. fst (SOME tl\\<sigma>'. ?proceed \\<sigma> tl\\<sigma>'))\n     (\\<lambda>\\<sigma>. snd (SOME tl\\<sigma>'. ?proceed \\<sigma> tl\\<sigma>')) \\<sigma>\""], ["proof (state)\nthis:\n  tls =\n  unfold_tllist\n   (\\<lambda>\\<sigma>.\n       (\\<exists>\\<sigma>'.\n           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n           (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n               \\<sigma>'')) \\<or>\n       \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n   (\\<lambda>\\<sigma>.\n       if \\<exists>\\<sigma>'.\n             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                 \\<sigma>'')\n       then \\<lfloor>SOME \\<sigma>'.\n                        \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                        (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                            -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n       else None)\n   (\\<lambda>\\<sigma>.\n       fst (SOME tl\\<sigma>'.\n               case tl\\<sigma>' of\n               (tl, \\<sigma>'') \\<Rightarrow>\n                 \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                    \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n   (\\<lambda>\\<sigma>.\n       snd (SOME tl\\<sigma>'.\n               case tl\\<sigma>' of\n               (tl, \\<sigma>'') \\<Rightarrow>\n                 \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                    \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<Down> ?tls", "then"], ["proof (chain)\npicking this:\n  tls =\n  unfold_tllist\n   (\\<lambda>\\<sigma>.\n       (\\<exists>\\<sigma>'.\n           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n           (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n               \\<sigma>'')) \\<or>\n       \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n   (\\<lambda>\\<sigma>.\n       if \\<exists>\\<sigma>'.\n             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                 \\<sigma>'')\n       then \\<lfloor>SOME \\<sigma>'.\n                        \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                        (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                            -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n       else None)\n   (\\<lambda>\\<sigma>.\n       fst (SOME tl\\<sigma>'.\n               case tl\\<sigma>' of\n               (tl, \\<sigma>'') \\<Rightarrow>\n                 \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                    \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n   (\\<lambda>\\<sigma>.\n       snd (SOME tl\\<sigma>'.\n               case tl\\<sigma>' of\n               (tl, \\<sigma>'') \\<Rightarrow>\n                 \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                    \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n   \\<sigma>", "show \"\\<sigma> \\<Down> tls\""], ["proof (prove)\nusing this:\n  tls =\n  unfold_tllist\n   (\\<lambda>\\<sigma>.\n       (\\<exists>\\<sigma>'.\n           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n           (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n               \\<sigma>'')) \\<or>\n       \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n   (\\<lambda>\\<sigma>.\n       if \\<exists>\\<sigma>'.\n             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                 \\<sigma>'')\n       then \\<lfloor>SOME \\<sigma>'.\n                        \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                        (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                            -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n       else None)\n   (\\<lambda>\\<sigma>.\n       fst (SOME tl\\<sigma>'.\n               case tl\\<sigma>' of\n               (tl, \\<sigma>'') \\<Rightarrow>\n                 \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                    \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n   (\\<lambda>\\<sigma>.\n       snd (SOME tl\\<sigma>'.\n               case tl\\<sigma>' of\n               (tl, \\<sigma>'') \\<Rightarrow>\n                 \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                    \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<Down> tls", "proof(coinduct \\<sigma> tls rule: \\<tau>Runs.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x2 =\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        x1 \\<Longrightarrow>\n       (\\<exists>s s'.\n           x1 = s \\<and>\n           x2 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           x1 = s \\<and>\n           x2 = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           x1 = s \\<and>\n           x2 = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           (tls =\n            unfold_tllist\n             (\\<lambda>\\<sigma>.\n                 (\\<exists>\\<sigma>'.\n                     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                     (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                         -tl\\<rightarrow> \\<sigma>'')) \\<or>\n                 \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n             (\\<lambda>\\<sigma>.\n                 if \\<exists>\\<sigma>'.\n                       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                       (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                           -tl\\<rightarrow> \\<sigma>'')\n                 then \\<lfloor>SOME \\<sigma>'.\n                                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n-tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n                 else None)\n             (\\<lambda>\\<sigma>.\n                 fst (SOME tl\\<sigma>'.\n                         case tl\\<sigma>' of\n                         (tl, \\<sigma>'') \\<Rightarrow>\n                           \\<exists>\\<sigma>'.\n                              \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                              \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                              \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n             (\\<lambda>\\<sigma>.\n                 snd (SOME tl\\<sigma>'.\n                         case tl\\<sigma>' of\n                         (tl, \\<sigma>'') \\<Rightarrow>\n                           \\<exists>\\<sigma>'.\n                              \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                              \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                              \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n             s'' \\<or>\n            s'' \\<Down> tls))", "case (\\<tau>Runs \\<sigma> tls)"], ["proof (state)\nthis:\n  tls =\n  unfold_tllist\n   (\\<lambda>\\<sigma>.\n       (\\<exists>\\<sigma>'.\n           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n           (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n               \\<sigma>'')) \\<or>\n       \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n   (\\<lambda>\\<sigma>.\n       if \\<exists>\\<sigma>'.\n             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                 \\<sigma>'')\n       then \\<lfloor>SOME \\<sigma>'.\n                        \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                        (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                            -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n       else None)\n   (\\<lambda>\\<sigma>.\n       fst (SOME tl\\<sigma>'.\n               case tl\\<sigma>' of\n               (tl, \\<sigma>'') \\<Rightarrow>\n                 \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                    \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n   (\\<lambda>\\<sigma>.\n       snd (SOME tl\\<sigma>'.\n               case tl\\<sigma>' of\n               (tl, \\<sigma>'') \\<Rightarrow>\n                 \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                    \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x2 =\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        x1 \\<Longrightarrow>\n       (\\<exists>s s'.\n           x1 = s \\<and>\n           x2 = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           x1 = s \\<and>\n           x2 = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           x1 = s \\<and>\n           x2 = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           (tls =\n            unfold_tllist\n             (\\<lambda>\\<sigma>.\n                 (\\<exists>\\<sigma>'.\n                     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                     (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                         -tl\\<rightarrow> \\<sigma>'')) \\<or>\n                 \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n             (\\<lambda>\\<sigma>.\n                 if \\<exists>\\<sigma>'.\n                       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                       (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                           -tl\\<rightarrow> \\<sigma>'')\n                 then \\<lfloor>SOME \\<sigma>'.\n                                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n-tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n                 else None)\n             (\\<lambda>\\<sigma>.\n                 fst (SOME tl\\<sigma>'.\n                         case tl\\<sigma>' of\n                         (tl, \\<sigma>'') \\<Rightarrow>\n                           \\<exists>\\<sigma>'.\n                              \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                              \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                              \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n             (\\<lambda>\\<sigma>.\n                 snd (SOME tl\\<sigma>'.\n                         case tl\\<sigma>' of\n                         (tl, \\<sigma>'') \\<Rightarrow>\n                           \\<exists>\\<sigma>'.\n                              \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                              \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                              \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n             s'' \\<or>\n            s'' \\<Down> tls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "proof(cases \"\\<exists>\\<sigma>'. ?\\<tau>halt \\<sigma> \\<sigma>'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))\n 2. \\<nexists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "case True"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (2 subgoals):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))\n 2. \\<nexists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "hence \"?\\<tau>halt \\<sigma> (SOME \\<sigma>'. ?\\<tau>halt \\<sigma> \\<sigma>')\""], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<sigma> -\\<tau>\\<rightarrow>* (SOME \\<sigma>''.\n \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n     \\<sigma>''')) \\<and>\n    (\\<forall>tl \\<sigma>''.\n        \\<not> (SOME \\<sigma>''.\n                   \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                   (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>''\n                       -tl\\<rightarrow> \\<sigma>'''))\n        -tl\\<rightarrow> \\<sigma>'')", "by(rule someI_ex)"], ["proof (state)\nthis:\n  \\<sigma> -\\<tau>\\<rightarrow>* (SOME \\<sigma>''.\n                                     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                                     (\\<forall>tl \\<sigma>'''.\n   \\<not> \\<sigma>'' -tl\\<rightarrow> \\<sigma>''')) \\<and>\n  (\\<forall>tl \\<sigma>''.\n      \\<not> (SOME \\<sigma>''.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                 (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>''\n                     -tl\\<rightarrow> \\<sigma>'''))\n      -tl\\<rightarrow> \\<sigma>'')\n\ngoal (2 subgoals):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))\n 2. \\<nexists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "hence ?Terminate"], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>\\<rightarrow>* (SOME \\<sigma>''.\n                                     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                                     (\\<forall>tl \\<sigma>'''.\n   \\<not> \\<sigma>'' -tl\\<rightarrow> \\<sigma>''')) \\<and>\n  (\\<forall>tl \\<sigma>''.\n      \\<not> (SOME \\<sigma>''.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                 (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>''\n                     -tl\\<rightarrow> \\<sigma>'''))\n      -tl\\<rightarrow> \\<sigma>'')\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       \\<sigma> = s \\<and>\n       tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)", "using True"], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>\\<rightarrow>* (SOME \\<sigma>''.\n                                     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                                     (\\<forall>tl \\<sigma>'''.\n   \\<not> \\<sigma>'' -tl\\<rightarrow> \\<sigma>''')) \\<and>\n  (\\<forall>tl \\<sigma>''.\n      \\<not> (SOME \\<sigma>''.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                 (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>''\n                     -tl\\<rightarrow> \\<sigma>'''))\n      -tl\\<rightarrow> \\<sigma>'')\n  \\<exists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       \\<sigma> = s \\<and>\n       tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)", "unfolding \\<tau>Runs"], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>\\<rightarrow>* (SOME \\<sigma>''.\n                                     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                                     (\\<forall>tl \\<sigma>'''.\n   \\<not> \\<sigma>'' -tl\\<rightarrow> \\<sigma>''')) \\<and>\n  (\\<forall>tl \\<sigma>''.\n      \\<not> (SOME \\<sigma>''.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n                 (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>''\n                     -tl\\<rightarrow> \\<sigma>'''))\n      -tl\\<rightarrow> \\<sigma>'')\n  \\<exists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       \\<sigma> = s \\<and>\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME (tl, \\<sigma>'').\n                    \\<exists>\\<sigma>'.\n                       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                       \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                       \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME (tl, \\<sigma>'').\n                    \\<exists>\\<sigma>'.\n                       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                       \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                       \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        \\<sigma> =\n       TNil \\<lfloor>s'\\<rfloor> \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)", "by simp"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     \\<sigma> = s \\<and>\n     tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)\n\ngoal (2 subgoals):\n 1. \\<exists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))\n 2. \\<nexists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s'.\n     \\<sigma> = s \\<and>\n     tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      \\<sigma> = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      \\<sigma> = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      \\<sigma> = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      (tls =\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        s'' \\<or>\n       s'' \\<Down> tls))\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "case False"], ["proof (state)\nthis:\n  \\<nexists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "note \\<tau>halt = this"], ["proof (state)\nthis:\n  \\<nexists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n       (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n           \\<sigma>''') \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "proof(cases \"?\\<tau>diverge \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))\n 2. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "case True"], ["proof (state)\nthis:\n  \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))\n 2. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "hence ?Diverge"], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       \\<sigma> = s \\<and>\n       tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>", "using False"], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>\n  \\<nexists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       \\<sigma> = s \\<and>\n       tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>", "unfolding \\<tau>Runs"], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>\n  \\<nexists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       \\<sigma> = s \\<and>\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME (tl, \\<sigma>'').\n                    \\<exists>\\<sigma>'.\n                       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                       \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                       \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME (tl, \\<sigma>'').\n                    \\<exists>\\<sigma>'.\n                       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                       \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                       \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        \\<sigma> =\n       TNil None \\<and>\n       s -\\<tau>\\<rightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  \\<exists>s.\n     \\<sigma> = s \\<and>\n     tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))\n 2. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     \\<sigma> = s \\<and>\n     tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      \\<sigma> = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      \\<sigma> = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      \\<sigma> = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      (tls =\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        s'' \\<or>\n       s'' \\<Down> tls))\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "case False"], ["proof (state)\nthis:\n  \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "from not_\\<tau>diverge_to_no_\\<tau>move[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>s'.\n     \\<sigma> -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')", "obtain \\<sigma>' where \\<sigma>_\\<sigma>': \"\\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\"\n          and no_\\<tau>: \"\\<And>\\<sigma>''. \\<not> \\<sigma>' -\\<tau>\\<rightarrow> \\<sigma>''\""], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     \\<sigma> -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>s''. \\<not> s' -\\<tau>\\<rightarrow> s'')\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''.\n        \\<lbrakk>\\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'';\n         \\<And>\\<sigma>'''.\n            \\<not> \\<sigma>'' -\\<tau>\\<rightarrow> \\<sigma>'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\n  \\<not> \\<sigma>' -\\<tau>\\<rightarrow> ?\\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "from \\<sigma>_\\<sigma>' \\<tau>halt"], ["proof (chain)\npicking this:\n  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\n  \\<nexists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')", "obtain tl \\<sigma>'' where \"\\<sigma>' -tl\\<rightarrow> \\<sigma>''\""], ["proof (prove)\nusing this:\n  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\n  \\<nexists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. (\\<And>tl \\<sigma>'''.\n        \\<sigma>' -tl\\<rightarrow> \\<sigma>''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "with no_\\<tau>[of \\<sigma>'']"], ["proof (chain)\npicking this:\n  \\<not> \\<sigma>' -\\<tau>\\<rightarrow> \\<sigma>''\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''", "have \"\\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\""], ["proof (prove)\nusing this:\n  \\<not> \\<sigma>' -\\<tau>\\<rightarrow> \\<sigma>''\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n  \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''", "have \"?proceed \\<sigma> (tl, \\<sigma>'')\""], ["proof (prove)\nusing this:\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n  \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\n\ngoal (1 subgoal):\n 1. case (tl, \\<sigma>'') of\n    (tl, \\<sigma>'') \\<Rightarrow>\n      \\<exists>\\<sigma>'''.\n         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n         \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n         \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''", "using \\<sigma>_\\<sigma>'"], ["proof (prove)\nusing this:\n  \\<sigma>' -tl\\<rightarrow> \\<sigma>''\n  \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''\n  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'\n\ngoal (1 subgoal):\n 1. case (tl, \\<sigma>'') of\n    (tl, \\<sigma>'') \\<Rightarrow>\n      \\<exists>\\<sigma>'''.\n         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n         \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n         \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''", "by auto"], ["proof (state)\nthis:\n  case (tl, \\<sigma>'') of\n  (tl, \\<sigma>'') \\<Rightarrow>\n    \\<exists>\\<sigma>'''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n       \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n       \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "hence \"?proceed \\<sigma> (SOME tl\\<sigma>. ?proceed \\<sigma> tl\\<sigma>)\""], ["proof (prove)\nusing this:\n  case (tl, \\<sigma>'') of\n  (tl, \\<sigma>'') \\<Rightarrow>\n    \\<exists>\\<sigma>'''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n       \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n       \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''\n\ngoal (1 subgoal):\n 1. case SOME tl\\<sigma>.\n            case tl\\<sigma> of\n            (tl, \\<sigma>'') \\<Rightarrow>\n              \\<exists>\\<sigma>'''.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n                 \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                 \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>'' of\n    (tl, \\<sigma>'') \\<Rightarrow>\n      \\<exists>\\<sigma>'''.\n         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n         \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n         \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME tl\\<sigma>.\n          case tl\\<sigma> of\n          (tl, \\<sigma>'') \\<Rightarrow>\n            \\<exists>\\<sigma>'''.\n               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n               \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n               \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>'' of\n  (tl, \\<sigma>'') \\<Rightarrow>\n    \\<exists>\\<sigma>'''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n       \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n       \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "hence ?Proceed"], ["proof (prove)\nusing this:\n  case SOME tl\\<sigma>.\n          case tl\\<sigma> of\n          (tl, \\<sigma>'') \\<Rightarrow>\n            \\<exists>\\<sigma>'''.\n               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n               \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n               \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>'' of\n  (tl, \\<sigma>'') \\<Rightarrow>\n    \\<exists>\\<sigma>'''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n       \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n       \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       \\<sigma> = s \\<and>\n       tls = TCons tl tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       (tls =\n        unfold_tllist\n         (\\<lambda>\\<sigma>.\n             (\\<exists>\\<sigma>'.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                 (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                     \\<sigma>'')) \\<or>\n             \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n         (\\<lambda>\\<sigma>.\n             if \\<exists>\\<sigma>'.\n                   \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                   (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                       -tl\\<rightarrow> \\<sigma>'')\n             then \\<lfloor>SOME \\<sigma>'.\n                              \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                              (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                  -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n             else None)\n         (\\<lambda>\\<sigma>.\n             fst (SOME tl\\<sigma>'.\n                     case tl\\<sigma>' of\n                     (tl, \\<sigma>'') \\<Rightarrow>\n                       \\<exists>\\<sigma>'.\n                          \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                          \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                          \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n         (\\<lambda>\\<sigma>.\n             snd (SOME tl\\<sigma>'.\n                     case tl\\<sigma>' of\n                     (tl, \\<sigma>'') \\<Rightarrow>\n                       \\<exists>\\<sigma>'.\n                          \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                          \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                          \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n         s'' \\<or>\n        s'' \\<Down> tls)", "using False \\<tau>halt"], ["proof (prove)\nusing this:\n  case SOME tl\\<sigma>.\n          case tl\\<sigma> of\n          (tl, \\<sigma>'') \\<Rightarrow>\n            \\<exists>\\<sigma>'''.\n               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n               \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n               \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>'' of\n  (tl, \\<sigma>'') \\<Rightarrow>\n    \\<exists>\\<sigma>'''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n       \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n       \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''\n  \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>\n  \\<nexists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       \\<sigma> = s \\<and>\n       tls = TCons tl tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       (tls =\n        unfold_tllist\n         (\\<lambda>\\<sigma>.\n             (\\<exists>\\<sigma>'.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                 (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                     \\<sigma>'')) \\<or>\n             \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n         (\\<lambda>\\<sigma>.\n             if \\<exists>\\<sigma>'.\n                   \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                   (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                       -tl\\<rightarrow> \\<sigma>'')\n             then \\<lfloor>SOME \\<sigma>'.\n                              \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                              (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                  -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n             else None)\n         (\\<lambda>\\<sigma>.\n             fst (SOME tl\\<sigma>'.\n                     case tl\\<sigma>' of\n                     (tl, \\<sigma>'') \\<Rightarrow>\n                       \\<exists>\\<sigma>'.\n                          \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                          \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                          \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n         (\\<lambda>\\<sigma>.\n             snd (SOME tl\\<sigma>'.\n                     case tl\\<sigma>' of\n                     (tl, \\<sigma>'') \\<Rightarrow>\n                       \\<exists>\\<sigma>'.\n                          \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                          \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                          \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n         s'' \\<or>\n        s'' \\<Down> tls)", "unfolding \\<tau>Runs"], ["proof (prove)\nusing this:\n  case SOME tl\\<sigma>.\n          case tl\\<sigma> of\n          (tl, \\<sigma>'') \\<Rightarrow>\n            \\<exists>\\<sigma>'''.\n               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n               \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n               \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>'' of\n  (tl, \\<sigma>'') \\<Rightarrow>\n    \\<exists>\\<sigma>'''.\n       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>''' \\<and>\n       \\<sigma>''' -tl\\<rightarrow> \\<sigma>'' \\<and>\n       \\<not> \\<tau>move \\<sigma>''' tl \\<sigma>''\n  \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>\n  \\<nexists>\\<sigma>''.\n     \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>'' \\<and>\n     (\\<forall>tl \\<sigma>'''. \\<not> \\<sigma>'' -tl\\<rightarrow>\n         \\<sigma>''')\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       \\<sigma> = s \\<and>\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME (tl, \\<sigma>'').\n                    \\<exists>\\<sigma>'.\n                       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                       \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                       \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME (tl, \\<sigma>'').\n                    \\<exists>\\<sigma>'.\n                       \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                       \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                       \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        \\<sigma> =\n       TCons tl tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       (tls =\n        unfold_tllist\n         (\\<lambda>\\<sigma>.\n             (\\<exists>\\<sigma>'.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                 (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                     \\<sigma>'')) \\<or>\n             \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n         (\\<lambda>\\<sigma>.\n             if \\<exists>\\<sigma>'.\n                   \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                   (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                       -tl\\<rightarrow> \\<sigma>'')\n             then \\<lfloor>SOME \\<sigma>'.\n                              \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                              (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                  -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n             else None)\n         (\\<lambda>\\<sigma>.\n             fst (SOME tl\\<sigma>'.\n                     case tl\\<sigma>' of\n                     (tl, \\<sigma>'') \\<Rightarrow>\n                       \\<exists>\\<sigma>'.\n                          \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                          \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                          \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n         (\\<lambda>\\<sigma>.\n             snd (SOME tl\\<sigma>'.\n                     case tl\\<sigma>' of\n                     (tl, \\<sigma>'') \\<Rightarrow>\n                       \\<exists>\\<sigma>'.\n                          \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                          \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                          \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n         s'' \\<or>\n        s'' \\<Down> tls)", "by(subst unfold_tllist.code) fastforce"], ["proof (state)\nthis:\n  \\<exists>s s' s'' tls tl.\n     \\<sigma> = s \\<and>\n     tls = TCons tl tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     (tls =\n      unfold_tllist\n       (\\<lambda>\\<sigma>.\n           (\\<exists>\\<sigma>'.\n               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                   \\<sigma>'')) \\<or>\n           \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n       (\\<lambda>\\<sigma>.\n           if \\<exists>\\<sigma>'.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                 (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                     \\<sigma>'')\n           then \\<lfloor>SOME \\<sigma>'.\n                            \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                            (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n           else None)\n       (\\<lambda>\\<sigma>.\n           fst (SOME tl\\<sigma>'.\n                   case tl\\<sigma>' of\n                   (tl, \\<sigma>'') \\<Rightarrow>\n                     \\<exists>\\<sigma>'.\n                        \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                        \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                        \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n       (\\<lambda>\\<sigma>.\n           snd (SOME tl\\<sigma>'.\n                   case tl\\<sigma>' of\n                   (tl, \\<sigma>'') \\<Rightarrow>\n                     \\<exists>\\<sigma>'.\n                        \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                        \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                        \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n       s'' \\<or>\n      s'' \\<Down> tls)\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> -\\<tau>\\<rightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' s'' tls tl.\n     \\<sigma> = s \\<and>\n     tls = TCons tl tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     (tls =\n      unfold_tllist\n       (\\<lambda>\\<sigma>.\n           (\\<exists>\\<sigma>'.\n               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                   \\<sigma>'')) \\<or>\n           \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n       (\\<lambda>\\<sigma>.\n           if \\<exists>\\<sigma>'.\n                 \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                 (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                     \\<sigma>'')\n           then \\<lfloor>SOME \\<sigma>'.\n                            \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                            (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n           else None)\n       (\\<lambda>\\<sigma>.\n           fst (SOME tl\\<sigma>'.\n                   case tl\\<sigma>' of\n                   (tl, \\<sigma>'') \\<Rightarrow>\n                     \\<exists>\\<sigma>'.\n                        \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                        \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                        \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n       (\\<lambda>\\<sigma>.\n           snd (SOME tl\\<sigma>'.\n                   case tl\\<sigma>' of\n                   (tl, \\<sigma>'') \\<Rightarrow>\n                     \\<exists>\\<sigma>'.\n                        \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                        \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                        \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n       s'' \\<or>\n      s'' \\<Down> tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        \\<sigma> = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        \\<sigma> = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        \\<sigma> = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        (tls =\n         unfold_tllist\n          (\\<lambda>\\<sigma>.\n              (\\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')) \\<or>\n              \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n          (\\<lambda>\\<sigma>.\n              if \\<exists>\\<sigma>'.\n                    \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                    (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                        -tl\\<rightarrow> \\<sigma>'')\n              then \\<lfloor>SOME \\<sigma>'.\n                               \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                               (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                   -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n              else None)\n          (\\<lambda>\\<sigma>.\n              fst (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          (\\<lambda>\\<sigma>.\n              snd (SOME tl\\<sigma>'.\n                      case tl\\<sigma>' of\n                      (tl, \\<sigma>'') \\<Rightarrow>\n                        \\<exists>\\<sigma>'.\n                           \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                           \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                           \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n          s'' \\<or>\n         s'' \\<Down> tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      \\<sigma> = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      \\<sigma> = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      \\<sigma> = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      (tls =\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        s'' \\<or>\n       s'' \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      \\<sigma> = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      \\<sigma> = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      \\<sigma> = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      (tls =\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        s'' \\<or>\n       s'' \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      \\<sigma> = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      \\<sigma> = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      \\<sigma> = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      (tls =\n       unfold_tllist\n        (\\<lambda>\\<sigma>.\n            (\\<exists>\\<sigma>'.\n                \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                    \\<sigma>'')) \\<or>\n            \\<sigma> -\\<tau>\\<rightarrow> \\<infinity>)\n        (\\<lambda>\\<sigma>.\n            if \\<exists>\\<sigma>'.\n                  \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                  (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>' -tl\\<rightarrow>\n                      \\<sigma>'')\n            then \\<lfloor>SOME \\<sigma>'.\n                             \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                             (\\<forall>tl \\<sigma>''. \\<not> \\<sigma>'\n                                 -tl\\<rightarrow> \\<sigma>'')\\<rfloor>\n            else None)\n        (\\<lambda>\\<sigma>.\n            fst (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        (\\<lambda>\\<sigma>.\n            snd (SOME tl\\<sigma>'.\n                    case tl\\<sigma>' of\n                    (tl, \\<sigma>'') \\<Rightarrow>\n                      \\<exists>\\<sigma>'.\n                         \\<sigma> -\\<tau>\\<rightarrow>* \\<sigma>' \\<and>\n                         \\<sigma>' -tl\\<rightarrow> \\<sigma>'' \\<and>\n                         \\<not> \\<tau>move \\<sigma>' tl \\<sigma>''))\n        s'' \\<or>\n       s'' \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma> \\<Down> tls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_move2_into_silent_move:\n  fixes tl\n  assumes \"silent_move2 s tl s'\"\n  shows \"s -\\<tau>\\<rightarrow> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> s'", "using assms"], ["proof (prove)\nusing this:\n  silent_move2 s tl s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> s'", "by(auto simp add: silent_move2_def)"], ["", "lemma silent_move_into_silent_move2:\n  assumes \"s -\\<tau>\\<rightarrow> s'\"\n  shows \"\\<exists>tl. silent_move2 s tl s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tl. silent_move2 s tl s'", "using assms"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<exists>tl. silent_move2 s tl s'", "by(auto simp add: silent_move2_def)"], ["", "lemma silent_moves2_into_silent_moves:\n  assumes \"silent_moves2 s tls s'\"\n  shows \"s -\\<tau>\\<rightarrow>* s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s'", "using assms"], ["proof (prove)\nusing this:\n  silent_moves2 s tls s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s'", "by(induct)(blast intro: silent_move2_into_silent_move rtranclp.rtrancl_into_rtrancl)+"], ["", "lemma silent_moves_into_silent_moves2:\n  assumes \"s -\\<tau>\\<rightarrow>* s'\"\n  shows \"\\<exists>tls. silent_moves2 s tls s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tls. silent_moves2 s tls s'", "using assms"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<exists>tls. silent_moves2 s tls s'", "by(induct)(blast dest: silent_move_into_silent_move2 intro: rtrancl3p_step)+"], ["", "lemma inf_step_silent_move2_into_\\<tau>diverge:\n  \"trsys.inf_step silent_move2 s tls \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trsys.inf_step silent_move2 s tls \\<Longrightarrow>\n    s -\\<tau>\\<rightarrow> \\<infinity>", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       trsys.inf_step silent_move2 s tls \\<Longrightarrow>\n       \\<exists>sa s'.\n          s = sa \\<and>\n          sa -\\<tau>\\<rightarrow> s' \\<and>\n          ((\\<exists>s tls.\n               s' = s \\<and> trsys.inf_step silent_move2 s tls) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>diverge s)"], ["proof (state)\nthis:\n  trsys.inf_step silent_move2 s tls\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       trsys.inf_step silent_move2 s tls \\<Longrightarrow>\n       \\<exists>sa s'.\n          s = sa \\<and>\n          sa -\\<tau>\\<rightarrow> s' \\<and>\n          ((\\<exists>s tls.\n               s' = s \\<and> trsys.inf_step silent_move2 s tls) \\<or>\n           s' -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?case"], ["proof (prove)\nusing this:\n  trsys.inf_step silent_move2 s tls\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s tls.\n            s' = s \\<and> trsys.inf_step silent_move2 s tls) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "by(cases rule: trsys.inf_step.cases[consumes 1])(auto intro: silent_move2_into_silent_move)"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     ((\\<exists>s tls.\n          s' = s \\<and> trsys.inf_step silent_move2 s tls) \\<or>\n      s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>diverge_into_inf_step_silent_move2:\n  assumes \"s -\\<tau>\\<rightarrow> \\<infinity>\"\n  obtains tls where \"trsys.inf_step silent_move2 s tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        trsys.inf_step silent_move2 s tls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        trsys.inf_step silent_move2 s tls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define tls where \"tls = unfold_llist\n     (\\<lambda>_. False)\n     (\\<lambda>s. fst (SOME (tl, s'). silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>))\n     (\\<lambda>s. snd (SOME (tl, s'). silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>))\n     s\" (is \"_ = ?tls s\")"], ["proof (state)\nthis:\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME (tl, s').\n               silent_move2 s tl s' \\<and>\n               s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME (tl, s').\n               silent_move2 s tl s' \\<and>\n               s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s\n\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        trsys.inf_step silent_move2 s tls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME (tl, s').\n               silent_move2 s tl s' \\<and>\n               s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME (tl, s').\n               silent_move2 s tl s' \\<and>\n               s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s", "have \"s -\\<tau>\\<rightarrow> \\<infinity> \\<and> tls = ?tls s\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME (tl, s').\n               silent_move2 s tl s' \\<and>\n               s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME (tl, s').\n               silent_move2 s tl s' \\<and>\n               s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n    tls =\n    unfold_llist (\\<lambda>_. False)\n     (\\<lambda>s.\n         fst (SOME a.\n                 case a of\n                 (tl, s') \\<Rightarrow>\n                   silent_move2 s tl s' \\<and>\n                   s' -\\<tau>\\<rightarrow> \\<infinity>))\n     (\\<lambda>s.\n         snd (SOME a.\n                 case a of\n                 (tl, s') \\<Rightarrow>\n                   silent_move2 s tl s' \\<and>\n                   s' -\\<tau>\\<rightarrow> \\<infinity>))\n     s", "by simp"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s\n\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        trsys.inf_step silent_move2 s tls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence \"trsys.inf_step silent_move2 s tls\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s\n\ngoal (1 subgoal):\n 1. trsys.inf_step silent_move2 s tls", "proof(coinduct rule: trsys.inf_step.coinduct[consumes 1, case_names inf_step, case_conclusion inf_step step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n       x2 =\n       unfold_llist (\\<lambda>_. False)\n        (\\<lambda>s.\n            fst (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        (\\<lambda>s.\n            snd (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        x1 \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          x1 = a \\<and>\n          x2 = LCons b bs \\<and>\n          silent_move2 a b a' \\<and>\n          (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n           bs =\n           unfold_llist (\\<lambda>_. False)\n            (\\<lambda>s.\n                fst (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            (\\<lambda>s.\n                snd (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            a' \\<or>\n           trsys.inf_step silent_move2 a' bs)", "case (inf_step s tls)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n       x2 =\n       unfold_llist (\\<lambda>_. False)\n        (\\<lambda>s.\n            fst (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        (\\<lambda>s.\n            snd (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        x1 \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          x1 = a \\<and>\n          x2 = LCons b bs \\<and>\n          silent_move2 a b a' \\<and>\n          (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n           bs =\n           unfold_llist (\\<lambda>_. False)\n            (\\<lambda>s.\n                fst (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            (\\<lambda>s.\n                snd (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            a' \\<or>\n           trsys.inf_step silent_move2 a' bs)", "let ?P = \"\\<lambda>(tl, s'). silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n       x2 =\n       unfold_llist (\\<lambda>_. False)\n        (\\<lambda>s.\n            fst (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        (\\<lambda>s.\n            snd (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        x1 \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          x1 = a \\<and>\n          x2 = LCons b bs \\<and>\n          silent_move2 a b a' \\<and>\n          (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n           bs =\n           unfold_llist (\\<lambda>_. False)\n            (\\<lambda>s.\n                fst (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            (\\<lambda>s.\n                snd (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            a' \\<or>\n           trsys.inf_step silent_move2 a' bs)", "from inf_step"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s", "obtain \"s -\\<tau>\\<rightarrow> \\<infinity>\" and tls: \"tls = ?tls s\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>s -\\<tau>\\<rightarrow> \\<infinity>;\n      tls =\n      unfold_llist (\\<lambda>_. False)\n       (\\<lambda>s.\n           fst (SOME a.\n                   case a of\n                   (tl, s') \\<Rightarrow>\n                     silent_move2 s tl s' \\<and>\n                     s' -\\<tau>\\<rightarrow> \\<infinity>))\n       (\\<lambda>s.\n           snd (SOME a.\n                   case a of\n                   (tl, s') \\<Rightarrow>\n                     silent_move2 s tl s' \\<and>\n                     s' -\\<tau>\\<rightarrow> \\<infinity>))\n       s\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n       x2 =\n       unfold_llist (\\<lambda>_. False)\n        (\\<lambda>s.\n            fst (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        (\\<lambda>s.\n            snd (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        x1 \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          x1 = a \\<and>\n          x2 = LCons b bs \\<and>\n          silent_move2 a b a' \\<and>\n          (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n           bs =\n           unfold_llist (\\<lambda>_. False)\n            (\\<lambda>s.\n                fst (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            (\\<lambda>s.\n                snd (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            a' \\<or>\n           trsys.inf_step silent_move2 a' bs)", "from \\<open>s -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> \\<infinity>", "obtain s' where \"s -\\<tau>\\<rightarrow> s'\" \"s' -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s -\\<tau>\\<rightarrow> s';\n         s' -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> s'\n  s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n       x2 =\n       unfold_llist (\\<lambda>_. False)\n        (\\<lambda>s.\n            fst (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        (\\<lambda>s.\n            snd (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        x1 \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          x1 = a \\<and>\n          x2 = LCons b bs \\<and>\n          silent_move2 a b a' \\<and>\n          (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n           bs =\n           unfold_llist (\\<lambda>_. False)\n            (\\<lambda>s.\n                fst (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            (\\<lambda>s.\n                snd (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            a' \\<or>\n           trsys.inf_step silent_move2 a' bs)", "from \\<open>s -\\<tau>\\<rightarrow> s'\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> s'", "obtain tl where \"silent_move2 s tl s'\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. (\\<And>tl.\n        silent_move2 s tl s' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: silent_move_into_silent_move2)"], ["proof (state)\nthis:\n  silent_move2 s tl s'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n       x2 =\n       unfold_llist (\\<lambda>_. False)\n        (\\<lambda>s.\n            fst (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        (\\<lambda>s.\n            snd (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        x1 \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          x1 = a \\<and>\n          x2 = LCons b bs \\<and>\n          silent_move2 a b a' \\<and>\n          (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n           bs =\n           unfold_llist (\\<lambda>_. False)\n            (\\<lambda>s.\n                fst (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            (\\<lambda>s.\n                snd (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            a' \\<or>\n           trsys.inf_step silent_move2 a' bs)", "with \\<open>s' -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s' -\\<tau>\\<rightarrow> \\<infinity>\n  silent_move2 s tl s'", "have \"?P (tl, s')\""], ["proof (prove)\nusing this:\n  s' -\\<tau>\\<rightarrow> \\<infinity>\n  silent_move2 s tl s'\n\ngoal (1 subgoal):\n 1. case (tl, s') of\n    (tl, s') \\<Rightarrow>\n      silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  case (tl, s') of\n  (tl, s') \\<Rightarrow>\n    silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n       x2 =\n       unfold_llist (\\<lambda>_. False)\n        (\\<lambda>s.\n            fst (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        (\\<lambda>s.\n            snd (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        x1 \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          x1 = a \\<and>\n          x2 = LCons b bs \\<and>\n          silent_move2 a b a' \\<and>\n          (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n           bs =\n           unfold_llist (\\<lambda>_. False)\n            (\\<lambda>s.\n                fst (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            (\\<lambda>s.\n                snd (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            a' \\<or>\n           trsys.inf_step silent_move2 a' bs)", "hence \"?P (Eps ?P)\""], ["proof (prove)\nusing this:\n  case (tl, s') of\n  (tl, s') \\<Rightarrow>\n    silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. case SOME (tl, s').\n            silent_move2 s tl s' \\<and>\n            s' -\\<tau>\\<rightarrow> \\<infinity> of\n    (tl, s') \\<Rightarrow>\n      silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (tl, s').\n          silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity> of\n  (tl, s') \\<Rightarrow>\n    silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n       x2 =\n       unfold_llist (\\<lambda>_. False)\n        (\\<lambda>s.\n            fst (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        (\\<lambda>s.\n            snd (SOME a.\n                    case a of\n                    (tl, s') \\<Rightarrow>\n                      silent_move2 s tl s' \\<and>\n                      s' -\\<tau>\\<rightarrow> \\<infinity>))\n        x1 \\<Longrightarrow>\n       \\<exists>a b a' bs.\n          x1 = a \\<and>\n          x2 = LCons b bs \\<and>\n          silent_move2 a b a' \\<and>\n          (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n           bs =\n           unfold_llist (\\<lambda>_. False)\n            (\\<lambda>s.\n                fst (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            (\\<lambda>s.\n                snd (SOME a.\n                        case a of\n                        (tl, s') \\<Rightarrow>\n                          silent_move2 s tl s' \\<and>\n                          s' -\\<tau>\\<rightarrow> \\<infinity>))\n            a' \\<or>\n           trsys.inf_step silent_move2 a' bs)", "thus ?case"], ["proof (prove)\nusing this:\n  case SOME (tl, s').\n          silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity> of\n  (tl, s') \\<Rightarrow>\n    silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>a b a' bs.\n       s = a \\<and>\n       tls = LCons b bs \\<and>\n       silent_move2 a b a' \\<and>\n       (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n        bs =\n        unfold_llist (\\<lambda>_. False)\n         (\\<lambda>s.\n             fst (SOME a.\n                     case a of\n                     (tl, s') \\<Rightarrow>\n                       silent_move2 s tl s' \\<and>\n                       s' -\\<tau>\\<rightarrow> \\<infinity>))\n         (\\<lambda>s.\n             snd (SOME a.\n                     case a of\n                     (tl, s') \\<Rightarrow>\n                       silent_move2 s tl s' \\<and>\n                       s' -\\<tau>\\<rightarrow> \\<infinity>))\n         a' \\<or>\n        trsys.inf_step silent_move2 a' bs)", "using tls"], ["proof (prove)\nusing this:\n  case SOME (tl, s').\n          silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity> of\n  (tl, s') \\<Rightarrow>\n    silent_move2 s tl s' \\<and> s' -\\<tau>\\<rightarrow> \\<infinity>\n  tls =\n  unfold_llist (\\<lambda>_. False)\n   (\\<lambda>s.\n       fst (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   (\\<lambda>s.\n       snd (SOME a.\n               case a of\n               (tl, s') \\<Rightarrow>\n                 silent_move2 s tl s' \\<and>\n                 s' -\\<tau>\\<rightarrow> \\<infinity>))\n   s\n\ngoal (1 subgoal):\n 1. \\<exists>a b a' bs.\n       s = a \\<and>\n       tls = LCons b bs \\<and>\n       silent_move2 a b a' \\<and>\n       (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n        bs =\n        unfold_llist (\\<lambda>_. False)\n         (\\<lambda>s.\n             fst (SOME a.\n                     case a of\n                     (tl, s') \\<Rightarrow>\n                       silent_move2 s tl s' \\<and>\n                       s' -\\<tau>\\<rightarrow> \\<infinity>))\n         (\\<lambda>s.\n             snd (SOME a.\n                     case a of\n                     (tl, s') \\<Rightarrow>\n                       silent_move2 s tl s' \\<and>\n                       s' -\\<tau>\\<rightarrow> \\<infinity>))\n         a' \\<or>\n        trsys.inf_step silent_move2 a' bs)", "by(subst (asm) unfold_llist.code)(auto)"], ["proof (state)\nthis:\n  \\<exists>a b a' bs.\n     s = a \\<and>\n     tls = LCons b bs \\<and>\n     silent_move2 a b a' \\<and>\n     (a' -\\<tau>\\<rightarrow> \\<infinity> \\<and>\n      bs =\n      unfold_llist (\\<lambda>_. False)\n       (\\<lambda>s.\n           fst (SOME a.\n                   case a of\n                   (tl, s') \\<Rightarrow>\n                     silent_move2 s tl s' \\<and>\n                     s' -\\<tau>\\<rightarrow> \\<infinity>))\n       (\\<lambda>s.\n           snd (SOME a.\n                   case a of\n                   (tl, s') \\<Rightarrow>\n                     silent_move2 s tl s' \\<and>\n                     s' -\\<tau>\\<rightarrow> \\<infinity>))\n       a' \\<or>\n      trsys.inf_step silent_move2 a' bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trsys.inf_step silent_move2 s tls\n\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        trsys.inf_step silent_move2 s tls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  trsys.inf_step silent_move2 s tls\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_into_\\<tau>rtrancl3p:\n  assumes runs: \"s \\<Down> tlss\"\n  and fin: \"tfinite tlss\"\n  and terminal: \"terminal tlss = Some s'\"\n  shows \"\\<tau>rtrancl3p s (list_of (llist_of_tllist tlss)) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>-list_of (llist_of_tllist tlss)\\<rightarrow>* s'", "using fin runs terminal"], ["proof (prove)\nusing this:\n  tfinite tlss\n  s \\<Down> tlss\n  terminal tlss = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. s -\\<tau>-list_of (llist_of_tllist tlss)\\<rightarrow>* s'", "proof(induct arbitrary: s rule: tfinite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y s.\n       \\<lbrakk>s \\<Down> TNil y;\n        terminal (TNil y) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TNil y))\\<rightarrow>* s'\n 2. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "case TNil"], ["proof (state)\nthis:\n  s \\<Down> TNil y_\n  terminal (TNil y_) = \\<lfloor>s'\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>y s.\n       \\<lbrakk>s \\<Down> TNil y;\n        terminal (TNil y) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TNil y))\\<rightarrow>* s'\n 2. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<Down> TNil y_\n  terminal (TNil y_) = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. s -\\<tau>-list_of (llist_of_tllist (TNil y_))\\<rightarrow>* s'", "by cases(auto intro: silent_moves_into_\\<tau>rtrancl3p)"], ["proof (state)\nthis:\n  s -\\<tau>-list_of (llist_of_tllist (TNil y_))\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "case (TCons tl tlss)"], ["proof (state)\nthis:\n  tfinite tlss\n  \\<lbrakk>?s \\<Down> tlss; terminal tlss = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> ?s -\\<tau>-list_of\n                                (llist_of_tllist tlss)\\<rightarrow>* s'\n  s \\<Down> TCons tl tlss\n  terminal (TCons tl tlss) = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "from \\<open>s \\<Down> TCons tl tlss\\<close>"], ["proof (chain)\npicking this:\n  s \\<Down> TCons tl tlss", "obtain s'' s'''\n    where step: \"s -\\<tau>\\<rightarrow>* s''\"\n    and step2: \"s'' -tl\\<rightarrow> s'''\" \"\\<not> \\<tau>move s'' tl s'''\" \n    and \"s''' \\<Down> tlss\""], ["proof (prove)\nusing this:\n  s \\<Down> TCons tl tlss\n\ngoal (1 subgoal):\n 1. (\\<And>s'' s'''.\n        \\<lbrakk>s -\\<tau>\\<rightarrow>* s''; s'' -tl\\<rightarrow> s''';\n         \\<not> \\<tau>move s'' tl s'''; s''' \\<Down> tlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* s''\n  s'' -tl\\<rightarrow> s'''\n  \\<not> \\<tau>move s'' tl s'''\n  s''' \\<Down> tlss\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "from \\<open>terminal (TCons tl tlss) = \\<lfloor>s'\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  terminal (TCons tl tlss) = \\<lfloor>s'\\<rfloor>", "have \"terminal tlss = \\<lfloor>s'\\<rfloor>\""], ["proof (prove)\nusing this:\n  terminal (TCons tl tlss) = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. terminal tlss = \\<lfloor>s'\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  terminal tlss = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "with \\<open>s''' \\<Down> tlss\\<close>"], ["proof (chain)\npicking this:\n  s''' \\<Down> tlss\n  terminal tlss = \\<lfloor>s'\\<rfloor>", "have \"s''' -\\<tau>-list_of (llist_of_tllist tlss)\\<rightarrow>* s'\""], ["proof (prove)\nusing this:\n  s''' \\<Down> tlss\n  terminal tlss = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. s''' -\\<tau>-list_of (llist_of_tllist tlss)\\<rightarrow>* s'", "by(rule TCons)"], ["proof (state)\nthis:\n  s''' -\\<tau>-list_of (llist_of_tllist tlss)\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "with step2"], ["proof (chain)\npicking this:\n  s'' -tl\\<rightarrow> s'''\n  \\<not> \\<tau>move s'' tl s'''\n  s''' -\\<tau>-list_of (llist_of_tllist tlss)\\<rightarrow>* s'", "have \"s'' -\\<tau>-tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'\""], ["proof (prove)\nusing this:\n  s'' -tl\\<rightarrow> s'''\n  \\<not> \\<tau>move s'' tl s'''\n  s''' -\\<tau>-list_of (llist_of_tllist tlss)\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. s'' -\\<tau>-tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'", "by(rule \\<tau>rtrancl3p_step)"], ["proof (state)\nthis:\n  s'' -\\<tau>-tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "with step"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* s''\n  s'' -\\<tau>-tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'", "have \"s -\\<tau>-[] @ tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s''\n  s'' -\\<tau>-tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>-[] @ tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'", "by(rule \\<tau>rtrancl3p_trans[OF silent_moves_into_\\<tau>rtrancl3p])"], ["proof (state)\nthis:\n  s -\\<tau>-[] @ tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>-list_of\n  (llist_of_tllist xs)\\<rightarrow>* s';\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>-list_of\n                                    (llist_of_tllist\n(TCons x xs))\\<rightarrow>* s'", "thus ?case"], ["proof (prove)\nusing this:\n  s -\\<tau>-[] @ tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>-list_of (llist_of_tllist (TCons tl tlss))\\<rightarrow>* s'", "using \\<open>tfinite tlss\\<close>"], ["proof (prove)\nusing this:\n  s -\\<tau>-[] @ tl # list_of (llist_of_tllist tlss)\\<rightarrow>* s'\n  tfinite tlss\n\ngoal (1 subgoal):\n 1. s -\\<tau>-list_of (llist_of_tllist (TCons tl tlss))\\<rightarrow>* s'", "by simp"], ["proof (state)\nthis:\n  s -\\<tau>-list_of (llist_of_tllist (TCons tl tlss))\\<rightarrow>* s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_terminal_stuck:\n  assumes Runs: \"s \\<Down> tlss\"\n  and fin: \"tfinite tlss\"\n  and terminal: \"terminal tlss = Some s'\"\n  and proceed: \"s' -tls\\<rightarrow> s''\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using fin Runs terminal"], ["proof (prove)\nusing this:\n  tfinite tlss\n  s \\<Down> tlss\n  terminal tlss = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. False", "proof(induct arbitrary: s rule: tfinite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y s.\n       \\<lbrakk>s \\<Down> TNil y;\n        terminal (TNil y) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> False;\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "case TNil"], ["proof (state)\nthis:\n  s \\<Down> TNil y_\n  terminal (TNil y_) = \\<lfloor>s'\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>y s.\n       \\<lbrakk>s \\<Down> TNil y;\n        terminal (TNil y) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> False;\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<Down> TNil y_\n  terminal (TNil y_) = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. False", "using proceed"], ["proof (prove)\nusing this:\n  s \\<Down> TNil y_\n  terminal (TNil y_) = \\<lfloor>s'\\<rfloor>\n  s' -tls\\<rightarrow> s''\n\ngoal (1 subgoal):\n 1. False", "by cases auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> False;\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> False;\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "case TCons"], ["proof (state)\nthis:\n  tfinite xs_\n  \\<lbrakk>?s \\<Down> xs_; terminal xs_ = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> False\n  s \\<Down> TCons x_ xs_\n  terminal (TCons x_ xs_) = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>tfinite xs;\n        \\<And>s.\n           \\<lbrakk>s \\<Down> xs;\n            terminal xs = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n           \\<Longrightarrow> False;\n        s \\<Down> TCons x xs;\n        terminal (TCons x xs) = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  tfinite xs_\n  \\<lbrakk>?s \\<Down> xs_; terminal xs_ = \\<lfloor>s'\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> False\n  s \\<Down> TCons x_ xs_\n  terminal (TCons x_ xs_) = \\<lfloor>s'\\<rfloor>\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim: \\<tau>Runs.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Runs_table_silent_diverge:\n  \"\\<lbrakk> Runs_table s stlss; \\<forall>(s, tl, s') \\<in> lset stlss. \\<tau>move s tl s'; \\<not> lfinite stlss \\<rbrakk>\n  \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Runs_table s stlss;\n     \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s';\n     \\<not> lfinite stlss\\<rbrakk>\n    \\<Longrightarrow> s -\\<tau>\\<rightarrow> \\<infinity>", "proof(coinduction arbitrary: s stlss)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s stlss.\n       \\<lbrakk>Runs_table s stlss;\n        \\<forall>x.\n           x \\<in> lset stlss \\<longrightarrow>\n           (case x of (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb);\n        \\<not> lfinite stlss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            sa -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s stlss.\n                                 s' = s \\<and>\n                                 Runs_table s stlss \\<and>\n                                 (\\<forall>x.\n                                     x \\<in> lset stlss \\<longrightarrow>\n                                     (case x of\n(s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)) \\<and>\n                                 \\<not> lfinite stlss) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "case (\\<tau>diverge s)"], ["proof (state)\nthis:\n  Runs_table s stlss\n  \\<forall>x.\n     x \\<in> lset stlss \\<longrightarrow>\n     (case x of (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)\n  \\<not> lfinite stlss\n\ngoal (1 subgoal):\n 1. \\<And>s stlss.\n       \\<lbrakk>Runs_table s stlss;\n        \\<forall>x.\n           x \\<in> lset stlss \\<longrightarrow>\n           (case x of (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb);\n        \\<not> lfinite stlss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            sa -\\<tau>\\<rightarrow> s' \\<and>\n                            ((\\<exists>s stlss.\n                                 s' = s \\<and>\n                                 Runs_table s stlss \\<and>\n                                 (\\<forall>x.\n                                     x \\<in> lset stlss \\<longrightarrow>\n                                     (case x of\n(s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)) \\<and>\n                                 \\<not> lfinite stlss) \\<or>\n                             s' -\\<tau>\\<rightarrow> \\<infinity>)", "thus ?case"], ["proof (prove)\nusing this:\n  Runs_table s stlss\n  \\<forall>x.\n     x \\<in> lset stlss \\<longrightarrow>\n     (case x of (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)\n  \\<not> lfinite stlss\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       s -\\<tau>\\<rightarrow> s' \\<and>\n       ((\\<exists>s stlss.\n            s' = s \\<and>\n            Runs_table s stlss \\<and>\n            (\\<forall>x.\n                x \\<in> lset stlss \\<longrightarrow>\n                (case x of\n                 (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)) \\<and>\n            \\<not> lfinite stlss) \\<or>\n        s' -\\<tau>\\<rightarrow> \\<infinity>)", "by cases(auto 5 2)"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     s -\\<tau>\\<rightarrow> s' \\<and>\n     ((\\<exists>s stlss.\n          s' = s \\<and>\n          Runs_table s stlss \\<and>\n          (\\<forall>x.\n              x \\<in> lset stlss \\<longrightarrow>\n              (case x of\n               (s, xa, xb) \\<Rightarrow> \\<tau>move s xa xb)) \\<and>\n          \\<not> lfinite stlss) \\<or>\n      s' -\\<tau>\\<rightarrow> \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Runs_table_silent_rtrancl:\n  assumes \"lfinite stlss\"\n  and \"Runs_table s stlss\"\n  and \"\\<forall>(s, tl, s') \\<in> lset stlss. \\<tau>move s tl s'\"\n  shows \"s -\\<tau>\\<rightarrow>* llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\" (is ?thesis1)\n  and \"llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -tl'\\<rightarrow> s'' \\<Longrightarrow> False\" (is \"PROP ?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap (\\<lambda>(s, tl, s'). s') stlss)) &&&\n    (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n     -tl'\\<rightarrow> s'' \\<Longrightarrow>\n     False)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap (\\<lambda>(s, tl, s'). s') stlss))\n 2. llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n    -tl'\\<rightarrow> s'' \\<Longrightarrow>\n    False", "from assms"], ["proof (chain)\npicking this:\n  lfinite stlss\n  Runs_table s stlss\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'", "have \"?thesis1 \\<and> (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -tl'\\<rightarrow> s'' \\<longrightarrow> False)\""], ["proof (prove)\nusing this:\n  lfinite stlss\n  Runs_table s stlss\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap (\\<lambda>(s, tl, s'). s')\n                                 stlss)) \\<and>\n    (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n     -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "proof(induct arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>Runs_table s LNil;\n        \\<forall>(s, x, y)\\<in>lset LNil. \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') LNil)) \\<and>\n                         (llast\n                           (LCons s (lmap (\\<lambda>(s, tl, s'). s') LNil))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)\n 2. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "case lfinite_LNil"], ["proof (state)\nthis:\n  Runs_table s LNil\n  \\<forall>a\\<in>lset LNil.\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>Runs_table s LNil;\n        \\<forall>(s, x, y)\\<in>lset LNil. \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') LNil)) \\<and>\n                         (llast\n                           (LCons s (lmap (\\<lambda>(s, tl, s'). s') LNil))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)\n 2. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "thus ?case"], ["proof (prove)\nusing this:\n  Runs_table s LNil\n  \\<forall>a\\<in>lset LNil.\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap\n                                 (\\<lambda>a.\n                                     case a of (s, tl, s') \\<Rightarrow> s')\n                                 LNil)) \\<and>\n    (llast\n      (LCons s\n        (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s') LNil))\n     -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "by(auto elim: Runs_table.cases)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap\n                               (\\<lambda>a.\n                                   case a of (s, tl, s') \\<Rightarrow> s')\n                               LNil)) \\<and>\n  (llast\n    (LCons s\n      (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s') LNil))\n   -tl'\\<rightarrow> s'' \\<longrightarrow> False)\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "case (lfinite_LConsI stlss stls)"], ["proof (state)\nthis:\n  lfinite stlss\n  \\<lbrakk>Runs_table ?s stlss;\n   \\<forall>a\\<in>lset stlss.\n      case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\\<rbrakk>\n  \\<Longrightarrow> ?s -\\<tau>\\<rightarrow>* llast\n        (LCons ?s\n          (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n            stlss)) \\<and>\n                    (llast\n                      (LCons ?s\n                        (lmap\n                          (\\<lambda>a.\n                              case a of (s, tl, s') \\<Rightarrow> s')\n                          stlss))\n                     -tl'\\<rightarrow> s'' \\<longrightarrow> False)\n  Runs_table s (LCons stls stlss)\n  \\<forall>a\\<in>lset (LCons stls stlss).\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "from \\<open>Runs_table s (LCons stls stlss)\\<close>"], ["proof (chain)\npicking this:\n  Runs_table s (LCons stls stlss)", "obtain tl s' where [simp]: \"stls = (s, tl, s')\"\n      and \"s -tl\\<rightarrow> s'\" and Run': \"Runs_table s' stlss\""], ["proof (prove)\nusing this:\n  Runs_table s (LCons stls stlss)\n\ngoal (1 subgoal):\n 1. (\\<And>tl s'.\n        \\<lbrakk>stls = (s, tl, s'); s -tl\\<rightarrow> s';\n         Runs_table s' stlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  stls = (s, tl, s')\n  s -tl\\<rightarrow> s'\n  Runs_table s' stlss\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "from \\<open>\\<forall>(s, tl, s')\\<in>lset (LCons stls stlss). \\<tau>move s tl s'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>(s, tl, s')\\<in>lset (LCons stls stlss). \\<tau>move s tl s'", "have \"\\<tau>move s tl s'\" and silent': \"\\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\""], ["proof (prove)\nusing this:\n  \\<forall>(s, tl, s')\\<in>lset (LCons stls stlss). \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. \\<tau>move s tl s' &&&\n    \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'", "by simp_all"], ["proof (state)\nthis:\n  \\<tau>move s tl s'\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "from \\<open>s -tl\\<rightarrow> s'\\<close> \\<open>\\<tau>move s tl s'\\<close>"], ["proof (chain)\npicking this:\n  s -tl\\<rightarrow> s'\n  \\<tau>move s tl s'", "have \"s -\\<tau>\\<rightarrow> s'\""], ["proof (prove)\nusing this:\n  s -tl\\<rightarrow> s'\n  \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> s'", "by auto"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "moreover"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "from Run' silent'"], ["proof (chain)\npicking this:\n  Runs_table s' stlss\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'", "have \"s' -\\<tau>\\<rightarrow>* llast (LCons s' (lmap (\\<lambda>(s, tl, s'). s') stlss)) \\<and>\n          (llast (LCons s' (lmap (\\<lambda>(s, tl, s'). s') stlss)) -tl'\\<rightarrow> s'' \\<longrightarrow> False)\""], ["proof (prove)\nusing this:\n  Runs_table s' stlss\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s' -\\<tau>\\<rightarrow>* llast\n                              (LCons s'\n                                (lmap (\\<lambda>(s, tl, s'). s')\n                                  stlss)) \\<and>\n    (llast (LCons s' (lmap (\\<lambda>(s, tl, s'). s') stlss))\n     -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "by(rule lfinite_LConsI)"], ["proof (state)\nthis:\n  s' -\\<tau>\\<rightarrow>* llast\n                            (LCons s'\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss)) \\<and>\n  (llast (LCons s' (lmap (\\<lambda>(s, tl, s'). s') stlss))\n   -tl'\\<rightarrow> s'' \\<longrightarrow> False)\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s xs;\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             (llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs))\n                              -tl'\\<rightarrow> s'' \\<longrightarrow>\n                              False);\n        Runs_table s (LCons x xs);\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         (llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs)))\n                          -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "ultimately"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> s'\n  s' -\\<tau>\\<rightarrow>* llast\n                            (LCons s'\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss)) \\<and>\n  (llast (LCons s' (lmap (\\<lambda>(s, tl, s'). s') stlss))\n   -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "show ?case"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> s'\n  s' -\\<tau>\\<rightarrow>* llast\n                            (LCons s'\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss)) \\<and>\n  (llast (LCons s' (lmap (\\<lambda>(s, tl, s'). s') stlss))\n   -tl'\\<rightarrow> s'' \\<longrightarrow> False)\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap\n                                 (\\<lambda>a.\n                                     case a of (s, tl, s') \\<Rightarrow> s')\n                                 (LCons stls stlss))) \\<and>\n    (llast\n      (LCons s\n        (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n          (LCons stls stlss)))\n     -tl'\\<rightarrow> s'' \\<longrightarrow> False)", "by(auto)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap\n                               (\\<lambda>a.\n                                   case a of (s, tl, s') \\<Rightarrow> s')\n                               (LCons stls stlss))) \\<and>\n  (llast\n    (LCons s\n      (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n        (LCons stls stlss)))\n   -tl'\\<rightarrow> s'' \\<longrightarrow> False)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') stlss)) \\<and>\n  (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -tl'\\<rightarrow>\n   s'' \\<longrightarrow> False)\n\ngoal (2 subgoals):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap (\\<lambda>(s, tl, s'). s') stlss))\n 2. llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n    -tl'\\<rightarrow> s'' \\<Longrightarrow>\n    False", "thus ?thesis1 \"PROP ?thesis2\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') stlss)) \\<and>\n  (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -tl'\\<rightarrow>\n   s'' \\<longrightarrow> False)\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap (\\<lambda>(s, tl, s'). s') stlss)) &&&\n    (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n     -tl'\\<rightarrow> s'' \\<Longrightarrow>\n     False)", "by blast+"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -tl'\\<rightarrow>\n  s'' \\<Longrightarrow>\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Runs_table_silent_lappendD:\n  fixes s stlss\n  defines \"s' \\<equiv> llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\"\n  assumes Runs: \"Runs_table s (lappend stlss stlss')\"\n  and fin: \"lfinite stlss\"\n  and silent: \"\\<forall>(s, tl, s') \\<in> lset stlss. \\<tau>move s tl s'\"\n  shows \"s -\\<tau>\\<rightarrow>* s'\" (is ?thesis1)\n  and \"Runs_table s' stlss'\" (is ?thesis2)\n  and \"stlss' \\<noteq> LNil \\<Longrightarrow> s' = fst (lhd stlss')\" (is \"PROP ?thesis3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s' &&&\n    Runs_table s' stlss' &&&\n    (stlss' \\<noteq> LNil \\<Longrightarrow> s' = fst (lhd stlss'))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. s -\\<tau>\\<rightarrow>* s'\n 2. Runs_table s' stlss'\n 3. stlss' \\<noteq> LNil \\<Longrightarrow> s' = fst (lhd stlss')", "from fin Runs silent"], ["proof (chain)\npicking this:\n  lfinite stlss\n  Runs_table s (lappend stlss stlss')\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'", "have \"?thesis1 \\<and> ?thesis2 \\<and> (stlss' \\<noteq> LNil \\<longrightarrow> s' = fst (lhd stlss'))\""], ["proof (prove)\nusing this:\n  lfinite stlss\n  Runs_table s (lappend stlss stlss')\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s' \\<and>\n    Runs_table s' stlss' \\<and>\n    (stlss' \\<noteq> LNil \\<longrightarrow> s' = fst (lhd stlss'))", "unfolding s'_def"], ["proof (prove)\nusing this:\n  lfinite stlss\n  Runs_table s (lappend stlss stlss')\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap (\\<lambda>(s, tl, s'). s')\n                                 stlss)) \\<and>\n    Runs_table (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)))\n     stlss' \\<and>\n    (stlss' \\<noteq> LNil \\<longrightarrow>\n     llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) =\n     fst (lhd stlss'))", "proof(induct arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>Runs_table s (lappend LNil stlss');\n        \\<forall>(s, x, y)\\<in>lset LNil. \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') LNil)) \\<and>\n                         Runs_table\n                          (llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s') LNil)))\n                          stlss' \\<and>\n                         (stlss' \\<noteq> LNil \\<longrightarrow>\n                          llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') LNil)) =\n                          fst (lhd stlss'))\n 2. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s (lappend xs stlss');\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             Runs_table\n                              (llast\n                                (LCons s\n                                  (lmap (\\<lambda>(s, tl, s'). s') xs)))\n                              stlss' \\<and>\n                             (stlss' \\<noteq> LNil \\<longrightarrow>\n                              llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs)) =\n                              fst (lhd stlss'));\n        Runs_table s (lappend (LCons x xs) stlss');\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         Runs_table\n                          (llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                (LCons x xs))))\n                          stlss' \\<and>\n                         (stlss' \\<noteq> LNil \\<longrightarrow>\n                          llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s')\n                               (LCons x xs))) =\n                          fst (lhd stlss'))", "case lfinite_LNil"], ["proof (state)\nthis:\n  Runs_table s (lappend LNil stlss')\n  \\<forall>a\\<in>lset LNil.\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>Runs_table s (lappend LNil stlss');\n        \\<forall>(s, x, y)\\<in>lset LNil. \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') LNil)) \\<and>\n                         Runs_table\n                          (llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s') LNil)))\n                          stlss' \\<and>\n                         (stlss' \\<noteq> LNil \\<longrightarrow>\n                          llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') LNil)) =\n                          fst (lhd stlss'))\n 2. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s (lappend xs stlss');\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             Runs_table\n                              (llast\n                                (LCons s\n                                  (lmap (\\<lambda>(s, tl, s'). s') xs)))\n                              stlss' \\<and>\n                             (stlss' \\<noteq> LNil \\<longrightarrow>\n                              llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs)) =\n                              fst (lhd stlss'));\n        Runs_table s (lappend (LCons x xs) stlss');\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         Runs_table\n                          (llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                (LCons x xs))))\n                          stlss' \\<and>\n                         (stlss' \\<noteq> LNil \\<longrightarrow>\n                          llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s')\n                               (LCons x xs))) =\n                          fst (lhd stlss'))", "thus ?case"], ["proof (prove)\nusing this:\n  Runs_table s (lappend LNil stlss')\n  \\<forall>a\\<in>lset LNil.\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap\n                                 (\\<lambda>a.\n                                     case a of (s, tl, s') \\<Rightarrow> s')\n                                 LNil)) \\<and>\n    Runs_table\n     (llast\n       (LCons s\n         (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s') LNil)))\n     stlss' \\<and>\n    (stlss' \\<noteq> LNil \\<longrightarrow>\n     llast\n      (LCons s\n        (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s') LNil)) =\n     fst (lhd stlss'))", "by(auto simp add: neq_LNil_conv Runs_table_simps)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap\n                               (\\<lambda>a.\n                                   case a of (s, tl, s') \\<Rightarrow> s')\n                               LNil)) \\<and>\n  Runs_table\n   (llast\n     (LCons s\n       (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s') LNil)))\n   stlss' \\<and>\n  (stlss' \\<noteq> LNil \\<longrightarrow>\n   llast\n    (LCons s\n      (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s') LNil)) =\n   fst (lhd stlss'))\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s (lappend xs stlss');\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             Runs_table\n                              (llast\n                                (LCons s\n                                  (lmap (\\<lambda>(s, tl, s'). s') xs)))\n                              stlss' \\<and>\n                             (stlss' \\<noteq> LNil \\<longrightarrow>\n                              llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs)) =\n                              fst (lhd stlss'));\n        Runs_table s (lappend (LCons x xs) stlss');\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         Runs_table\n                          (llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                (LCons x xs))))\n                          stlss' \\<and>\n                         (stlss' \\<noteq> LNil \\<longrightarrow>\n                          llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s')\n                               (LCons x xs))) =\n                          fst (lhd stlss'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s (lappend xs stlss');\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             Runs_table\n                              (llast\n                                (LCons s\n                                  (lmap (\\<lambda>(s, tl, s'). s') xs)))\n                              stlss' \\<and>\n                             (stlss' \\<noteq> LNil \\<longrightarrow>\n                              llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs)) =\n                              fst (lhd stlss'));\n        Runs_table s (lappend (LCons x xs) stlss');\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         Runs_table\n                          (llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                (LCons x xs))))\n                          stlss' \\<and>\n                         (stlss' \\<noteq> LNil \\<longrightarrow>\n                          llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s')\n                               (LCons x xs))) =\n                          fst (lhd stlss'))", "case lfinite_LConsI"], ["proof (state)\nthis:\n  lfinite xs_\n  \\<lbrakk>Runs_table ?s (lappend xs_ stlss');\n   \\<forall>a\\<in>lset xs_.\n      case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\\<rbrakk>\n  \\<Longrightarrow> ?s -\\<tau>\\<rightarrow>* llast\n        (LCons ?s\n          (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n            xs_)) \\<and>\n                    Runs_table\n                     (llast\n                       (LCons ?s\n                         (lmap\n                           (\\<lambda>a.\n                               case a of (s, tl, s') \\<Rightarrow> s')\n                           xs_)))\n                     stlss' \\<and>\n                    (stlss' \\<noteq> LNil \\<longrightarrow>\n                     llast\n                      (LCons ?s\n                        (lmap\n                          (\\<lambda>a.\n                              case a of (s, tl, s') \\<Rightarrow> s')\n                          xs_)) =\n                     fst (lhd stlss'))\n  Runs_table s (lappend (LCons x_ xs_) stlss')\n  \\<forall>a\\<in>lset (LCons x_ xs_).\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (1 subgoal):\n 1. \\<And>xs x s.\n       \\<lbrakk>lfinite xs;\n        \\<And>s.\n           \\<lbrakk>Runs_table s (lappend xs stlss');\n            \\<forall>(s, x, y)\\<in>lset xs. \\<tau>move s x y\\<rbrakk>\n           \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') xs)) \\<and>\n                             Runs_table\n                              (llast\n                                (LCons s\n                                  (lmap (\\<lambda>(s, tl, s'). s') xs)))\n                              stlss' \\<and>\n                             (stlss' \\<noteq> LNil \\<longrightarrow>\n                              llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s') xs)) =\n                              fst (lhd stlss'));\n        Runs_table s (lappend (LCons x xs) stlss');\n        \\<forall>(s, x, y)\\<in>lset (LCons x xs). \\<tau>move s x y\\<rbrakk>\n       \\<Longrightarrow> s -\\<tau>\\<rightarrow>* llast\n            (LCons s (lmap (\\<lambda>(s, tl, s'). s') (LCons x xs))) \\<and>\n                         Runs_table\n                          (llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                (LCons x xs))))\n                          stlss' \\<and>\n                         (stlss' \\<noteq> LNil \\<longrightarrow>\n                          llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s')\n                               (LCons x xs))) =\n                          fst (lhd stlss'))", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs_\n  \\<lbrakk>Runs_table ?s (lappend xs_ stlss');\n   \\<forall>a\\<in>lset xs_.\n      case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\\<rbrakk>\n  \\<Longrightarrow> ?s -\\<tau>\\<rightarrow>* llast\n        (LCons ?s\n          (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n            xs_)) \\<and>\n                    Runs_table\n                     (llast\n                       (LCons ?s\n                         (lmap\n                           (\\<lambda>a.\n                               case a of (s, tl, s') \\<Rightarrow> s')\n                           xs_)))\n                     stlss' \\<and>\n                    (stlss' \\<noteq> LNil \\<longrightarrow>\n                     llast\n                      (LCons ?s\n                        (lmap\n                          (\\<lambda>a.\n                              case a of (s, tl, s') \\<Rightarrow> s')\n                          xs_)) =\n                     fst (lhd stlss'))\n  Runs_table s (lappend (LCons x_ xs_) stlss')\n  \\<forall>a\\<in>lset (LCons x_ xs_).\n     case a of (s, b, c) \\<Rightarrow> \\<tau>move s b c\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap\n                                 (\\<lambda>a.\n                                     case a of (s, tl, s') \\<Rightarrow> s')\n                                 (LCons x_ xs_))) \\<and>\n    Runs_table\n     (llast\n       (LCons s\n         (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n           (LCons x_ xs_))))\n     stlss' \\<and>\n    (stlss' \\<noteq> LNil \\<longrightarrow>\n     llast\n      (LCons s\n        (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n          (LCons x_ xs_))) =\n     fst (lhd stlss'))", "by(clarsimp simp add: neq_LNil_conv Runs_table_simps)(blast intro: converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap\n                               (\\<lambda>a.\n                                   case a of (s, tl, s') \\<Rightarrow> s')\n                               (LCons x_ xs_))) \\<and>\n  Runs_table\n   (llast\n     (LCons s\n       (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n         (LCons x_ xs_))))\n   stlss' \\<and>\n  (stlss' \\<noteq> LNil \\<longrightarrow>\n   llast\n    (LCons s\n      (lmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n        (LCons x_ xs_))) =\n   fst (lhd stlss'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* s' \\<and>\n  Runs_table s' stlss' \\<and>\n  (stlss' \\<noteq> LNil \\<longrightarrow> s' = fst (lhd stlss'))\n\ngoal (3 subgoals):\n 1. s -\\<tau>\\<rightarrow>* s'\n 2. Runs_table s' stlss'\n 3. stlss' \\<noteq> LNil \\<Longrightarrow> s' = fst (lhd stlss')", "thus ?thesis1 ?thesis2 \"PROP ?thesis3\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s' \\<and>\n  Runs_table s' stlss' \\<and>\n  (stlss' \\<noteq> LNil \\<longrightarrow> s' = fst (lhd stlss'))\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s' &&&\n    Runs_table s' stlss' &&&\n    (stlss' \\<noteq> LNil \\<Longrightarrow> s' = fst (lhd stlss'))", "by simp_all"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* s'\n  Runs_table s' stlss'\n  stlss' \\<noteq> LNil \\<Longrightarrow> s' = fst (lhd stlss')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Runs_table_into_\\<tau>Runs:\n  fixes s stlss\n  defines \"tls \\<equiv> tmap (\\<lambda>(s, tl, s'). tl) id (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') (tllist_of_llist (Some (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)))) stlss))\"\n  (is \"_ \\<equiv> ?conv s stlss\")\n  assumes \"Runs_table s stlss\"\n  shows \"\\<tau>Runs s tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<Down> tls", "using assms"], ["proof (prove)\nusing this:\n  tls \\<equiv>\n  tmap (\\<lambda>(s, tl, s'). tl) id\n   (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n       stlss))\n  Runs_table s stlss\n\ngoal (1 subgoal):\n 1. s \\<Down> tls", "proof(coinduction arbitrary: s tls stlss)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls stlss.\n       \\<lbrakk>tls =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss));\n        Runs_table s stlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa s'.\n                             s = sa \\<and>\n                             tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             sa -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>sa.\n                             s = sa \\<and>\n                             tls = TNil None \\<and>\n                             sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>sa s' s'' tlsa tl.\n                             s = sa \\<and>\n                             tls = TCons tl tlsa \\<and>\n                             sa -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls stlss.\n                                  s'' = s \\<and>\n                                  tlsa = tls \\<and>\n                                  tls =\n                                  tmap (\\<lambda>(s, tl, s'). tl) id\n                                   (tfilter None\n                                     (\\<lambda>(s, tl, s').\n   \\<not> \\<tau>move s tl s')\n                                     (tllist_of_llist\n \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n stlss)) \\<and>\n                                  Runs_table s stlss) \\<or>\n                              s'' \\<Down> tlsa))", "case (\\<tau>Runs s tls stlss)"], ["proof (state)\nthis:\n  tls =\n  tmap (\\<lambda>(s, tl, s'). tl) id\n   (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n       stlss))\n  Runs_table s stlss\n\ngoal (1 subgoal):\n 1. \\<And>s tls stlss.\n       \\<lbrakk>tls =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss));\n        Runs_table s stlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa s'.\n                             s = sa \\<and>\n                             tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             sa -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>sa.\n                             s = sa \\<and>\n                             tls = TNil None \\<and>\n                             sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>sa s' s'' tlsa tl.\n                             s = sa \\<and>\n                             tls = TCons tl tlsa \\<and>\n                             sa -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls stlss.\n                                  s'' = s \\<and>\n                                  tlsa = tls \\<and>\n                                  tls =\n                                  tmap (\\<lambda>(s, tl, s'). tl) id\n                                   (tfilter None\n                                     (\\<lambda>(s, tl, s').\n   \\<not> \\<tau>move s tl s')\n                                     (tllist_of_llist\n \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n stlss)) \\<and>\n                                  Runs_table s stlss) \\<or>\n                              s'' \\<Down> tlsa))", "note tls = \\<open>tls = ?conv s stlss\\<close>\n    and Run = \\<open>Runs_table s stlss\\<close>"], ["proof (state)\nthis:\n  tls =\n  tmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> tl) id\n   (tfilter None\n     (\\<lambda>a.\n         case a of (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s\n                   (lmap\n                     (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n                     stlss))\\<rfloor>\n       stlss))\n  Runs_table s stlss\n\ngoal (1 subgoal):\n 1. \\<And>s tls stlss.\n       \\<lbrakk>tls =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss));\n        Runs_table s stlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa s'.\n                             s = sa \\<and>\n                             tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n                             sa -\\<tau>\\<rightarrow>* s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>sa.\n                             s = sa \\<and>\n                             tls = TNil None \\<and>\n                             sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n                         (\\<exists>sa s' s'' tlsa tl.\n                             s = sa \\<and>\n                             tls = TCons tl tlsa \\<and>\n                             sa -\\<tau>\\<rightarrow>* s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls stlss.\n                                  s'' = s \\<and>\n                                  tlsa = tls \\<and>\n                                  tls =\n                                  tmap (\\<lambda>(s, tl, s'). tl) id\n                                   (tfilter None\n                                     (\\<lambda>(s, tl, s').\n   \\<not> \\<tau>move s tl s')\n                                     (tllist_of_llist\n \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n stlss)) \\<and>\n                                  Runs_table s stlss) \\<or>\n                              s'' \\<Down> tlsa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "proof(cases tls)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       tls = TNil x1 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))\n 2. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "case [simp]: (TNil so)"], ["proof (state)\nthis:\n  tls = TNil so\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       tls = TNil x1 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))\n 2. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "from tls"], ["proof (chain)\npicking this:\n  tls =\n  tmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> tl) id\n   (tfilter None\n     (\\<lambda>a.\n         case a of (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s\n                   (lmap\n                     (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n                     stlss))\\<rfloor>\n       stlss))", "have silent: \"\\<forall>(s, tl, s') \\<in> lset stlss. \\<tau>move s tl s'\""], ["proof (prove)\nusing this:\n  tls =\n  tmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> tl) id\n   (tfilter None\n     (\\<lambda>a.\n         case a of (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s\n                   (lmap\n                     (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n                     stlss))\\<rfloor>\n       stlss))\n\ngoal (1 subgoal):\n 1. \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'", "by(auto simp add: TNil_eq_tmap_conv tfilter_empty_conv)"], ["proof (state)\nthis:\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       tls = TNil x1 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))\n 2. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "proof(cases \"lfinite stlss\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))\n 2. \\<not> lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite stlss\n\ngoal (2 subgoals):\n 1. lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))\n 2. \\<not> lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "with Run silent"], ["proof (chain)\npicking this:\n  Runs_table s stlss\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\n  \\<not> lfinite stlss", "have \"s -\\<tau>\\<rightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  Runs_table s stlss\n  \\<forall>(s, tl, s')\\<in>lset stlss. \\<tau>move s tl s'\n  \\<not> lfinite stlss\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow> \\<infinity>", "by(rule Runs_table_silent_diverge)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))\n 2. \\<not> lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "hence ?Diverge"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>", "using False tls"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n  \\<not> lfinite stlss\n  tls =\n  tmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> tl) id\n   (tfilter None\n     (\\<lambda>a.\n         case a of (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s\n                   (lmap\n                     (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n                     stlss))\\<rfloor>\n       stlss))\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>", "by(simp add: TNil_eq_tmap_conv tfilter_empty_conv)"], ["proof (state)\nthis:\n  \\<exists>s.\n     s = s \\<and> tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))\n 2. \\<not> lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s = s \\<and> tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa stlss.\n           s'' = s \\<and>\n           tls = tlsa \\<and>\n           tlsa =\n           tmap (\\<lambda>(s, tl, s'). tl) id\n            (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              (tllist_of_llist\n                \\<lfloor>llast\n                          (LCons s\n                            (lmap (\\<lambda>(s, tl, s'). s')\n                              stlss))\\<rfloor>\n                stlss)) \\<and>\n           Runs_table s stlss) \\<or>\n       s'' \\<Down> tls))\n\ngoal (1 subgoal):\n 1. lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "case True"], ["proof (state)\nthis:\n  lfinite stlss\n\ngoal (1 subgoal):\n 1. lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "with Runs_table_silent_rtrancl[OF this Run silent]"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -?tl'\\<rightarrow>\n  ?s'' \\<Longrightarrow>\n  False\n  lfinite stlss", "have ?Terminate"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -?tl'\\<rightarrow>\n  ?s'' \\<Longrightarrow>\n  False\n  lfinite stlss\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)", "using tls"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss)) -?tl'\\<rightarrow>\n  ?s'' \\<Longrightarrow>\n  False\n  lfinite stlss\n  tls =\n  tmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> tl) id\n   (tfilter None\n     (\\<lambda>a.\n         case a of (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s\n                   (lmap\n                     (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n                     stlss))\\<rfloor>\n       stlss))\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)", "by(auto simp add: TNil_eq_tmap_conv tfilter_empty_conv terminal_tllist_of_llist split_def)"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)\n\ngoal (1 subgoal):\n 1. lfinite stlss \\<Longrightarrow>\n    (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s'.\n     s = s \\<and>\n     tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa stlss.\n           s'' = s \\<and>\n           tls = tlsa \\<and>\n           tlsa =\n           tmap (\\<lambda>(s, tl, s'). tl) id\n            (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              (tllist_of_llist\n                \\<lfloor>llast\n                          (LCons s\n                            (lmap (\\<lambda>(s, tl, s'). s')\n                              stlss))\\<rfloor>\n                stlss)) \\<and>\n           Runs_table s stlss) \\<or>\n       s'' \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa stlss.\n           s'' = s \\<and>\n           tls = tlsa \\<and>\n           tlsa =\n           tmap (\\<lambda>(s, tl, s'). tl) id\n            (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              (tllist_of_llist\n                \\<lfloor>llast\n                          (LCons s\n                            (lmap (\\<lambda>(s, tl, s'). s')\n                              stlss))\\<rfloor>\n                stlss)) \\<and>\n           Runs_table s stlss) \\<or>\n       s'' \\<Down> tls))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "case [simp]: (TCons tl tls')"], ["proof (state)\nthis:\n  tls = TCons tl tls'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "from tls"], ["proof (chain)\npicking this:\n  tls =\n  tmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> tl) id\n   (tfilter None\n     (\\<lambda>a.\n         case a of (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s\n                   (lmap\n                     (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n                     stlss))\\<rfloor>\n       stlss))", "obtain s' s'' stlss' \n      where tl': \"tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') (tllist_of_llist \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor> stlss) = TCons (s', tl, s'') stlss'\"\n      and tls': \"tls' = tmap (\\<lambda>(s, tl, s'). tl) id stlss'\""], ["proof (prove)\nusing this:\n  tls =\n  tmap (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> tl) id\n   (tfilter None\n     (\\<lambda>a.\n         case a of (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s')\n     (tllist_of_llist\n       \\<lfloor>llast\n                 (LCons s\n                   (lmap\n                     (\\<lambda>a. case a of (s, tl, s') \\<Rightarrow> s')\n                     stlss))\\<rfloor>\n       stlss))\n\ngoal (1 subgoal):\n 1. (\\<And>s' s'' stlss'.\n        \\<lbrakk>tfilter None\n                  (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                  (tllist_of_llist\n                    \\<lfloor>llast\n                              (LCons s\n                                (lmap (\\<lambda>(s, tl, s'). s')\n                                  stlss))\\<rfloor>\n                    stlss) =\n                 TCons (s', tl, s'') stlss';\n         tls' = tmap (\\<lambda>(s, tl, s'). tl) id stlss'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: TCons_eq_tmap_conv split_def id_def split_paired_Ex) blast"], ["proof (state)\nthis:\n  tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n   (tllist_of_llist\n     \\<lfloor>llast\n               (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n     stlss) =\n  TCons (s', tl, s'') stlss'\n  tls' = tmap (\\<lambda>(s, tl, s'). tl) id stlss'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "from tfilter_eq_TConsD[OF tl']"], ["proof (chain)\npicking this:\n  \\<exists>us vs.\n     tllist_of_llist\n      \\<lfloor>llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n      stlss =\n     lappendt us (TCons (s', tl, s'') vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us.\n         \\<not> (case u of\n                 (s, tl, s') \\<Rightarrow>\n                   \\<not> \\<tau>move s tl s')) \\<and>\n     (case (s', tl, s'') of\n      (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s') \\<and>\n     stlss' =\n     tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') vs", "obtain stls\\<tau> rest\n      where stlss_eq: \"tllist_of_llist \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor> stlss = lappendt stls\\<tau> (TCons (s', tl, s'') rest)\"\n      and fin: \"lfinite stls\\<tau>\"\n      and silent: \"\\<forall>(s, tl, s')\\<in>lset stls\\<tau>. \\<tau>move s tl s'\"\n      and \"\\<not> \\<tau>move s' tl s''\"\n      and stlss': \"stlss' = tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') rest\""], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     tllist_of_llist\n      \\<lfloor>llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n      stlss =\n     lappendt us (TCons (s', tl, s'') vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us.\n         \\<not> (case u of\n                 (s, tl, s') \\<Rightarrow>\n                   \\<not> \\<tau>move s tl s')) \\<and>\n     (case (s', tl, s'') of\n      (s, tl, s') \\<Rightarrow> \\<not> \\<tau>move s tl s') \\<and>\n     stlss' =\n     tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') vs\n\ngoal (1 subgoal):\n 1. (\\<And>stls\\<tau> rest.\n        \\<lbrakk>tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss =\n                 lappendt stls\\<tau> (TCons (s', tl, s'') rest);\n         lfinite stls\\<tau>;\n         \\<forall>(s, tl, s')\\<in>lset stls\\<tau>. \\<tau>move s tl s';\n         \\<not> \\<tau>move s' tl s'';\n         stlss' =\n         tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n          rest\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: split_def)"], ["proof (state)\nthis:\n  tllist_of_llist\n   \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n   stlss =\n  lappendt stls\\<tau> (TCons (s', tl, s'') rest)\n  lfinite stls\\<tau>\n  \\<forall>(s, tl, s')\\<in>lset stls\\<tau>. \\<tau>move s tl s'\n  \\<not> \\<tau>move s' tl s''\n  stlss' =\n  tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') rest\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "from stlss_eq fin"], ["proof (chain)\npicking this:\n  tllist_of_llist\n   \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n   stlss =\n  lappendt stls\\<tau> (TCons (s', tl, s'') rest)\n  lfinite stls\\<tau>", "obtain rest'\n      where stlss: \"stlss = lappend stls\\<tau> rest'\"\n      and rest': \"tllist_of_llist \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor> rest' = TCons (s', tl, s'') rest\""], ["proof (prove)\nusing this:\n  tllist_of_llist\n   \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n   stlss =\n  lappendt stls\\<tau> (TCons (s', tl, s'') rest)\n  lfinite stls\\<tau>\n\ngoal (1 subgoal):\n 1. (\\<And>rest'.\n        \\<lbrakk>stlss = lappend stls\\<tau> rest';\n         tllist_of_llist\n          \\<lfloor>llast\n                    (LCons s\n                      (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n          rest' =\n         TCons (s', tl, s'') rest\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding tllist_of_llist_eq_lappendt_conv"], ["proof (prove)\nusing this:\n  \\<exists>xs' a'.\n     stlss = lappend stls\\<tau> xs' \\<and>\n     TCons (s', tl, s'') rest = tllist_of_llist a' xs' \\<and>\n     (lfinite stls\\<tau> \\<longrightarrow>\n      \\<lfloor>llast\n                (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor> =\n      a')\n  lfinite stls\\<tau>\n\ngoal (1 subgoal):\n 1. (\\<And>rest'.\n        \\<lbrakk>stlss = lappend stls\\<tau> rest';\n         tllist_of_llist\n          \\<lfloor>llast\n                    (LCons s\n                      (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n          rest' =\n         TCons (s', tl, s'') rest\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stlss = lappend stls\\<tau> rest'\n  tllist_of_llist\n   \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n   rest' =\n  TCons (s', tl, s'') rest\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "hence \"rest' \\<noteq> LNil\""], ["proof (prove)\nusing this:\n  stlss = lappend stls\\<tau> rest'\n  tllist_of_llist\n   \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n   rest' =\n  TCons (s', tl, s'') rest\n\ngoal (1 subgoal):\n 1. rest' \\<noteq> LNil", "by clarsimp"], ["proof (state)\nthis:\n  rest' \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "from Run[unfolded stlss] fin silent"], ["proof (chain)\npicking this:\n  Runs_table s (lappend stls\\<tau> rest')\n  lfinite stls\\<tau>\n  \\<forall>(s, tl, s')\\<in>lset stls\\<tau>. \\<tau>move s tl s'", "have \"s -\\<tau>\\<rightarrow>* llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>))\"\n      and \"Runs_table (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>))) rest'\"\n      and \"llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)) = fst (lhd rest')\""], ["proof (prove)\nusing this:\n  Runs_table s (lappend stls\\<tau> rest')\n  lfinite stls\\<tau>\n  \\<forall>(s, tl, s')\\<in>lset stls\\<tau>. \\<tau>move s tl s'\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* llast\n                             (LCons s\n                               (lmap (\\<lambda>(s, tl, s'). s')\n                                 stls\\<tau>)) &&&\n    Runs_table\n     (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)))\n     rest' &&&\n    llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)) =\n    fst (lhd rest')", "by(rule Runs_table_silent_lappendD)+(simp add: \\<open>rest' \\<noteq> LNil\\<close>)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>))\n  Runs_table (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)))\n   rest'\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)) =\n  fst (lhd rest')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "moreover"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>))\n  Runs_table (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)))\n   rest'\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)) =\n  fst (lhd rest')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "with rest' \\<open>rest' \\<noteq> LNil\\<close> stlss fin"], ["proof (chain)\npicking this:\n  tllist_of_llist\n   \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n   rest' =\n  TCons (s', tl, s'') rest\n  rest' \\<noteq> LNil\n  stlss = lappend stls\\<tau> rest'\n  lfinite stls\\<tau>\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>))\n  Runs_table (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)))\n   rest'\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)) =\n  fst (lhd rest')", "obtain rest''\n      where rest': \"rest' = LCons (s', tl, s'') rest''\"\n      and rest: \"rest = tllist_of_llist \\<lfloor>llast (LCons s'' (lmap (\\<lambda>(s, tl, s'). s') rest''))\\<rfloor> rest''\""], ["proof (prove)\nusing this:\n  tllist_of_llist\n   \\<lfloor>llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n   rest' =\n  TCons (s', tl, s'') rest\n  rest' \\<noteq> LNil\n  stlss = lappend stls\\<tau> rest'\n  lfinite stls\\<tau>\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>))\n  Runs_table (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)))\n   rest'\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)) =\n  fst (lhd rest')\n\ngoal (1 subgoal):\n 1. (\\<And>rest''.\n        \\<lbrakk>rest' = LCons (s', tl, s'') rest'';\n         rest =\n         tllist_of_llist\n          \\<lfloor>llast\n                    (LCons s''\n                      (lmap (\\<lambda>(s, tl, s'). s') rest''))\\<rfloor>\n          rest''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: neq_LNil_conv llast_LCons lmap_lappend_distrib)"], ["proof (state)\nthis:\n  rest' = LCons (s', tl, s'') rest''\n  rest =\n  tllist_of_llist\n   \\<lfloor>llast\n             (LCons s'' (lmap (\\<lambda>(s, tl, s'). s') rest''))\\<rfloor>\n   rest''\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "ultimately"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>))\n  Runs_table (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)))\n   rest'\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)) =\n  fst (lhd rest')\n  rest' = LCons (s', tl, s'') rest''\n  rest =\n  tllist_of_llist\n   \\<lfloor>llast\n             (LCons s'' (lmap (\\<lambda>(s, tl, s'). s') rest''))\\<rfloor>\n   rest''", "have \"s -\\<tau>\\<rightarrow>* s'\" \"s' -tl\\<rightarrow> s''\" \"Runs_table s'' rest''\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>))\n  Runs_table (llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)))\n   rest'\n  llast (LCons s (lmap (\\<lambda>(s, tl, s'). s') stls\\<tau>)) =\n  fst (lhd rest')\n  rest' = LCons (s', tl, s'') rest''\n  rest =\n  tllist_of_llist\n   \\<lfloor>llast\n             (LCons s'' (lmap (\\<lambda>(s, tl, s'). s') rest''))\\<rfloor>\n   rest''\n\ngoal (1 subgoal):\n 1. s -\\<tau>\\<rightarrow>* s' &&&\n    s' -tl\\<rightarrow> s'' &&& Runs_table s'' rest''", "by(simp_all add: Runs_table_simps)"], ["proof (state)\nthis:\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  Runs_table s'' rest''\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "hence ?Proceed"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  Runs_table s'' rest''\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s = s \\<and>\n       tls = TCons tl tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s tlsa stlss.\n            s'' = s \\<and>\n            tls = tlsa \\<and>\n            tlsa =\n            tmap (\\<lambda>(s, tl, s'). tl) id\n             (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n               (tllist_of_llist\n                 \\<lfloor>llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s')\n                               stlss))\\<rfloor>\n                 stlss)) \\<and>\n            Runs_table s stlss) \\<or>\n        s'' \\<Down> tls)", "using \\<open>\\<not> \\<tau>move s' tl s''\\<close> tls' stlss' rest"], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  Runs_table s'' rest''\n  \\<not> \\<tau>move s' tl s''\n  tls' = tmap (\\<lambda>(s, tl, s'). tl) id stlss'\n  stlss' =\n  tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s') rest\n  rest =\n  tllist_of_llist\n   \\<lfloor>llast\n             (LCons s'' (lmap (\\<lambda>(s, tl, s'). s') rest''))\\<rfloor>\n   rest''\n\ngoal (1 subgoal):\n 1. \\<exists>s s' s'' tls tl.\n       s = s \\<and>\n       tls = TCons tl tls \\<and>\n       s -\\<tau>\\<rightarrow>* s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s tlsa stlss.\n            s'' = s \\<and>\n            tls = tlsa \\<and>\n            tlsa =\n            tmap (\\<lambda>(s, tl, s'). tl) id\n             (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n               (tllist_of_llist\n                 \\<lfloor>llast\n                           (LCons s\n                             (lmap (\\<lambda>(s, tl, s'). s')\n                               stlss))\\<rfloor>\n                 stlss)) \\<and>\n            Runs_table s stlss) \\<or>\n        s'' \\<Down> tls)", "by(auto simp add: id_def)"], ["proof (state)\nthis:\n  \\<exists>s s' s'' tls tl.\n     s = s \\<and>\n     tls = TCons tl tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s tlsa stlss.\n          s'' = s \\<and>\n          tls = tlsa \\<and>\n          tlsa =\n          tmap (\\<lambda>(s, tl, s'). tl) id\n           (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n             (tllist_of_llist\n               \\<lfloor>llast\n                         (LCons s\n                           (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n               stlss)) \\<and>\n          Runs_table s stlss) \\<or>\n      s'' \\<Down> tls)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       tls = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s s'.\n           s = s \\<and>\n           tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>s.\n           s = s \\<and>\n           tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>s s' s'' tls tl.\n           s = s \\<and>\n           tls = TCons tl tls \\<and>\n           s -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsa stlss.\n                s'' = s \\<and>\n                tls = tlsa \\<and>\n                tlsa =\n                tmap (\\<lambda>(s, tl, s'). tl) id\n                 (tfilter None\n                   (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                   (tllist_of_llist\n                     \\<lfloor>llast\n                               (LCons s\n                                 (lmap (\\<lambda>(s, tl, s'). s')\n                                   stlss))\\<rfloor>\n                     stlss)) \\<and>\n                Runs_table s stlss) \\<or>\n            s'' \\<Down> tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' s'' tls tl.\n     s = s \\<and>\n     tls = TCons tl tls \\<and>\n     s -\\<tau>\\<rightarrow>* s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s tlsa stlss.\n          s'' = s \\<and>\n          tls = tlsa \\<and>\n          tlsa =\n          tmap (\\<lambda>(s, tl, s'). tl) id\n           (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n             (tllist_of_llist\n               \\<lfloor>llast\n                         (LCons s\n                           (lmap (\\<lambda>(s, tl, s'). s') stlss))\\<rfloor>\n               stlss)) \\<and>\n          Runs_table s stlss) \\<or>\n      s'' \\<Down> tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tls = TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsa stlss.\n             s'' = s \\<and>\n             tls = tlsa \\<and>\n             tlsa =\n             tmap (\\<lambda>(s, tl, s'). tl) id\n              (tfilter None\n                (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n                (tllist_of_llist\n                  \\<lfloor>llast\n                            (LCons s\n                              (lmap (\\<lambda>(s, tl, s'). s')\n                                stlss))\\<rfloor>\n                  stlss)) \\<and>\n             Runs_table s stlss) \\<or>\n         s'' \\<Down> tls))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa stlss.\n           s'' = s \\<and>\n           tls = tlsa \\<and>\n           tlsa =\n           tmap (\\<lambda>(s, tl, s'). tl) id\n            (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              (tllist_of_llist\n                \\<lfloor>llast\n                          (LCons s\n                            (lmap (\\<lambda>(s, tl, s'). s')\n                              stlss))\\<rfloor>\n                stlss)) \\<and>\n           Runs_table s stlss) \\<or>\n       s'' \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      tls = TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      tls = TNil None \\<and> s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      tls = TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsa stlss.\n           s'' = s \\<and>\n           tls = tlsa \\<and>\n           tlsa =\n           tmap (\\<lambda>(s, tl, s'). tl) id\n            (tfilter None (\\<lambda>(s, tl, s'). \\<not> \\<tau>move s tl s')\n              (tllist_of_llist\n                \\<lfloor>llast\n                          (LCons s\n                            (lmap (\\<lambda>(s, tl, s'). s')\n                              stlss))\\<rfloor>\n                stlss)) \\<and>\n           Runs_table s stlss) \\<or>\n       s'' \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_table2_into_\\<tau>Runs:\n  \"\\<tau>Runs_table2 s tlsstlss\n  \\<Longrightarrow> s \\<Down> tmap (\\<lambda>(tls, s', tl, s''). tl) (\\<lambda>x. case x of Inl (tls, s') \\<Rightarrow> Some s' | Inr _ \\<Rightarrow> None) tlsstlss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Runs_table2 s tlsstlss \\<Longrightarrow>\n    s \\<Down> tmap (\\<lambda>(tls, s', tl, s''). tl)\n               (\\<lambda>x.\n                   case x of\n                   Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n                   | Inr x \\<Rightarrow> Map.empty x)\n               tlsstlss", "proof(coinduction arbitrary: s tlsstlss)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tlsstlss.\n       \\<tau>Runs_table2 s tlsstlss \\<Longrightarrow>\n       (\\<exists>sa s'.\n           s = sa \\<and>\n           tmap (\\<lambda>(tls, s', tl, s''). tl)\n            (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n            tlsstlss =\n           TNil \\<lfloor>s'\\<rfloor> \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           tmap (\\<lambda>(tls, s', tl, s''). tl)\n            (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n            tlsstlss =\n           TNil None \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           tmap (\\<lambda>(tls, s', tl, s''). tl)\n            (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n            tlsstlss =\n           TCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsstlss.\n                s'' = s \\<and>\n                tls =\n                tmap (\\<lambda>(tls, s', tl, s''). tl)\n                 (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                   Map.empty)\n                 tlsstlss \\<and>\n                \\<tau>Runs_table2 s tlsstlss) \\<or>\n            s'' \\<Down> tls))", "case (\\<tau>Runs s tlsstlss)"], ["proof (state)\nthis:\n  \\<tau>Runs_table2 s tlsstlss\n\ngoal (1 subgoal):\n 1. \\<And>s tlsstlss.\n       \\<tau>Runs_table2 s tlsstlss \\<Longrightarrow>\n       (\\<exists>sa s'.\n           s = sa \\<and>\n           tmap (\\<lambda>(tls, s', tl, s''). tl)\n            (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n            tlsstlss =\n           TNil \\<lfloor>s'\\<rfloor> \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa.\n           s = sa \\<and>\n           tmap (\\<lambda>(tls, s', tl, s''). tl)\n            (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n            tlsstlss =\n           TNil None \\<and>\n           sa -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n       (\\<exists>sa s' s'' tls tl.\n           s = sa \\<and>\n           tmap (\\<lambda>(tls, s', tl, s''). tl)\n            (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n            tlsstlss =\n           TCons tl tls \\<and>\n           sa -\\<tau>\\<rightarrow>* s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tlsstlss.\n                s'' = s \\<and>\n                tls =\n                tmap (\\<lambda>(tls, s', tl, s''). tl)\n                 (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                   Map.empty)\n                 tlsstlss \\<and>\n                \\<tau>Runs_table2 s tlsstlss) \\<or>\n            s'' \\<Down> tls))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<tau>Runs_table2 s tlsstlss\n\ngoal (1 subgoal):\n 1. (\\<exists>s s'.\n        s = s \\<and>\n        tmap (\\<lambda>(tls, s', tl, s''). tl)\n         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n         tlsstlss =\n        TNil \\<lfloor>s'\\<rfloor> \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s.\n        s = s \\<and>\n        tmap (\\<lambda>(tls, s', tl, s''). tl)\n         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n         tlsstlss =\n        TNil None \\<and>\n        s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n    (\\<exists>s s' s'' tls tl.\n        s = s \\<and>\n        tmap (\\<lambda>(tls, s', tl, s''). tl)\n         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n         tlsstlss =\n        TCons tl tls \\<and>\n        s -\\<tau>\\<rightarrow>* s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tlsstlss.\n             s'' = s \\<and>\n             tls =\n             tmap (\\<lambda>(tls, s', tl, s''). tl)\n              (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n              tlsstlss \\<and>\n             \\<tau>Runs_table2 s tlsstlss) \\<or>\n         s'' \\<Down> tls))", "by cases(auto intro: silent_moves2_into_silent_moves inf_step_silent_move2_into_\\<tau>diverge)"], ["proof (state)\nthis:\n  (\\<exists>s s'.\n      s = s \\<and>\n      tmap (\\<lambda>(tls, s', tl, s''). tl)\n       (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n       tlsstlss =\n      TNil \\<lfloor>s'\\<rfloor> \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s.\n      s = s \\<and>\n      tmap (\\<lambda>(tls, s', tl, s''). tl)\n       (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n       tlsstlss =\n      TNil None \\<and>\n      s -\\<tau>\\<rightarrow> \\<infinity>) \\<or>\n  (\\<exists>s s' s'' tls tl.\n      s = s \\<and>\n      tmap (\\<lambda>(tls, s', tl, s''). tl)\n       (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n       tlsstlss =\n      TCons tl tls \\<and>\n      s -\\<tau>\\<rightarrow>* s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tlsstlss.\n           s'' = s \\<and>\n           tls =\n           tmap (\\<lambda>(tls, s', tl, s''). tl)\n            (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n            tlsstlss \\<and>\n           \\<tau>Runs_table2 s tlsstlss) \\<or>\n       s'' \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_into_\\<tau>Runs_table2:\n  assumes \"s \\<Down> tls\"\n  obtains tlsstlss\n  where \"\\<tau>Runs_table2 s tlsstlss\"\n  and \"tls = tmap (\\<lambda>(tls, s', tl, s''). tl) (\\<lambda>x. case x of Inl (tls, s') \\<Rightarrow> Some s' | Inr _ \\<Rightarrow> None) tlsstlss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?terminal = \"\\<lambda>s tls. case terminal tls of \n          None \\<Rightarrow> Inr (SOME tls'. trsys.inf_step silent_move2 s tls')\n        | Some s' \\<Rightarrow> let tls' = SOME tls'. silent_moves2 s tls' s' in Inl (tls', s')\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?P = \"\\<lambda>s tls (tls'', s', s''). silent_moves2 s tls'' s' \\<and> s' -thd tls\\<rightarrow> s'' \\<and> \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define tlsstlss where \"tlsstlss s tls = unfold_tllist\n      (\\<lambda>(s, tls). is_TNil tls)\n      (\\<lambda>(s, tls). ?terminal s tls)\n      (\\<lambda>(s, tls). let (tls'', s', s'') = Eps (?P s tls) in (tls'', s', thd tls, s''))\n      (\\<lambda>(s, tls). let (tls'', s', s'') = Eps (?P s tls) in (s'', ttl tls))\n      (s, tls)\"\n    for s tls"], ["proof (state)\nthis:\n  tlsstlss ?s ?tls =\n  unfold_tllist (\\<lambda>(s, tls). is_TNil tls)\n   (\\<lambda>(s, tls).\n       case terminal tls of\n       None \\<Rightarrow>\n         Inr (SOME tls'. trsys.inf_step silent_move2 s tls')\n       | \\<lfloor>s'\\<rfloor> \\<Rightarrow>\n           let tls' = SOME tls'. silent_moves2 s tls' s' in Inl (tls', s'))\n   (\\<lambda>(s, tls).\n       let (tls'', s', s'') =\n             SOME (tls'', s', s'').\n                silent_moves2 s tls'' s' \\<and>\n                s' -thd tls\\<rightarrow> s'' \\<and>\n                \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                s'' \\<Down> ttl tls\n       in (tls'', s', thd tls, s''))\n   (\\<lambda>(s, tls).\n       let (tls'', s', s'') =\n             SOME (tls'', s', s'').\n                silent_moves2 s tls'' s' \\<and>\n                s' -thd tls\\<rightarrow> s'' \\<and>\n                \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                s'' \\<Down> ttl tls\n       in (s'', ttl tls))\n   (?s, ?tls)\n\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]:\n    \"\\<And>s tls. is_TNil (tlsstlss s tls) \\<longleftrightarrow> is_TNil tls\"\n    \"\\<And>s tls. is_TNil tls \\<Longrightarrow> terminal (tlsstlss s tls) = ?terminal s tls\"\n    \"\\<And>s tls. \\<not> is_TNil tls \\<Longrightarrow> thd (tlsstlss s tls) = (let (tls'', s', s'') = Eps (?P s tls) in (tls'', s', thd tls, s''))\"\n    \"\\<And>s tls. \\<not> is_TNil tls \\<Longrightarrow> ttl (tlsstlss s tls) = (let (tls'', s', s'') = Eps (?P s tls) in tlsstlss s'' (ttl tls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>s tls. is_TNil (tlsstlss s tls) = is_TNil tls) &&&\n     (\\<And>s tls.\n         is_TNil tls \\<Longrightarrow>\n         terminal (tlsstlss s tls) =\n         (case terminal tls of\n          None \\<Rightarrow>\n            Inr (SOME tls'. trsys.inf_step silent_move2 s tls')\n          | \\<lfloor>s'\\<rfloor> \\<Rightarrow>\n              let tls' = SOME tls'. silent_moves2 s tls' s'\n              in Inl (tls', s')))) &&&\n    (\\<And>s tls.\n        \\<not> is_TNil tls \\<Longrightarrow>\n        thd (tlsstlss s tls) =\n        (let (tls'', s', s'') =\n               SOME (tls'', s', s'').\n                  silent_moves2 s tls'' s' \\<and>\n                  s' -thd tls\\<rightarrow> s'' \\<and>\n                  \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                  s'' \\<Down> ttl tls\n         in (tls'', s', thd tls, s''))) &&&\n    (\\<And>s tls.\n        \\<not> is_TNil tls \\<Longrightarrow>\n        ttl (tlsstlss s tls) =\n        (let (tls'', s', s'') =\n               SOME (tls'', s', s'').\n                  silent_moves2 s tls'' s' \\<and>\n                  s' -thd tls\\<rightarrow> s'' \\<and>\n                  \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                  s'' \\<Down> ttl tls\n         in tlsstlss s'' (ttl tls)))", "by(simp_all add: tlsstlss_def split_beta)"], ["proof (state)\nthis:\n  is_TNil (tlsstlss ?s1 ?tls1) = is_TNil ?tls1\n  is_TNil ?tls1 \\<Longrightarrow>\n  terminal (tlsstlss ?s1 ?tls1) =\n  (case terminal ?tls1 of\n   None \\<Rightarrow> Inr (SOME tls'. trsys.inf_step silent_move2 ?s1 tls')\n   | \\<lfloor>s'\\<rfloor> \\<Rightarrow>\n       let tls' = SOME tls'. silent_moves2 ?s1 tls' s' in Inl (tls', s'))\n  \\<not> is_TNil ?tls1 \\<Longrightarrow>\n  thd (tlsstlss ?s1 ?tls1) =\n  (let (tls'', s', s'') =\n         SOME (tls'', s', s'').\n            silent_moves2 ?s1 tls'' s' \\<and>\n            s' -thd ?tls1\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' (thd ?tls1) s'' \\<and>\n            s'' \\<Down> ttl ?tls1\n   in (tls'', s', thd ?tls1, s''))\n  \\<not> is_TNil ?tls1 \\<Longrightarrow>\n  ttl (tlsstlss ?s1 ?tls1) =\n  (let (tls'', s', s'') =\n         SOME (tls'', s', s'').\n            silent_moves2 ?s1 tls'' s' \\<and>\n            s' -thd ?tls1\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' (thd ?tls1) s'' \\<and>\n            s'' \\<Down> ttl ?tls1\n   in tlsstlss s'' (ttl ?tls1))\n\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]:\n    \"\\<And>s. tlsstlss s (TNil None) = TNil (Inr (SOME tls'. trsys.inf_step silent_move2 s tls'))\"\n    \"\\<And>s s'. tlsstlss s (TNil (Some s')) = TNil (Inl (SOME tls'. silent_moves2 s tls' s', s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        tlsstlss s (TNil None) =\n        TNil (Inr (SOME tls'. trsys.inf_step silent_move2 s tls'))) &&&\n    (\\<And>s s'.\n        tlsstlss s (TNil \\<lfloor>s'\\<rfloor>) =\n        TNil (Inl (SOME tls'. silent_moves2 s tls' s', s')))", "unfolding tlsstlss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        unfold_tllist (\\<lambda>(s, y). is_TNil y)\n         (\\<lambda>(s, tls).\n             case terminal tls of\n             None \\<Rightarrow> Inr (Eps (trsys.inf_step silent_move2 s))\n             | \\<lfloor>s'\\<rfloor> \\<Rightarrow>\n                 let tls' = SOME tls'. silent_moves2 s tls' s'\n                 in Inl (tls', s'))\n         (\\<lambda>(s, tls).\n             let (tls'', s', s'') =\n                   SOME (tls'', s', s'').\n                      silent_moves2 s tls'' s' \\<and>\n                      s' -thd tls\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                      s'' \\<Down> ttl tls\n             in (tls'', s', thd tls, s''))\n         (\\<lambda>(s, tls).\n             let (tls'', s', s'') =\n                   SOME (tls'', s', s'').\n                      silent_moves2 s tls'' s' \\<and>\n                      s' -thd tls\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                      s'' \\<Down> ttl tls\n             in (s'', ttl tls))\n         (s, TNil None) =\n        TNil (Inr (SOME tls'. trsys.inf_step silent_move2 s tls'))) &&&\n    (\\<And>s s'.\n        unfold_tllist (\\<lambda>(s, y). is_TNil y)\n         (\\<lambda>(s, tls).\n             case terminal tls of\n             None \\<Rightarrow> Inr (Eps (trsys.inf_step silent_move2 s))\n             | \\<lfloor>s'\\<rfloor> \\<Rightarrow>\n                 let tls' = SOME tls'. silent_moves2 s tls' s'\n                 in Inl (tls', s'))\n         (\\<lambda>(s, tls).\n             let (tls'', s', s'') =\n                   SOME (tls'', s', s'').\n                      silent_moves2 s tls'' s' \\<and>\n                      s' -thd tls\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                      s'' \\<Down> ttl tls\n             in (tls'', s', thd tls, s''))\n         (\\<lambda>(s, tls).\n             let (tls'', s', s'') =\n                   SOME (tls'', s', s'').\n                      silent_moves2 s tls'' s' \\<and>\n                      s' -thd tls\\<rightarrow> s'' \\<and>\n                      \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                      s'' \\<Down> ttl tls\n             in (s'', ttl tls))\n         (s, TNil \\<lfloor>s'\\<rfloor>) =\n        TNil (Inl (SOME tls'. silent_moves2 s tls' s', s')))", "by simp_all"], ["proof (state)\nthis:\n  tlsstlss ?s1 (TNil None) =\n  TNil (Inr (SOME tls'. trsys.inf_step silent_move2 ?s1 tls'))\n  tlsstlss ?s1 (TNil \\<lfloor>?s'1\\<rfloor>) =\n  TNil (Inl (SOME tls'. silent_moves2 ?s1 tls' ?s'1, ?s'1))\n\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?conv = \"tmap (\\<lambda>(tls, s', tl, s''). tl) (\\<lambda>x. case x of Inl (tls, s') \\<Rightarrow> Some s' | Inr _ \\<Rightarrow> None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  s \\<Down> tls", "have \"\\<tau>Runs_table2 s (tlsstlss s tls)\""], ["proof (prove)\nusing this:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. \\<tau>Runs_table2 s (tlsstlss s tls)", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s \\<Down> tls \\<Longrightarrow>\n       (\\<exists>sa tlsa s'.\n           s = sa \\<and>\n           tlsstlss s tls = TNil (Inl (tlsa, s')) \\<and>\n           silent_moves2 sa tlsa s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa tlsa.\n           s = sa \\<and>\n           tlsstlss s tls = TNil (Inr tlsa) \\<and>\n           trsys.inf_step silent_move2 sa tlsa) \\<or>\n       (\\<exists>sa tlsa s' s'' tlsstlssa tl.\n           s = sa \\<and>\n           tlsstlss s tls = TCons (tlsa, s', tl, s'') tlsstlssa \\<and>\n           silent_moves2 sa tlsa s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tls.\n                s'' = s \\<and>\n                tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n            \\<tau>Runs_table2 s'' tlsstlssa))", "case (\\<tau>Runs_table2 s tls)"], ["proof (state)\nthis:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s \\<Down> tls \\<Longrightarrow>\n       (\\<exists>sa tlsa s'.\n           s = sa \\<and>\n           tlsstlss s tls = TNil (Inl (tlsa, s')) \\<and>\n           silent_moves2 sa tlsa s' \\<and>\n           (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa tlsa.\n           s = sa \\<and>\n           tlsstlss s tls = TNil (Inr tlsa) \\<and>\n           trsys.inf_step silent_move2 sa tlsa) \\<or>\n       (\\<exists>sa tlsa s' s'' tlsstlssa tl.\n           s = sa \\<and>\n           tlsstlss s tls = TCons (tlsa, s', tl, s'') tlsstlssa \\<and>\n           silent_moves2 sa tlsa s' \\<and>\n           s' -tl\\<rightarrow> s'' \\<and>\n           \\<not> \\<tau>move s' tl s'' \\<and>\n           ((\\<exists>s tls.\n                s'' = s \\<and>\n                tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n            \\<tau>Runs_table2 s'' tlsstlssa))", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. (\\<exists>s tls s'.\n        s = s \\<and>\n        tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n        silent_moves2 s tls s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s tls.\n        s = s \\<and>\n        tlsstlss s tls = TNil (Inr tls) \\<and>\n        trsys.inf_step silent_move2 s tls) \\<or>\n    (\\<exists>s tls s' s'' tlsstlssa tl.\n        s = s \\<and>\n        tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n        silent_moves2 s tls s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tls.\n             s'' = s \\<and>\n             tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n         \\<tau>Runs_table2 s'' tlsstlssa))", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "case (Terminate s')"], ["proof (state)\nthis:\n  tls = TNil \\<lfloor>s'\\<rfloor>\n  s -\\<tau>\\<rightarrow>* s'\n  \\<not> s' -?tl2\\<rightarrow> ?s''2\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "let ?P = \"\\<lambda>tls'. silent_moves2 s tls' s'\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "from \\<open>s -\\<tau>\\<rightarrow>* s'\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* s'", "obtain tls' where \"?P tls'\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. (\\<And>tls'.\n        silent_moves2 s tls' s' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: silent_moves_into_silent_moves2)"], ["proof (state)\nthis:\n  silent_moves2 s tls' s'\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "hence \"?P (Eps ?P)\""], ["proof (prove)\nusing this:\n  silent_moves2 s tls' s'\n\ngoal (1 subgoal):\n 1. silent_moves2 s (SOME tls'. silent_moves2 s tls' s') s'", "by(rule someI)"], ["proof (state)\nthis:\n  silent_moves2 s (SOME tls'. silent_moves2 s tls' s') s'\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "with Terminate"], ["proof (chain)\npicking this:\n  tls = TNil \\<lfloor>s'\\<rfloor>\n  s -\\<tau>\\<rightarrow>* s'\n  \\<not> s' -?tl2\\<rightarrow> ?s''2\n  silent_moves2 s (SOME tls'. silent_moves2 s tls' s') s'", "have ?Terminate"], ["proof (prove)\nusing this:\n  tls = TNil \\<lfloor>s'\\<rfloor>\n  s -\\<tau>\\<rightarrow>* s'\n  \\<not> s' -?tl2\\<rightarrow> ?s''2\n  silent_moves2 s (SOME tls'. silent_moves2 s tls' s') s'\n\ngoal (1 subgoal):\n 1. \\<exists>s tls s'.\n       s = s \\<and>\n       tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n       silent_moves2 s tls s' \\<and>\n       (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s tls s'.\n     s = s \\<and>\n     tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n     silent_moves2 s tls s' \\<and>\n     (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s tls s'.\n     s = s \\<and>\n     tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n     silent_moves2 s tls s' \\<and>\n     (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s tls s'.\n        s = s \\<and>\n        tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n        silent_moves2 s tls s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s tls.\n        s = s \\<and>\n        tlsstlss s tls = TNil (Inr tls) \\<and>\n        trsys.inf_step silent_move2 s tls) \\<or>\n    (\\<exists>s tls s' s'' tlsstlssa tl.\n        s = s \\<and>\n        tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n        silent_moves2 s tls s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tls.\n             s'' = s \\<and>\n             tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n         \\<tau>Runs_table2 s'' tlsstlssa))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s tls s'.\n      s = s \\<and>\n      tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n      silent_moves2 s tls s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s tls.\n      s = s \\<and>\n      tlsstlss s tls = TNil (Inr tls) \\<and>\n      trsys.inf_step silent_move2 s tls) \\<or>\n  (\\<exists>s tls s' s'' tlsstlssa tl.\n      s = s \\<and>\n      tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n      silent_moves2 s tls s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tls.\n           s'' = s \\<and>\n           tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n       \\<tau>Runs_table2 s'' tlsstlssa))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "case Diverge"], ["proof (state)\nthis:\n  tls = TNil None\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "let ?P = \"\\<lambda>tls'. trsys.inf_step silent_move2 s tls'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "from \\<open>s -\\<tau>\\<rightarrow> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow> \\<infinity>", "obtain tls' where \"?P tls'\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>tls'.\n        trsys.inf_step silent_move2 s tls' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(rule \\<tau>diverge_into_inf_step_silent_move2)"], ["proof (state)\nthis:\n  trsys.inf_step silent_move2 s tls'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "hence \"?P (Eps ?P)\""], ["proof (prove)\nusing this:\n  trsys.inf_step silent_move2 s tls'\n\ngoal (1 subgoal):\n 1. trsys.inf_step silent_move2 s\n     (SOME tls'. trsys.inf_step silent_move2 s tls')", "by(rule someI)"], ["proof (state)\nthis:\n  trsys.inf_step silent_move2 s\n   (SOME tls'. trsys.inf_step silent_move2 s tls')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "hence ?Diverge"], ["proof (prove)\nusing this:\n  trsys.inf_step silent_move2 s\n   (SOME tls'. trsys.inf_step silent_move2 s tls')\n\ngoal (1 subgoal):\n 1. \\<exists>s tls.\n       s = s \\<and>\n       tlsstlss s tls = TNil (Inr tls) \\<and>\n       trsys.inf_step silent_move2 s tls", "using \\<open>tls = TNil None\\<close>"], ["proof (prove)\nusing this:\n  trsys.inf_step silent_move2 s\n   (SOME tls'. trsys.inf_step silent_move2 s tls')\n  tls = TNil None\n\ngoal (1 subgoal):\n 1. \\<exists>s tls.\n       s = s \\<and>\n       tlsstlss s tls = TNil (Inr tls) \\<and>\n       trsys.inf_step silent_move2 s tls", "by simp"], ["proof (state)\nthis:\n  \\<exists>s tls.\n     s = s \\<and>\n     tlsstlss s tls = TNil (Inr tls) \\<and>\n     trsys.inf_step silent_move2 s tls\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s tls s'.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s tls.\n                          s = s \\<and>\n                          tlsstlss s tls = TNil (Inr tls) \\<and>\n                          trsys.inf_step silent_move2 s tls) \\<or>\n                      (\\<exists>s tls s' s'' tlsstlssa tl.\n                          s = s \\<and>\n                          tlsstlss s tls =\n                          TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                          silent_moves2 s tls s' \\<and>\n                          s' -tl\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' tl s'' \\<and>\n                          ((\\<exists>s tls.\n                               s'' = s \\<and>\n                               tlsstlssa = tlsstlss s tls \\<and>\n                               s \\<Down> tls) \\<or>\n                           \\<tau>Runs_table2 s'' tlsstlssa))\n 2. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s tls.\n     s = s \\<and>\n     tlsstlss s tls = TNil (Inr tls) \\<and>\n     trsys.inf_step silent_move2 s tls\n\ngoal (1 subgoal):\n 1. (\\<exists>s tls s'.\n        s = s \\<and>\n        tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n        silent_moves2 s tls s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s tls.\n        s = s \\<and>\n        tlsstlss s tls = TNil (Inr tls) \\<and>\n        trsys.inf_step silent_move2 s tls) \\<or>\n    (\\<exists>s tls s' s'' tlsstlssa tl.\n        s = s \\<and>\n        tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n        silent_moves2 s tls s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tls.\n             s'' = s \\<and>\n             tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n         \\<tau>Runs_table2 s'' tlsstlssa))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s tls s'.\n      s = s \\<and>\n      tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n      silent_moves2 s tls s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s tls.\n      s = s \\<and>\n      tlsstlss s tls = TNil (Inr tls) \\<and>\n      trsys.inf_step silent_move2 s tls) \\<or>\n  (\\<exists>s tls s' s'' tlsstlssa tl.\n      s = s \\<and>\n      tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n      silent_moves2 s tls s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tls.\n           s'' = s \\<and>\n           tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n       \\<tau>Runs_table2 s'' tlsstlssa))\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "case (Proceed s' s'' tls' tl)"], ["proof (state)\nthis:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "from \\<open>s -\\<tau>\\<rightarrow>* s'\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* s'", "obtain tls'' where \"silent_moves2 s tls'' s'\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. (\\<And>tls''.\n        silent_moves2 s tls'' s' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: silent_moves_into_silent_moves2)"], ["proof (state)\nthis:\n  silent_moves2 s tls'' s'\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "with Proceed"], ["proof (chain)\npicking this:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n  silent_moves2 s tls'' s'", "have \"?P s tls (tls'', s', s'')\""], ["proof (prove)\nusing this:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n  silent_moves2 s tls'' s'\n\ngoal (1 subgoal):\n 1. case (tls'', s', s'') of\n    (tls'', s', s'') \\<Rightarrow>\n      silent_moves2 s tls'' s' \\<and>\n      s' -thd tls\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls", "by simp"], ["proof (state)\nthis:\n  case (tls'', s', s'') of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "hence \"?P s tls (Eps (?P s tls))\""], ["proof (prove)\nusing this:\n  case (tls'', s', s'') of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n\ngoal (1 subgoal):\n 1. case SOME (tls'', s', s'').\n            silent_moves2 s tls'' s' \\<and>\n            s' -thd tls\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n    (tls'', s', s'') \\<Rightarrow>\n      silent_moves2 s tls'' s' \\<and>\n      s' -thd tls\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (tls'', s', s'').\n          silent_moves2 s tls'' s' \\<and>\n          s' -thd tls\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "hence ?Proceed"], ["proof (prove)\nusing this:\n  case SOME (tls'', s', s'').\n          silent_moves2 s tls'' s' \\<and>\n          s' -thd tls\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n\ngoal (1 subgoal):\n 1. \\<exists>s tls s' s'' tlsstlssa tl.\n       s = s \\<and>\n       tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n       silent_moves2 s tls s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s tls.\n            s'' = s \\<and>\n            tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n        \\<tau>Runs_table2 s'' tlsstlssa)", "using Proceed"], ["proof (prove)\nusing this:\n  case SOME (tls'', s', s'').\n          silent_moves2 s tls'' s' \\<and>\n          s' -thd tls\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<exists>s tls s' s'' tlsstlssa tl.\n       s = s \\<and>\n       tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n       silent_moves2 s tls s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s tls.\n            s'' = s \\<and>\n            tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n        \\<tau>Runs_table2 s'' tlsstlssa)", "unfolding tlsstlss_def"], ["proof (prove)\nusing this:\n  case SOME (tls'', s', s'').\n          silent_moves2 s tls'' s' \\<and>\n          s' -thd tls\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n\ngoal (1 subgoal):\n 1. \\<exists>s tls s' s'' tlsstlss tl.\n       s = s \\<and>\n       unfold_tllist (\\<lambda>(s, y). is_TNil y)\n        (\\<lambda>(s, tls).\n            case terminal tls of\n            None \\<Rightarrow> Inr (Eps (trsys.inf_step silent_move2 s))\n            | \\<lfloor>s'\\<rfloor> \\<Rightarrow>\n                let tls' = SOME tls'. silent_moves2 s tls' s'\n                in Inl (tls', s'))\n        (\\<lambda>(s, tls).\n            let (tls'', s', s'') =\n                  SOME (tls'', s', s'').\n                     silent_moves2 s tls'' s' \\<and>\n                     s' -thd tls\\<rightarrow> s'' \\<and>\n                     \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                     s'' \\<Down> ttl tls\n            in (tls'', s', thd tls, s''))\n        (\\<lambda>(s, tls).\n            let (tls'', s', s'') =\n                  SOME (tls'', s', s'').\n                     silent_moves2 s tls'' s' \\<and>\n                     s' -thd tls\\<rightarrow> s'' \\<and>\n                     \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                     s'' \\<Down> ttl tls\n            in (s'', ttl tls))\n        (s, tls) =\n       TCons (tls, s', tl, s'') tlsstlss \\<and>\n       silent_moves2 s tls s' \\<and>\n       s' -tl\\<rightarrow> s'' \\<and>\n       \\<not> \\<tau>move s' tl s'' \\<and>\n       ((\\<exists>s tls.\n            s'' = s \\<and>\n            tlsstlss =\n            unfold_tllist (\\<lambda>(s, y). is_TNil y)\n             (\\<lambda>(s, tls).\n                 case terminal tls of\n                 None \\<Rightarrow>\n                   Inr (Eps (trsys.inf_step silent_move2 s))\n                 | \\<lfloor>s'\\<rfloor> \\<Rightarrow>\n                     let tls' = SOME tls'. silent_moves2 s tls' s'\n                     in Inl (tls', s'))\n             (\\<lambda>(s, tls).\n                 let (tls'', s', s'') =\n                       SOME (tls'', s', s'').\n                          silent_moves2 s tls'' s' \\<and>\n                          s' -thd tls\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                          s'' \\<Down> ttl tls\n                 in (tls'', s', thd tls, s''))\n             (\\<lambda>(s, tls).\n                 let (tls'', s', s'') =\n                       SOME (tls'', s', s'').\n                          silent_moves2 s tls'' s' \\<and>\n                          s' -thd tls\\<rightarrow> s'' \\<and>\n                          \\<not> \\<tau>move s' (thd tls) s'' \\<and>\n                          s'' \\<Down> ttl tls\n                 in (s'', ttl tls))\n             (s, tls) \\<and>\n            s \\<Down> tls) \\<or>\n        \\<tau>Runs_table2 s'' tlsstlss)", "by(subst unfold_tllist.code)(auto simp add: split_def)"], ["proof (state)\nthis:\n  \\<exists>s tls s' s'' tlsstlssa tl.\n     s = s \\<and>\n     tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n     silent_moves2 s tls s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s tls.\n          s'' = s \\<and>\n          tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n      \\<tau>Runs_table2 s'' tlsstlssa)\n\ngoal (1 subgoal):\n 1. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s tls s'.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             (\\<forall>x xa. \\<not> s' -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s tls.\n                             s = s \\<and>\n                             tlsstlss s tls = TNil (Inr tls) \\<and>\n                             trsys.inf_step silent_move2 s tls) \\<or>\n                         (\\<exists>s tls s' s'' tlsstlssa tl.\n                             s = s \\<and>\n                             tlsstlss s tls =\n                             TCons (tls, s', tl, s'') tlsstlssa \\<and>\n                             silent_moves2 s tls s' \\<and>\n                             s' -tl\\<rightarrow> s'' \\<and>\n                             \\<not> \\<tau>move s' tl s'' \\<and>\n                             ((\\<exists>s tls.\n                                  s'' = s \\<and>\n                                  tlsstlssa = tlsstlss s tls \\<and>\n                                  s \\<Down> tls) \\<or>\n                              \\<tau>Runs_table2 s'' tlsstlssa))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s tls s' s'' tlsstlssa tl.\n     s = s \\<and>\n     tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n     silent_moves2 s tls s' \\<and>\n     s' -tl\\<rightarrow> s'' \\<and>\n     \\<not> \\<tau>move s' tl s'' \\<and>\n     ((\\<exists>s tls.\n          s'' = s \\<and>\n          tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n      \\<tau>Runs_table2 s'' tlsstlssa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s tls s'.\n        s = s \\<and>\n        tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n        silent_moves2 s tls s' \\<and>\n        (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s tls.\n        s = s \\<and>\n        tlsstlss s tls = TNil (Inr tls) \\<and>\n        trsys.inf_step silent_move2 s tls) \\<or>\n    (\\<exists>s tls s' s'' tlsstlssa tl.\n        s = s \\<and>\n        tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n        silent_moves2 s tls s' \\<and>\n        s' -tl\\<rightarrow> s'' \\<and>\n        \\<not> \\<tau>move s' tl s'' \\<and>\n        ((\\<exists>s tls.\n             s'' = s \\<and>\n             tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n         \\<tau>Runs_table2 s'' tlsstlssa))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>s tls s'.\n      s = s \\<and>\n      tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n      silent_moves2 s tls s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s tls.\n      s = s \\<and>\n      tlsstlss s tls = TNil (Inr tls) \\<and>\n      trsys.inf_step silent_move2 s tls) \\<or>\n  (\\<exists>s tls s' s'' tlsstlssa tl.\n      s = s \\<and>\n      tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n      silent_moves2 s tls s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tls.\n           s'' = s \\<and>\n           tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n       \\<tau>Runs_table2 s'' tlsstlssa))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s tls s'.\n      s = s \\<and>\n      tlsstlss s tls = TNil (Inl (tls, s')) \\<and>\n      silent_moves2 s tls s' \\<and>\n      (\\<forall>x xa. \\<not> s' -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s tls.\n      s = s \\<and>\n      tlsstlss s tls = TNil (Inr tls) \\<and>\n      trsys.inf_step silent_move2 s tls) \\<or>\n  (\\<exists>s tls s' s'' tlsstlssa tl.\n      s = s \\<and>\n      tlsstlss s tls = TCons (tls, s', tl, s'') tlsstlssa \\<and>\n      silent_moves2 s tls s' \\<and>\n      s' -tl\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' tl s'' \\<and>\n      ((\\<exists>s tls.\n           s'' = s \\<and>\n           tlsstlssa = tlsstlss s tls \\<and> s \\<Down> tls) \\<or>\n       \\<tau>Runs_table2 s'' tlsstlssa))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>Runs_table2 s (tlsstlss s tls)\n\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<tau>Runs_table2 s (tlsstlss s tls)\n\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  s \\<Down> tls", "have \"tls = ?conv (tlsstlss s tls)\""], ["proof (prove)\nusing this:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. tls =\n    tmap (\\<lambda>(tls, s', tl, s''). tl)\n     (\\<lambda>x.\n         case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n         | Inr x \\<Rightarrow> Map.empty x)\n     (tlsstlss s tls)", "proof(coinduction arbitrary: s tls)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s \\<Down> tls \\<Longrightarrow>\n       is_TNil tls =\n       is_TNil\n        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n          (tlsstlss s tls)) \\<and>\n       (is_TNil tls \\<longrightarrow>\n        is_TNil\n         (tmap (\\<lambda>(tls, s', tl, s''). tl)\n           (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n           (tlsstlss s tls)) \\<longrightarrow>\n        terminal tls =\n        terminal\n         (tmap (\\<lambda>(tls, s', tl, s''). tl)\n           (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n           (tlsstlss s tls))) \\<and>\n       (\\<not> is_TNil tls \\<longrightarrow>\n        \\<not> is_TNil\n                (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                  (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                    Map.empty)\n                  (tlsstlss s tls)) \\<longrightarrow>\n        thd tls =\n        thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n              (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n              (tlsstlss s tls)) \\<and>\n        (\\<exists>sa tlsa.\n            ttl tls = tlsa \\<and>\n            ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                  (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                    Map.empty)\n                  (tlsstlss s tls)) =\n            tmap (\\<lambda>(tls, s', tl, s''). tl)\n             (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n             (tlsstlss sa tlsa) \\<and>\n            sa \\<Down> tlsa))", "case (Eq_tllist s tls)"], ["proof (state)\nthis:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. \\<And>s tls.\n       s \\<Down> tls \\<Longrightarrow>\n       is_TNil tls =\n       is_TNil\n        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n          (tlsstlss s tls)) \\<and>\n       (is_TNil tls \\<longrightarrow>\n        is_TNil\n         (tmap (\\<lambda>(tls, s', tl, s''). tl)\n           (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n           (tlsstlss s tls)) \\<longrightarrow>\n        terminal tls =\n        terminal\n         (tmap (\\<lambda>(tls, s', tl, s''). tl)\n           (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n           (tlsstlss s tls))) \\<and>\n       (\\<not> is_TNil tls \\<longrightarrow>\n        \\<not> is_TNil\n                (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                  (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                    Map.empty)\n                  (tlsstlss s tls)) \\<longrightarrow>\n        thd tls =\n        thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n              (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n              (tlsstlss s tls)) \\<and>\n        (\\<exists>sa tlsa.\n            ttl tls = tlsa \\<and>\n            ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                  (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                    Map.empty)\n                  (tlsstlss s tls)) =\n            tmap (\\<lambda>(tls, s', tl, s''). tl)\n             (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n             (tlsstlss sa tlsa) \\<and>\n            sa \\<Down> tlsa))", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<Down> tls\n\ngoal (1 subgoal):\n 1. is_TNil tls =\n    is_TNil\n     (tmap (\\<lambda>(tls, s', tl, s''). tl)\n       (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n       (tlsstlss s tls)) \\<and>\n    (is_TNil tls \\<longrightarrow>\n     is_TNil\n      (tmap (\\<lambda>(tls, s', tl, s''). tl)\n        (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n        (tlsstlss s tls)) \\<longrightarrow>\n     terminal tls =\n     terminal\n      (tmap (\\<lambda>(tls, s', tl, s''). tl)\n        (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n        (tlsstlss s tls))) \\<and>\n    (\\<not> is_TNil tls \\<longrightarrow>\n     \\<not> is_TNil\n             (tmap (\\<lambda>(tls, s', tl, s''). tl)\n               (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n               (tlsstlss s tls)) \\<longrightarrow>\n     thd tls =\n     thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n           (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n           (tlsstlss s tls)) \\<and>\n     (\\<exists>s tls.\n         ttl tls = tls \\<and>\n         ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n               (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n               (tlsstlss s tls)) =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n          (tlsstlss s tls) \\<and>\n         s \\<Down> tls))", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil tls =\n                      is_TNil\n                       (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                           Map.empty)\n                         (tlsstlss s tls)) \\<and>\n                      (is_TNil tls \\<longrightarrow>\n                       is_TNil\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls)) \\<longrightarrow>\n                       terminal tls =\n                       terminal\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls))) \\<and>\n                      (\\<not> is_TNil tls \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) \\<longrightarrow>\n                       thd tls =\n                       thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<and>\n                       (\\<exists>s tls.\n                           ttl tls = tls \\<and>\n                           ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) =\n                           tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls) \\<and>\n                           s \\<Down> tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))", "case (Proceed s' s'' tls' tl)"], ["proof (state)\nthis:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil tls =\n                      is_TNil\n                       (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                           Map.empty)\n                         (tlsstlss s tls)) \\<and>\n                      (is_TNil tls \\<longrightarrow>\n                       is_TNil\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls)) \\<longrightarrow>\n                       terminal tls =\n                       terminal\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls))) \\<and>\n                      (\\<not> is_TNil tls \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) \\<longrightarrow>\n                       thd tls =\n                       thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<and>\n                       (\\<exists>s tls.\n                           ttl tls = tls \\<and>\n                           ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) =\n                           tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls) \\<and>\n                           s \\<Down> tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))", "from \\<open>s -\\<tau>\\<rightarrow>* s'\\<close>"], ["proof (chain)\npicking this:\n  s -\\<tau>\\<rightarrow>* s'", "obtain tls'' where \"silent_moves2 s tls'' s'\""], ["proof (prove)\nusing this:\n  s -\\<tau>\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. (\\<And>tls''.\n        silent_moves2 s tls'' s' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: silent_moves_into_silent_moves2)"], ["proof (state)\nthis:\n  silent_moves2 s tls'' s'\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil tls =\n                      is_TNil\n                       (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                           Map.empty)\n                         (tlsstlss s tls)) \\<and>\n                      (is_TNil tls \\<longrightarrow>\n                       is_TNil\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls)) \\<longrightarrow>\n                       terminal tls =\n                       terminal\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls))) \\<and>\n                      (\\<not> is_TNil tls \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) \\<longrightarrow>\n                       thd tls =\n                       thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<and>\n                       (\\<exists>s tls.\n                           ttl tls = tls \\<and>\n                           ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) =\n                           tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls) \\<and>\n                           s \\<Down> tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))", "with Proceed"], ["proof (chain)\npicking this:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n  silent_moves2 s tls'' s'", "have \"?P s tls (tls'', s', s'')\""], ["proof (prove)\nusing this:\n  tls = TCons tl tls'\n  s -\\<tau>\\<rightarrow>* s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  s'' \\<Down> tls'\n  silent_moves2 s tls'' s'\n\ngoal (1 subgoal):\n 1. case (tls'', s', s'') of\n    (tls'', s', s'') \\<Rightarrow>\n      silent_moves2 s tls'' s' \\<and>\n      s' -thd tls\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls", "by simp"], ["proof (state)\nthis:\n  case (tls'', s', s'') of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil tls =\n                      is_TNil\n                       (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                           Map.empty)\n                         (tlsstlss s tls)) \\<and>\n                      (is_TNil tls \\<longrightarrow>\n                       is_TNil\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls)) \\<longrightarrow>\n                       terminal tls =\n                       terminal\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls))) \\<and>\n                      (\\<not> is_TNil tls \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) \\<longrightarrow>\n                       thd tls =\n                       thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<and>\n                       (\\<exists>s tls.\n                           ttl tls = tls \\<and>\n                           ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) =\n                           tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls) \\<and>\n                           s \\<Down> tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))", "hence \"?P s tls (Eps (?P s tls))\""], ["proof (prove)\nusing this:\n  case (tls'', s', s'') of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n\ngoal (1 subgoal):\n 1. case SOME (tls'', s', s'').\n            silent_moves2 s tls'' s' \\<and>\n            s' -thd tls\\<rightarrow> s'' \\<and>\n            \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n    (tls'', s', s'') \\<Rightarrow>\n      silent_moves2 s tls'' s' \\<and>\n      s' -thd tls\\<rightarrow> s'' \\<and>\n      \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls", "by(rule someI)"], ["proof (state)\nthis:\n  case SOME (tls'', s', s'').\n          silent_moves2 s tls'' s' \\<and>\n          s' -thd tls\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n\ngoal (3 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil tls =\n                      is_TNil\n                       (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                           Map.empty)\n                         (tlsstlss s tls)) \\<and>\n                      (is_TNil tls \\<longrightarrow>\n                       is_TNil\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls)) \\<longrightarrow>\n                       terminal tls =\n                       terminal\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls))) \\<and>\n                      (\\<not> is_TNil tls \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) \\<longrightarrow>\n                       thd tls =\n                       thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<and>\n                       (\\<exists>s tls.\n                           ttl tls = tls \\<and>\n                           ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) =\n                           tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls) \\<and>\n                           s \\<Down> tls))\n 3. \\<And>s' s'' tls tl.\n       \\<lbrakk>tls = TCons tl tls; s -\\<tau>\\<rightarrow>* s';\n        s' -tl\\<rightarrow> s''; \\<not> \\<tau>move s' tl s'';\n        s'' \\<Down> tls\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  case SOME (tls'', s', s'').\n          silent_moves2 s tls'' s' \\<and>\n          s' -thd tls\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n\ngoal (1 subgoal):\n 1. is_TNil tls =\n    is_TNil\n     (tmap (\\<lambda>(tls, s', tl, s''). tl)\n       (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n       (tlsstlss s tls)) \\<and>\n    (is_TNil tls \\<longrightarrow>\n     is_TNil\n      (tmap (\\<lambda>(tls, s', tl, s''). tl)\n        (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n        (tlsstlss s tls)) \\<longrightarrow>\n     terminal tls =\n     terminal\n      (tmap (\\<lambda>(tls, s', tl, s''). tl)\n        (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n        (tlsstlss s tls))) \\<and>\n    (\\<not> is_TNil tls \\<longrightarrow>\n     \\<not> is_TNil\n             (tmap (\\<lambda>(tls, s', tl, s''). tl)\n               (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n               (tlsstlss s tls)) \\<longrightarrow>\n     thd tls =\n     thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n           (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n           (tlsstlss s tls)) \\<and>\n     (\\<exists>s tls.\n         ttl tls = tls \\<and>\n         ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n               (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n               (tlsstlss s tls)) =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n          (tlsstlss s tls) \\<and>\n         s \\<Down> tls))", "using \\<open>tls = TCons tl tls'\\<close>"], ["proof (prove)\nusing this:\n  case SOME (tls'', s', s'').\n          silent_moves2 s tls'' s' \\<and>\n          s' -thd tls\\<rightarrow> s'' \\<and>\n          \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls of\n  (tls'', s', s'') \\<Rightarrow>\n    silent_moves2 s tls'' s' \\<and>\n    s' -thd tls\\<rightarrow> s'' \\<and>\n    \\<not> \\<tau>move s' (thd tls) s'' \\<and> s'' \\<Down> ttl tls\n  tls = TCons tl tls'\n\ngoal (1 subgoal):\n 1. is_TNil tls =\n    is_TNil\n     (tmap (\\<lambda>(tls, s', tl, s''). tl)\n       (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n       (tlsstlss s tls)) \\<and>\n    (is_TNil tls \\<longrightarrow>\n     is_TNil\n      (tmap (\\<lambda>(tls, s', tl, s''). tl)\n        (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n        (tlsstlss s tls)) \\<longrightarrow>\n     terminal tls =\n     terminal\n      (tmap (\\<lambda>(tls, s', tl, s''). tl)\n        (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n        (tlsstlss s tls))) \\<and>\n    (\\<not> is_TNil tls \\<longrightarrow>\n     \\<not> is_TNil\n             (tmap (\\<lambda>(tls, s', tl, s''). tl)\n               (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n               (tlsstlss s tls)) \\<longrightarrow>\n     thd tls =\n     thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n           (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n           (tlsstlss s tls)) \\<and>\n     (\\<exists>s tls.\n         ttl tls = tls \\<and>\n         ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n               (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n               (tlsstlss s tls)) =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n          (tlsstlss s tls) \\<and>\n         s \\<Down> tls))", "by auto"], ["proof (state)\nthis:\n  is_TNil tls =\n  is_TNil\n   (tmap (\\<lambda>(tls, s', tl, s''). tl)\n     (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n     (tlsstlss s tls)) \\<and>\n  (is_TNil tls \\<longrightarrow>\n   is_TNil\n    (tmap (\\<lambda>(tls, s', tl, s''). tl)\n      (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n      (tlsstlss s tls)) \\<longrightarrow>\n   terminal tls =\n   terminal\n    (tmap (\\<lambda>(tls, s', tl, s''). tl)\n      (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n      (tlsstlss s tls))) \\<and>\n  (\\<not> is_TNil tls \\<longrightarrow>\n   \\<not> is_TNil\n           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n             (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n             (tlsstlss s tls)) \\<longrightarrow>\n   thd tls =\n   thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n         (tlsstlss s tls)) \\<and>\n   (\\<exists>s tls.\n       ttl tls = tls \\<and>\n       ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n             (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n             (tlsstlss s tls)) =\n       tmap (\\<lambda>(tls, s', tl, s''). tl)\n        (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n        (tlsstlss s tls) \\<and>\n       s \\<Down> tls))\n\ngoal (2 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>tls = TNil \\<lfloor>s'\\<rfloor>; s -\\<tau>\\<rightarrow>* s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> is_TNil tls =\n                         is_TNil\n                          (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls)) \\<and>\n                         (is_TNil tls \\<longrightarrow>\n                          is_TNil\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<longrightarrow>\n                          terminal tls =\n                          terminal\n                           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls))) \\<and>\n                         (\\<not> is_TNil tls \\<longrightarrow>\n                          \\<not> is_TNil\n                                  (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) \\<longrightarrow>\n                          thd tls =\n                          thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                (case_sum\n                                  (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                  Map.empty)\n                                (tlsstlss s tls)) \\<and>\n                          (\\<exists>s tls.\n                              ttl tls = tls \\<and>\n                              ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                    (case_sum\n(\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n                                    (tlsstlss s tls)) =\n                              tmap (\\<lambda>(tls, s', tl, s''). tl)\n                               (case_sum\n                                 (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                 Map.empty)\n                               (tlsstlss s tls) \\<and>\n                              s \\<Down> tls))\n 2. \\<lbrakk>tls = TNil None; s -\\<tau>\\<rightarrow> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> is_TNil tls =\n                      is_TNil\n                       (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                           Map.empty)\n                         (tlsstlss s tls)) \\<and>\n                      (is_TNil tls \\<longrightarrow>\n                       is_TNil\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls)) \\<longrightarrow>\n                       terminal tls =\n                       terminal\n                        (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                          (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                            Map.empty)\n                          (tlsstlss s tls))) \\<and>\n                      (\\<not> is_TNil tls \\<longrightarrow>\n                       \\<not> is_TNil\n                               (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) \\<longrightarrow>\n                       thd tls =\n                       thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                             (case_sum\n                               (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                               Map.empty)\n                             (tlsstlss s tls)) \\<and>\n                       (\\<exists>s tls.\n                           ttl tls = tls \\<and>\n                           ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n                                 (case_sum\n                                   (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                                   Map.empty)\n                                 (tlsstlss s tls)) =\n                           tmap (\\<lambda>(tls, s', tl, s''). tl)\n                            (case_sum\n                              (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>)\n                              Map.empty)\n                            (tlsstlss s tls) \\<and>\n                           s \\<Down> tls))", "qed auto"], ["proof (state)\nthis:\n  is_TNil tls =\n  is_TNil\n   (tmap (\\<lambda>(tls, s', tl, s''). tl)\n     (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n     (tlsstlss s tls)) \\<and>\n  (is_TNil tls \\<longrightarrow>\n   is_TNil\n    (tmap (\\<lambda>(tls, s', tl, s''). tl)\n      (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n      (tlsstlss s tls)) \\<longrightarrow>\n   terminal tls =\n   terminal\n    (tmap (\\<lambda>(tls, s', tl, s''). tl)\n      (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n      (tlsstlss s tls))) \\<and>\n  (\\<not> is_TNil tls \\<longrightarrow>\n   \\<not> is_TNil\n           (tmap (\\<lambda>(tls, s', tl, s''). tl)\n             (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n             (tlsstlss s tls)) \\<longrightarrow>\n   thd tls =\n   thd (tmap (\\<lambda>(tls, s', tl, s''). tl)\n         (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n         (tlsstlss s tls)) \\<and>\n   (\\<exists>s tls.\n       ttl tls = tls \\<and>\n       ttl (tmap (\\<lambda>(tls, s', tl, s''). tl)\n             (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n             (tlsstlss s tls)) =\n       tmap (\\<lambda>(tls, s', tl, s''). tl)\n        (case_sum (\\<lambda>(tls, y). \\<lfloor>y\\<rfloor>) Map.empty)\n        (tlsstlss s tls) \\<and>\n       s \\<Down> tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tls =\n  tmap (\\<lambda>(tls, s', tl, s''). tl)\n   (\\<lambda>x.\n       case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n       | Inr x \\<Rightarrow> Map.empty x)\n   (tlsstlss s tls)\n\ngoal (1 subgoal):\n 1. (\\<And>tlsstlss.\n        \\<lbrakk>\\<tau>Runs_table2 s tlsstlss;\n         tls =\n         tmap (\\<lambda>(tls, s', tl, s''). tl)\n          (\\<lambda>x.\n              case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n              | Inr x \\<Rightarrow> Map.empty x)\n          tlsstlss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau>Runs_table2 s (tlsstlss s tls)\n  tls =\n  tmap (\\<lambda>(tls, s', tl, s''). tl)\n   (\\<lambda>x.\n       case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n       | Inr x \\<Rightarrow> Map.empty x)\n   (tlsstlss s tls)", "show thesis"], ["proof (prove)\nusing this:\n  \\<tau>Runs_table2 s (tlsstlss s tls)\n  tls =\n  tmap (\\<lambda>(tls, s', tl, s''). tl)\n   (\\<lambda>x.\n       case x of Inl (tls, s') \\<Rightarrow> \\<lfloor>s'\\<rfloor>\n       | Inr x \\<Rightarrow> Map.empty x)\n   (tlsstlss s tls)\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_table2_into_Runs:\n  assumes \"\\<tau>Runs_table2 s tlsstlss\"\n  shows \"Runs s (lconcat (lappend (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl])) (llist_of_tllist tlsstlss)) (LCons (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls | Inr tls \\<Rightarrow> tls) LNil)))\"\n  (is \"Runs _ (?conv tlsstlss)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Runs s\n     (lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)))", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>Runs_table2 s tlsstlss\n\ngoal (1 subgoal):\n 1. Runs s\n     (lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)))", "proof(coinduction arbitrary: s tlsstlss)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s tlsstlss.\n       \\<tau>Runs_table2 s tlsstlss \\<Longrightarrow>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) =\n           LNil \\<and>\n           (\\<forall>x xa. \\<not> sa -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa s' tls tl.\n           s = sa \\<and>\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) =\n           LCons tl tls \\<and>\n           sa -tl\\<rightarrow> s' \\<and>\n           ((\\<exists>s tlsstlss.\n                s' = s \\<and>\n                tls =\n                lconcat\n                 (lappend\n                   (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                     (llist_of_tllist tlsstlss))\n                   (LCons\n                     (case terminal tlsstlss of\n                      Inl (tls, s') \\<Rightarrow> llist_of tls\n                      | Inr tls \\<Rightarrow> tls)\n                     LNil)) \\<and>\n                \\<tau>Runs_table2 s tlsstlss) \\<or>\n            Runs s' tls))", "case (Runs s tlsstlss)"], ["proof (state)\nthis:\n  \\<tau>Runs_table2 s tlsstlss\n\ngoal (1 subgoal):\n 1. \\<And>s tlsstlss.\n       \\<tau>Runs_table2 s tlsstlss \\<Longrightarrow>\n       (\\<exists>sa.\n           s = sa \\<and>\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) =\n           LNil \\<and>\n           (\\<forall>x xa. \\<not> sa -x\\<rightarrow> xa)) \\<or>\n       (\\<exists>sa s' tls tl.\n           s = sa \\<and>\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) =\n           LCons tl tls \\<and>\n           sa -tl\\<rightarrow> s' \\<and>\n           ((\\<exists>s tlsstlss.\n                s' = s \\<and>\n                tls =\n                lconcat\n                 (lappend\n                   (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                     (llist_of_tllist tlsstlss))\n                   (LCons\n                     (case terminal tlsstlss of\n                      Inl (tls, s') \\<Rightarrow> llist_of tls\n                      | Inr tls \\<Rightarrow> tls)\n                     LNil)) \\<and>\n                \\<tau>Runs_table2 s tlsstlss) \\<or>\n            Runs s' tls))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<tau>Runs_table2 s tlsstlss\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LCons tl tls \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s tlsstlss.\n             s' = s \\<and>\n             tls =\n             lconcat\n              (lappend\n                (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                  (llist_of_tllist tlsstlss))\n                (LCons\n                  (case terminal tlsstlss of\n                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                   | Inr tls \\<Rightarrow> tls)\n                  LNil)) \\<and>\n             \\<tau>Runs_table2 s tlsstlss) \\<or>\n         Runs s' tls))", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>tls s'.\n       \\<lbrakk>tlsstlss = TNil (Inl (tls, s')); silent_moves2 s tls s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 2. \\<And>tls.\n       \\<lbrakk>tlsstlss = TNil (Inr tls);\n        trsys.inf_step silent_move2 s tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 3. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "case (Terminate tls' s')"], ["proof (state)\nthis:\n  tlsstlss = TNil (Inl (tls', s'))\n  silent_moves2 s tls' s'\n  \\<not> s' -?tl\\<rightarrow> ?s''\n\ngoal (3 subgoals):\n 1. \\<And>tls s'.\n       \\<lbrakk>tlsstlss = TNil (Inl (tls, s')); silent_moves2 s tls s';\n        \\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 2. \\<And>tls.\n       \\<lbrakk>tlsstlss = TNil (Inr tls);\n        trsys.inf_step silent_move2 s tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 3. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "from \\<open>silent_moves2 s tls' s'\\<close>"], ["proof (chain)\npicking this:\n  silent_moves2 s tls' s'", "show ?thesis"], ["proof (prove)\nusing this:\n  silent_moves2 s tls' s'\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LCons tl tls \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s tlsstlss.\n             s' = s \\<and>\n             tls =\n             lconcat\n              (lappend\n                (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                  (llist_of_tllist tlsstlss))\n                (LCons\n                  (case terminal tlsstlss of\n                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                   | Inr tls \\<Rightarrow> tls)\n                  LNil)) \\<and>\n             \\<tau>Runs_table2 s tlsstlss) \\<or>\n         Runs s' tls))", "proof(cases rule: rtrancl3p_converseE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s = s'; tls' = []\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          lconcat\n                           (lappend\n                             (lmap\n                               (\\<lambda>(tls, s, tl, s').\n                                   llist_of (tls @ [tl]))\n                               (llist_of_tllist tlsstlss))\n                             (LCons\n                               (case terminal tlsstlss of\n                                Inl (tls, s') \\<Rightarrow> llist_of tls\n                                | Inr tls \\<Rightarrow> tls)\n                               LNil)) =\n                          LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' tls tl.\n                          s = s \\<and>\n                          lconcat\n                           (lappend\n                             (lmap\n                               (\\<lambda>(tls, s, tl, s').\n                                   llist_of (tls @ [tl]))\n                               (llist_of_tllist tlsstlss))\n                             (LCons\n                               (case terminal tlsstlss of\n                                Inl (tls, s') \\<Rightarrow> llist_of tls\n                                | Inr tls \\<Rightarrow> tls)\n                               LNil)) =\n                          LCons tl tls \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tlsstlss.\n                               s' = s \\<and>\n                               tls =\n                               lconcat\n                                (lappend\n                                  (lmap\n                                    (\\<lambda>(tls, s, tl, s').\n  llist_of (tls @ [tl]))\n                                    (llist_of_tllist tlsstlss))\n                                  (LCons\n                                    (case terminal tlsstlss of\n                                     Inl (tls, s') \\<Rightarrow>\n llist_of tls\n                                     | Inr tls \\<Rightarrow> tls)\n                                    LNil)) \\<and>\n                               \\<tau>Runs_table2 s tlsstlss) \\<or>\n                           Runs s' tls))\n 2. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "case refl"], ["proof (state)\nthis:\n  s = s'\n  tls' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s = s'; tls' = []\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          lconcat\n                           (lappend\n                             (lmap\n                               (\\<lambda>(tls, s, tl, s').\n                                   llist_of (tls @ [tl]))\n                               (llist_of_tllist tlsstlss))\n                             (LCons\n                               (case terminal tlsstlss of\n                                Inl (tls, s') \\<Rightarrow> llist_of tls\n                                | Inr tls \\<Rightarrow> tls)\n                               LNil)) =\n                          LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' tls tl.\n                          s = s \\<and>\n                          lconcat\n                           (lappend\n                             (lmap\n                               (\\<lambda>(tls, s, tl, s').\n                                   llist_of (tls @ [tl]))\n                               (llist_of_tllist tlsstlss))\n                             (LCons\n                               (case terminal tlsstlss of\n                                Inl (tls, s') \\<Rightarrow> llist_of tls\n                                | Inr tls \\<Rightarrow> tls)\n                               LNil)) =\n                          LCons tl tls \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tlsstlss.\n                               s' = s \\<and>\n                               tls =\n                               lconcat\n                                (lappend\n                                  (lmap\n                                    (\\<lambda>(tls, s, tl, s').\n  llist_of (tls @ [tl]))\n                                    (llist_of_tllist tlsstlss))\n                                  (LCons\n                                    (case terminal tlsstlss of\n                                     Inl (tls, s') \\<Rightarrow>\n llist_of tls\n                                     | Inr tls \\<Rightarrow> tls)\n                                    LNil)) \\<and>\n                               \\<tau>Runs_table2 s tlsstlss) \\<or>\n                           Runs s' tls))\n 2. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "hence ?Stuck"], ["proof (prove)\nusing this:\n  s = s'\n  tls' = []\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       lconcat\n        (lappend\n          (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n            (llist_of_tllist tlsstlss))\n          (LCons\n            (case terminal tlsstlss of\n             Inl (tls, s') \\<Rightarrow> llist_of tls\n             | Inr tls \\<Rightarrow> tls)\n            LNil)) =\n       LNil \\<and>\n       (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)", "using Terminate"], ["proof (prove)\nusing this:\n  s = s'\n  tls' = []\n  tlsstlss = TNil (Inl (tls', s'))\n  silent_moves2 s tls' s'\n  \\<not> s' -?tl\\<rightarrow> ?s''\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s = s \\<and>\n       lconcat\n        (lappend\n          (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n            (llist_of_tllist tlsstlss))\n          (LCons\n            (case terminal tlsstlss of\n             Inl (tls, s') \\<Rightarrow> llist_of tls\n             | Inr tls \\<Rightarrow> tls)\n            LNil)) =\n       LNil \\<and>\n       (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)", "by simp"], ["proof (state)\nthis:\n  \\<exists>s.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LNil \\<and>\n     (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s = s'; tls' = []\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          s = s \\<and>\n                          lconcat\n                           (lappend\n                             (lmap\n                               (\\<lambda>(tls, s, tl, s').\n                                   llist_of (tls @ [tl]))\n                               (llist_of_tllist tlsstlss))\n                             (LCons\n                               (case terminal tlsstlss of\n                                Inl (tls, s') \\<Rightarrow> llist_of tls\n                                | Inr tls \\<Rightarrow> tls)\n                               LNil)) =\n                          LNil \\<and>\n                          (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                              xa)) \\<or>\n                      (\\<exists>s s' tls tl.\n                          s = s \\<and>\n                          lconcat\n                           (lappend\n                             (lmap\n                               (\\<lambda>(tls, s, tl, s').\n                                   llist_of (tls @ [tl]))\n                               (llist_of_tllist tlsstlss))\n                             (LCons\n                               (case terminal tlsstlss of\n                                Inl (tls, s') \\<Rightarrow> llist_of tls\n                                | Inr tls \\<Rightarrow> tls)\n                               LNil)) =\n                          LCons tl tls \\<and>\n                          s -tl\\<rightarrow> s' \\<and>\n                          ((\\<exists>s tlsstlss.\n                               s' = s \\<and>\n                               tls =\n                               lconcat\n                                (lappend\n                                  (lmap\n                                    (\\<lambda>(tls, s, tl, s').\n  llist_of (tls @ [tl]))\n                                    (llist_of_tllist tlsstlss))\n                                  (LCons\n                                    (case terminal tlsstlss of\n                                     Inl (tls, s') \\<Rightarrow>\n llist_of tls\n                                     | Inr tls \\<Rightarrow> tls)\n                                    LNil)) \\<and>\n                               \\<tau>Runs_table2 s tlsstlss) \\<or>\n                           Runs s' tls))\n 2. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LNil \\<and>\n     (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LCons tl tls \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s tlsstlss.\n             s' = s \\<and>\n             tls =\n             lconcat\n              (lappend\n                (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                  (llist_of_tllist tlsstlss))\n                (LCons\n                  (case terminal tlsstlss of\n                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                   | Inr tls \\<Rightarrow> tls)\n                  LNil)) \\<and>\n             \\<tau>Runs_table2 s tlsstlss) \\<or>\n         Runs s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LCons tl tls \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s tlsstlss.\n           s' = s \\<and>\n           tls =\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) \\<and>\n           \\<tau>Runs_table2 s tlsstlss) \\<or>\n       Runs s' tls))\n\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "case (step tls'' tl s'')"], ["proof (state)\nthis:\n  tls' = tl # tls''\n  silent_move2 s tl s''\n  silent_moves2 s'' tls'' s'\n\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "from \\<open>silent_moves2 s'' tls'' s'\\<close> \\<open>\\<And>tl s''. \\<not> s' -tl\\<rightarrow> s''\\<close>"], ["proof (chain)\npicking this:\n  silent_moves2 s'' tls'' s'\n  \\<not> s' -?tl\\<rightarrow> ?s''", "have \"\\<tau>Runs_table2 s'' (TNil (Inl (tls'', s')))\""], ["proof (prove)\nusing this:\n  silent_moves2 s'' tls'' s'\n  \\<not> s' -?tl\\<rightarrow> ?s''\n\ngoal (1 subgoal):\n 1. \\<tau>Runs_table2 s'' (TNil (Inl (tls'', s')))", ".."], ["proof (state)\nthis:\n  \\<tau>Runs_table2 s'' (TNil (Inl (tls'', s')))\n\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "with \\<open>tls' = tl # tls''\\<close> \\<open>silent_move2 s tl s''\\<close> \\<open>tlsstlss = TNil (Inl (tls', s'))\\<close>"], ["proof (chain)\npicking this:\n  tls' = tl # tls''\n  silent_move2 s tl s''\n  tlsstlss = TNil (Inl (tls', s'))\n  \\<tau>Runs_table2 s'' (TNil (Inl (tls'', s')))", "have ?Step"], ["proof (prove)\nusing this:\n  tls' = tl # tls''\n  silent_move2 s tl s''\n  tlsstlss = TNil (Inl (tls', s'))\n  \\<tau>Runs_table2 s'' (TNil (Inl (tls'', s')))\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       s = s \\<and>\n       lconcat\n        (lappend\n          (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n            (llist_of_tllist tlsstlss))\n          (LCons\n            (case terminal tlsstlss of\n             Inl (tls, s') \\<Rightarrow> llist_of tls\n             | Inr tls \\<Rightarrow> tls)\n            LNil)) =\n       LCons tl tls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tlsstlss.\n            s' = s \\<and>\n            tls =\n            lconcat\n             (lappend\n               (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                 (llist_of_tllist tlsstlss))\n               (LCons\n                 (case terminal tlsstlss of\n                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                  | Inr tls \\<Rightarrow> tls)\n                 LNil)) \\<and>\n            \\<tau>Runs_table2 s tlsstlss) \\<or>\n        Runs s' tls)", "by(auto simp add: silent_move2_def intro!: exI)"], ["proof (state)\nthis:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LCons tl tls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tlsstlss.\n          s' = s \\<and>\n          tls =\n          lconcat\n           (lappend\n             (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n               (llist_of_tllist tlsstlss))\n             (LCons\n               (case terminal tlsstlss of\n                Inl (tls, s') \\<Rightarrow> llist_of tls\n                | Inr tls \\<Rightarrow> tls)\n               LNil)) \\<and>\n          \\<tau>Runs_table2 s tlsstlss) \\<or>\n      Runs s' tls)\n\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LCons tl tls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tlsstlss.\n          s' = s \\<and>\n          tls =\n          lconcat\n           (lappend\n             (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n               (llist_of_tllist tlsstlss))\n             (LCons\n               (case terminal tlsstlss of\n                Inl (tls, s') \\<Rightarrow> llist_of tls\n                | Inr tls \\<Rightarrow> tls)\n               LNil)) \\<and>\n          \\<tau>Runs_table2 s tlsstlss) \\<or>\n      Runs s' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LCons tl tls \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s tlsstlss.\n             s' = s \\<and>\n             tls =\n             lconcat\n              (lappend\n                (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                  (llist_of_tllist tlsstlss))\n                (LCons\n                  (case terminal tlsstlss of\n                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                   | Inr tls \\<Rightarrow> tls)\n                  LNil)) \\<and>\n             \\<tau>Runs_table2 s tlsstlss) \\<or>\n         Runs s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LCons tl tls \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s tlsstlss.\n           s' = s \\<and>\n           tls =\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) \\<and>\n           \\<tau>Runs_table2 s tlsstlss) \\<or>\n       Runs s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LCons tl tls \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s tlsstlss.\n           s' = s \\<and>\n           tls =\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) \\<and>\n           \\<tau>Runs_table2 s tlsstlss) \\<or>\n       Runs s' tls))\n\ngoal (2 subgoals):\n 1. \\<And>tls.\n       \\<lbrakk>tlsstlss = TNil (Inr tls);\n        trsys.inf_step silent_move2 s tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 2. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tls.\n       \\<lbrakk>tlsstlss = TNil (Inr tls);\n        trsys.inf_step silent_move2 s tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 2. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "case (Diverge tls')"], ["proof (state)\nthis:\n  tlsstlss = TNil (Inr tls')\n  trsys.inf_step silent_move2 s tls'\n\ngoal (2 subgoals):\n 1. \\<And>tls.\n       \\<lbrakk>tlsstlss = TNil (Inr tls);\n        trsys.inf_step silent_move2 s tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 2. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "from \\<open>trsys.inf_step silent_move2 s tls'\\<close>"], ["proof (chain)\npicking this:\n  trsys.inf_step silent_move2 s tls'", "obtain tl tls'' s' where \"silent_move2 s tl s'\" \n      and \"tls' = LCons tl tls''\" \"trsys.inf_step silent_move2 s' tls''\""], ["proof (prove)\nusing this:\n  trsys.inf_step silent_move2 s tls'\n\ngoal (1 subgoal):\n 1. (\\<And>tl s' tls''.\n        \\<lbrakk>silent_move2 s tl s'; tls' = LCons tl tls'';\n         trsys.inf_step silent_move2 s' tls''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rule: trsys.inf_step.cases[consumes 1]) auto"], ["proof (state)\nthis:\n  silent_move2 s tl s'\n  tls' = LCons tl tls''\n  trsys.inf_step silent_move2 s' tls''\n\ngoal (2 subgoals):\n 1. \\<And>tls.\n       \\<lbrakk>tlsstlss = TNil (Inr tls);\n        trsys.inf_step silent_move2 s tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 2. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "from \\<open>trsys.inf_step silent_move2 s' tls''\\<close>"], ["proof (chain)\npicking this:\n  trsys.inf_step silent_move2 s' tls''", "have \"\\<tau>Runs_table2 s' (TNil (Inr tls''))\""], ["proof (prove)\nusing this:\n  trsys.inf_step silent_move2 s' tls''\n\ngoal (1 subgoal):\n 1. \\<tau>Runs_table2 s' (TNil (Inr tls''))", ".."], ["proof (state)\nthis:\n  \\<tau>Runs_table2 s' (TNil (Inr tls''))\n\ngoal (2 subgoals):\n 1. \\<And>tls.\n       \\<lbrakk>tlsstlss = TNil (Inr tls);\n        trsys.inf_step silent_move2 s tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 2. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "hence ?Step"], ["proof (prove)\nusing this:\n  \\<tau>Runs_table2 s' (TNil (Inr tls''))\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       s = s \\<and>\n       lconcat\n        (lappend\n          (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n            (llist_of_tllist tlsstlss))\n          (LCons\n            (case terminal tlsstlss of\n             Inl (tls, s') \\<Rightarrow> llist_of tls\n             | Inr tls \\<Rightarrow> tls)\n            LNil)) =\n       LCons tl tls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tlsstlss.\n            s' = s \\<and>\n            tls =\n            lconcat\n             (lappend\n               (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                 (llist_of_tllist tlsstlss))\n               (LCons\n                 (case terminal tlsstlss of\n                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                  | Inr tls \\<Rightarrow> tls)\n                 LNil)) \\<and>\n            \\<tau>Runs_table2 s tlsstlss) \\<or>\n        Runs s' tls)", "using \\<open>tlsstlss = TNil (Inr tls')\\<close> \\<open>tls' = LCons tl tls''\\<close> \\<open>silent_move2 s tl s'\\<close>"], ["proof (prove)\nusing this:\n  \\<tau>Runs_table2 s' (TNil (Inr tls''))\n  tlsstlss = TNil (Inr tls')\n  tls' = LCons tl tls''\n  silent_move2 s tl s'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       s = s \\<and>\n       lconcat\n        (lappend\n          (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n            (llist_of_tllist tlsstlss))\n          (LCons\n            (case terminal tlsstlss of\n             Inl (tls, s') \\<Rightarrow> llist_of tls\n             | Inr tls \\<Rightarrow> tls)\n            LNil)) =\n       LCons tl tls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tlsstlss.\n            s' = s \\<and>\n            tls =\n            lconcat\n             (lappend\n               (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                 (llist_of_tllist tlsstlss))\n               (LCons\n                 (case terminal tlsstlss of\n                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                  | Inr tls \\<Rightarrow> tls)\n                 LNil)) \\<and>\n            \\<tau>Runs_table2 s tlsstlss) \\<or>\n        Runs s' tls)", "by(auto simp add: silent_move2_def intro!: exI)"], ["proof (state)\nthis:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LCons tl tls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tlsstlss.\n          s' = s \\<and>\n          tls =\n          lconcat\n           (lappend\n             (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n               (llist_of_tllist tlsstlss))\n             (LCons\n               (case terminal tlsstlss of\n                Inl (tls, s') \\<Rightarrow> llist_of tls\n                | Inr tls \\<Rightarrow> tls)\n               LNil)) \\<and>\n          \\<tau>Runs_table2 s tlsstlss) \\<or>\n      Runs s' tls)\n\ngoal (2 subgoals):\n 1. \\<And>tls.\n       \\<lbrakk>tlsstlss = TNil (Inr tls);\n        trsys.inf_step silent_move2 s tls\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))\n 2. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LCons tl tls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tlsstlss.\n          s' = s \\<and>\n          tls =\n          lconcat\n           (lappend\n             (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n               (llist_of_tllist tlsstlss))\n             (LCons\n               (case terminal tlsstlss of\n                Inl (tls, s') \\<Rightarrow> llist_of tls\n                | Inr tls \\<Rightarrow> tls)\n               LNil)) \\<and>\n          \\<tau>Runs_table2 s tlsstlss) \\<or>\n      Runs s' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LCons tl tls \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s tlsstlss.\n             s' = s \\<and>\n             tls =\n             lconcat\n              (lappend\n                (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                  (llist_of_tllist tlsstlss))\n                (LCons\n                  (case terminal tlsstlss of\n                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                   | Inr tls \\<Rightarrow> tls)\n                  LNil)) \\<and>\n             \\<tau>Runs_table2 s tlsstlss) \\<or>\n         Runs s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LCons tl tls \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s tlsstlss.\n           s' = s \\<and>\n           tls =\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) \\<and>\n           \\<tau>Runs_table2 s tlsstlss) \\<or>\n       Runs s' tls))\n\ngoal (1 subgoal):\n 1. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "case (Proceed tls' s' s'' tlsstlss' tl)"], ["proof (state)\nthis:\n  tlsstlss = TCons (tls', s', tl, s'') tlsstlss'\n  silent_moves2 s tls' s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  \\<tau>Runs_table2 s'' tlsstlss'\n\ngoal (1 subgoal):\n 1. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "from \\<open>silent_moves2 s tls' s'\\<close>"], ["proof (chain)\npicking this:\n  silent_moves2 s tls' s'", "have ?Step"], ["proof (prove)\nusing this:\n  silent_moves2 s tls' s'\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       s = s \\<and>\n       lconcat\n        (lappend\n          (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n            (llist_of_tllist tlsstlss))\n          (LCons\n            (case terminal tlsstlss of\n             Inl (tls, s') \\<Rightarrow> llist_of tls\n             | Inr tls \\<Rightarrow> tls)\n            LNil)) =\n       LCons tl tls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tlsstlss.\n            s' = s \\<and>\n            tls =\n            lconcat\n             (lappend\n               (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                 (llist_of_tllist tlsstlss))\n               (LCons\n                 (case terminal tlsstlss of\n                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                  | Inr tls \\<Rightarrow> tls)\n                 LNil)) \\<and>\n            \\<tau>Runs_table2 s tlsstlss) \\<or>\n        Runs s' tls)", "proof(cases rule: rtrancl3p_converseE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s = s'; tls' = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s s' tls tl.\n                         s = s \\<and>\n                         lconcat\n                          (lappend\n                            (lmap\n                              (\\<lambda>(tls, s, tl, s').\n                                  llist_of (tls @ [tl]))\n                              (llist_of_tllist tlsstlss))\n                            (LCons\n                              (case terminal tlsstlss of\n                               Inl (tls, s') \\<Rightarrow> llist_of tls\n                               | Inr tls \\<Rightarrow> tls)\n                              LNil)) =\n                         LCons tl tls \\<and>\n                         s -tl\\<rightarrow> s' \\<and>\n                         ((\\<exists>s tlsstlss.\n                              s' = s \\<and>\n                              tls =\n                              lconcat\n                               (lappend\n                                 (lmap\n                                   (\\<lambda>(tls, s, tl, s').\n llist_of (tls @ [tl]))\n                                   (llist_of_tllist tlsstlss))\n                                 (LCons\n                                   (case terminal tlsstlss of\n                                    Inl (tls, s') \\<Rightarrow> llist_of tls\n                                    | Inr tls \\<Rightarrow> tls)\n                                   LNil)) \\<and>\n                              \\<tau>Runs_table2 s tlsstlss) \\<or>\n                          Runs s' tls)\n 2. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' tls tl.\n                            s = s \\<and>\n                            lconcat\n                             (lappend\n                               (lmap\n                                 (\\<lambda>(tls, s, tl, s').\n                                     llist_of (tls @ [tl]))\n                                 (llist_of_tllist tlsstlss))\n                               (LCons\n                                 (case terminal tlsstlss of\n                                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                                  | Inr tls \\<Rightarrow> tls)\n                                 LNil)) =\n                            LCons tl tls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tlsstlss.\n                                 s' = s \\<and>\n                                 tls =\n                                 lconcat\n                                  (lappend\n                                    (lmap\n(\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n(llist_of_tllist tlsstlss))\n                                    (LCons\n(case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n | Inr tls \\<Rightarrow> tls)\nLNil)) \\<and>\n                                 \\<tau>Runs_table2 s tlsstlss) \\<or>\n                             Runs s' tls)", "case refl"], ["proof (state)\nthis:\n  s = s'\n  tls' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s = s'; tls' = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s s' tls tl.\n                         s = s \\<and>\n                         lconcat\n                          (lappend\n                            (lmap\n                              (\\<lambda>(tls, s, tl, s').\n                                  llist_of (tls @ [tl]))\n                              (llist_of_tllist tlsstlss))\n                            (LCons\n                              (case terminal tlsstlss of\n                               Inl (tls, s') \\<Rightarrow> llist_of tls\n                               | Inr tls \\<Rightarrow> tls)\n                              LNil)) =\n                         LCons tl tls \\<and>\n                         s -tl\\<rightarrow> s' \\<and>\n                         ((\\<exists>s tlsstlss.\n                              s' = s \\<and>\n                              tls =\n                              lconcat\n                               (lappend\n                                 (lmap\n                                   (\\<lambda>(tls, s, tl, s').\n llist_of (tls @ [tl]))\n                                   (llist_of_tllist tlsstlss))\n                                 (LCons\n                                   (case terminal tlsstlss of\n                                    Inl (tls, s') \\<Rightarrow> llist_of tls\n                                    | Inr tls \\<Rightarrow> tls)\n                                   LNil)) \\<and>\n                              \\<tau>Runs_table2 s tlsstlss) \\<or>\n                          Runs s' tls)\n 2. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' tls tl.\n                            s = s \\<and>\n                            lconcat\n                             (lappend\n                               (lmap\n                                 (\\<lambda>(tls, s, tl, s').\n                                     llist_of (tls @ [tl]))\n                                 (llist_of_tllist tlsstlss))\n                               (LCons\n                                 (case terminal tlsstlss of\n                                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                                  | Inr tls \\<Rightarrow> tls)\n                                 LNil)) =\n                            LCons tl tls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tlsstlss.\n                                 s' = s \\<and>\n                                 tls =\n                                 lconcat\n                                  (lappend\n                                    (lmap\n(\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n(llist_of_tllist tlsstlss))\n                                    (LCons\n(case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n | Inr tls \\<Rightarrow> tls)\nLNil)) \\<and>\n                                 \\<tau>Runs_table2 s tlsstlss) \\<or>\n                             Runs s' tls)", "with Proceed"], ["proof (chain)\npicking this:\n  tlsstlss = TCons (tls', s', tl, s'') tlsstlss'\n  silent_moves2 s tls' s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  \\<tau>Runs_table2 s'' tlsstlss'\n  s = s'\n  tls' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  tlsstlss = TCons (tls', s', tl, s'') tlsstlss'\n  silent_moves2 s tls' s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  \\<tau>Runs_table2 s'' tlsstlss'\n  s = s'\n  tls' = []\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       s = s \\<and>\n       lconcat\n        (lappend\n          (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n            (llist_of_tllist tlsstlss))\n          (LCons\n            (case terminal tlsstlss of\n             Inl (tls, s') \\<Rightarrow> llist_of tls\n             | Inr tls \\<Rightarrow> tls)\n            LNil)) =\n       LCons tl tls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tlsstlss.\n            s' = s \\<and>\n            tls =\n            lconcat\n             (lappend\n               (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                 (llist_of_tllist tlsstlss))\n               (LCons\n                 (case terminal tlsstlss of\n                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                  | Inr tls \\<Rightarrow> tls)\n                 LNil)) \\<and>\n            \\<tau>Runs_table2 s tlsstlss) \\<or>\n        Runs s' tls)", "by auto"], ["proof (state)\nthis:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LCons tl tls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tlsstlss.\n          s' = s \\<and>\n          tls =\n          lconcat\n           (lappend\n             (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n               (llist_of_tllist tlsstlss))\n             (LCons\n               (case terminal tlsstlss of\n                Inl (tls, s') \\<Rightarrow> llist_of tls\n                | Inr tls \\<Rightarrow> tls)\n               LNil)) \\<and>\n          \\<tau>Runs_table2 s tlsstlss) \\<or>\n      Runs s' tls)\n\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' tls tl.\n                            s = s \\<and>\n                            lconcat\n                             (lappend\n                               (lmap\n                                 (\\<lambda>(tls, s, tl, s').\n                                     llist_of (tls @ [tl]))\n                                 (llist_of_tllist tlsstlss))\n                               (LCons\n                                 (case terminal tlsstlss of\n                                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                                  | Inr tls \\<Rightarrow> tls)\n                                 LNil)) =\n                            LCons tl tls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tlsstlss.\n                                 s' = s \\<and>\n                                 tls =\n                                 lconcat\n                                  (lappend\n                                    (lmap\n(\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n(llist_of_tllist tlsstlss))\n                                    (LCons\n(case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n | Inr tls \\<Rightarrow> tls)\nLNil)) \\<and>\n                                 \\<tau>Runs_table2 s tlsstlss) \\<or>\n                             Runs s' tls)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' tls tl.\n                            s = s \\<and>\n                            lconcat\n                             (lappend\n                               (lmap\n                                 (\\<lambda>(tls, s, tl, s').\n                                     llist_of (tls @ [tl]))\n                                 (llist_of_tllist tlsstlss))\n                               (LCons\n                                 (case terminal tlsstlss of\n                                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                                  | Inr tls \\<Rightarrow> tls)\n                                 LNil)) =\n                            LCons tl tls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tlsstlss.\n                                 s' = s \\<and>\n                                 tls =\n                                 lconcat\n                                  (lappend\n                                    (lmap\n(\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n(llist_of_tllist tlsstlss))\n                                    (LCons\n(case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n | Inr tls \\<Rightarrow> tls)\nLNil)) \\<and>\n                                 \\<tau>Runs_table2 s tlsstlss) \\<or>\n                             Runs s' tls)", "case (step tls'' tl' s''')"], ["proof (state)\nthis:\n  tls' = tl' # tls''\n  silent_move2 s tl' s'''\n  silent_moves2 s''' tls'' s'\n\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' tls tl.\n                            s = s \\<and>\n                            lconcat\n                             (lappend\n                               (lmap\n                                 (\\<lambda>(tls, s, tl, s').\n                                     llist_of (tls @ [tl]))\n                                 (llist_of_tllist tlsstlss))\n                               (LCons\n                                 (case terminal tlsstlss of\n                                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                                  | Inr tls \\<Rightarrow> tls)\n                                 LNil)) =\n                            LCons tl tls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tlsstlss.\n                                 s' = s \\<and>\n                                 tls =\n                                 lconcat\n                                  (lappend\n                                    (lmap\n(\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n(llist_of_tllist tlsstlss))\n                                    (LCons\n(case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n | Inr tls \\<Rightarrow> tls)\nLNil)) \\<and>\n                                 \\<tau>Runs_table2 s tlsstlss) \\<or>\n                             Runs s' tls)", "from \\<open>silent_moves2 s''' tls'' s'\\<close> \\<open>s' -tl\\<rightarrow> s''\\<close> \\<open>\\<not> \\<tau>move s' tl s''\\<close> \\<open>\\<tau>Runs_table2 s'' tlsstlss'\\<close>"], ["proof (chain)\npicking this:\n  silent_moves2 s''' tls'' s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  \\<tau>Runs_table2 s'' tlsstlss'", "have \"\\<tau>Runs_table2 s''' (TCons (tls'', s', tl, s'') tlsstlss')\""], ["proof (prove)\nusing this:\n  silent_moves2 s''' tls'' s'\n  s' -tl\\<rightarrow> s''\n  \\<not> \\<tau>move s' tl s''\n  \\<tau>Runs_table2 s'' tlsstlss'\n\ngoal (1 subgoal):\n 1. \\<tau>Runs_table2 s''' (TCons (tls'', s', tl, s'') tlsstlss')", ".."], ["proof (state)\nthis:\n  \\<tau>Runs_table2 s''' (TCons (tls'', s', tl, s'') tlsstlss')\n\ngoal (1 subgoal):\n 1. \\<And>bs' b a'.\n       \\<lbrakk>tls' = b # bs'; silent_move2 s b a';\n        silent_moves2 a' bs' s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s s' tls tl.\n                            s = s \\<and>\n                            lconcat\n                             (lappend\n                               (lmap\n                                 (\\<lambda>(tls, s, tl, s').\n                                     llist_of (tls @ [tl]))\n                                 (llist_of_tllist tlsstlss))\n                               (LCons\n                                 (case terminal tlsstlss of\n                                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                                  | Inr tls \\<Rightarrow> tls)\n                                 LNil)) =\n                            LCons tl tls \\<and>\n                            s -tl\\<rightarrow> s' \\<and>\n                            ((\\<exists>s tlsstlss.\n                                 s' = s \\<and>\n                                 tls =\n                                 lconcat\n                                  (lappend\n                                    (lmap\n(\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n(llist_of_tllist tlsstlss))\n                                    (LCons\n(case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n | Inr tls \\<Rightarrow> tls)\nLNil)) \\<and>\n                                 \\<tau>Runs_table2 s tlsstlss) \\<or>\n                             Runs s' tls)", "with \\<open>tls' = tl' # tls''\\<close> \\<open>silent_move2 s tl' s'''\\<close> \\<open>tlsstlss = TCons (tls', s', tl, s'') tlsstlss'\\<close>"], ["proof (chain)\npicking this:\n  tls' = tl' # tls''\n  silent_move2 s tl' s'''\n  tlsstlss = TCons (tls', s', tl, s'') tlsstlss'\n  \\<tau>Runs_table2 s''' (TCons (tls'', s', tl, s'') tlsstlss')", "show ?thesis"], ["proof (prove)\nusing this:\n  tls' = tl' # tls''\n  silent_move2 s tl' s'''\n  tlsstlss = TCons (tls', s', tl, s'') tlsstlss'\n  \\<tau>Runs_table2 s''' (TCons (tls'', s', tl, s'') tlsstlss')\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       s = s \\<and>\n       lconcat\n        (lappend\n          (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n            (llist_of_tllist tlsstlss))\n          (LCons\n            (case terminal tlsstlss of\n             Inl (tls, s') \\<Rightarrow> llist_of tls\n             | Inr tls \\<Rightarrow> tls)\n            LNil)) =\n       LCons tl tls \\<and>\n       s -tl\\<rightarrow> s' \\<and>\n       ((\\<exists>s tlsstlss.\n            s' = s \\<and>\n            tls =\n            lconcat\n             (lappend\n               (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                 (llist_of_tllist tlsstlss))\n               (LCons\n                 (case terminal tlsstlss of\n                  Inl (tls, s') \\<Rightarrow> llist_of tls\n                  | Inr tls \\<Rightarrow> tls)\n                 LNil)) \\<and>\n            \\<tau>Runs_table2 s tlsstlss) \\<or>\n        Runs s' tls)", "by(auto simp add: silent_move2_def intro!: exI)"], ["proof (state)\nthis:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LCons tl tls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tlsstlss.\n          s' = s \\<and>\n          tls =\n          lconcat\n           (lappend\n             (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n               (llist_of_tllist tlsstlss))\n             (LCons\n               (case terminal tlsstlss of\n                Inl (tls, s') \\<Rightarrow> llist_of tls\n                | Inr tls \\<Rightarrow> tls)\n               LNil)) \\<and>\n          \\<tau>Runs_table2 s tlsstlss) \\<or>\n      Runs s' tls)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LCons tl tls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tlsstlss.\n          s' = s \\<and>\n          tls =\n          lconcat\n           (lappend\n             (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n               (llist_of_tllist tlsstlss))\n             (LCons\n               (case terminal tlsstlss of\n                Inl (tls, s') \\<Rightarrow> llist_of tls\n                | Inr tls \\<Rightarrow> tls)\n               LNil)) \\<and>\n          \\<tau>Runs_table2 s tlsstlss) \\<or>\n      Runs s' tls)\n\ngoal (1 subgoal):\n 1. \\<And>tls s' s'' tlsstlss tl.\n       \\<lbrakk>tlsstlss = TCons (tls, s', tl, s'') tlsstlss;\n        silent_moves2 s tls s'; s' -tl\\<rightarrow> s'';\n        \\<not> \\<tau>move s' tl s''; \\<tau>Runs_table2 s'' tlsstlss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LNil \\<and>\n                             (\\<forall>x xa. \\<not> s -x\\<rightarrow>\n                                 xa)) \\<or>\n                         (\\<exists>s s' tls tl.\n                             s = s \\<and>\n                             lconcat\n                              (lappend\n                                (lmap\n                                  (\\<lambda>(tls, s, tl, s').\nllist_of (tls @ [tl]))\n                                  (llist_of_tllist tlsstlss))\n                                (LCons\n                                  (case terminal tlsstlss of\n                                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                                   | Inr tls \\<Rightarrow> tls)\n                                  LNil)) =\n                             LCons tl tls \\<and>\n                             s -tl\\<rightarrow> s' \\<and>\n                             ((\\<exists>s tlsstlss.\n                                  s' = s \\<and>\n                                  tls =\n                                  lconcat\n                                   (lappend\n                                     (lmap\n (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n (llist_of_tllist tlsstlss))\n                                     (LCons\n (case terminal tlsstlss of Inl (tls, s') \\<Rightarrow> llist_of tls\n  | Inr tls \\<Rightarrow> tls)\n LNil)) \\<and>\n                                  \\<tau>Runs_table2 s tlsstlss) \\<or>\n                              Runs s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' tls tl.\n     s = s \\<and>\n     lconcat\n      (lappend\n        (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n          (llist_of_tllist tlsstlss))\n        (LCons\n          (case terminal tlsstlss of\n           Inl (tls, s') \\<Rightarrow> llist_of tls\n           | Inr tls \\<Rightarrow> tls)\n          LNil)) =\n     LCons tl tls \\<and>\n     s -tl\\<rightarrow> s' \\<and>\n     ((\\<exists>s tlsstlss.\n          s' = s \\<and>\n          tls =\n          lconcat\n           (lappend\n             (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n               (llist_of_tllist tlsstlss))\n             (LCons\n               (case terminal tlsstlss of\n                Inl (tls, s') \\<Rightarrow> llist_of tls\n                | Inr tls \\<Rightarrow> tls)\n               LNil)) \\<and>\n          \\<tau>Runs_table2 s tlsstlss) \\<or>\n      Runs s' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LNil \\<and>\n        (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        s = s \\<and>\n        lconcat\n         (lappend\n           (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n             (llist_of_tllist tlsstlss))\n           (LCons\n             (case terminal tlsstlss of\n              Inl (tls, s') \\<Rightarrow> llist_of tls\n              | Inr tls \\<Rightarrow> tls)\n             LNil)) =\n        LCons tl tls \\<and>\n        s -tl\\<rightarrow> s' \\<and>\n        ((\\<exists>s tlsstlss.\n             s' = s \\<and>\n             tls =\n             lconcat\n              (lappend\n                (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                  (llist_of_tllist tlsstlss))\n                (LCons\n                  (case terminal tlsstlss of\n                   Inl (tls, s') \\<Rightarrow> llist_of tls\n                   | Inr tls \\<Rightarrow> tls)\n                  LNil)) \\<and>\n             \\<tau>Runs_table2 s tlsstlss) \\<or>\n         Runs s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LCons tl tls \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s tlsstlss.\n           s' = s \\<and>\n           tls =\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) \\<and>\n           \\<tau>Runs_table2 s tlsstlss) \\<or>\n       Runs s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LNil \\<and>\n      (\\<forall>x xa. \\<not> s -x\\<rightarrow> xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      s = s \\<and>\n      lconcat\n       (lappend\n         (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n           (llist_of_tllist tlsstlss))\n         (LCons\n           (case terminal tlsstlss of\n            Inl (tls, s') \\<Rightarrow> llist_of tls\n            | Inr tls \\<Rightarrow> tls)\n           LNil)) =\n      LCons tl tls \\<and>\n      s -tl\\<rightarrow> s' \\<and>\n      ((\\<exists>s tlsstlss.\n           s' = s \\<and>\n           tls =\n           lconcat\n            (lappend\n              (lmap (\\<lambda>(tls, s, tl, s'). llist_of (tls @ [tl]))\n                (llist_of_tllist tlsstlss))\n              (LCons\n                (case terminal tlsstlss of\n                 Inl (tls, s') \\<Rightarrow> llist_of tls\n                 | Inr tls \\<Rightarrow> tls)\n                LNil)) \\<and>\n           \\<tau>Runs_table2 s tlsstlss) \\<or>\n       Runs s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_table2_silentsD:\n  fixes tl\n  assumes Runs: \"\\<tau>Runs_table2 s tlsstlss\"\n  and tset: \"(tls, s', tl', s'') \\<in> tset tlsstlss\"\n  and set: \"tl \\<in> set tls\"\n  shows \"\\<exists>s''' s''''. silent_move2 s''' tl s''''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s''' s''''. silent_move2 s''' tl s''''", "using tset Runs"], ["proof (prove)\nusing this:\n  (tls, s', tl', s'') \\<in> tset tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n\ngoal (1 subgoal):\n 1. \\<exists>s''' s''''. silent_move2 s''' tl s''''", "proof(induct arbitrary: s rule: tset_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<tau>Runs_table2 s (TCons (tls, s', tl', s'') xs) \\<Longrightarrow>\n       \\<exists>s'''. Ex (silent_move2 s''' tl)\n 2. \\<And>x' xs s.\n       \\<lbrakk>(tls, s', tl', s'') \\<in> tset xs;\n        (tls, s', tl', s'') \\<noteq> x';\n        \\<And>s.\n           \\<tau>Runs_table2 s xs \\<Longrightarrow>\n           \\<exists>s'''. Ex (silent_move2 s''' tl);\n        \\<tau>Runs_table2 s (TCons x' xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'''. Ex (silent_move2 s''' tl)", "case (find tlsstlss')"], ["proof (state)\nthis:\n  \\<tau>Runs_table2 s (TCons (tls, s', tl', s'') tlsstlss')\n\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<tau>Runs_table2 s (TCons (tls, s', tl', s'') xs) \\<Longrightarrow>\n       \\<exists>s'''. Ex (silent_move2 s''' tl)\n 2. \\<And>x' xs s.\n       \\<lbrakk>(tls, s', tl', s'') \\<in> tset xs;\n        (tls, s', tl', s'') \\<noteq> x';\n        \\<And>s.\n           \\<tau>Runs_table2 s xs \\<Longrightarrow>\n           \\<exists>s'''. Ex (silent_move2 s''' tl);\n        \\<tau>Runs_table2 s (TCons x' xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'''. Ex (silent_move2 s''' tl)", "from \\<open>\\<tau>Runs_table2 s (TCons (tls, s', tl', s'') tlsstlss')\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>Runs_table2 s (TCons (tls, s', tl', s'') tlsstlss')", "have \"silent_moves2 s tls s'\""], ["proof (prove)\nusing this:\n  \\<tau>Runs_table2 s (TCons (tls, s', tl', s'') tlsstlss')\n\ngoal (1 subgoal):\n 1. silent_moves2 s tls s'", "by cases"], ["proof (state)\nthis:\n  silent_moves2 s tls s'\n\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<tau>Runs_table2 s (TCons (tls, s', tl', s'') xs) \\<Longrightarrow>\n       \\<exists>s'''. Ex (silent_move2 s''' tl)\n 2. \\<And>x' xs s.\n       \\<lbrakk>(tls, s', tl', s'') \\<in> tset xs;\n        (tls, s', tl', s'') \\<noteq> x';\n        \\<And>s.\n           \\<tau>Runs_table2 s xs \\<Longrightarrow>\n           \\<exists>s'''. Ex (silent_move2 s''' tl);\n        \\<tau>Runs_table2 s (TCons x' xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'''. Ex (silent_move2 s''' tl)", "thus ?case"], ["proof (prove)\nusing this:\n  silent_moves2 s tls s'\n\ngoal (1 subgoal):\n 1. \\<exists>s''' a. silent_move2 s''' tl a", "using set"], ["proof (prove)\nusing this:\n  silent_moves2 s tls s'\n  tl \\<in> set tls\n\ngoal (1 subgoal):\n 1. \\<exists>s''' a. silent_move2 s''' tl a", "by induct auto"], ["proof (state)\nthis:\n  \\<exists>s''' a. silent_move2 s''' tl a\n\ngoal (1 subgoal):\n 1. \\<And>x' xs s.\n       \\<lbrakk>(tls, s', tl', s'') \\<in> tset xs;\n        (tls, s', tl', s'') \\<noteq> x';\n        \\<And>s.\n           \\<tau>Runs_table2 s xs \\<Longrightarrow>\n           \\<exists>s'''. Ex (silent_move2 s''' tl);\n        \\<tau>Runs_table2 s (TCons x' xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'''. Ex (silent_move2 s''' tl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' xs s.\n       \\<lbrakk>(tls, s', tl', s'') \\<in> tset xs;\n        (tls, s', tl', s'') \\<noteq> x';\n        \\<And>s.\n           \\<tau>Runs_table2 s xs \\<Longrightarrow>\n           \\<exists>s'''. Ex (silent_move2 s''' tl);\n        \\<tau>Runs_table2 s (TCons x' xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'''. Ex (silent_move2 s''' tl)", "case step"], ["proof (state)\nthis:\n  (tls, s', tl', s'') \\<in> tset xs_\n  (tls, s', tl', s'') \\<noteq> x'_\n  \\<tau>Runs_table2 ?s xs_ \\<Longrightarrow>\n  \\<exists>s''' a. silent_move2 s''' tl a\n  \\<tau>Runs_table2 s (TCons x'_ xs_)\n\ngoal (1 subgoal):\n 1. \\<And>x' xs s.\n       \\<lbrakk>(tls, s', tl', s'') \\<in> tset xs;\n        (tls, s', tl', s'') \\<noteq> x';\n        \\<And>s.\n           \\<tau>Runs_table2 s xs \\<Longrightarrow>\n           \\<exists>s'''. Ex (silent_move2 s''' tl);\n        \\<tau>Runs_table2 s (TCons x' xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'''. Ex (silent_move2 s''' tl)", "thus ?case"], ["proof (prove)\nusing this:\n  (tls, s', tl', s'') \\<in> tset xs_\n  (tls, s', tl', s'') \\<noteq> x'_\n  \\<tau>Runs_table2 ?s xs_ \\<Longrightarrow>\n  \\<exists>s''' a. silent_move2 s''' tl a\n  \\<tau>Runs_table2 s (TCons x'_ xs_)\n\ngoal (1 subgoal):\n 1. \\<exists>s''' a. silent_move2 s''' tl a", "by(auto simp add: \\<tau>Runs_table2_simps)"], ["proof (state)\nthis:\n  \\<exists>s''' a. silent_move2 s''' tl a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_table2_terminal_silentsD:\n  assumes Runs: \"\\<tau>Runs_table2 s tlsstlss\"\n  and fin: \"lfinite (llist_of_tllist tlsstlss)\"\n  and terminal: \"terminal tlsstlss = Inl (tls, s'')\"\n  shows \"\\<exists>s'. silent_moves2 s' tls s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. silent_moves2 s' tls s''", "using fin Runs terminal"], ["proof (prove)\nusing this:\n  tfinite tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inl (tls, s'')\n\ngoal (1 subgoal):\n 1. \\<exists>s'. silent_moves2 s' tls s''", "proof(induct \"llist_of_tllist tlsstlss\" arbitrary: tlsstlss s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tlsstlss s.\n       \\<lbrakk>LNil = llist_of_tllist tlsstlss;\n        \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''\n 2. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s'';\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''", "case lfinite_LNil"], ["proof (state)\nthis:\n  LNil = llist_of_tllist tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inl (tls, s'')\n\ngoal (2 subgoals):\n 1. \\<And>tlsstlss s.\n       \\<lbrakk>LNil = llist_of_tllist tlsstlss;\n        \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''\n 2. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s'';\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''", "thus ?case"], ["proof (prove)\nusing this:\n  LNil = llist_of_tllist tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inl (tls, s'')\n\ngoal (1 subgoal):\n 1. \\<exists>s'. silent_moves2 s' tls s''", "by(cases tlsstlss)(auto simp add: \\<tau>Runs_table2_simps)"], ["proof (state)\nthis:\n  \\<exists>s'. silent_moves2 s' tls s''\n\ngoal (1 subgoal):\n 1. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s'';\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s'';\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''", "case (lfinite_LConsI xs tlsstls)"], ["proof (state)\nthis:\n  lfinite xs\n  \\<lbrakk>xs = llist_of_tllist ?tlsstlss; \\<tau>Runs_table2 ?s ?tlsstlss;\n   terminal ?tlsstlss = Inl (tls, s'')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''\n  LCons tlsstls xs = llist_of_tllist tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inl (tls, s'')\n\ngoal (1 subgoal):\n 1. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s'';\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inl (tls, s'')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  \\<lbrakk>xs = llist_of_tllist ?tlsstlss; \\<tau>Runs_table2 ?s ?tlsstlss;\n   terminal ?tlsstlss = Inl (tls, s'')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'. silent_moves2 s' tls s''\n  LCons tlsstls xs = llist_of_tllist tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inl (tls, s'')\n\ngoal (1 subgoal):\n 1. \\<exists>s'. silent_moves2 s' tls s''", "by(cases tlsstlss)(auto simp add: \\<tau>Runs_table2_simps)"], ["proof (state)\nthis:\n  \\<exists>s'. silent_moves2 s' tls s''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_table2_terminal_inf_stepD:\n  assumes Runs: \"\\<tau>Runs_table2 s tlsstlss\"\n  and fin: \"lfinite (llist_of_tllist tlsstlss)\"\n  and terminal: \"terminal tlsstlss = Inr tls\"\n  shows \"\\<exists>s'. trsys.inf_step silent_move2 s' tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. trsys.inf_step silent_move2 s' tls", "using fin Runs terminal"], ["proof (prove)\nusing this:\n  tfinite tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inr tls\n\ngoal (1 subgoal):\n 1. \\<exists>s'. trsys.inf_step silent_move2 s' tls", "proof(induct \"llist_of_tllist tlsstlss\" arbitrary: s tlsstlss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tlsstlss s.\n       \\<lbrakk>LNil = llist_of_tllist tlsstlss;\n        \\<tau>Runs_table2 s tlsstlss; terminal tlsstlss = Inr tls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls\n 2. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inr tls\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                trsys.inf_step silent_move2 s' tls;\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inr tls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls", "case lfinite_LNil"], ["proof (state)\nthis:\n  LNil = llist_of_tllist tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inr tls\n\ngoal (2 subgoals):\n 1. \\<And>tlsstlss s.\n       \\<lbrakk>LNil = llist_of_tllist tlsstlss;\n        \\<tau>Runs_table2 s tlsstlss; terminal tlsstlss = Inr tls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls\n 2. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inr tls\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                trsys.inf_step silent_move2 s' tls;\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inr tls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls", "thus ?case"], ["proof (prove)\nusing this:\n  LNil = llist_of_tllist tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inr tls\n\ngoal (1 subgoal):\n 1. \\<exists>s'. trsys.inf_step silent_move2 s' tls", "by(cases tlsstlss)(auto simp add: \\<tau>Runs_table2_simps)"], ["proof (state)\nthis:\n  \\<exists>s'. trsys.inf_step silent_move2 s' tls\n\ngoal (1 subgoal):\n 1. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inr tls\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                trsys.inf_step silent_move2 s' tls;\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inr tls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inr tls\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                trsys.inf_step silent_move2 s' tls;\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inr tls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls", "case (lfinite_LConsI xs tlsstls)"], ["proof (state)\nthis:\n  lfinite xs\n  \\<lbrakk>xs = llist_of_tllist ?tlsstlss; \\<tau>Runs_table2 ?s ?tlsstlss;\n   terminal ?tlsstlss = Inr tls\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls\n  LCons tlsstls xs = llist_of_tllist tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inr tls\n\ngoal (1 subgoal):\n 1. \\<And>xs x tlsstlss s.\n       \\<lbrakk>lfinite xs;\n        \\<And>tlsstlss s.\n           \\<lbrakk>xs = llist_of_tllist tlsstlss;\n            \\<tau>Runs_table2 s tlsstlss;\n            terminal tlsstlss = Inr tls\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                trsys.inf_step silent_move2 s' tls;\n        LCons x xs = llist_of_tllist tlsstlss; \\<tau>Runs_table2 s tlsstlss;\n        terminal tlsstlss = Inr tls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  \\<lbrakk>xs = llist_of_tllist ?tlsstlss; \\<tau>Runs_table2 ?s ?tlsstlss;\n   terminal ?tlsstlss = Inr tls\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'. trsys.inf_step silent_move2 s' tls\n  LCons tlsstls xs = llist_of_tllist tlsstlss\n  \\<tau>Runs_table2 s tlsstlss\n  terminal tlsstlss = Inr tls\n\ngoal (1 subgoal):\n 1. \\<exists>s'. trsys.inf_step silent_move2 s' tls", "by(cases tlsstlss)(auto simp add: \\<tau>Runs_table2_simps)"], ["proof (state)\nthis:\n  \\<exists>s'. trsys.inf_step silent_move2 s' tls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>Runs_table2_lappendtD:\n  assumes Runs: \"\\<tau>Runs_table2 s (lappendt tlsstlss tlsstlss')\"\n  and fin: \"lfinite tlsstlss\"\n  shows \"\\<exists>s'. \\<tau>Runs_table2 s' tlsstlss'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. \\<tau>Runs_table2 s' tlsstlss'", "using fin Runs"], ["proof (prove)\nusing this:\n  lfinite tlsstlss\n  \\<tau>Runs_table2 s (lappendt tlsstlss tlsstlss')\n\ngoal (1 subgoal):\n 1. \\<exists>s'. \\<tau>Runs_table2 s' tlsstlss'", "by(induct arbitrary: s)(auto simp add: \\<tau>Runs_table2_simps)"], ["", "end"], ["", "lemma \\<tau>moves_False: \"\\<tau>trsys.silent_move r (\\<lambda>s ta s'. False) = (\\<lambda>s s'. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>trsys.silent_move r (\\<lambda>s ta s'. False) =\n    (\\<lambda>s s'. False)", "by(auto simp add: \\<tau>trsys.silent_move_iff)"], ["", "lemma \\<tau>rtrancl3p_False_eq_rtrancl3p: \"\\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) = rtrancl3p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) = rtrancl3p r", "proof(intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa\n        xb \\<Longrightarrow>\n       rtrancl3p r x xa xb\n 2. \\<And>x xa xb.\n       rtrancl3p r x xa xb \\<Longrightarrow>\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa xb", "fix s tls s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa\n        xb \\<Longrightarrow>\n       rtrancl3p r x xa xb\n 2. \\<And>x xa xb.\n       rtrancl3p r x xa xb \\<Longrightarrow>\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa xb", "assume \"\\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) s tls s'\""], ["proof (state)\nthis:\n  \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) s tls s'\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa\n        xb \\<Longrightarrow>\n       rtrancl3p r x xa xb\n 2. \\<And>x xa xb.\n       rtrancl3p r x xa xb \\<Longrightarrow>\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa xb", "thus \"rtrancl3p r s tls s'\""], ["proof (prove)\nusing this:\n  \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) s tls s'\n\ngoal (1 subgoal):\n 1. rtrancl3p r s tls s'", "by(rule \\<tau>trsys.\\<tau>rtrancl3p.induct)(blast intro: rtrancl3p_step_converse)+"], ["proof (state)\nthis:\n  rtrancl3p r s tls s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       rtrancl3p r x xa xb \\<Longrightarrow>\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa xb", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       rtrancl3p r x xa xb \\<Longrightarrow>\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa xb", "fix s tls s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       rtrancl3p r x xa xb \\<Longrightarrow>\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa xb", "assume \"rtrancl3p r s tls s'\""], ["proof (state)\nthis:\n  rtrancl3p r s tls s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       rtrancl3p r x xa xb \\<Longrightarrow>\n       \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) x xa xb", "thus \"\\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) s tls s'\""], ["proof (prove)\nusing this:\n  rtrancl3p r s tls s'\n\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) s tls s'", "by(induct rule: rtrancl3p_converse_induct)(auto intro: \\<tau>trsys.\\<tau>rtrancl3p.intros)"], ["proof (state)\nthis:\n  \\<tau>trsys.\\<tau>rtrancl3p r (\\<lambda>s tl s'. False) s tls s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>diverge_empty_\\<tau>move:\n  \"\\<tau>trsys.\\<tau>diverge r (\\<lambda>s ta s'. False) = (\\<lambda>s. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>diverge r (\\<lambda>s ta s'. False) =\n    (\\<lambda>s. False)", "by(auto intro!: ext elim: \\<tau>trsys.\\<tau>diverge.cases \\<tau>trsys.silent_move.cases)"], ["", "end"]]}