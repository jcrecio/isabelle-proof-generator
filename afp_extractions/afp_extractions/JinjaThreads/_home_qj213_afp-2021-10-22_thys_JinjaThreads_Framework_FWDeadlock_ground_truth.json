{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWDeadlock.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma all_final_except_mono [mono]:\n  \"(\\<And>x. x \\<in> A \\<longrightarrow> x \\<in> B) \\<Longrightarrow> all_final_except ts A \\<longrightarrow> all_final_except ts B\"", "lemma all_final_except_mono':\n  \"\\<lbrakk> all_final_except ts A; \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> B \\<rbrakk> \\<Longrightarrow> all_final_except ts B\"", "lemma all_final_exceptI:\n  \"(\\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> Ts) \\<Longrightarrow> all_final_except s Ts\"", "lemma all_final_exceptD:\n  \"\\<lbrakk> all_final_except s Ts; not_final_thread s t \\<rbrakk> \\<Longrightarrow> t \\<in> Ts\"", "lemma must_wait_elims [consumes 1, case_names lock join interrupt, cases pred]:\n  assumes \"must_wait s t lt Ts\"\n  obtains l t' where \"lt = Inl l\" \"has_lock (locks s $ l) t'\" \"t' \\<noteq> t\" \"t' \\<in> Ts\"\n  | t' where \"lt = Inr (Inl t')\" \"not_final_thread s t'\" \"t' \\<in> Ts\"\n  | t' where \"lt = Inr (Inr t')\" \"all_final_except s Ts\" \"t' \\<notin> interrupts s\"", "lemma must_wait_iff:\n  \"must_wait s t lt Ts \\<longleftrightarrow> \n  (case lt of Inl l \\<Rightarrow> \\<exists>t'\\<in>Ts. t \\<noteq> t' \\<and> has_lock (locks s $ l) t'\n     | Inr (Inl t') \\<Rightarrow> not_final_thread s t' \\<and> t' \\<in> Ts\n     | Inr (Inr t') \\<Rightarrow> all_final_except s Ts \\<and> t' \\<notin> interrupts s)\"", "lemma deadlockI:\n  \"\\<lbrakk> \\<And>t x. \\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \\<not> final x; wset s t = None \\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s))));\n    \\<And>t x ln l. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; ln $ l > 0; \\<not> waiting (wset s t) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>l t'. ln $ l > 0 \\<and> t \\<noteq> t' \\<and> thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t';\n    \\<And>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> deadlock s\"", "lemma deadlockE:\n  assumes \"deadlock s\"\n  obtains \"\\<forall>t x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> \\<not> final x \\<and> wset s t = None\n        \\<longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s))))\"\n  and \"\\<forall>t x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> (\\<exists>l. ln $ l > 0) \\<and> \\<not> waiting (wset s t)\n                \\<longrightarrow> (\\<exists>l t'. ln $ l > 0 \\<and> t \\<noteq> t' \\<and> thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t')\"\n  and \"\\<forall>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\"", "lemma deadlockD1:\n  assumes \"deadlock s\"\n  and \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n  and \"\\<not> final x\"\n  and \"wset s t = None\"\n  obtains \"t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>\"\n  and \"\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s)))\"", "lemma deadlockD2:\n  fixes ln\n  assumes \"deadlock s\"\n  and \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n  and \"ln $ l > 0\"\n  and \"\\<not> waiting (wset s t)\"\n  obtains l' t' where \"ln $ l' > 0\" \"t \\<noteq> t'\" \"thr s t' \\<noteq> None\" \"has_lock (locks s $ l') t'\"", "lemma deadlockD3:\n  assumes \"deadlock s\"\n  and \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n  shows \"\\<forall>w. wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\"", "lemma deadlock_def2:\n  \"deadlock s \\<longleftrightarrow>\n    (\\<forall>t x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> \\<not> final x \\<and> wset s t = None\n    \\<longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s)))))\n  \\<and> (\\<forall>t x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln \\<noteq> no_wait_locks \\<and> \\<not> waiting (wset s t)\n    \\<longrightarrow> (\\<exists>l. ln $ l > 0 \\<and> must_wait s t (Inl l) (dom (thr s))))\n  \\<and> (\\<forall>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and> wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>)\"", "lemma all_waiting_implies_deadlock:\n  assumes \"lock_thread_ok (locks s) (thr s)\"\n  and normal: \"\\<And>t x. \\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \\<not> final x; wset s t = None \\<rbrakk> \n               \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s))))\"\n  and acquire: \"\\<And>t x ln l. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); ln $ l > 0 \\<rbrakk>\n                 \\<Longrightarrow> \\<exists>l'. ln $ l' > 0 \\<and> \\<not> may_lock (locks s $ l') t\"\n  and wakeup: \"\\<And>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\"\n  shows \"deadlock s\"", "lemma mfinal_deadlock:\n  \"mfinal s \\<Longrightarrow> deadlock s\"", "lemma must_wait_mono:\n  \"(\\<And>x. x \\<in> A \\<longrightarrow> x \\<in> B) \\<Longrightarrow> must_wait s t lt A \\<longrightarrow> must_wait s t lt B\"", "lemma must_wait_mono':\n  \"\\<lbrakk> must_wait s t lt A; A \\<subseteq> B \\<rbrakk> \\<Longrightarrow> must_wait s t lt B\"", "lemma UN_mono: \"\\<lbrakk> x \\<in> A \\<longrightarrow> x \\<in> A'; x \\<in> B \\<longrightarrow> x \\<in> B' \\<rbrakk> \\<Longrightarrow> x \\<in> A \\<union> B \\<longrightarrow> x \\<in> A' \\<union> B'\"", "lemma Collect_mono_conv [mono]: \"x \\<in> {x. P x} \\<longleftrightarrow> P x\"", "lemma deadlockedAcquire_must_wait:\n  \"\\<And>ln. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); ln $ l > 0; must_wait s t (Inl l) (deadlocked s \\<union> final_threads s) \\<rbrakk>\n  \\<Longrightarrow> t \\<in> deadlocked s\"", "lemma deadlocked_elims [consumes 1, case_names lock wait acquire]:\n  assumes \"t \\<in> deadlocked s\"\n  and lock: \"\\<And>x. \\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>; wset s t = None;\n     \\<And>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<Longrightarrow> \\<exists>lt \\<in> LT. must_wait s t lt (deadlocked s \\<union> final_threads s) \\<rbrakk>\n     \\<Longrightarrow> thesis\"\n  and wait: \"\\<And>x ln. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; all_final_except s (deadlocked s); waiting (wset s t) \\<rbrakk>\n     \\<Longrightarrow> thesis\"\n  and acquire: \"\\<And>x ln l t'. \n    \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); 0 < ln $ l; has_lock (locks s $ l) t'; t \\<noteq> t';\n      t' \\<in> deadlocked s \\<or> final_thread s t' \\<rbrakk> \\<Longrightarrow> thesis\"\n  shows thesis", "lemma deadlocked_coinduct \n  [consumes 1, case_names deadlocked, case_conclusion deadlocked Lock Wait Acquire, coinduct set: deadlocked]:\n  assumes major: \"t \\<in> X\"\n  and step: \n  \"\\<And>t. t \\<in> X \\<Longrightarrow>\n     (\\<exists>x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> wset s t = None \\<and>\n         (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt\\<in>LT. must_wait s t lt (X \\<union> deadlocked s \\<union> final_threads s)))) \\<or>\n     (\\<exists>x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> all_final_except s (X \\<union> deadlocked s) \\<and> waiting (wset s t)) \\<or>\n     (\\<exists>x l t' ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> waiting (wset s t) \\<and> 0 < ln $ l \\<and> has_lock (locks s $ l) t' \\<and>\n         t' \\<noteq> t \\<and> ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or> final_thread s t'))\"\n  shows \"t \\<in> deadlocked s\"", "lemma deadlocked'I:\n  \"(\\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s) \\<Longrightarrow> deadlocked' s\"", "lemma deadlocked'D2:\n  \"\\<lbrakk> deadlocked' s; not_final_thread s t; t \\<in> deadlocked s \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma not_deadlocked'I:\n  \"\\<lbrakk> not_final_thread s t; t \\<notin> deadlocked s \\<rbrakk> \\<Longrightarrow> \\<not> deadlocked' s\"", "lemma deadlocked'_intro:\n  \"\\<lbrakk> \\<forall>t. not_final_thread s t \\<longrightarrow> t \\<in> deadlocked s \\<rbrakk> \\<Longrightarrow> deadlocked' s\"", "lemma deadlocked_thread_exists: \n  assumes \"t \\<in> deadlocked s\"\n  and \"\\<And>x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> thesis\"\n  shows thesis", "lemma red_no_deadlock: \n  assumes P: \"s -t\\<triangleright>ta\\<rightarrow> s'\"\n  and dead: \"t \\<in> deadlocked s\"\n  shows False", "lemma deadlocked'_no_red:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; deadlocked' s \\<rbrakk> \\<Longrightarrow> False\"", "lemma not_final_thread_deadlocked_final_thread [iff]: \n  \"thr s t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow> not_final_thread s t \\<or> t \\<in> deadlocked s \\<or> final_thread s t\"", "lemma all_waiting_deadlocked:\n  assumes \"not_final_thread s t\"\n  and \"lock_thread_ok (locks s) (thr s)\" \n  and normal: \"\\<And>t x. \\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \\<not> final x; wset s t = None \\<rbrakk> \n               \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt\\<in>LT. must_wait s t lt (final_threads s)))\"\n  and acquire: \"\\<And>t x ln l. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); ln $ l > 0 \\<rbrakk>\n                \\<Longrightarrow> \\<exists>l'. ln $ l' > 0 \\<and> \\<not> may_lock (locks s $ l') t\"\n  and wakeup: \"\\<And>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\"\n  shows \"t \\<in> deadlocked s\"", "lemma deadlock_implies_deadlocked':\n  assumes dead: \"deadlock s\" \n  shows \"deadlocked' s\"", "lemma deadlocked'_implies_deadlock:\n  assumes dead: \"deadlocked' s\" \n  shows \"deadlock s\"", "lemma deadlock_eq_deadlocked':\n  \"deadlock = deadlocked'\"", "lemma deadlock_no_red:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; deadlock s \\<rbrakk> \\<Longrightarrow> False\"", "lemma deadlock_no_active_threads:\n  assumes dead: \"deadlock s\"\n  shows \"active_threads s = {}\"", "lemma redT_deadlocked_subset:\n  assumes wfs: \"s \\<in> wf_state\"\n  and Red: \"s -t\\<triangleright>ta\\<rightarrow> s'\"\n  shows \"deadlocked s \\<subseteq> deadlocked s'\""], "translations": [["", "lemma all_final_except_mono [mono]:\n  \"(\\<And>x. x \\<in> A \\<longrightarrow> x \\<in> B) \\<Longrightarrow> all_final_except ts A \\<longrightarrow> all_final_except ts B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<longrightarrow> x \\<in> B) \\<Longrightarrow>\n    all_final_except ts A \\<longrightarrow> all_final_except ts B", "by(auto simp add: all_final_except_def)"], ["", "lemma all_final_except_mono':\n  \"\\<lbrakk> all_final_except ts A; \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> B \\<rbrakk> \\<Longrightarrow> all_final_except ts B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_final_except ts A;\n     \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> B\\<rbrakk>\n    \\<Longrightarrow> all_final_except ts B", "by(blast intro: all_final_except_mono[rule_format])"], ["", "lemma all_final_exceptI:\n  \"(\\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> Ts) \\<Longrightarrow> all_final_except s Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        not_final_thread s t \\<Longrightarrow> t \\<in> Ts) \\<Longrightarrow>\n    all_final_except s Ts", "by(auto simp add: all_final_except_def)"], ["", "lemma all_final_exceptD:\n  \"\\<lbrakk> all_final_except s Ts; not_final_thread s t \\<rbrakk> \\<Longrightarrow> t \\<in> Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_final_except s Ts; not_final_thread s t\\<rbrakk>\n    \\<Longrightarrow> t \\<in> Ts", "by(auto simp add: all_final_except_def)"], ["", "inductive must_wait :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't \\<Rightarrow> ('l + 't + 't) \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  for s :: \"('l,'t,'x,'m,'w) state\" and t :: \"'t\" where\n  \\<comment> \\<open>Lock l\\<close>\n  \"\\<lbrakk> has_lock (locks s $ l) t'; t' \\<noteq> t; t' \\<in> Ts \\<rbrakk> \\<Longrightarrow> must_wait s t (Inl l) Ts\"\n| \\<comment> \\<open>Join t'\\<close>\n  \"\\<lbrakk> not_final_thread s t'; t' \\<in> Ts \\<rbrakk> \\<Longrightarrow> must_wait s t (Inr (Inl t')) Ts\"\n| \\<comment> \\<open>IsInterrupted t' True\\<close>\n  \"\\<lbrakk> all_final_except s Ts; t' \\<notin> interrupts s \\<rbrakk> \\<Longrightarrow> must_wait s t (Inr (Inr t')) Ts\""], ["", "declare must_wait.cases [elim]"], ["", "declare must_wait.intros [intro]"], ["", "lemma must_wait_elims [consumes 1, case_names lock join interrupt, cases pred]:\n  assumes \"must_wait s t lt Ts\"\n  obtains l t' where \"lt = Inl l\" \"has_lock (locks s $ l) t'\" \"t' \\<noteq> t\" \"t' \\<in> Ts\"\n  | t' where \"lt = Inr (Inl t')\" \"not_final_thread s t'\" \"t' \\<in> Ts\"\n  | t' where \"lt = Inr (Inr t')\" \"all_final_except s Ts\" \"t' \\<notin> interrupts s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l t'.\n                \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t';\n                 t' \\<noteq> t; t' \\<in> Ts\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>t'.\n        \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n         t' \\<in> Ts\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>t'.\n        \\<lbrakk>lt = Inr (Inr t'); all_final_except s Ts;\n         t' \\<notin> interrupts s\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  must_wait s t lt Ts\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l t'.\n                \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t';\n                 t' \\<noteq> t; t' \\<in> Ts\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>t'.\n        \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n         t' \\<in> Ts\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>t'.\n        \\<lbrakk>lt = Inr (Inr t'); all_final_except s Ts;\n         t' \\<notin> interrupts s\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto)"], ["", "inductive_cases must_wait_elims2 [elim!]:\n  \"must_wait s t (Inl l) Ts\"\n  \"must_wait s t (Inr (Inl t'')) Ts\"\n  \"must_wait s t (Inr (Inr t'')) Ts\""], ["", "lemma must_wait_iff:\n  \"must_wait s t lt Ts \\<longleftrightarrow> \n  (case lt of Inl l \\<Rightarrow> \\<exists>t'\\<in>Ts. t \\<noteq> t' \\<and> has_lock (locks s $ l) t'\n     | Inr (Inl t') \\<Rightarrow> not_final_thread s t' \\<and> t' \\<in> Ts\n     | Inr (Inr t') \\<Rightarrow> all_final_except s Ts \\<and> t' \\<notin> interrupts s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. must_wait s t lt Ts =\n    (case lt of\n     Inl l \\<Rightarrow>\n       \\<exists>t'\\<in>Ts. t \\<noteq> t' \\<and> has_lock (locks s $ l) t'\n     | Inr (Inl t') \\<Rightarrow> not_final_thread s t' \\<and> t' \\<in> Ts\n     | Inr (Inr t') \\<Rightarrow>\n         all_final_except s Ts \\<and> t' \\<notin> interrupts s)", "by(auto simp add: must_wait.simps split: sum.splits)"], ["", "end"], ["", "text\\<open>Deadlock as a system-wide property\\<close>"], ["", "context multithreaded_base begin"], ["", "definition\n  deadlock :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> bool\"\nwhere\n  \"deadlock s\n   \\<equiv>   (\\<forall>t x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> \\<not> final x \\<and> wset s t = None\n        \\<longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s)))))\n     \\<and> (\\<forall>t x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> (\\<exists>l. ln $ l > 0) \\<and> \\<not> waiting (wset s t)\n        \\<longrightarrow> (\\<exists>l t'. ln $ l > 0 \\<and> t \\<noteq> t' \\<and> thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'))\n     \\<and> (\\<forall>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>)\""], ["", "lemma deadlockI:\n  \"\\<lbrakk> \\<And>t x. \\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \\<not> final x; wset s t = None \\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s))));\n    \\<And>t x ln l. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; ln $ l > 0; \\<not> waiting (wset s t) \\<rbrakk>\n    \\<Longrightarrow> \\<exists>l t'. ln $ l > 0 \\<and> t \\<noteq> t' \\<and> thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t';\n    \\<And>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> deadlock s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t x.\n                \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n                 \\<not> final x; wset s t = None\\<rbrakk>\n                \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                                  \\<wrong> \\<and>\n                                  (\\<forall>LT.\nt \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow>\n(\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n     \\<And>t x ln l.\n        \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n         \\<not> waiting (wset s t)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l t'.\n                             0 < ln $ l \\<and>\n                             t \\<noteq> t' \\<and>\n                             thr s t' \\<noteq> None \\<and>\n                             has_lock (locks s $ l) t';\n     \\<And>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> deadlock s", "by(auto simp add: deadlock_def)"], ["", "lemma deadlockE:\n  assumes \"deadlock s\"\n  obtains \"\\<forall>t x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> \\<not> final x \\<and> wset s t = None\n        \\<longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s))))\"\n  and \"\\<forall>t x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> (\\<exists>l. ln $ l > 0) \\<and> \\<not> waiting (wset s t)\n                \\<longrightarrow> (\\<exists>l t'. ln $ l > 0 \\<and> t \\<noteq> t' \\<and> thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t')\"\n  and \"\\<forall>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>t x.\n                 thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                 \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                 t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                 (\\<forall>LT.\n                     t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                     \\<wrong> \\<longrightarrow>\n                     (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n      \\<forall>t x ln.\n         thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n         (\\<exists>l. 0 < ln $ l) \\<and>\n         \\<not> waiting (wset s t) \\<longrightarrow>\n         (\\<exists>l t'.\n             0 < ln $ l \\<and>\n             t \\<noteq> t' \\<and>\n             thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t');\n      \\<forall>t x w.\n         thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n         wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  deadlock s\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>t x.\n                 thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                 \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                 t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                 (\\<forall>LT.\n                     t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                     \\<wrong> \\<longrightarrow>\n                     (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n      \\<forall>t x ln.\n         thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n         (\\<exists>l. 0 < ln $ l) \\<and>\n         \\<not> waiting (wset s t) \\<longrightarrow>\n         (\\<exists>l t'.\n             0 < ln $ l \\<and>\n             t \\<noteq> t' \\<and>\n             thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t');\n      \\<forall>t x w.\n         thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n         wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding deadlock_def"], ["proof (prove)\nusing this:\n  (\\<forall>t x.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n      t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n  (\\<forall>t x ln.\n      thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      (\\<exists>l. 0 < ln $ l) \\<and>\n      \\<not> waiting (wset s t) \\<longrightarrow>\n      (\\<exists>l t'.\n          0 < ln $ l \\<and>\n          t \\<noteq> t' \\<and>\n          thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t')) \\<and>\n  (\\<forall>t x w.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n      wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>t x.\n                 thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                 \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                 t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                 (\\<forall>LT.\n                     t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                     \\<wrong> \\<longrightarrow>\n                     (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n      \\<forall>t x ln.\n         thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n         (\\<exists>l. 0 < ln $ l) \\<and>\n         \\<not> waiting (wset s t) \\<longrightarrow>\n         (\\<exists>l t'.\n             0 < ln $ l \\<and>\n             t \\<noteq> t' \\<and>\n             thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t');\n      \\<forall>t x w.\n         thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n         wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast)"], ["", "lemma deadlockD1:\n  assumes \"deadlock s\"\n  and \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n  and \"\\<not> final x\"\n  and \"wset s t = None\"\n  obtains \"t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>\"\n  and \"\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n      \\<forall>LT.\n         t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n         \\<wrong> \\<longrightarrow>\n         (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s)))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  deadlock s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final x\n  wset s t = None\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n      \\<forall>LT.\n         t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n         \\<wrong> \\<longrightarrow>\n         (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s)))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding deadlock_def"], ["proof (prove)\nusing this:\n  (\\<forall>t x.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n      t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n  (\\<forall>t x ln.\n      thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      (\\<exists>l. 0 < ln $ l) \\<and>\n      \\<not> waiting (wset s t) \\<longrightarrow>\n      (\\<exists>l t'.\n          0 < ln $ l \\<and>\n          t \\<noteq> t' \\<and>\n          thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t')) \\<and>\n  (\\<forall>t x w.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n      wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>)\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final x\n  wset s t = None\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n      \\<forall>LT.\n         t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n         \\<wrong> \\<longrightarrow>\n         (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s)))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast)"], ["", "lemma deadlockD2:\n  fixes ln\n  assumes \"deadlock s\"\n  and \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n  and \"ln $ l > 0\"\n  and \"\\<not> waiting (wset s t)\"\n  obtains l' t' where \"ln $ l' > 0\" \"t \\<noteq> t'\" \"thr s t' \\<noteq> None\" \"has_lock (locks s $ l') t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' t'.\n        \\<lbrakk>0 < ln $ l'; t \\<noteq> t'; thr s t' \\<noteq> None;\n         has_lock (locks s $ l') t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  deadlock s\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset s t)\n\ngoal (1 subgoal):\n 1. (\\<And>l' t'.\n        \\<lbrakk>0 < ln $ l'; t \\<noteq> t'; thr s t' \\<noteq> None;\n         has_lock (locks s $ l') t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding deadlock_def"], ["proof (prove)\nusing this:\n  (\\<forall>t x.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n      t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n  (\\<forall>t x ln.\n      thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      (\\<exists>l. 0 < ln $ l) \\<and>\n      \\<not> waiting (wset s t) \\<longrightarrow>\n      (\\<exists>l t'.\n          0 < ln $ l \\<and>\n          t \\<noteq> t' \\<and>\n          thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t')) \\<and>\n  (\\<forall>t x w.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n      wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ l\n  \\<not> waiting (wset s t)\n\ngoal (1 subgoal):\n 1. (\\<And>l' t'.\n        \\<lbrakk>0 < ln $ l'; t \\<noteq> t'; thr s t' \\<noteq> None;\n         has_lock (locks s $ l') t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma deadlockD3:\n  assumes \"deadlock s\"\n  and \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n  shows \"\\<forall>w. wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w. wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  deadlock s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>w. wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "unfolding deadlock_def"], ["proof (prove)\nusing this:\n  (\\<forall>t x.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n      t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n  (\\<forall>t x ln.\n      thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      (\\<exists>l. 0 < ln $ l) \\<and>\n      \\<not> waiting (wset s t) \\<longrightarrow>\n      (\\<exists>l t'.\n          0 < ln $ l \\<and>\n          t \\<noteq> t' \\<and>\n          thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t')) \\<and>\n  (\\<forall>t x w.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n      wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>)\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>w. wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "by blast"], ["", "lemma deadlock_def2:\n  \"deadlock s \\<longleftrightarrow>\n    (\\<forall>t x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> \\<not> final x \\<and> wset s t = None\n    \\<longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s)))))\n  \\<and> (\\<forall>t x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln \\<noteq> no_wait_locks \\<and> \\<not> waiting (wset s t)\n    \\<longrightarrow> (\\<exists>l. ln $ l > 0 \\<and> must_wait s t (Inl l) (dom (thr s))))\n  \\<and> (\\<forall>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and> wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlock s =\n    ((\\<forall>t x.\n         thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n         \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n         t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n         (\\<forall>LT.\n             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n             \\<wrong> \\<longrightarrow>\n             (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n     (\\<forall>t x ln.\n         thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n         ln \\<noteq> no_wait_locks \\<and>\n         \\<not> waiting (wset s t) \\<longrightarrow>\n         (\\<exists>l.\n             0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n     (\\<forall>t x w.\n         thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n         wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n         wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>))", "unfolding neq_no_wait_locks_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlock s =\n    ((\\<forall>t x.\n         thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n         \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n         t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n         (\\<forall>LT.\n             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n             \\<wrong> \\<longrightarrow>\n             (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n     (\\<forall>t x ln.\n         thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n         (\\<exists>l. 0 < ln $ l) \\<and>\n         \\<not> waiting (wset s t) \\<longrightarrow>\n         (\\<exists>l.\n             0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n     (\\<forall>t x w.\n         thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n         wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n         wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. deadlock s \\<Longrightarrow>\n    (\\<forall>t x.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n    (\\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l.\n            0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n    (\\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>)\n 2. (\\<forall>t x.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n    (\\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l.\n            0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n    (\\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq>\n        \\<lfloor>PostWS WSWokenUp\\<rfloor>) \\<Longrightarrow>\n    deadlock s", "apply(intro strip conjI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>\n 2. \\<And>t x LT.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None;\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))\n 3. \\<And>t x ln.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and> \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            0 < ln $ l \\<and>\n                            must_wait s t (Inl l) (dom (thr s))\n 4. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSNotified\\<rfloor>\n 5. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSWokenUp\\<rfloor>\n 6. (\\<forall>t x.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n    (\\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l.\n            0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n    (\\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq>\n        \\<lfloor>PostWS WSWokenUp\\<rfloor>) \\<Longrightarrow>\n    deadlock s", "apply(blast dest: deadlockD1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>t x LT.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None;\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))\n 2. \\<And>t x ln.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and> \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            0 < ln $ l \\<and>\n                            must_wait s t (Inl l) (dom (thr s))\n 3. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSNotified\\<rfloor>\n 4. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSWokenUp\\<rfloor>\n 5. (\\<forall>t x.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n    (\\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l.\n            0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n    (\\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq>\n        \\<lfloor>PostWS WSWokenUp\\<rfloor>) \\<Longrightarrow>\n    deadlock s", "apply(blast dest: deadlockD1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t x ln.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and> \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            0 < ln $ l \\<and>\n                            must_wait s t (Inl l) (dom (thr s))\n 2. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSNotified\\<rfloor>\n 3. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSWokenUp\\<rfloor>\n 4. (\\<forall>t x.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n    (\\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l.\n            0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n    (\\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq>\n        \\<lfloor>PostWS WSWokenUp\\<rfloor>) \\<Longrightarrow>\n    deadlock s", "apply(blast elim: deadlockD2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSNotified\\<rfloor>\n 2. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSWokenUp\\<rfloor>\n 3. (\\<forall>t x.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n    (\\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l.\n            0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n    (\\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq>\n        \\<lfloor>PostWS WSWokenUp\\<rfloor>) \\<Longrightarrow>\n    deadlock s", "apply(blast dest: deadlockD3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x w.\n       \\<lbrakk>deadlock s;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq>\n                         \\<lfloor>PostWS WSWokenUp\\<rfloor>\n 2. (\\<forall>t x.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n    (\\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l.\n            0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n    (\\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq>\n        \\<lfloor>PostWS WSWokenUp\\<rfloor>) \\<Longrightarrow>\n    deadlock s", "apply(blast dest: deadlockD3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t x.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        (\\<forall>LT.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))))) \\<and>\n    (\\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l.\n            0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)))) \\<and>\n    (\\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq>\n        \\<lfloor>PostWS WSWokenUp\\<rfloor>) \\<Longrightarrow>\n    deadlock s", "apply(elim conjE exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t x.\n                thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                (\\<forall>LT.\n                    t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                    \\<wrong> \\<longrightarrow>\n                    (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n     \\<forall>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        (\\<exists>l. 0 < ln $ l) \\<and>\n        \\<not> waiting (wset s t) \\<longrightarrow>\n        (\\<exists>l. 0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n     \\<forall>t x w.\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n        wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> deadlock s", "apply(rule deadlockI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \\<not> final x;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(rotate_tac 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>\\<forall>t x ln.\n                   thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                   (\\<exists>l. 0 < ln $ l) \\<and>\n                   \\<not> waiting (wset s t) \\<longrightarrow>\n                   (\\<exists>l.\n                       0 < ln $ l \\<and>\n                       must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt (dom (thr s))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(erule allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>\\<forall>xa lna.\n                   thr s (?t231 t x ln l) =\n                   \\<lfloor>(xa, lna)\\<rfloor> \\<and>\n                   (\\<exists>l. 0 < lna $ l) \\<and>\n                   \\<not> waiting\n                           (wset s (?t231 t x ln l)) \\<longrightarrow>\n                   (\\<exists>la.\n                       0 < lna $ la \\<and>\n                       must_wait s (?t231 t x ln l) (Inl la) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt (dom (thr s))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(erule allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>\\<forall>lna.\n                   thr s (?t231 t x ln l) =\n                   \\<lfloor>(?x233 t x ln l, lna)\\<rfloor> \\<and>\n                   (\\<exists>l. 0 < lna $ l) \\<and>\n                   \\<not> waiting\n                           (wset s (?t231 t x ln l)) \\<longrightarrow>\n                   (\\<exists>la.\n                       0 < lna $ la \\<and>\n                       must_wait s (?t231 t x ln l) (Inl la) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt (dom (thr s))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(erule allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s (?t231 t x ln l) =\n                \\<lfloor>(?x233 t x ln l, ?ln235 t x ln l)\\<rfloor> \\<and>\n                (\\<exists>la. 0 < ?ln235 t x ln l $ la) \\<and>\n                \\<not> waiting (wset s (?t231 t x ln l)) \\<longrightarrow>\n                (\\<exists>la.\n                    0 < ?ln235 t x ln l $ la \\<and>\n                    must_wait s (?t231 t x ln l) (Inl la) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt (dom (thr s))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(erule impE, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        \\<exists>l.\n           0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(elim exE conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x ln l la.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; must_wait s t (Inl la) (dom (thr s))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(erule must_wait.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t x ln l la lb t' Ts.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inl lb; dom (thr s) = Ts;\n        has_lock (locks s $ lb) t'; t' \\<noteq> t; t' \\<in> Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x ln l la t' Ts.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inl t'); dom (thr s) = Ts;\n        not_final_thread s t'; t' \\<in> Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x ln l la Ts t'.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inr t'); dom (thr s) = Ts;\n        all_final_except s Ts; t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 4. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(clarify)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t x ln l la lb t' Ts a b.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ lb; has_lock (locks s $ lb) t'; t' \\<noteq> t;\n        thr s t' = \\<lfloor>(a, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x ln l la t' Ts.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inl t'); dom (thr s) = Ts;\n        not_final_thread s t'; t' \\<in> Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x ln l la Ts t'.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inr t'); dom (thr s) = Ts;\n        all_final_except s Ts; t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 4. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(rotate_tac 3)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t x ln l la lb t' Ts a b.\n       \\<lbrakk>\\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ lb; has_lock (locks s $ lb) t'; t' \\<noteq> t;\n        thr s t' = \\<lfloor>(a, b)\\<rfloor>;\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x ln l la t' Ts.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inl t'); dom (thr s) = Ts;\n        not_final_thread s t'; t' \\<in> Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x ln l la Ts t'.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inr t'); dom (thr s) = Ts;\n        all_final_except s Ts; t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 4. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(rule exI conjI|erule not_sym|assumption)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>t x ln l la lb t' Ts a b.\n       \\<lbrakk>\\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ lb; has_lock (locks s $ lb) t'; t' \\<noteq> t;\n        thr s t' = \\<lfloor>(a, b)\\<rfloor>;\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l\\<rbrakk>\n       \\<Longrightarrow> thr s t' \\<noteq> None\n 2. \\<And>t x ln l la lb t' Ts a b.\n       \\<lbrakk>\\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ lb; has_lock (locks s $ lb) t'; t' \\<noteq> t;\n        thr s t' = \\<lfloor>(a, b)\\<rfloor>;\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l\\<rbrakk>\n       \\<Longrightarrow> has_lock (locks s $ lb) t'\n 3. \\<And>t x ln l la t' Ts.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inl t'); dom (thr s) = Ts;\n        not_final_thread s t'; t' \\<in> Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 4. \\<And>t x ln l la Ts t'.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inr t'); dom (thr s) = Ts;\n        all_final_except s Ts; t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 5. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t x ln l la lb t' Ts a b.\n       \\<lbrakk>\\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ lb; has_lock (locks s $ lb) t'; t' \\<noteq> t;\n        thr s t' = \\<lfloor>(a, b)\\<rfloor>;\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l\\<rbrakk>\n       \\<Longrightarrow> has_lock (locks s $ lb) t'\n 2. \\<And>t x ln l la t' Ts.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inl t'); dom (thr s) = Ts;\n        not_final_thread s t'; t' \\<in> Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x ln l la Ts t'.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inr t'); dom (thr s) = Ts;\n        all_final_except s Ts; t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 4. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x ln l la t' Ts.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inl t'); dom (thr s) = Ts;\n        not_final_thread s t'; t' \\<in> Ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x ln l la Ts t'.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inr t'); dom (thr s) = Ts;\n        all_final_except s Ts; t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x ln l la Ts t'.\n       \\<lbrakk>\\<forall>t x w.\n                   thr s t =\n                   \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                   wset s t \\<noteq>\n                   \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n                   wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t);\n        \\<forall>t x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT. must_wait s t lt (dom (thr s))));\n        0 < ln $ la; Inl la = Inr (Inr t'); dom (thr s) = Ts;\n        all_final_except s Ts; t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply(case_tac w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        w = WSNotified\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\n 2. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        w = WSWokenUp\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       \\<lbrakk>\\<forall>t x.\n                   thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                   \\<not> final x \\<and> wset s t = None \\<longrightarrow>\n                   t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n                   (\\<forall>LT.\n                       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                       \\<wrong> \\<longrightarrow>\n                       (\\<exists>lt\\<in>LT.\n                           must_wait s t lt (dom (thr s))));\n        \\<forall>t x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           (\\<exists>l. 0 < ln $ l) \\<and>\n           \\<not> waiting (wset s t) \\<longrightarrow>\n           (\\<exists>l.\n               0 < ln $ l \\<and> must_wait s t (Inl l) (dom (thr s)));\n        \\<forall>t x w.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n           wset s t \\<noteq> \\<lfloor>PostWS WSNotified\\<rfloor> \\<and>\n           wset s t \\<noteq> \\<lfloor>PostWS WSWokenUp\\<rfloor>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        w = WSWokenUp\\<rbrakk>\n       \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma all_waiting_implies_deadlock:\n  assumes \"lock_thread_ok (locks s) (thr s)\"\n  and normal: \"\\<And>t x. \\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \\<not> final x; wset s t = None \\<rbrakk> \n               \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (dom (thr s))))\"\n  and acquire: \"\\<And>t x ln l. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); ln $ l > 0 \\<rbrakk>\n                 \\<Longrightarrow> \\<exists>l'. ln $ l' > 0 \\<and> \\<not> may_lock (locks s $ l') t\"\n  and wakeup: \"\\<And>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\"\n  shows \"deadlock s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlock s", "proof(rule deadlockI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix T X"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume \"thr s T = \\<lfloor>(X, no_wait_locks)\\<rfloor>\" \"\\<not> final X\" \"wset s T = None\""], ["proof (state)\nthis:\n  thr s T = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  \\<not> final X\n  wset s T = None\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "thus \"T \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. T \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt\\<in>LT. must_wait s T lt (dom (thr s))))\""], ["proof (prove)\nusing this:\n  thr s T = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  \\<not> final X\n  wset s T = None\n\ngoal (1 subgoal):\n 1. T \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong> \\<and>\n    (\\<forall>LT.\n        T \\<turnstile> \\<langle>X, shr s\\<rangle> LT\n        \\<wrong> \\<longrightarrow>\n        (\\<exists>lt\\<in>LT. must_wait s T lt (dom (thr s))))", "by(rule normal)"], ["proof (state)\nthis:\n  T \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong> \\<and>\n  (\\<forall>LT.\n      T \\<turnstile> \\<langle>X, shr s\\<rangle> LT\n      \\<wrong> \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. must_wait s T lt (dom (thr s))))\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix T X LN l'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume \"thr s T = \\<lfloor>(X, LN)\\<rfloor>\"\n    and \"0 < LN $ l'\"\n    and wset: \"\\<not> waiting (wset s T)\""], ["proof (state)\nthis:\n  thr s T = \\<lfloor>(X, LN)\\<rfloor>\n  0 < LN $ l'\n  \\<not> waiting (wset s T)\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "from acquire[OF \\<open>thr s T = \\<lfloor>(X, LN)\\<rfloor>\\<close> wset, OF \\<open>0 < LN $ l'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>l'. 0 < LN $ l' \\<and> \\<not> may_lock (locks s $ l') T", "obtain l' where \"0 < LN $ l'\" \"\\<not> may_lock (locks s $ l') T\""], ["proof (prove)\nusing this:\n  \\<exists>l'. 0 < LN $ l' \\<and> \\<not> may_lock (locks s $ l') T\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>0 < LN $ l'; \\<not> may_lock (locks s $ l') T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 < LN $ l'\n  \\<not> may_lock (locks s $ l') T\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  0 < LN $ l'\n  \\<not> may_lock (locks s $ l') T", "obtain t' where \"T \\<noteq> t'\" \"has_lock (locks s $ l') t'\""], ["proof (prove)\nusing this:\n  0 < LN $ l'\n  \\<not> may_lock (locks s $ l') T\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>T \\<noteq> t'; has_lock (locks s $ l') t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding not_may_lock_conv"], ["proof (prove)\nusing this:\n  0 < LN $ l'\n  \\<exists>t'. t' \\<noteq> T \\<and> has_lock (locks s $ l') t'\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>T \\<noteq> t'; has_lock (locks s $ l') t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  T \\<noteq> t'\n  has_lock (locks s $ l') t'\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  T \\<noteq> t'\n  has_lock (locks s $ l') t'\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "with \\<open>lock_thread_ok (locks s) (thr s)\\<close>"], ["proof (chain)\npicking this:\n  lock_thread_ok (locks s) (thr s)\n  T \\<noteq> t'\n  has_lock (locks s $ l') t'", "have \"thr s t' \\<noteq> None\""], ["proof (prove)\nusing this:\n  lock_thread_ok (locks s) (thr s)\n  T \\<noteq> t'\n  has_lock (locks s $ l') t'\n\ngoal (1 subgoal):\n 1. thr s t' \\<noteq> None", "by(auto dest: lock_thread_okD)"], ["proof (state)\nthis:\n  thr s t' \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  T \\<noteq> t'\n  has_lock (locks s $ l') t'\n  thr s t' \\<noteq> None", "show \"\\<exists>l t'. 0 < LN $ l \\<and> T \\<noteq> t' \\<and> thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'\""], ["proof (prove)\nusing this:\n  T \\<noteq> t'\n  has_lock (locks s $ l') t'\n  thr s t' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>l t'.\n       0 < LN $ l \\<and>\n       T \\<noteq> t' \\<and>\n       thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'", "using \\<open>0 < LN $ l'\\<close>"], ["proof (prove)\nusing this:\n  T \\<noteq> t'\n  has_lock (locks s $ l') t'\n  thr s t' \\<noteq> None\n  0 < LN $ l'\n\ngoal (1 subgoal):\n 1. \\<exists>l t'.\n       0 < LN $ l \\<and>\n       T \\<noteq> t' \\<and>\n       thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>l t'.\n     0 < LN $ l \\<and>\n     T \\<noteq> t' \\<and>\n     thr s t' \\<noteq> None \\<and> has_lock (locks s $ l) t'\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "qed(rule wakeup)"], ["", "lemma mfinal_deadlock:\n  \"mfinal s \\<Longrightarrow> deadlock s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mfinal s \\<Longrightarrow> deadlock s", "unfolding mfinal_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (thr s) \\<subseteq> final_threads s \\<Longrightarrow> deadlock s", "by(rule deadlockI)(auto simp add: final_thread_def)"], ["", "text \\<open>Now deadlock for single threads\\<close>"], ["", "lemma must_wait_mono:\n  \"(\\<And>x. x \\<in> A \\<longrightarrow> x \\<in> B) \\<Longrightarrow> must_wait s t lt A \\<longrightarrow> must_wait s t lt B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<longrightarrow> x \\<in> B) \\<Longrightarrow>\n    must_wait s t lt A \\<longrightarrow> must_wait s t lt B", "by(auto simp add: must_wait_iff split: sum.split elim: all_final_except_mono')"], ["", "lemma must_wait_mono':\n  \"\\<lbrakk> must_wait s t lt A; A \\<subseteq> B \\<rbrakk> \\<Longrightarrow> must_wait s t lt B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>must_wait s t lt A; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> must_wait s t lt B", "using must_wait_mono[of A B s t lt]"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> A \\<longrightarrow> x \\<in> B) \\<Longrightarrow>\n  must_wait s t lt A \\<longrightarrow> must_wait s t lt B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>must_wait s t lt A; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> must_wait s t lt B", "by blast"], ["", "end"], ["", "lemma UN_mono: \"\\<lbrakk> x \\<in> A \\<longrightarrow> x \\<in> A'; x \\<in> B \\<longrightarrow> x \\<in> B' \\<rbrakk> \\<Longrightarrow> x \\<in> A \\<union> B \\<longrightarrow> x \\<in> A' \\<union> B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A \\<longrightarrow> x \\<in> A';\n     x \\<in> B \\<longrightarrow> x \\<in> B'\\<rbrakk>\n    \\<Longrightarrow> x \\<in> A \\<union> B \\<longrightarrow>\n                      x \\<in> A' \\<union> B'", "by blast"], ["", "lemma Collect_mono_conv [mono]: \"x \\<in> {x. P x} \\<longleftrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {x. P x}) = P x", "by blast"], ["", "context multithreaded_base begin"], ["", "coinductive_set deadlocked :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't set\"\n  for s :: \"('l,'t,'x,'m,'w) state\" where\n  deadlockedLock:\n    \"\\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>; wset s t = None;\n       \\<And>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<Longrightarrow> \\<exists>lt \\<in> LT. must_wait s t lt (deadlocked s \\<union> final_threads s) \\<rbrakk>\n     \\<Longrightarrow> t \\<in> deadlocked s\"\n\n| deadlockedWait:\n    \"\\<And>ln. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; all_final_except s (deadlocked s); waiting (wset s t) \\<rbrakk> \\<Longrightarrow> t \\<in> deadlocked s\"\n\n| deadlockedAcquire:\n    \"\\<And>ln. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); ln $ l > 0; has_lock (locks s $ l) t'; t' \\<noteq> t; \n       t' \\<in> deadlocked s \\<or> final_thread s t' \\<rbrakk> \n     \\<Longrightarrow> t \\<in> deadlocked s\"\nmonos must_wait_mono UN_mono"], ["", "lemma deadlockedAcquire_must_wait:\n  \"\\<And>ln. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); ln $ l > 0; must_wait s t (Inl l) (deadlocked s \\<union> final_threads s) \\<rbrakk>\n  \\<Longrightarrow> t \\<in> deadlocked s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t); 0 < ln $ l;\n        must_wait s t (Inl l)\n         (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t \\<in> deadlocked s", "apply(erule must_wait_elims)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ln la t'.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t); 0 < ln $ l; Inl l = Inl la;\n        has_lock (locks s $ la) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> t \\<in> deadlocked s\n 2. \\<And>ln t'.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t); 0 < ln $ l; Inl l = Inr (Inl t');\n        not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> t \\<in> deadlocked s\n 3. \\<And>ln t'.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t); 0 < ln $ l; Inl l = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> t \\<in> deadlocked s", "apply(erule (2) deadlockedAcquire)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ln la t'.\n       \\<lbrakk>\\<not> waiting (wset s t); 0 < ln $ l; Inl l = Inl la;\n        has_lock (locks s $ la) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> has_lock (locks s $ l) (?t'4 ln la t')\n 2. \\<And>ln la t'.\n       \\<lbrakk>\\<not> waiting (wset s t); 0 < ln $ l; Inl l = Inl la;\n        has_lock (locks s $ la) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> ?t'4 ln la t' \\<noteq> t\n 3. \\<And>ln la t'.\n       \\<lbrakk>\\<not> waiting (wset s t); 0 < ln $ l; Inl l = Inl la;\n        has_lock (locks s $ la) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> ?t'4 ln la t' \\<in> deadlocked s \\<or>\n                         ?t'4 ln la t' \\<in> final_threads s\n 4. \\<And>ln t'.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t); 0 < ln $ l; Inl l = Inr (Inl t');\n        not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> t \\<in> deadlocked s\n 5. \\<And>ln t'.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t); 0 < ln $ l; Inl l = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> t \\<in> deadlocked s", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deadlocked_elims [consumes 1, case_names lock wait acquire]:\n  assumes \"t \\<in> deadlocked s\"\n  and lock: \"\\<And>x. \\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>; wset s t = None;\n     \\<And>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<Longrightarrow> \\<exists>lt \\<in> LT. must_wait s t lt (deadlocked s \\<union> final_threads s) \\<rbrakk>\n     \\<Longrightarrow> thesis\"\n  and wait: \"\\<And>x ln. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; all_final_except s (deadlocked s); waiting (wset s t) \\<rbrakk>\n     \\<Longrightarrow> thesis\"\n  and acquire: \"\\<And>x ln l t'. \n    \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); 0 < ln $ l; has_lock (locks s $ l) t'; t \\<noteq> t';\n      t' \\<in> deadlocked s \\<or> final_thread s t' \\<rbrakk> \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> deadlocked s\n  \\<lbrakk>thr s t = \\<lfloor>(?x14, no_wait_locks)\\<rfloor>;\n   t \\<turnstile> \\<langle>?x14, shr s\\<rangle> \\<wrong>; wset s t = None;\n   \\<And>LT.\n      t \\<turnstile> \\<langle>?x14, shr s\\<rangle> LT\n      \\<wrong> \\<Longrightarrow>\n      \\<exists>lt\\<in>LT.\n         must_wait s t lt (deadlocked s \\<union> final_threads s)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>thr s t = \\<lfloor>(?x14, ?ln14)\\<rfloor>;\n   all_final_except s (deadlocked s); waiting (wset s t)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>thr s t = \\<lfloor>(?x14, ?ln14)\\<rfloor>;\n   \\<not> waiting (wset s t); 0 < ?ln14 $ ?l14;\n   has_lock (locks s $ ?l14) ?t'14; t \\<noteq> ?t'14;\n   ?t'14 \\<in> deadlocked s \\<or> final_thread s ?t'14\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by cases blast+"], ["", "lemma deadlocked_coinduct \n  [consumes 1, case_names deadlocked, case_conclusion deadlocked Lock Wait Acquire, coinduct set: deadlocked]:\n  assumes major: \"t \\<in> X\"\n  and step: \n  \"\\<And>t. t \\<in> X \\<Longrightarrow>\n     (\\<exists>x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> wset s t = None \\<and>\n         (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt\\<in>LT. must_wait s t lt (X \\<union> deadlocked s \\<union> final_threads s)))) \\<or>\n     (\\<exists>x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> all_final_except s (X \\<union> deadlocked s) \\<and> waiting (wset s t)) \\<or>\n     (\\<exists>x l t' ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> waiting (wset s t) \\<and> 0 < ln $ l \\<and> has_lock (locks s $ l) t' \\<and>\n         t' \\<noteq> t \\<and> ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or> final_thread s t'))\"\n  shows \"t \\<in> deadlocked s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "using major"], ["proof (prove)\nusing this:\n  t \\<in> X\n\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       (\\<exists>t xa.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>xa, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>x.\n               t \\<turnstile> \\<langle>xa, shr s\\<rangle> x\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>x.\n                   must_wait s t lt\n                    ({a. a \\<in> X} \\<union> deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>t xa ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           all_final_except s\n            {x. x \\<in> X \\<or> x \\<in> deadlocked s} \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>t xa l t' ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or>\n            t' \\<in> final_threads s))", "case (deadlocked t)"], ["proof (state)\nthis:\n  t \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       (\\<exists>t xa.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>xa, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>x.\n               t \\<turnstile> \\<langle>xa, shr s\\<rangle> x\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>x.\n                   must_wait s t lt\n                    ({a. a \\<in> X} \\<union> deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>t xa ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           all_final_except s\n            {x. x \\<in> X \\<or> x \\<in> deadlocked s} \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>t xa l t' ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or>\n            t' \\<in> final_threads s))", "have \"X \\<union> deadlocked s \\<union> final_threads s = {x. x \\<in> X \\<or> x \\<in> deadlocked s \\<or> x \\<in> final_threads s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<union> deadlocked s \\<union> final_threads s =\n    {x. x \\<in> X \\<or> x \\<in> deadlocked s \\<or> x \\<in> final_threads s}", "by auto"], ["proof (state)\nthis:\n  X \\<union> deadlocked s \\<union> final_threads s =\n  {x. x \\<in> X \\<or> x \\<in> deadlocked s \\<or> x \\<in> final_threads s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       (\\<exists>t xa.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>xa, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>x.\n               t \\<turnstile> \\<langle>xa, shr s\\<rangle> x\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>x.\n                   must_wait s t lt\n                    ({a. a \\<in> X} \\<union> deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>t xa ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           all_final_except s\n            {x. x \\<in> X \\<or> x \\<in> deadlocked s} \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>t xa l t' ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or>\n            t' \\<in> final_threads s))", "moreover"], ["proof (state)\nthis:\n  X \\<union> deadlocked s \\<union> final_threads s =\n  {x. x \\<in> X \\<or> x \\<in> deadlocked s \\<or> x \\<in> final_threads s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       (\\<exists>t xa.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>xa, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>x.\n               t \\<turnstile> \\<langle>xa, shr s\\<rangle> x\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>x.\n                   must_wait s t lt\n                    ({a. a \\<in> X} \\<union> deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>t xa ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           all_final_except s\n            {x. x \\<in> X \\<or> x \\<in> deadlocked s} \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>t xa l t' ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or>\n            t' \\<in> final_threads s))", "have \"X \\<union> deadlocked s = {x. x \\<in> X \\<or> x \\<in> deadlocked s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<union> deadlocked s = {x. x \\<in> X \\<or> x \\<in> deadlocked s}", "by blast"], ["proof (state)\nthis:\n  X \\<union> deadlocked s = {x. x \\<in> X \\<or> x \\<in> deadlocked s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       (\\<exists>t xa.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>xa, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>x.\n               t \\<turnstile> \\<langle>xa, shr s\\<rangle> x\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>x.\n                   must_wait s t lt\n                    ({a. a \\<in> X} \\<union> deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>t xa ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           all_final_except s\n            {x. x \\<in> X \\<or> x \\<in> deadlocked s} \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>t xa l t' ln.\n           x = t \\<and>\n           thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or>\n            t' \\<in> final_threads s))", "ultimately"], ["proof (chain)\npicking this:\n  X \\<union> deadlocked s \\<union> final_threads s =\n  {x. x \\<in> X \\<or> x \\<in> deadlocked s \\<or> x \\<in> final_threads s}\n  X \\<union> deadlocked s = {x. x \\<in> X \\<or> x \\<in> deadlocked s}", "show ?case"], ["proof (prove)\nusing this:\n  X \\<union> deadlocked s \\<union> final_threads s =\n  {x. x \\<in> X \\<or> x \\<in> deadlocked s \\<or> x \\<in> final_threads s}\n  X \\<union> deadlocked s = {x. x \\<in> X \\<or> x \\<in> deadlocked s}\n\ngoal (1 subgoal):\n 1. (\\<exists>t x.\n        t = t \\<and>\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t = None \\<and>\n        (\\<forall>xa.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> xa\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>xa.\n                must_wait s t lt\n                 ({a. a \\<in> X} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>t x ln.\n        t = t \\<and>\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s {x. x \\<in> X \\<or> x \\<in> deadlocked s} \\<and>\n        waiting (wset s t)) \\<or>\n    (\\<exists>t x l t' ln.\n        t = t \\<and>\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t \\<and>\n        ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or>\n         t' \\<in> final_threads s))", "using step[OF deadlocked]"], ["proof (prove)\nusing this:\n  X \\<union> deadlocked s \\<union> final_threads s =\n  {x. x \\<in> X \\<or> x \\<in> deadlocked s \\<or> x \\<in> final_threads s}\n  X \\<union> deadlocked s = {x. x \\<in> X \\<or> x \\<in> deadlocked s}\n  (\\<exists>x.\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t = None \\<and>\n      (\\<forall>LT.\n          t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t lt\n               (X \\<union> deadlocked s \\<union> final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s (X \\<union> deadlocked s) \\<and>\n      waiting (wset s t)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t \\<and>\n      ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or> final_thread s t'))\n\ngoal (1 subgoal):\n 1. (\\<exists>t x.\n        t = t \\<and>\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t = None \\<and>\n        (\\<forall>xa.\n            t \\<turnstile> \\<langle>x, shr s\\<rangle> xa\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>xa.\n                must_wait s t lt\n                 ({a. a \\<in> X} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>t x ln.\n        t = t \\<and>\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s {x. x \\<in> X \\<or> x \\<in> deadlocked s} \\<and>\n        waiting (wset s t)) \\<or>\n    (\\<exists>t x l t' ln.\n        t = t \\<and>\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t \\<and>\n        ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or>\n         t' \\<in> final_threads s))", "by(elim disjE) simp_all"], ["proof (state)\nthis:\n  (\\<exists>t x.\n      t = t \\<and>\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t = None \\<and>\n      (\\<forall>xa.\n          t \\<turnstile> \\<langle>x, shr s\\<rangle> xa\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>xa.\n              must_wait s t lt\n               ({a. a \\<in> X} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>t x ln.\n      t = t \\<and>\n      thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s {x. x \\<in> X \\<or> x \\<in> deadlocked s} \\<and>\n      waiting (wset s t)) \\<or>\n  (\\<exists>t x l t' ln.\n      t = t \\<and>\n      thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t \\<and>\n      ((t' \\<in> X \\<or> t' \\<in> deadlocked s) \\<or>\n       t' \\<in> final_threads s))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition deadlocked' :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> bool\" where\n  \"deadlocked' s \\<equiv> (\\<forall>t. not_final_thread s t \\<longrightarrow> t \\<in> deadlocked s)\""], ["", "lemma deadlocked'I:\n  \"(\\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s) \\<Longrightarrow> deadlocked' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        not_final_thread s t \\<Longrightarrow>\n        t \\<in> deadlocked s) \\<Longrightarrow>\n    deadlocked' s", "by(auto simp add: deadlocked'_def)"], ["", "lemma deadlocked'D2:\n  \"\\<lbrakk> deadlocked' s; not_final_thread s t; t \\<in> deadlocked s \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deadlocked' s; not_final_thread s t;\n     t \\<in> deadlocked s \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto simp add: deadlocked'_def)"], ["", "lemma not_deadlocked'I:\n  \"\\<lbrakk> not_final_thread s t; t \\<notin> deadlocked s \\<rbrakk> \\<Longrightarrow> \\<not> deadlocked' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_final_thread s t; t \\<notin> deadlocked s\\<rbrakk>\n    \\<Longrightarrow> \\<not> deadlocked' s", "by(auto dest: deadlocked'D2)"], ["", "lemma deadlocked'_intro:\n  \"\\<lbrakk> \\<forall>t. not_final_thread s t \\<longrightarrow> t \\<in> deadlocked s \\<rbrakk> \\<Longrightarrow> deadlocked' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       not_final_thread s t \\<longrightarrow>\n       t \\<in> deadlocked s \\<Longrightarrow>\n    deadlocked' s", "by(rule deadlocked'I)(blast)+"], ["", "lemma deadlocked_thread_exists: \n  assumes \"t \\<in> deadlocked s\"\n  and \"\\<And>x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> deadlocked s\n  thr s t = \\<lfloor>(?x14, ?ln14)\\<rfloor> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by cases blast+"], ["", "end"], ["", "context multithreaded begin"], ["", "lemma red_no_deadlock: \n  assumes P: \"s -t\\<triangleright>ta\\<rightarrow> s'\"\n  and dead: \"t \\<in> deadlocked s\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from P"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'", "show False"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. False", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> False", "case (redT_normal x x' m')"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> False", "note red = \\<open>t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\\<close>"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> False", "note tst = \\<open>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> False", "note aok = \\<open>actions_ok s t ta\\<close>"], ["proof (state)\nthis:\n  actions_ok s t ta\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"\\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False\n 2. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False\n 2. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "with aok"], ["proof (chain)\npicking this:\n  actions_ok s t ta\n  \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  actions_ok s t ta\n  \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: wset_actions_ok_def split: if_split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "with dead tst"], ["proof (chain)\npicking this:\n  t \\<in> deadlocked s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor>", "have mle: \"t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>\"\n        and cledead: \"\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t lt (deadlocked s \\<union> final_threads s))\""], ["proof (prove)\nusing this:\n  t \\<in> deadlocked s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> &&&\n    \\<forall>LT.\n       t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n       \\<wrong> \\<longrightarrow>\n       (\\<exists>lt\\<in>LT.\n           must_wait s t lt (deadlocked s \\<union> final_threads s))", "by(cases, auto simp add: waiting_def)+"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>\n  \\<forall>LT.\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow>\n     (\\<exists>lt\\<in>LT.\n         must_wait s t lt (deadlocked s \\<union> final_threads s))\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "let ?LT = \"collect_waits ta\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "from red"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>", "have \"t \\<turnstile> \\<langle>x, shr s\\<rangle> ?LT \\<wrong>\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n\ngoal (1 subgoal):\n 1. t \\<turnstile> \\<langle>x, shr s\\<rangle> collect_waits ta \\<wrong>", "by(auto intro: can_syncI)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> collect_waits ta \\<wrong>\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> collect_waits ta \\<wrong>", "obtain lt where lt: \"lt \\<in> ?LT\" and mw: \"must_wait s t lt (deadlocked s \\<union> final_threads s)\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> collect_waits ta \\<wrong>\n\ngoal (1 subgoal):\n 1. (\\<And>lt.\n        \\<lbrakk>lt \\<in> collect_waits ta;\n         must_wait s t lt (deadlocked s \\<union> final_threads s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: cledead[rule_format])"], ["proof (state)\nthis:\n  lt \\<in> collect_waits ta\n  must_wait s t lt (deadlocked s \\<union> final_threads s)\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "from mw"], ["proof (chain)\npicking this:\n  must_wait s t lt (deadlocked s \\<union> final_threads s)", "show False"], ["proof (prove)\nusing this:\n  must_wait s t lt (deadlocked s \\<union> final_threads s)\n\ngoal (1 subgoal):\n 1. False", "proof(cases rule: must_wait_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "case (lock l t')"], ["proof (state)\nthis:\n  lt = Inl l\n  has_lock (locks s $ l) t'\n  t' \\<noteq> t\n  t' \\<in> deadlocked s \\<union> final_threads s\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>lt = Inl l\\<close> lt"], ["proof (chain)\npicking this:\n  lt = Inl l\n  lt \\<in> collect_waits ta", "have \"l \\<in> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\""], ["proof (prove)\nusing this:\n  lt = Inl l\n  lt \\<in> collect_waits ta\n\ngoal (1 subgoal):\n 1. l \\<in> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>", "by(auto)"], ["proof (state)\nthis:\n  l \\<in> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "with aok"], ["proof (chain)\npicking this:\n  actions_ok s t ta\n  l \\<in> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>", "have \"may_lock (locks s $ l) t\""], ["proof (prove)\nusing this:\n  actions_ok s t ta\n  l \\<in> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>\n\ngoal (1 subgoal):\n 1. may_lock (locks s $ l) t", "by(auto elim!: collect_locksE lock_ok_las_may_lock)"], ["proof (state)\nthis:\n  may_lock (locks s $ l) t\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>has_lock (locks s $ l) t'\\<close>"], ["proof (chain)\npicking this:\n  has_lock (locks s $ l) t'\n  may_lock (locks s $ l) t", "have \"t' = t\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ l) t'\n  may_lock (locks s $ l) t\n\ngoal (1 subgoal):\n 1. t' = t", "by(auto dest: has_lock_may_lock_t_eq)"], ["proof (state)\nthis:\n  t' = t\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t;\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>t' \\<noteq> t\\<close>"], ["proof (chain)\npicking this:\n  t' \\<noteq> t\n  t' = t", "show False"], ["proof (prove)\nusing this:\n  t' \\<noteq> t\n  t' = t\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "case (join t')"], ["proof (state)\nthis:\n  lt = Inr (Inl t')\n  not_final_thread s t'\n  t' \\<in> deadlocked s \\<union> final_threads s\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>lt = Inr (Inl t')\\<close> lt"], ["proof (chain)\npicking this:\n  lt = Inr (Inl t')\n  lt \\<in> collect_waits ta", "have \"Join t' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\""], ["proof (prove)\nusing this:\n  lt = Inr (Inl t')\n  lt \\<in> collect_waits ta\n\ngoal (1 subgoal):\n 1. Join t' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>", "by auto"], ["proof (state)\nthis:\n  Join t' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>not_final_thread s t'\\<close>"], ["proof (chain)\npicking this:\n  not_final_thread s t'", "obtain x'' ln''\n          where \"thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\""], ["proof (prove)\nusing this:\n  not_final_thread s t'\n\ngoal (1 subgoal):\n 1. (\\<And>x'' ln''.\n        thr s t' = \\<lfloor>(x'', ln'')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(rule not_final_thread_existsE)"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>Join t' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\\<close> aok"], ["proof (chain)\npicking this:\n  Join t' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\n  actions_ok s t ta\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>", "have \"final x''\" \"ln'' = no_wait_locks\" \"wset s t' = None\""], ["proof (prove)\nusing this:\n  Join t' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>\n  actions_ok s t ta\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. final x'' &&& ln'' = no_wait_locks &&& wset s t' = None", "by(auto dest: cond_action_oks_Join)"], ["proof (state)\nthis:\n  final x''\n  ln'' = no_wait_locks\n  wset s t' = None\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  final x''\n  ln'' = no_wait_locks\n  wset s t' = None", "show False"], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  final x''\n  ln'' = no_wait_locks\n  wset s t' = None\n\ngoal (1 subgoal):\n 1. False", "using \\<open>not_final_thread s t'\\<close>"], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  final x''\n  ln'' = no_wait_locks\n  wset s t' = None\n  not_final_thread s t'\n\ngoal (1 subgoal):\n 1. False", "by(auto)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "case (interrupt t')"], ["proof (state)\nthis:\n  lt = Inr (Inr t')\n  all_final_except s (deadlocked s \\<union> final_threads s)\n  t' \\<notin> interrupts s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "from  aok lt \\<open>lt = Inr (Inr t')\\<close>"], ["proof (chain)\npicking this:\n  actions_ok s t ta\n  lt \\<in> collect_waits ta\n  lt = Inr (Inr t')", "have \"t' \\<in> interrupts s\""], ["proof (prove)\nusing this:\n  actions_ok s t ta\n  lt \\<in> collect_waits ta\n  lt = Inr (Inr t')\n\ngoal (1 subgoal):\n 1. t' \\<in> interrupts s", "by(auto intro: collect_interrupts_interrupted)"], ["proof (state)\nthis:\n  t' \\<in> interrupts s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>t' \\<notin> interrupts s\\<close>"], ["proof (chain)\npicking this:\n  t' \\<notin> interrupts s\n  t' \\<in> interrupts s", "show False"], ["proof (prove)\nusing this:\n  t' \\<notin> interrupts s\n  t' \\<in> interrupts s\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> False", "case (redT_acquire x n ln)"], ["proof (state)\nthis:\n  ta = (K$ [], [], [], [], [], convert_RA ln)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t ln\n  0 < ln $ n\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"\\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False\n 2. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False\n 2. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "with \\<open>\\<not> waiting (wset s t)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s t)\n  \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t)\n  \\<exists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "with dead \\<open>thr s t = \\<lfloor>(x, ln)\\<rfloor>\\<close> \\<open>0 < ln $ n\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> deadlocked s\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ n\n  \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor>", "obtain l t' where \"0 < ln $ l\" \"t \\<noteq> t'\"\n        and \"has_lock (locks s $ l) t'\""], ["proof (prove)\nusing this:\n  t \\<in> deadlocked s\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ n\n  \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>l t'.\n        \\<lbrakk>0 < ln $ l; t \\<noteq> t';\n         has_lock (locks s $ l) t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases)(fastforce simp add: waiting_def)+"], ["proof (state)\nthis:\n  0 < ln $ l\n  t \\<noteq> t'\n  has_lock (locks s $ l) t'\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "hence \"\\<not> may_acquire_all (locks s) t ln\""], ["proof (prove)\nusing this:\n  0 < ln $ l\n  t \\<noteq> t'\n  has_lock (locks s $ l) t'\n\ngoal (1 subgoal):\n 1. \\<not> may_acquire_all (locks s) t ln", "by(auto elim: may_acquire_allE dest: has_lock_may_lock_t_eq)"], ["proof (state)\nthis:\n  \\<not> may_acquire_all (locks s) t ln\n\ngoal (1 subgoal):\n 1. \\<nexists>w. wset s t = \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow> False", "with \\<open>may_acquire_all (locks s) t ln\\<close>"], ["proof (chain)\npicking this:\n  may_acquire_all (locks s) t ln\n  \\<not> may_acquire_all (locks s) t ln", "show ?thesis"], ["proof (prove)\nusing this:\n  may_acquire_all (locks s) t ln\n  \\<not> may_acquire_all (locks s) t ln\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deadlocked'_no_red:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; deadlocked' s \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s'; deadlocked' s\\<rbrakk>\n    \\<Longrightarrow> False", "apply(rule red_no_deadlock)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s'; deadlocked' s\\<rbrakk>\n    \\<Longrightarrow> ?s -?t\\<triangleright>?ta\\<rightarrow> ?s'\n 2. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s'; deadlocked' s\\<rbrakk>\n    \\<Longrightarrow> ?t \\<in> deadlocked ?s", "apply(assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s'; deadlocked' s\\<rbrakk>\n    \\<Longrightarrow> t \\<in> deadlocked s", "apply(erule deadlocked'D2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s -t\\<triangleright>ta\\<rightarrow> s' \\<Longrightarrow>\n    not_final_thread s ?t3\n 2. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s';\n     ?t3 \\<in> deadlocked s\\<rbrakk>\n    \\<Longrightarrow> t \\<in> deadlocked s", "by(rule red_not_final_thread)"], ["", "lemma not_final_thread_deadlocked_final_thread [iff]: \n  \"thr s t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow> not_final_thread s t \\<or> t \\<in> deadlocked s \\<or> final_thread s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr s t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow>\n    not_final_thread s t \\<or> t \\<in> deadlocked s \\<or> final_thread s t", "by(auto simp add: not_final_thread_final_thread_conv[symmetric])"], ["", "lemma all_waiting_deadlocked:\n  assumes \"not_final_thread s t\"\n  and \"lock_thread_ok (locks s) (thr s)\" \n  and normal: \"\\<And>t x. \\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \\<not> final x; wset s t = None \\<rbrakk> \n               \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t \\<turnstile> \\<langle>x, shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt\\<in>LT. must_wait s t lt (final_threads s)))\"\n  and acquire: \"\\<And>t x ln l. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t); ln $ l > 0 \\<rbrakk>\n                \\<Longrightarrow> \\<exists>l'. ln $ l' > 0 \\<and> \\<not> may_lock (locks s $ l') t\"\n  and wakeup: \"\\<And>t x w. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow> wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\"\n  shows \"t \\<in> deadlocked s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "from \\<open>not_final_thread s t\\<close>"], ["proof (chain)\npicking this:\n  not_final_thread s t", "have \"t \\<in> {t. not_final_thread s t}\""], ["proof (prove)\nusing this:\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. t \\<in> {t. not_final_thread s t}", "by simp"], ["proof (state)\nthis:\n  t \\<in> {t. not_final_thread s t}\n\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> {t. not_final_thread s t}\n\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (deadlocked z)"], ["proof (state)\nthis:\n  z \\<in> {t. not_final_thread s t}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence \"not_final_thread s z\""], ["proof (prove)\nusing this:\n  z \\<in> {t. not_final_thread s t}\n\ngoal (1 subgoal):\n 1. not_final_thread s z", "by simp"], ["proof (state)\nthis:\n  not_final_thread s z\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "then"], ["proof (chain)\npicking this:\n  not_final_thread s z", "obtain x' ln' where \"thr s z = \\<lfloor>(x', ln')\\<rfloor>\""], ["proof (prove)\nusing this:\n  not_final_thread s z\n\ngoal (1 subgoal):\n 1. (\\<And>x' ln'.\n        thr s z = \\<lfloor>(x', ln')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!: not_final_thread_existsE)"], ["proof (state)\nthis:\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "{"], ["proof (state)\nthis:\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "assume \"wset s z = None\" \"\\<not> final x'\"\n        and [simp]: \"ln' = no_wait_locks\""], ["proof (state)\nthis:\n  wset s z = None\n  \\<not> final x'\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = None\n  \\<not> final x'\n  ln' = no_wait_locks", "have \"z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. z \\<turnstile> \\<langle>x', shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s z lt (final_threads s)))\""], ["proof (prove)\nusing this:\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = None\n  \\<not> final x'\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n    (\\<forall>LT.\n        z \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n        \\<wrong> \\<longrightarrow>\n        (\\<exists>lt\\<in>LT. must_wait s z lt (final_threads s)))", "by(auto dest: normal)"], ["proof (state)\nthis:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n  (\\<forall>LT.\n      z \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n      \\<wrong> \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. must_wait s z lt (final_threads s)))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n  (\\<forall>LT.\n      z \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n      \\<wrong> \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. must_wait s z lt (final_threads s)))", "obtain \"z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong>\"\n        and clnml: \"\\<And>LT. z \\<turnstile> \\<langle>x', shr s\\<rangle> LT \\<wrong> \\<Longrightarrow> \\<exists>lt \\<in> LT. must_wait s z lt (final_threads s)\""], ["proof (prove)\nusing this:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n  (\\<forall>LT.\n      z \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n      \\<wrong> \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. must_wait s z lt (final_threads s)))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong>;\n      \\<And>LT.\n         z \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n         \\<wrong> \\<Longrightarrow>\n         \\<exists>lt\\<in>LT. must_wait s z lt (final_threads s)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast)"], ["proof (state)\nthis:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong>\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14. must_wait s z lt (final_threads s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "{"], ["proof (state)\nthis:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong>\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14. must_wait s z lt (final_threads s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "fix LT"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "assume \"z \\<turnstile> \\<langle>x', shr s\\<rangle> LT \\<wrong>\""], ["proof (state)\nthis:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> LT \\<wrong>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> LT \\<wrong>", "obtain lt where mw: \"must_wait s z lt (final_threads s)\" and lt: \"lt \\<in> LT\""], ["proof (prove)\nusing this:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> LT \\<wrong>\n\ngoal (1 subgoal):\n 1. (\\<And>lt.\n        \\<lbrakk>must_wait s z lt (final_threads s); lt \\<in> LT\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: clnml)"], ["proof (state)\nthis:\n  must_wait s z lt (final_threads s)\n  lt \\<in> LT\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from mw"], ["proof (chain)\npicking this:\n  must_wait s z lt (final_threads s)", "have \"must_wait s z lt ({t. not_final_thread s t} \\<union> deadlocked s \\<union> final_threads s)\""], ["proof (prove)\nusing this:\n  must_wait s z lt (final_threads s)\n\ngoal (1 subgoal):\n 1. must_wait s z lt\n     ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n      final_threads s)", "by(blast intro: must_wait_mono')"], ["proof (state)\nthis:\n  must_wait s z lt\n   ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n    final_threads s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with lt"], ["proof (chain)\npicking this:\n  lt \\<in> LT\n  must_wait s z lt\n   ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n    final_threads s)", "have \"\\<exists>lt \\<in> LT. must_wait s z lt ({t. not_final_thread s t} \\<union> deadlocked s \\<union> final_threads s)\""], ["proof (prove)\nusing this:\n  lt \\<in> LT\n  must_wait s z lt\n   ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n    final_threads s)\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT.\n       must_wait s z lt\n        ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n         final_threads s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT.\n     must_wait s z lt\n      ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n       final_threads s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "}"], ["proof (state)\nthis:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s z lt\n      ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n       final_threads s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with \\<open>z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong>\\<close> \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close> \\<open>wset s z = None\\<close>"], ["proof (chain)\npicking this:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong>\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = None\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s z lt\n      ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n       final_threads s)", "have ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong>\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = None\n  z \\<turnstile> \\<langle>x', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s z lt\n      ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n       final_threads s)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(simp)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>wset s z = None; \\<not> final x'; ln' = no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s z =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        z \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s z = None \\<and>\n                        (\\<forall>LT.\n                            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s z lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s z)) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s z) \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> z \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "note c1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>wset s z = None; \\<not> final x'; ln' = no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s z =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        z \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s z = None \\<and>\n                        (\\<forall>LT.\n                            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s z lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s z)) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s z) \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> z \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>wset s z = None; \\<not> final x'; ln' = no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s z =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        z \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s z = None \\<and>\n                        (\\<forall>LT.\n                            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s z lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s z)) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s z) \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> z \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "assume wsz: \"\\<not> waiting (wset s z)\"\n        and \"ln' \\<noteq> no_wait_locks\""], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from \\<open>ln' \\<noteq> no_wait_locks\\<close>"], ["proof (chain)\npicking this:\n  ln' \\<noteq> no_wait_locks", "obtain l where \"0 < ln' $ l\""], ["proof (prove)\nusing this:\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<And>l. 0 < ln' $ l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(auto simp add: neq_no_wait_locks_conv)"], ["proof (state)\nthis:\n  0 < ln' $ l\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with wsz \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s z)\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  0 < ln' $ l", "obtain l' where \"0 < ln' $ l'\" \"\\<not> may_lock (locks s $ l') z\""], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  0 < ln' $ l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>0 < ln' $ l'; \\<not> may_lock (locks s $ l') z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: acquire)"], ["proof (state)\nthis:\n  0 < ln' $ l'\n  \\<not> may_lock (locks s $ l') z\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "then"], ["proof (chain)\npicking this:\n  0 < ln' $ l'\n  \\<not> may_lock (locks s $ l') z", "obtain t'' where \"t'' \\<noteq> z\" \"has_lock (locks s $ l') t''\""], ["proof (prove)\nusing this:\n  0 < ln' $ l'\n  \\<not> may_lock (locks s $ l') z\n\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>t'' \\<noteq> z; has_lock (locks s $ l') t''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding not_may_lock_conv"], ["proof (prove)\nusing this:\n  0 < ln' $ l'\n  \\<exists>t'. t' \\<noteq> z \\<and> has_lock (locks s $ l') t'\n\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>t'' \\<noteq> z; has_lock (locks s $ l') t''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t'' \\<noteq> z\n  has_lock (locks s $ l') t''\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with \\<open>lock_thread_ok (locks s) (thr s)\\<close>"], ["proof (chain)\npicking this:\n  lock_thread_ok (locks s) (thr s)\n  t'' \\<noteq> z\n  has_lock (locks s $ l') t''", "obtain x'' ln'' where \"thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\""], ["proof (prove)\nusing this:\n  lock_thread_ok (locks s) (thr s)\n  t'' \\<noteq> z\n  has_lock (locks s $ l') t''\n\ngoal (1 subgoal):\n 1. (\\<And>x'' ln''.\n        thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: lock_thread_ok_has_lockE)"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence \"(not_final_thread s t'' \\<or> t'' \\<in> deadlocked s) \\<or> final_thread s t''\""], ["proof (prove)\nusing this:\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (not_final_thread s t'' \\<or> t'' \\<in> deadlocked s) \\<or>\n    final_thread s t''", "by(clarsimp simp add: not_final_thread_iff final_thread_def)"], ["proof (state)\nthis:\n  (not_final_thread s t'' \\<or> t'' \\<in> deadlocked s) \\<or>\n  final_thread s t''\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with wsz \\<open>0 < ln' $ l'\\<close> \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close> \\<open>t'' \\<noteq> z\\<close> \\<open>has_lock (locks s $ l') t''\\<close>"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s z)\n  0 < ln' $ l'\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  t'' \\<noteq> z\n  has_lock (locks s $ l') t''\n  (not_final_thread s t'' \\<or> t'' \\<in> deadlocked s) \\<or>\n  final_thread s t''", "have ?Acquire"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n  0 < ln' $ l'\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  t'' \\<noteq> z\n  has_lock (locks s $ l') t''\n  (not_final_thread s t'' \\<or> t'' \\<in> deadlocked s) \\<or>\n  final_thread s t''\n\ngoal (1 subgoal):\n 1. \\<exists>x l t' ln.\n       thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       \\<not> waiting (wset s z) \\<and>\n       0 < ln $ l \\<and>\n       has_lock (locks s $ l) t' \\<and>\n       t' \\<noteq> z \\<and>\n       ((t' \\<in> {t. not_final_thread s t} \\<or>\n         t' \\<in> deadlocked s) \\<or>\n        final_thread s t')", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>x l t' ln.\n     thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     \\<not> waiting (wset s z) \\<and>\n     0 < ln $ l \\<and>\n     has_lock (locks s $ l) t' \\<and>\n     t' \\<noteq> z \\<and>\n     ((t' \\<in> {t. not_final_thread s t} \\<or> t' \\<in> deadlocked s) \\<or>\n      final_thread s t')\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence ?case"], ["proof (prove)\nusing this:\n  \\<exists>x l t' ln.\n     thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     \\<not> waiting (wset s z) \\<and>\n     0 < ln $ l \\<and>\n     has_lock (locks s $ l) t' \\<and>\n     t' \\<noteq> z \\<and>\n     ((t' \\<in> {t. not_final_thread s t} \\<or> t' \\<in> deadlocked s) \\<or>\n      final_thread s t')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> waiting (wset s z); ln' \\<noteq> no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s z =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        z \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s z = None \\<and>\n                        (\\<forall>LT.\n                            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s z lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s z)) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s z) \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> z \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "note c2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> waiting (wset s z); ln' \\<noteq> no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s z =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        z \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s z = None \\<and>\n                        (\\<forall>LT.\n                            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s z lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s z)) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s z) \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> z \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> waiting (wset s z); ln' \\<noteq> no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s z =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        z \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s z = None \\<and>\n                        (\\<forall>LT.\n                            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s z lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s z)) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s z) \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> z \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "assume \"waiting (wset s z)\""], ["proof (state)\nthis:\n  waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  waiting (wset s z)", "have \"?Wait\""], ["proof (prove)\nusing this:\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<exists>x ln.\n       thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       all_final_except s\n        ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n       waiting (wset s z)", "by(clarsimp simp add: all_final_except_def)"], ["proof (state)\nthis:\n  \\<exists>x ln.\n     thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     all_final_except s\n      ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n     waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence ?case"], ["proof (prove)\nusing this:\n  \\<exists>x ln.\n     thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     all_final_except s\n      ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n     waiting (wset s z)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "}"], ["proof (state)\nthis:\n  waiting (wset s z) \\<Longrightarrow>\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "note c3 = this"], ["proof (state)\nthis:\n  waiting (wset s z) \\<Longrightarrow>\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from \\<open>not_final_thread s z\\<close> \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  not_final_thread s z\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  not_final_thread s z\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases rule: not_final_thread_cases2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<not> final x' \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 3. \\<And>w.\n       wset s z = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case final"], ["proof (state)\nthis:\n  \\<not> final x'\n\ngoal (3 subgoals):\n 1. \\<not> final x' \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 3. \\<And>w.\n       wset s z = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases \"wset s z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wset s z = None \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case None"], ["proof (state)\nthis:\n  wset s z = None\n\ngoal (2 subgoals):\n 1. wset s z = None \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases \"ln' = no_wait_locks\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ln' = no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "case True"], ["proof (state)\nthis:\n  ln' = no_wait_locks\n\ngoal (2 subgoals):\n 1. ln' = no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "with None final"], ["proof (chain)\npicking this:\n  wset s z = None\n  \\<not> final x'\n  ln' = no_wait_locks", "show ?thesis"], ["proof (prove)\nusing this:\n  wset s z = None\n  \\<not> final x'\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c1)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "case False"], ["proof (state)\nthis:\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "from None"], ["proof (chain)\npicking this:\n  wset s z = None", "have \"\\<not> waiting (wset s z)\""], ["proof (prove)\nusing this:\n  wset s z = None\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s z)", "by(simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "using False"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (Some w)"], ["proof (state)\nthis:\n  wset s z = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (InWS w')"], ["proof (state)\nthis:\n  w = InWS w'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with Some"], ["proof (chain)\npicking this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = InWS w'", "have \"waiting (wset s z)\""], ["proof (prove)\nusing this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = InWS w'\n\ngoal (1 subgoal):\n 1. waiting (wset s z)", "by(simp add: waiting_def)"], ["proof (state)\nthis:\n  waiting (wset s z)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  waiting (wset s z)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c3)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (PostWS w')"], ["proof (state)\nthis:\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with Some"], ["proof (chain)\npicking this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = PostWS w'", "have \"\\<not> waiting (wset s z)\""], ["proof (prove)\nusing this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s z)", "by(simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from PostWS \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close> Some"], ["proof (chain)\npicking this:\n  w = PostWS w'\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = \\<lfloor>w\\<rfloor>", "have \"ln' \\<noteq> no_wait_locks\""], ["proof (prove)\nusing this:\n  w = PostWS w'\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks", "by(auto dest: wakeup)"], ["proof (state)\nthis:\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (2 subgoals):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>w.\n       wset s z = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>w.\n       wset s z = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case wait_locks"], ["proof (state)\nthis:\n  ln' \\<noteq> no_wait_locks\n\ngoal (2 subgoals):\n 1. ln' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>w.\n       wset s z = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases \"wset s z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wset s z = None \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case None"], ["proof (state)\nthis:\n  wset s z = None\n\ngoal (2 subgoals):\n 1. wset s z = None \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence \"\\<not> waiting (wset s z)\""], ["proof (prove)\nusing this:\n  wset s z = None\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s z)", "by(simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n\ngoal (2 subgoals):\n 1. wset s z = None \\<Longrightarrow>\n    (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "using wait_locks"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (Some w)"], ["proof (state)\nthis:\n  wset s z = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s z = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (InWS w')"], ["proof (state)\nthis:\n  w = InWS w'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with Some"], ["proof (chain)\npicking this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = InWS w'", "have \"waiting (wset s z)\""], ["proof (prove)\nusing this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = InWS w'\n\ngoal (1 subgoal):\n 1. waiting (wset s z)", "by(simp add: waiting_def)"], ["proof (state)\nthis:\n  waiting (wset s z)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  waiting (wset s z)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c3)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (PostWS w')"], ["proof (state)\nthis:\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with Some"], ["proof (chain)\npicking this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = PostWS w'", "have \"\\<not> waiting (wset s z)\""], ["proof (prove)\nusing this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s z)", "by(simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from PostWS \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close> Some"], ["proof (chain)\npicking this:\n  w = PostWS w'\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = \\<lfloor>w\\<rfloor>", "have \"ln' \\<noteq> no_wait_locks\""], ["proof (prove)\nusing this:\n  w = PostWS w'\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks", "by(auto dest: wakeup)"], ["proof (state)\nthis:\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       wset s z = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       wset s z = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (wait_set w)"], ["proof (state)\nthis:\n  wset s z = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       wset s z = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (InWS w')"], ["proof (state)\nthis:\n  w = InWS w'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with wait_set"], ["proof (chain)\npicking this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = InWS w'", "have \"waiting (wset s z)\""], ["proof (prove)\nusing this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = InWS w'\n\ngoal (1 subgoal):\n 1. waiting (wset s z)", "by(simp add: waiting_def)"], ["proof (state)\nthis:\n  waiting (wset s z)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  waiting (wset s z)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c3)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (PostWS w')"], ["proof (state)\nthis:\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with wait_set"], ["proof (chain)\npicking this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = PostWS w'", "have \"\\<not> waiting (wset s z)\""], ["proof (prove)\nusing this:\n  wset s z = \\<lfloor>w\\<rfloor>\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s z)", "by(simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  \\<not> waiting (wset s z)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from PostWS \\<open>thr s z = \\<lfloor>(x', ln')\\<rfloor>\\<close> wait_set"], ["proof (chain)\npicking this:\n  w = PostWS w'\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = \\<lfloor>w\\<rfloor>", "have \"ln' \\<noteq> no_wait_locks\""], ["proof (prove)\nusing this:\n  w = PostWS w'\n  thr s z = \\<lfloor>(x', ln')\\<rfloor>\n  wset s z = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. ln' \\<noteq> no_wait_locks", "by(auto dest: wakeup[simplified])"], ["proof (state)\nthis:\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s z = None \\<and>\n           (\\<forall>LT.\n               z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s z lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s z)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s z) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> z \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s z)\n  ln' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s z = None \\<and>\n        (\\<forall>LT.\n            z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s z lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s z)) \\<or>\n    (\\<exists>x l t' ln.\n        thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s z) \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> z \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s z = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      z \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s z = None \\<and>\n      (\\<forall>LT.\n          z \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s z lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s z)) \\<or>\n  (\\<exists>x l t' ln.\n      thr s z = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s z) \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> z \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> deadlocked s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Equivalence proof for both notions of deadlock\\<close>"], ["", "lemma deadlock_implies_deadlocked':\n  assumes dead: \"deadlock s\" \n  shows \"deadlocked' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlocked' s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deadlocked' s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlocked' s", "proof(rule deadlocked'I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s", "assume \"not_final_thread s t\""], ["proof (state)\nthis:\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s", "hence \"t \\<in> {t. not_final_thread s t}\""], ["proof (prove)\nusing this:\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. t \\<in> {t. not_final_thread s t}", ".."], ["proof (state)\nthis:\n  t \\<in> {t. not_final_thread s t}\n\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s", "thus \"t \\<in> deadlocked s\""], ["proof (prove)\nusing this:\n  t \\<in> {t. not_final_thread s t}\n\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (deadlocked t'')"], ["proof (state)\nthis:\n  t'' \\<in> {t. not_final_thread s t}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence \"not_final_thread s t''\""], ["proof (prove)\nusing this:\n  t'' \\<in> {t. not_final_thread s t}\n\ngoal (1 subgoal):\n 1. not_final_thread s t''", ".."], ["proof (state)\nthis:\n  not_final_thread s t''\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "then"], ["proof (chain)\npicking this:\n  not_final_thread s t''", "obtain x'' ln'' where tst'': \"thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\""], ["proof (prove)\nusing this:\n  not_final_thread s t''\n\ngoal (1 subgoal):\n 1. (\\<And>x'' ln''.\n        thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(rule not_final_thread_existsE)"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "{"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "assume \"waiting (wset s t'')\""], ["proof (state)\nthis:\n  waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with tst''"], ["proof (chain)\npicking this:\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  waiting (wset s t'')", "have nfine: \"not_final_thread s t''\""], ["proof (prove)\nusing this:\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. not_final_thread s t''", "unfolding waiting_def"], ["proof (prove)\nusing this:\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  \\<exists>w'. wset s t'' = \\<lfloor>InWS w'\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_final_thread s t''", "by(blast intro: not_final_thread.intros)"], ["proof (state)\nthis:\n  not_final_thread s t''\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "ultimately"], ["proof (chain)\npicking this:\n  waiting (wset s t'')\n  not_final_thread s t''", "have ?case"], ["proof (prove)\nusing this:\n  waiting (wset s t'')\n  not_final_thread s t''\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "using tst''"], ["proof (prove)\nusing this:\n  waiting (wset s t'')\n  not_final_thread s t''\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(blast intro: all_final_exceptI not_final_thread_final)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "}"], ["proof (state)\nthis:\n  waiting (wset s t'') \\<Longrightarrow>\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "note c1 = this"], ["proof (state)\nthis:\n  waiting (wset s t'') \\<Longrightarrow>\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "{"], ["proof (state)\nthis:\n  waiting (wset s t'') \\<Longrightarrow>\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "assume wst'': \"\\<not> waiting (wset s t'')\"\n          and \"ln'' \\<noteq> no_wait_locks\""], ["proof (state)\nthis:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "then"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks", "obtain l where l: \"ln'' $ l > 0\""], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<And>l. 0 < ln'' $ l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: neq_no_wait_locks_conv)"], ["proof (state)\nthis:\n  0 < ln'' $ l\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with dead wst'' tst''"], ["proof (chain)\npicking this:\n  deadlock s\n  \\<not> waiting (wset s t'')\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  0 < ln'' $ l", "obtain l' T\n          where \"ln'' $ l' > 0\" \"t'' \\<noteq> T\" \n          and hl: \"has_lock (locks s $ l') T\"\n          and tsT: \"thr s T \\<noteq> None\""], ["proof (prove)\nusing this:\n  deadlock s\n  \\<not> waiting (wset s t'')\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  0 < ln'' $ l\n\ngoal (1 subgoal):\n 1. (\\<And>l' T.\n        \\<lbrakk>0 < ln'' $ l'; t'' \\<noteq> T; has_lock (locks s $ l') T;\n         thr s T \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (erule deadlockD2)"], ["proof (state)\nthis:\n  0 < ln'' $ l'\n  t'' \\<noteq> T\n  has_lock (locks s $ l') T\n  thr s T \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  0 < ln'' $ l'\n  t'' \\<noteq> T\n  has_lock (locks s $ l') T\n  thr s T \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from \\<open>thr s T \\<noteq> None\\<close>"], ["proof (chain)\npicking this:\n  thr s T \\<noteq> None", "obtain xln where tsT: \"thr s T = \\<lfloor>xln\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s T \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>xln.\n        thr s T = \\<lfloor>xln\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  thr s T = \\<lfloor>xln\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "then"], ["proof (chain)\npicking this:\n  thr s T = \\<lfloor>xln\\<rfloor>", "obtain X LN where \"thr s T = \\<lfloor>(X, LN)\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s T = \\<lfloor>xln\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>X LN.\n        thr s T = \\<lfloor>(X, LN)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases xln, auto)"], ["proof (state)\nthis:\n  thr s T = \\<lfloor>(X, LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  thr s T = \\<lfloor>(X, LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence \"not_final_thread s T \\<or> final_thread s T\""], ["proof (prove)\nusing this:\n  thr s T = \\<lfloor>(X, LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_final_thread s T \\<or> final_thread s T", "by(auto simp add: final_thread_def not_final_thread_iff)"], ["proof (state)\nthis:\n  not_final_thread s T \\<or> final_thread s T\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "ultimately"], ["proof (chain)\npicking this:\n  0 < ln'' $ l'\n  t'' \\<noteq> T\n  has_lock (locks s $ l') T\n  thr s T \\<noteq> None\n  thr s T = \\<lfloor>(X, LN)\\<rfloor>\n  not_final_thread s T \\<or> final_thread s T", "have ?case"], ["proof (prove)\nusing this:\n  0 < ln'' $ l'\n  t'' \\<noteq> T\n  has_lock (locks s $ l') T\n  thr s T \\<noteq> None\n  thr s T = \\<lfloor>(X, LN)\\<rfloor>\n  not_final_thread s T \\<or> final_thread s T\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "using wst'' tst''"], ["proof (prove)\nusing this:\n  0 < ln'' $ l'\n  t'' \\<noteq> T\n  has_lock (locks s $ l') T\n  thr s T \\<noteq> None\n  thr s T = \\<lfloor>(X, LN)\\<rfloor>\n  not_final_thread s T \\<or> final_thread s T\n  \\<not> waiting (wset s t'')\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> waiting (wset s t''); ln'' \\<noteq> no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s t'' =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        t'' \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s t'' = None \\<and>\n                        (\\<forall>LT.\n                            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s t'' lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s t'')) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s t'') \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> t'' \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "note c2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> waiting (wset s t''); ln'' \\<noteq> no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s t'' =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        t'' \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s t'' = None \\<and>\n                        (\\<forall>LT.\n                            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s t'' lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s t'')) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s t'') \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> t'' \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> waiting (wset s t''); ln'' \\<noteq> no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s t'' =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        t'' \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s t'' = None \\<and>\n                        (\\<forall>LT.\n                            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s t'' lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s t'')) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s t'') \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> t'' \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "assume \"wset s t'' = None\"\n        and [simp]: \"ln'' = no_wait_locks\""], ["proof (state)\nthis:\n  wset s t'' = None\n  ln'' = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  wset s t'' = None\n  ln'' = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with \\<open>not_final_thread s t''\\<close> tst''"], ["proof (chain)\npicking this:\n  not_final_thread s t''\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  wset s t'' = None\n  ln'' = no_wait_locks", "have \"\\<not> final x''\""], ["proof (prove)\nusing this:\n  not_final_thread s t''\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  wset s t'' = None\n  ln'' = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<not> final x''", "by(auto)"], ["proof (state)\nthis:\n  \\<not> final x''\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "ultimately"], ["proof (chain)\npicking this:\n  wset s t'' = None\n  ln'' = no_wait_locks\n  \\<not> final x''", "obtain \"t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\"\n          and clnml: \"\\<And>LT. t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT \\<wrong> \\<Longrightarrow> \\<exists>t'. thr s t' \\<noteq> None \\<and> (\\<exists>lt\\<in>LT. must_wait s t'' lt (dom (thr s)))\""], ["proof (prove)\nusing this:\n  wset s t'' = None\n  ln'' = no_wait_locks\n  \\<not> final x''\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>;\n      \\<And>LT.\n         t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT\n         \\<wrong> \\<Longrightarrow>\n         \\<exists>t'.\n            thr s t' \\<noteq> None \\<and>\n            (\\<exists>lt\\<in>LT. must_wait s t'' lt (dom (thr s)))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\\<close> \\<open>deadlock s\\<close>"], ["proof (prove)\nusing this:\n  wset s t'' = None\n  ln'' = no_wait_locks\n  \\<not> final x''\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  deadlock s\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>;\n      \\<And>LT.\n         t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT\n         \\<wrong> \\<Longrightarrow>\n         \\<exists>t'.\n            thr s t' \\<noteq> None \\<and>\n            (\\<exists>lt\\<in>LT. must_wait s t'' lt (dom (thr s)))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast elim: deadlockD1)"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>t'.\n     thr s t' \\<noteq> None \\<and>\n     (\\<exists>lt\\<in>?LT14. must_wait s t'' lt (dom (thr s)))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "{"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>t'.\n     thr s t' \\<noteq> None \\<and>\n     (\\<exists>lt\\<in>?LT14. must_wait s t'' lt (dom (thr s)))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "fix LT"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "assume \"t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT \\<wrong>\""], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT \\<wrong>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "then"], ["proof (chain)\npicking this:\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT \\<wrong>", "obtain lt where lt: \"lt \\<in> LT\"\n            and mw: \"must_wait s t'' lt (dom (thr s))\""], ["proof (prove)\nusing this:\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT \\<wrong>\n\ngoal (1 subgoal):\n 1. (\\<And>lt.\n        \\<lbrakk>lt \\<in> LT; must_wait s t'' lt (dom (thr s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: clnml)"], ["proof (state)\nthis:\n  lt \\<in> LT\n  must_wait s t'' lt (dom (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "note mw"], ["proof (state)\nthis:\n  must_wait s t'' lt (dom (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "also"], ["proof (state)\nthis:\n  must_wait s t'' lt (dom (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "have \"dom (thr s) = {t. not_final_thread s t} \\<union> deadlocked s \\<union> final_threads s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (thr s) =\n    {t. not_final_thread s t} \\<union> deadlocked s \\<union> final_threads s", "by(auto simp add: not_final_thread_conv dest: deadlocked_thread_exists elim: final_threadE)"], ["proof (state)\nthis:\n  dom (thr s) =\n  {t. not_final_thread s t} \\<union> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "finally"], ["proof (chain)\npicking this:\n  must_wait s t'' lt\n   ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n    final_threads s)", "have \"\\<exists>lt\\<in>LT. must_wait s t'' lt ({t. not_final_thread s t} \\<union> deadlocked s \\<union> final_threads s)\""], ["proof (prove)\nusing this:\n  must_wait s t'' lt\n   ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n    final_threads s)\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT.\n       must_wait s t'' lt\n        ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n         final_threads s)", "using lt"], ["proof (prove)\nusing this:\n  must_wait s t'' lt\n   ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n    final_threads s)\n  lt \\<in> LT\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT.\n       must_wait s t'' lt\n        ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n         final_threads s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT.\n     must_wait s t'' lt\n      ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n       final_threads s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "}"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s t'' lt\n      ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n       final_threads s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with \\<open>t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\\<close> tst'' \\<open>wset s t'' = None\\<close>"], ["proof (chain)\npicking this:\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  wset s t'' = None\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s t'' lt\n      ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n       final_threads s)", "have ?case"], ["proof (prove)\nusing this:\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n  wset s t'' = None\n  t'' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s t'' lt\n      ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n       final_threads s)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(simp)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>wset s t'' = None; ln'' = no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s t'' =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        t'' \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s t'' = None \\<and>\n                        (\\<forall>LT.\n                            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s t'' lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s t'')) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s t'') \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> t'' \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "note c3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>wset s t'' = None; ln'' = no_wait_locks\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        thr s t'' =\n                        \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                        t'' \\<turnstile> \\<langle>x, shr s\\<rangle>\n                        \\<wrong> \\<and>\n                        wset s t'' = None \\<and>\n                        (\\<forall>LT.\n                            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                            \\<wrong> \\<longrightarrow>\n                            (\\<exists>lt\\<in>LT.\n                                must_wait s t'' lt\n                                 ({t. not_final_thread s t} \\<union>\n                                  deadlocked s \\<union>\n                                  final_threads s)))) \\<or>\n                    (\\<exists>x ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        all_final_except s\n                         ({t. not_final_thread s t} \\<union>\n                          deadlocked s) \\<and>\n                        waiting (wset s t'')) \\<or>\n                    (\\<exists>x l t' ln.\n                        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                        \\<not> waiting (wset s t'') \\<and>\n                        0 < ln $ l \\<and>\n                        has_lock (locks s $ l) t' \\<and>\n                        t' \\<noteq> t'' \\<and>\n                        ((t' \\<in> {t. not_final_thread s t} \\<or>\n                          t' \\<in> deadlocked s) \\<or>\n                         final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {t. not_final_thread s t} \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from \\<open>not_final_thread s t''\\<close> tst''"], ["proof (chain)\npicking this:\n  not_final_thread s t''\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  not_final_thread s t''\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases rule: not_final_thread_cases2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<not> final x'' \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 3. \\<And>w.\n       wset s t'' = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case final"], ["proof (state)\nthis:\n  \\<not> final x''\n\ngoal (3 subgoals):\n 1. \\<not> final x'' \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 3. \\<And>w.\n       wset s t'' = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases \"wset s t''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wset s t'' = None \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>a.\n       wset s t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case None"], ["proof (state)\nthis:\n  wset s t'' = None\n\ngoal (2 subgoals):\n 1. wset s t'' = None \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>a.\n       wset s t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases \"ln'' = no_wait_locks\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ln'' = no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "case True"], ["proof (state)\nthis:\n  ln'' = no_wait_locks\n\ngoal (2 subgoals):\n 1. ln'' = no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "with None"], ["proof (chain)\npicking this:\n  wset s t'' = None\n  ln'' = no_wait_locks", "show ?thesis"], ["proof (prove)\nusing this:\n  wset s t'' = None\n  ln'' = no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c3)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "case False"], ["proof (state)\nthis:\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "from None"], ["proof (chain)\npicking this:\n  wset s t'' = None", "have \"\\<not> waiting (wset s t'')\""], ["proof (prove)\nusing this:\n  wset s t'' = None\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s t'')", "by(simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "using False"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (Some w)"], ["proof (state)\nthis:\n  wset s t'' = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       wset s t'' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (InWS w')"], ["proof (state)\nthis:\n  w = InWS w'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with Some"], ["proof (chain)\npicking this:\n  wset s t'' = \\<lfloor>w\\<rfloor>\n  w = InWS w'", "have \"waiting (wset s t'')\""], ["proof (prove)\nusing this:\n  wset s t'' = \\<lfloor>w\\<rfloor>\n  w = InWS w'\n\ngoal (1 subgoal):\n 1. waiting (wset s t'')", "by(simp add: waiting_def)"], ["proof (state)\nthis:\n  waiting (wset s t'')\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c1)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (PostWS w')"], ["proof (state)\nthis:\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence \"\\<not> waiting (wset s t'')\""], ["proof (prove)\nusing this:\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s t'')", "using Some"], ["proof (prove)\nusing this:\n  w = PostWS w'\n  wset s t'' = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s t'')", "by(simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  \\<not> waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from PostWS Some tst''"], ["proof (chain)\npicking this:\n  w = PostWS w'\n  wset s t'' = \\<lfloor>w\\<rfloor>\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>", "have \"ln'' \\<noteq> no_wait_locks\""], ["proof (prove)\nusing this:\n  w = PostWS w'\n  wset s t'' = \\<lfloor>w\\<rfloor>\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. ln'' \\<noteq> no_wait_locks", "by(auto dest: deadlockD3[OF dead])"], ["proof (state)\nthis:\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (2 subgoals):\n 1. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>w.\n       wset s t'' = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>w.\n       wset s t'' = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case wait_locks"], ["proof (state)\nthis:\n  ln'' \\<noteq> no_wait_locks\n\ngoal (2 subgoals):\n 1. ln'' \\<noteq> no_wait_locks \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<And>w.\n       wset s t'' = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases \"waiting (wset s t'')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. waiting (wset s t'') \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<not> waiting (wset s t'') \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "case False"], ["proof (state)\nthis:\n  \\<not> waiting (wset s t'')\n\ngoal (2 subgoals):\n 1. waiting (wset s t'') \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))\n 2. \\<not> waiting (wset s t'') \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "using wait_locks"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. waiting (wset s t'') \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. waiting (wset s t'') \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "case True"], ["proof (state)\nthis:\n  waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. waiting (wset s t'') \\<Longrightarrow>\n    (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c1)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       wset s t'' = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       wset s t'' = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (wait_set w)"], ["proof (state)\nthis:\n  wset s t'' = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       wset s t'' = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "proof(cases w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case InWS"], ["proof (state)\nthis:\n  w = InWS x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "with wait_set"], ["proof (chain)\npicking this:\n  wset s t'' = \\<lfloor>w\\<rfloor>\n  w = InWS x1_", "have \"waiting (wset s t'')\""], ["proof (prove)\nusing this:\n  wset s t'' = \\<lfloor>w\\<rfloor>\n  w = InWS x1_\n\ngoal (1 subgoal):\n 1. waiting (wset s t'')", "by(simp add: waiting_def)"], ["proof (state)\nthis:\n  waiting (wset s t'')\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       w = InWS x1 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))\n 2. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c1)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "case (PostWS w')"], ["proof (state)\nthis:\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "hence \"\\<not> waiting (wset s t'')\""], ["proof (prove)\nusing this:\n  w = PostWS w'\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s t'')", "using wait_set"], ["proof (prove)\nusing this:\n  w = PostWS w'\n  wset s t'' = \\<lfloor>w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s t'')", "by(simp add: not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "moreover"], ["proof (state)\nthis:\n  \\<not> waiting (wset s t'')\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "from PostWS wait_set tst''"], ["proof (chain)\npicking this:\n  w = PostWS w'\n  wset s t'' = \\<lfloor>w\\<rfloor>\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>", "have \"ln'' \\<noteq> no_wait_locks\""], ["proof (prove)\nusing this:\n  w = PostWS w'\n  wset s t'' = \\<lfloor>w\\<rfloor>\n  thr s t'' = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. ln'' \\<noteq> no_wait_locks", "by(auto dest: deadlockD3[OF dead])"], ["proof (state)\nthis:\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       w = PostWS x2 \\<Longrightarrow>\n       (\\<exists>x.\n           thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n           wset s t'' = None \\<and>\n           (\\<forall>LT.\n               t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s t'' lt\n                    ({t. not_final_thread s t} \\<union>\n                     deadlocked s \\<union>\n                     final_threads s)))) \\<or>\n       (\\<exists>x ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s\n            ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n           waiting (wset s t'')) \\<or>\n       (\\<exists>x l t' ln.\n           thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s t'') \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s $ l) t' \\<and>\n           t' \\<noteq> t'' \\<and>\n           ((t' \\<in> {t. not_final_thread s t} \\<or>\n             t' \\<in> deadlocked s) \\<or>\n            final_thread s t'))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n  ln'' \\<noteq> no_wait_locks\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n        wset s t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s t'' lt\n                 ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                  final_threads s)))) \\<or>\n    (\\<exists>x ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s\n         ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n        waiting (wset s t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> {t. not_final_thread s t} \\<or>\n          t' \\<in> deadlocked s) \\<or>\n         final_thread s t'))", "by(rule c2)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<and>\n      wset s t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               ({t. not_final_thread s t} \\<union> deadlocked s \\<union>\n                final_threads s)))) \\<or>\n  (\\<exists>x ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s\n       ({t. not_final_thread s t} \\<union> deadlocked s) \\<and>\n      waiting (wset s t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> {t. not_final_thread s t} \\<or>\n        t' \\<in> deadlocked s) \\<or>\n       final_thread s t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> deadlocked s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deadlocked' s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deadlocked'_implies_deadlock:\n  assumes dead: \"deadlocked' s\" \n  shows \"deadlock s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlock s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deadlock s", "have deadlocked: \"\\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s", "using dead"], ["proof (prove)\nusing this:\n  deadlocked' s\n\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s t \\<Longrightarrow> t \\<in> deadlocked s", "by(rule deadlocked'D2)"], ["proof (state)\nthis:\n  not_final_thread s ?t14 \\<Longrightarrow> ?t14 \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. deadlock s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlock s", "proof(rule deadlockI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t' x'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume \"thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\"\n      and \"\\<not> final x'\"\n      and \"wset s t' = None\""], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  \\<not> final x'\n  wset s t' = None\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "hence \"not_final_thread s t'\""], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  \\<not> final x'\n  wset s t' = None\n\ngoal (1 subgoal):\n 1. not_final_thread s t'", "by(auto intro: not_final_thread_final)"], ["proof (state)\nthis:\n  not_final_thread s t'\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "hence \"t' \\<in> deadlocked s\""], ["proof (prove)\nusing this:\n  not_final_thread s t'\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s", "by(rule deadlocked)"], ["proof (state)\nthis:\n  t' \\<in> deadlocked s\n\ngoal (3 subgoals):\n 1. \\<And>t x.\n       \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        \\<not> final x; wset s t = None\\<rbrakk>\n       \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t lt (dom (thr s))))\n 2. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 3. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "thus \"t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and> (\\<forall>LT. t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT \\<wrong> \\<longrightarrow> (\\<exists>lt \\<in> LT. must_wait s t' lt (dom (thr s))))\""], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n    (\\<forall>LT.\n        t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n        \\<wrong> \\<longrightarrow>\n        (\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))))", "proof(cases rule: deadlocked_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "case (lock x'')"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  wset s t' = None\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "note lock = \\<open>\\<And>LT. t' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT \\<wrong> \\<Longrightarrow> \\<exists>lt \\<in> LT. must_wait s t' lt (deadlocked s \\<union> final_threads s)\\<close>"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT.\n     must_wait s t' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "from \\<open>thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\\<close> \\<open>thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>", "have [simp]: \"x' = x''\""], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. x' = x''", "by auto"], ["proof (state)\nthis:\n  x' = x''\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "{"], ["proof (state)\nthis:\n  x' = x''\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "fix LT"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "assume \"t' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT \\<wrong>\""], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> LT \\<wrong>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "from lock[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>lt\\<in>LT.\n     must_wait s t' lt (deadlocked s \\<union> final_threads s)", "obtain lt where lt: \"lt \\<in> LT\"\n          and mw: \"must_wait s t' lt (deadlocked s \\<union> final_threads s)\""], ["proof (prove)\nusing this:\n  \\<exists>lt\\<in>LT.\n     must_wait s t' lt (deadlocked s \\<union> final_threads s)\n\ngoal (1 subgoal):\n 1. (\\<And>lt.\n        \\<lbrakk>lt \\<in> LT;\n         must_wait s t' lt (deadlocked s \\<union> final_threads s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lt \\<in> LT\n  must_wait s t' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "have \"deadlocked s \\<union> final_threads s \\<subseteq> dom (thr s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlocked s \\<union> final_threads s \\<subseteq> dom (thr s)", "by(auto elim: final_threadE dest: deadlocked_thread_exists)"], ["proof (state)\nthis:\n  deadlocked s \\<union> final_threads s \\<subseteq> dom (thr s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "with mw"], ["proof (chain)\npicking this:\n  must_wait s t' lt (deadlocked s \\<union> final_threads s)\n  deadlocked s \\<union> final_threads s \\<subseteq> dom (thr s)", "have \"must_wait s t' lt (dom (thr s))\""], ["proof (prove)\nusing this:\n  must_wait s t' lt (deadlocked s \\<union> final_threads s)\n  deadlocked s \\<union> final_threads s \\<subseteq> dom (thr s)\n\ngoal (1 subgoal):\n 1. must_wait s t' lt (dom (thr s))", "by(rule must_wait_mono')"], ["proof (state)\nthis:\n  must_wait s t' lt (dom (thr s))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "with lt"], ["proof (chain)\npicking this:\n  lt \\<in> LT\n  must_wait s t' lt (dom (thr s))", "have \"\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))\""], ["proof (prove)\nusing this:\n  lt \\<in> LT\n  must_wait s t' lt (dom (thr s))\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))", "by blast"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "}"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16. must_wait s t' lt (dom (thr s))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "with \\<open>t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\\<close>"], ["proof (chain)\npicking this:\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16. must_wait s t' lt (dom (thr s))", "show ?thesis"], ["proof (prove)\nusing this:\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16. must_wait s t' lt (dom (thr s))\n\ngoal (1 subgoal):\n 1. t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n    (\\<forall>LT.\n        t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n        \\<wrong> \\<longrightarrow>\n        (\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))))", "by(auto)"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n  (\\<forall>LT.\n      t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n      \\<wrong> \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))))\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "case (wait x'' ln'')"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  all_final_except s (deadlocked s)\n  waiting (wset s t')\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "from \\<open>wset s t' = None\\<close> \\<open>waiting (wset s t')\\<close>"], ["proof (chain)\npicking this:\n  wset s t' = None\n  waiting (wset s t')", "have False"], ["proof (prove)\nusing this:\n  wset s t' = None\n  waiting (wset s t')\n\ngoal (1 subgoal):\n 1. False", "by(simp add: waiting_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))\n 2. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n    (\\<forall>LT.\n        t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n        \\<wrong> \\<longrightarrow>\n        (\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))))", ".."], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n  (\\<forall>LT.\n      t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n      \\<wrong> \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))))\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "case (acquire x'' ln'' l'' T)"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  \\<not> waiting (wset s t')\n  0 < ln'' $ l''\n  has_lock (locks s $ l'') T\n  t' \\<noteq> T\n  T \\<in> deadlocked s \\<or> final_thread s T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "from \\<open>thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\\<close> \\<open>thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\\<close> \\<open>0 < ln'' $ l''\\<close>"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  0 < ln'' $ l''", "have False"], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  0 < ln'' $ l''\n\ngoal (1 subgoal):\n 1. False", "by(auto)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> t' \\<turnstile> \\<langle>x', shr s\\<rangle>\n                         \\<wrong> \\<and>\n                         (\\<forall>LT.\n                             t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n                             \\<wrong> \\<longrightarrow>\n                             (\\<exists>lt\\<in>LT.\n                                 must_wait s t' lt (dom (thr s))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n    (\\<forall>LT.\n        t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n        \\<wrong> \\<longrightarrow>\n        (\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))))", ".."], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n  (\\<forall>LT.\n      t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n      \\<wrong> \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> \\<wrong> \\<and>\n  (\\<forall>LT.\n      t' \\<turnstile> \\<langle>x', shr s\\<rangle> LT\n      \\<wrong> \\<longrightarrow>\n      (\\<exists>lt\\<in>LT. must_wait s t' lt (dom (thr s))))\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t' x' ln' l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume \"thr s t' = \\<lfloor>(x', ln')\\<rfloor>\"\n      and \"0 < ln' $ l\"\n      and wst': \"\\<not> waiting (wset s t')\""], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  0 < ln' $ l\n  \\<not> waiting (wset s t')\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "hence \"not_final_thread s t'\""], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  0 < ln' $ l\n  \\<not> waiting (wset s t')\n\ngoal (1 subgoal):\n 1. not_final_thread s t'", "by(auto intro: not_final_thread_wait_locks)"], ["proof (state)\nthis:\n  not_final_thread s t'\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "hence \"t' \\<in> deadlocked s\""], ["proof (prove)\nusing this:\n  not_final_thread s t'\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s", "by(rule deadlocked)"], ["proof (state)\nthis:\n  t' \\<in> deadlocked s\n\ngoal (2 subgoals):\n 1. \\<And>t x ln l.\n       \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>; 0 < ln $ l;\n        \\<not> waiting (wset s t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l t'.\n                            0 < ln $ l \\<and>\n                            t \\<noteq> t' \\<and>\n                            thr s t' \\<noteq> None \\<and>\n                            has_lock (locks s $ l) t'\n 2. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "thus \"\\<exists>l T. 0 < ln' $ l \\<and> t' \\<noteq> T \\<and> thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T\""], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<exists>l T.\n       0 < ln' $ l \\<and>\n       t' \\<noteq> T \\<and>\n       thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T", "proof(cases rule: deadlocked_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "case (lock x'')"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  wset s t' = None\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "from \\<open>thr s t' = \\<lfloor>(x', ln')\\<rfloor>\\<close> \\<open>thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\\<close> \\<open>0 < ln' $ l\\<close>"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  0 < ln' $ l", "have False"], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  0 < ln' $ l\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 3. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>l T.\n       0 < ln' $ l \\<and>\n       t' \\<noteq> T \\<and>\n       thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T", ".."], ["proof (state)\nthis:\n  \\<exists>l T.\n     0 < ln' $ l \\<and>\n     t' \\<noteq> T \\<and>\n     thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 2. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 2. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "case (wait x' ln')"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  all_final_except s (deadlocked s)\n  waiting (wset s t')\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln'__ $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 2. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln'__ $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "from wst' \\<open>waiting (wset s t')\\<close>"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s t')\n  waiting (wset s t')", "have False"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t')\n  waiting (wset s t')\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln'__ $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T\n 2. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln'__ $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>l T.\n       0 < ln'__ $ l \\<and>\n       t' \\<noteq> T \\<and>\n       thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T", ".."], ["proof (state)\nthis:\n  \\<exists>l T.\n     0 < ln'__ $ l \\<and>\n     t' \\<noteq> T \\<and>\n     thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln'__ $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "case (acquire x'' ln'' l'' t'')"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  \\<not> waiting (wset s t')\n  0 < ln'' $ l''\n  has_lock (locks s $ l'') t''\n  t' \\<noteq> t''\n  t'' \\<in> deadlocked s \\<or> final_thread s t''\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "from \\<open>thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\\<close> \\<open>thr s t' = \\<lfloor>(x', ln')\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>", "have [simp]: \"x' = x''\" \"ln' = ln''\""], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. x' = x'' &&& ln' = ln''", "by auto"], ["proof (state)\nthis:\n  x' = x''\n  ln' = ln''\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "moreover"], ["proof (state)\nthis:\n  x' = x''\n  ln' = ln''\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "from \\<open>t'' \\<in> deadlocked s \\<or> final_thread s t''\\<close>"], ["proof (chain)\npicking this:\n  t'' \\<in> deadlocked s \\<or> final_thread s t''", "have \"thr s t'' \\<noteq> None\""], ["proof (prove)\nusing this:\n  t'' \\<in> deadlocked s \\<or> final_thread s t''\n\ngoal (1 subgoal):\n 1. thr s t'' \\<noteq> None", "by(auto elim: deadlocked_thread_exists simp add: final_thread_def)"], ["proof (state)\nthis:\n  thr s t'' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'a.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t'a;\n        t' \\<noteq> t'a;\n        t'a \\<in> deadlocked s \\<or> final_thread s t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l T.\n                            0 < ln' $ l \\<and>\n                            t' \\<noteq> T \\<and>\n                            thr s T \\<noteq> None \\<and>\n                            has_lock (locks s $ l) T", "with \\<open>0 < ln'' $ l''\\<close> \\<open>has_lock (locks s $ l'') t''\\<close> \\<open>t' \\<noteq> t''\\<close> \\<open>thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  0 < ln'' $ l''\n  has_lock (locks s $ l'') t''\n  t' \\<noteq> t''\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  thr s t'' \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ln'' $ l''\n  has_lock (locks s $ l'') t''\n  t' \\<noteq> t''\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  thr s t'' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>l T.\n       0 < ln' $ l \\<and>\n       t' \\<noteq> T \\<and>\n       thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T", "by auto"], ["proof (state)\nthis:\n  \\<exists>l T.\n     0 < ln' $ l \\<and>\n     t' \\<noteq> T \\<and>\n     thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l T.\n     0 < ln' $ l \\<and>\n     t' \\<noteq> T \\<and>\n     thr s T \\<noteq> None \\<and> has_lock (locks s $ l) T\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "fix t x w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "assume tst: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>t x w.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n       wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "show \"wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. wset s t = \\<lfloor>PostWS w\\<rfloor> \\<Longrightarrow> False", "assume \"wset s t = \\<lfloor>PostWS w\\<rfloor>\""], ["proof (state)\nthis:\n  wset s t = \\<lfloor>PostWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. wset s t = \\<lfloor>PostWS w\\<rfloor> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  wset s t = \\<lfloor>PostWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. wset s t = \\<lfloor>PostWS w\\<rfloor> \\<Longrightarrow> False", "with tst"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = \\<lfloor>PostWS w\\<rfloor>", "have \"not_final_thread s t\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = \\<lfloor>PostWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_final_thread s t", "by(auto simp add: not_final_thread_iff)"], ["proof (state)\nthis:\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. wset s t = \\<lfloor>PostWS w\\<rfloor> \\<Longrightarrow> False", "hence \"t \\<in> deadlocked s\""], ["proof (prove)\nusing this:\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "by(rule deadlocked)"], ["proof (state)\nthis:\n  t \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. wset s t = \\<lfloor>PostWS w\\<rfloor> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  wset s t = \\<lfloor>PostWS w\\<rfloor>\n  t \\<in> deadlocked s", "show False"], ["proof (prove)\nusing this:\n  wset s t = \\<lfloor>PostWS w\\<rfloor>\n  t \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. False", "using tst"], ["proof (prove)\nusing this:\n  wset s t = \\<lfloor>PostWS w\\<rfloor>\n  t \\<in> deadlocked s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. False", "by(auto elim: deadlocked.cases simp add: waiting_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wset s t \\<noteq> \\<lfloor>PostWS w\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deadlock s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deadlock_eq_deadlocked':\n  \"deadlock = deadlocked'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlock = deadlocked'", "by(rule ext)(auto intro: deadlock_implies_deadlocked' deadlocked'_implies_deadlock)"], ["", "lemma deadlock_no_red:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; deadlock s \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s'; deadlock s\\<rbrakk>\n    \\<Longrightarrow> False", "unfolding deadlock_eq_deadlocked'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s'; deadlocked' s\\<rbrakk>\n    \\<Longrightarrow> False", "by(rule deadlocked'_no_red)"], ["", "lemma deadlock_no_active_threads:\n  assumes dead: \"deadlock s\"\n  shows \"active_threads s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. active_threads s = {}", "proof(rule equals0I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> active_threads s \\<Longrightarrow> False", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> active_threads s \\<Longrightarrow> False", "assume active: \"t \\<in> active_threads s\""], ["proof (state)\nthis:\n  t \\<in> active_threads s\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> active_threads s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<in> active_threads s", "obtain ta s' where \"s -t\\<triangleright>ta\\<rightarrow> s'\""], ["proof (prove)\nusing this:\n  t \\<in> active_threads s\n\ngoal (1 subgoal):\n 1. (\\<And>ta s'.\n        s -t\\<triangleright>ta\\<rightarrow> s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: active_thread_ex_red)"], ["proof (state)\nthis:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> active_threads s \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. False", "using dead"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  deadlock s\n\ngoal (1 subgoal):\n 1. False", "by(rule deadlock_no_red)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale preserve_deadlocked = multithreaded final r convert_RA \n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" (\"_ \\<turnstile> _ -_\\<rightarrow> _\" [50,0,0,50] 80) \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  +\n  fixes wf_state :: \"('l,'t,'x,'m,'w) state set\"\n  assumes invariant3p_wf_state: \"invariant3p redT wf_state\"\n  assumes can_lock_preserved: \n    \"\\<lbrakk> s \\<in> wf_state; s -t'\\<triangleright>ta'\\<rightarrow> s';\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong> \\<rbrakk>\n    \\<Longrightarrow> t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong>\"\n  and can_lock_devreserp:\n    \"\\<lbrakk> s \\<in> wf_state; s -t'\\<triangleright>ta'\\<rightarrow> s';\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> \\<langle>x, shr s'\\<rangle> L \\<wrong> \\<rbrakk>\n    \\<Longrightarrow> \\<exists>L'\\<subseteq>L. t \\<turnstile> \\<langle>x, shr s\\<rangle> L' \\<wrong>\"\nbegin"], ["", "lemma redT_deadlocked_subset:\n  assumes wfs: \"s \\<in> wf_state\"\n  and Red: \"s -t\\<triangleright>ta\\<rightarrow> s'\"\n  shows \"deadlocked s \\<subseteq> deadlocked s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlocked s \\<subseteq> deadlocked s'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "assume t'dead: \"t' \\<in> deadlocked s\""], ["proof (state)\nthis:\n  t' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "from Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'", "have tndead: \"t \\<notin> deadlocked s\""], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. t \\<notin> deadlocked s", "by(auto dest: red_no_deadlock)"], ["proof (state)\nthis:\n  t \\<notin> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "with t'dead"], ["proof (chain)\npicking this:\n  t' \\<in> deadlocked s\n  t \\<notin> deadlocked s", "have t't: \"t' \\<noteq> t\""], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s\n  t \\<notin> deadlocked s\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t", "by auto"], ["proof (state)\nthis:\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "{"], ["proof (state)\nthis:\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "assume \"final_thread s t'\""], ["proof (state)\nthis:\n  final_thread s t'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "then"], ["proof (chain)\npicking this:\n  final_thread s t'", "obtain x' ln' where tst': \"thr s t' = \\<lfloor>(x', ln')\\<rfloor>\""], ["proof (prove)\nusing this:\n  final_thread s t'\n\ngoal (1 subgoal):\n 1. (\\<And>x' ln'.\n        thr s t' = \\<lfloor>(x', ln')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: final_threadE)"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "with \\<open>final_thread s t'\\<close>"], ["proof (chain)\npicking this:\n  final_thread s t'\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>", "have \"final x'\" \n      and \"wset s t' = None\" and [simp]: \"ln' = no_wait_locks\""], ["proof (prove)\nusing this:\n  final_thread s t'\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. final x' &&& wset s t' = None &&& ln' = no_wait_locks", "by(auto elim: final_threadE)"], ["proof (state)\nthis:\n  final x'\n  wset s t' = None\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "with Red tst'"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  final x'\n  wset s t' = None\n  ln' = no_wait_locks", "have \"t \\<noteq> t'\""], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  final x'\n  wset s t' = None\n  ln' = no_wait_locks\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'", "by cases(auto dest: final_no_red)"], ["proof (state)\nthis:\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "with Red tst'"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  t \\<noteq> t'", "have \"thr s' t' = \\<lfloor>(x', ln')\\<rfloor>\""], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. thr s' t' = \\<lfloor>(x', ln')\\<rfloor>", "by cases(auto intro: redT_updTs_Some)"], ["proof (state)\nthis:\n  thr s' t' = \\<lfloor>(x', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "moreover"], ["proof (state)\nthis:\n  thr s' t' = \\<lfloor>(x', ln')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "from Red  \\<open>t \\<noteq> t'\\<close> \\<open>wset s t' = None\\<close>"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t \\<noteq> t'\n  wset s t' = None", "have \"wset s' t' = None\""], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t \\<noteq> t'\n  wset s t' = None\n\ngoal (1 subgoal):\n 1. wset s' t' = None", "by cases(auto simp: redT_updWs_None_implies_None)"], ["proof (state)\nthis:\n  wset s' t' = None\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "ultimately"], ["proof (chain)\npicking this:\n  thr s' t' = \\<lfloor>(x', ln')\\<rfloor>\n  wset s' t' = None", "have \"final_thread s' t'\""], ["proof (prove)\nusing this:\n  thr s' t' = \\<lfloor>(x', ln')\\<rfloor>\n  wset s' t' = None\n\ngoal (1 subgoal):\n 1. final_thread s' t'", "using tst' \\<open>final x'\\<close>"], ["proof (prove)\nusing this:\n  thr s' t' = \\<lfloor>(x', ln')\\<rfloor>\n  wset s' t' = None\n  thr s t' = \\<lfloor>(x', ln')\\<rfloor>\n  final x'\n\ngoal (1 subgoal):\n 1. final_thread s' t'", "by(auto simp add: final_thread_def)"], ["proof (state)\nthis:\n  final_thread s' t'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "}"], ["proof (state)\nthis:\n  final_thread s ?t'a16 \\<Longrightarrow> final_thread s' ?t'a16\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "hence subset: \"deadlocked s \\<union> final_threads s \\<subseteq> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\""], ["proof (prove)\nusing this:\n  final_thread s ?t'a16 \\<Longrightarrow> final_thread s' ?t'a16\n\ngoal (1 subgoal):\n 1. deadlocked s \\<union> final_threads s\n    \\<subseteq> deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s'", "by(auto)"], ["proof (state)\nthis:\n  deadlocked s \\<union> final_threads s\n  \\<subseteq> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> deadlocked s \\<Longrightarrow> x \\<in> deadlocked s'", "from Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'", "show \"t' \\<in> deadlocked s'\""], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s'", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "case (redT_normal x x' m')"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "note red = \\<open>t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\\<close>\n      and tst = \\<open>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>\n      and aok = \\<open>actions_ok s t ta\\<close>\n      and s' = \\<open>redT_upd s t ta x' m' s'\\<close>"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  actions_ok s t ta\n  redT_upd s t ta x' m' s'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "from red"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>", "have \"\\<not> final x\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> final x", "by(auto dest: final_no_red)"], ["proof (state)\nthis:\n  \\<not> final x\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "with tndead tst"], ["proof (chain)\npicking this:\n  t \\<notin> deadlocked s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final x", "have nafe: \"\\<not> all_final_except s (deadlocked s)\""], ["proof (prove)\nusing this:\n  t \\<notin> deadlocked s\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<not> final x\n\ngoal (1 subgoal):\n 1. \\<not> all_final_except s (deadlocked s)", "by(fastforce simp add: all_final_except_def not_final_thread_iff)"], ["proof (state)\nthis:\n  \\<not> all_final_except s (deadlocked s)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "from t'dead"], ["proof (chain)\npicking this:\n  t' \\<in> deadlocked s", "show ?thesis"], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s'", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> deadlocked s \\<Longrightarrow>\n       (\\<exists>x.\n           thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n           wset s' t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s' t lt\n                    (deadlocked s \\<union> deadlocked s' \\<union>\n                     final_threads s')))) \\<or>\n       (\\<exists>x ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n           waiting (wset s' t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s' t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s' $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n            final_thread s' t'))", "case (deadlocked t'')"], ["proof (state)\nthis:\n  t'' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> deadlocked s \\<Longrightarrow>\n       (\\<exists>x.\n           thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n           wset s' t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s' t lt\n                    (deadlocked s \\<union> deadlocked s' \\<union>\n                     final_threads s')))) \\<or>\n       (\\<exists>x ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n           waiting (wset s' t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s' t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s' $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n            final_thread s' t'))", "note t''dead = this"], ["proof (state)\nthis:\n  t'' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> deadlocked s \\<Longrightarrow>\n       (\\<exists>x.\n           thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n           wset s' t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s' t lt\n                    (deadlocked s \\<union> deadlocked s' \\<union>\n                     final_threads s')))) \\<or>\n       (\\<exists>x ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n           waiting (wset s' t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s' t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s' $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n            final_thread s' t'))", "with Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t'' \\<in> deadlocked s", "have t''t: \"t'' \\<noteq> t\""], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t'' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. t'' \\<noteq> t", "by(auto dest: red_no_deadlock)"], ["proof (state)\nthis:\n  t'' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> deadlocked s \\<Longrightarrow>\n       (\\<exists>x.\n           thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n           wset s' t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s' t lt\n                    (deadlocked s \\<union> deadlocked s' \\<union>\n                     final_threads s')))) \\<or>\n       (\\<exists>x ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n           waiting (wset s' t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s' t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s' $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n            final_thread s' t'))", "from t''dead"], ["proof (chain)\npicking this:\n  t'' \\<in> deadlocked s", "show ?case"], ["proof (prove)\nusing this:\n  t'' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "proof(cases rule: deadlocked_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "case (lock X)"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>\n  wset s t'' = None\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "hence est'': \"thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\"\n          and msE: \"t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>\"\n          and csexdead: \"\\<And>LT. t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong> \\<Longrightarrow> \\<exists>lt \\<in> LT. must_wait s t'' lt (deadlocked s \\<union> final_threads s)\""], ["proof (prove)\nusing this:\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>\n  wset s t'' = None\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (1 subgoal):\n 1. thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor> &&&\n    t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong> &&&\n    (\\<And>LT.\n        t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT\n        \\<wrong> \\<Longrightarrow>\n        \\<exists>lt\\<in>LT.\n           must_wait s t'' lt (deadlocked s \\<union> final_threads s))", "by auto"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from t''t Red est''"], ["proof (chain)\npicking this:\n  t'' \\<noteq> t\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>", "have es't'': \"thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  t'' \\<noteq> t\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>", "by(cases s)(cases s', auto elim!: redT_ts_Some_inv)"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "note es't''"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from wfs Red est'' msE"], ["proof (chain)\npicking this:\n  s \\<in> wf_state\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>", "have msE': \"t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> \\<wrong>\""], ["proof (prove)\nusing this:\n  s \\<in> wf_state\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>\n\ngoal (1 subgoal):\n 1. t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> \\<wrong>", "by(rule can_lock_preserved)"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> \\<wrong>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> \\<wrong>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "{"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> \\<wrong>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "fix LT"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "assume clL'': \"t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> LT \\<wrong>\""], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> LT \\<wrong>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "with est''"], ["proof (chain)\npicking this:\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> LT \\<wrong>", "have \"\\<exists>LT'\\<subseteq>LT. t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT' \\<wrong>\""], ["proof (prove)\nusing this:\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> LT \\<wrong>\n\ngoal (1 subgoal):\n 1. \\<exists>LT'\\<subseteq>LT. t'' \\<turnstile> \\<langle>X, shr s\\<rangle>\n       LT' \\<wrong>", "by(rule can_lock_devreserp[OF wfs Red])"], ["proof (state)\nthis:\n  \\<exists>LT'\\<subseteq>LT. t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT'\n     \\<wrong>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "then"], ["proof (chain)\npicking this:\n  \\<exists>LT'\\<subseteq>LT. t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT'\n     \\<wrong>", "obtain LT' where clL': \"t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT' \\<wrong>\"\n            and LL': \"LT' \\<subseteq> LT\""], ["proof (prove)\nusing this:\n  \\<exists>LT'\\<subseteq>LT. t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT'\n     \\<wrong>\n\ngoal (1 subgoal):\n 1. (\\<And>LT'.\n        \\<lbrakk>t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT' \\<wrong>;\n         LT' \\<subseteq> LT\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT' \\<wrong>\n  LT' \\<subseteq> LT\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "with csexdead"], ["proof (chain)\npicking this:\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT' \\<wrong>\n  LT' \\<subseteq> LT", "obtain lt\n            where lt: \"lt \\<in> LT\" and mw: \"must_wait s t'' lt (deadlocked s \\<union> final_threads s)\""], ["proof (prove)\nusing this:\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT' \\<wrong>\n  LT' \\<subseteq> LT\n\ngoal (1 subgoal):\n 1. (\\<And>lt.\n        \\<lbrakk>lt \\<in> LT;\n         must_wait s t'' lt (deadlocked s \\<union> final_threads s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lt \\<in> LT\n  must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from mw"], ["proof (chain)\npicking this:\n  must_wait s t'' lt (deadlocked s \\<union> final_threads s)", "have \"must_wait s' t'' lt (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\""], ["proof (prove)\nusing this:\n  must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (1 subgoal):\n 1. must_wait s' t'' lt\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "proof(cases rule: must_wait_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "case (lock l t')"], ["proof (state)\nthis:\n  lt = Inl l\n  has_lock (locks s $ l) t'\n  t' \\<noteq> t''\n  t' \\<in> deadlocked s \\<union> final_threads s\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from \\<open>t' \\<in> deadlocked s \\<union> final_threads s\\<close> Red"], ["proof (chain)\npicking this:\n  t' \\<in> deadlocked s \\<union> final_threads s\n  s -t\\<triangleright>ta\\<rightarrow> s'", "have tt': \"t \\<noteq> t'\""], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s \\<union> final_threads s\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'", "by(auto dest: red_no_deadlock final_no_redT elim: final_threadE)"], ["proof (state)\nthis:\n  t \\<noteq> t'\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from aok"], ["proof (chain)\npicking this:\n  actions_ok s t ta", "have \"lock_actions_ok (locks s $ l) t (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\""], ["proof (prove)\nusing this:\n  actions_ok s t ta\n\ngoal (1 subgoal):\n 1. lock_actions_ok (locks s $ l) t\n     (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)", "by(auto simp add: lock_ok_las_def)"], ["proof (state)\nthis:\n  lock_actions_ok (locks s $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "with tt' \\<open>has_lock (locks s $ l) t'\\<close> s'"], ["proof (chain)\npicking this:\n  t \\<noteq> t'\n  has_lock (locks s $ l) t'\n  redT_upd s t ta x' m' s'\n  lock_actions_ok (locks s $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)", "have hl't': \"has_lock (locks s' $ l) t'\""], ["proof (prove)\nusing this:\n  t \\<noteq> t'\n  has_lock (locks s $ l) t'\n  redT_upd s t ta x' m' s'\n  lock_actions_ok (locks s $ l) t\n   (\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> $ l)\n\ngoal (1 subgoal):\n 1. has_lock (locks s' $ l) t'", "by(auto)"], ["proof (state)\nthis:\n  has_lock (locks s' $ l) t'\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  has_lock (locks s' $ l) t'\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "note \\<open>t' \\<noteq> t''\\<close>"], ["proof (state)\nthis:\n  t' \\<noteq> t''\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  t' \\<noteq> t''\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from \\<open>t' \\<in> deadlocked s \\<union> final_threads s\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> deadlocked s \\<union> final_threads s", "have \"t' \\<in> (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\""], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "using subset"], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s \\<union> final_threads s\n  deadlocked s \\<union> final_threads s\n  \\<subseteq> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "by blast"], ["proof (state)\nthis:\n  t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "ultimately"], ["proof (chain)\npicking this:\n  has_lock (locks s' $ l) t'\n  t' \\<noteq> t''\n  t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "show ?thesis"], ["proof (prove)\nusing this:\n  has_lock (locks s' $ l) t'\n  t' \\<noteq> t''\n  t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. must_wait s' t'' lt\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "unfolding \\<open>lt = Inl l\\<close>"], ["proof (prove)\nusing this:\n  has_lock (locks s' $ l) t'\n  t' \\<noteq> t''\n  t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. must_wait s' t'' (Inl l)\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", ".."], ["proof (state)\nthis:\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "case (join t')"], ["proof (state)\nthis:\n  lt = Inr (Inl t')\n  not_final_thread s t'\n  t' \\<in> deadlocked s \\<union> final_threads s\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "note t'dead = \\<open>t' \\<in> deadlocked s \\<union> final_threads s\\<close>"], ["proof (state)\nthis:\n  t' \\<in> deadlocked s \\<union> final_threads s\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "with Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t' \\<in> deadlocked s \\<union> final_threads s", "have tt': \"t \\<noteq> t'\""], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t' \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'", "by(auto dest: red_no_deadlock final_no_redT elim: final_threadE)"], ["proof (state)\nthis:\n  t \\<noteq> t'\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "note nftt' = \\<open>not_final_thread s t'\\<close>"], ["proof (state)\nthis:\n  not_final_thread s t'\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from t'dead Red aok s' tt'"], ["proof (chain)\npicking this:\n  t' \\<in> deadlocked s \\<union> final_threads s\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  actions_ok s t ta\n  redT_upd s t ta x' m' s'\n  t \\<noteq> t'", "have ts't': \"thr s' t' = thr s t'\""], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s \\<union> final_threads s\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  actions_ok s t ta\n  redT_upd s t ta x' m' s'\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. thr s' t' = thr s t'", "by(auto elim!: deadlocked_thread_exists final_threadE intro: redT_updTs_Some)"], ["proof (state)\nthis:\n  thr s' t' = thr s t'\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from nftt'"], ["proof (chain)\npicking this:\n  not_final_thread s t'", "have \"thr s t' \\<noteq> None\""], ["proof (prove)\nusing this:\n  not_final_thread s t'\n\ngoal (1 subgoal):\n 1. thr s t' \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  thr s t' \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "with nftt' t'dead"], ["proof (chain)\npicking this:\n  not_final_thread s t'\n  t' \\<in> deadlocked s \\<union> final_threads s\n  thr s t' \\<noteq> None", "have \"t' \\<in> deadlocked s\""], ["proof (prove)\nusing this:\n  not_final_thread s t'\n  t' \\<in> deadlocked s \\<union> final_threads s\n  thr s t' \\<noteq> None\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s", "by(simp add: not_final_thread_final_thread_conv[symmetric])"], ["proof (state)\nthis:\n  t' \\<in> deadlocked s\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "hence \"not_final_thread s' t'\""], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. not_final_thread s' t'", "proof(cases rule: deadlocked_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "case (lock x'')"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n  wset s t' = None\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "from \\<open>t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\\<close>"], ["proof (chain)\npicking this:\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>", "have \"\\<not> final x''\""], ["proof (prove)\nusing this:\n  t' \\<turnstile> \\<langle>x'', shr s\\<rangle> \\<wrong>\n\ngoal (1 subgoal):\n 1. \\<not> final x''", "by(auto elim: must_syncE dest: final_no_red)"], ["proof (state)\nthis:\n  \\<not> final x''\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t' = None;\n        \\<And>LT.\n           t' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "with \\<open>thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\\<close> ts't'"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  thr s' t' = thr s t'\n  \\<not> final x''", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x'', no_wait_locks)\\<rfloor>\n  thr s' t' = thr s t'\n  \\<not> final x''\n\ngoal (1 subgoal):\n 1. not_final_thread s' t'", "by(auto intro: not_final_thread.intros)"], ["proof (state)\nthis:\n  not_final_thread s' t'\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "case (wait x'' ln'')"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  all_final_except s (deadlocked s)\n  waiting (wset s t')\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "from \\<open>\\<not> final x\\<close> tst \\<open>all_final_except s (deadlocked s)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> final x\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  all_final_except s (deadlocked s)", "have \"t \\<in> deadlocked s\""], ["proof (prove)\nusing this:\n  \\<not> final x\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  all_final_except s (deadlocked s)\n\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s", "by(fastforce dest: all_final_exceptD simp add: not_final_thread_iff)"], ["proof (state)\nthis:\n  t \\<in> deadlocked s\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "with Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t \\<in> deadlocked s", "have False"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. False", "by(auto dest: red_no_deadlock)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t')\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. not_final_thread s' t'", ".."], ["proof (state)\nthis:\n  not_final_thread s' t'\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "case (acquire x'' ln'' l'' T'')"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  \\<not> waiting (wset s t')\n  0 < ln'' $ l''\n  has_lock (locks s $ l'') T''\n  t' \\<noteq> T''\n  T'' \\<in> deadlocked s \\<or> final_thread s T''\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t'); 0 < ln $ l; has_lock (locks s $ l) t';\n        t' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> not_final_thread s' t'", "from \\<open>thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\\<close> \\<open>0 < ln'' $ l''\\<close> ts't'"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  0 < ln'' $ l''\n  thr s' t' = thr s t'", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x'', ln'')\\<rfloor>\n  0 < ln'' $ l''\n  thr s' t' = thr s t'\n\ngoal (1 subgoal):\n 1. not_final_thread s' t'", "by(auto intro: not_final_thread.intros(2))"], ["proof (state)\nthis:\n  not_final_thread s' t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  not_final_thread s' t'\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  not_final_thread s' t'\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from t'dead subset"], ["proof (chain)\npicking this:\n  t' \\<in> deadlocked s \\<union> final_threads s\n  deadlocked s \\<union> final_threads s\n  \\<subseteq> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "have \"t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\""], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s \\<union> final_threads s\n  deadlocked s \\<union> final_threads s\n  \\<subseteq> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", ".."], ["proof (state)\nthis:\n  t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "ultimately"], ["proof (chain)\npicking this:\n  not_final_thread s' t'\n  t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "show ?thesis"], ["proof (prove)\nusing this:\n  not_final_thread s' t'\n  t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. must_wait s' t'' lt\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "unfolding \\<open>lt = Inr (Inl t')\\<close>"], ["proof (prove)\nusing this:\n  not_final_thread s' t'\n  t' \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. must_wait s' t'' (Inr (Inl t'))\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", ".."], ["proof (state)\nthis:\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "case (interrupt t')"], ["proof (state)\nthis:\n  lt = Inr (Inr t')\n  all_final_except s (deadlocked s \\<union> final_threads s)\n  t' \\<notin> interrupts s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from tst red aok"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  actions_ok s t ta", "have \"not_final_thread s t\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  actions_ok s t ta\n\ngoal (1 subgoal):\n 1. not_final_thread s t", "by(auto simp add: wset_actions_ok_def not_final_thread_iff split: if_split_asm dest: final_no_red)"], ["proof (state)\nthis:\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "with \\<open>all_final_except s (deadlocked s \\<union> final_threads s)\\<close>"], ["proof (chain)\npicking this:\n  all_final_except s (deadlocked s \\<union> final_threads s)\n  not_final_thread s t", "have \"t \\<in> deadlocked s \\<union> final_threads s\""], ["proof (prove)\nusing this:\n  all_final_except s (deadlocked s \\<union> final_threads s)\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s \\<union> final_threads s", "by(rule all_final_exceptD)"], ["proof (state)\nthis:\n  t \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  t \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "have \"t \\<notin> deadlocked s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> deadlocked s", "using Red"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. t \\<notin> deadlocked s", "by(blast dest: red_no_deadlock)"], ["proof (state)\nthis:\n  t \\<notin> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  t \\<notin> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "have \"\\<not> final_thread s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> final_thread s t", "using red tst"], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> final_thread s t", "by(auto simp add: final_thread_def dest: final_no_red)"], ["proof (state)\nthis:\n  \\<not> final_thread s t\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> deadlocked s \\<union> final_threads s\n  t \\<notin> deadlocked s\n  \\<not> final_thread s t", "have False"], ["proof (prove)\nusing this:\n  t \\<in> deadlocked s \\<union> final_threads s\n  t \\<notin> deadlocked s\n  \\<not> final_thread s t\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. must_wait s' t'' lt\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", ".."], ["proof (state)\nthis:\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "with lt"], ["proof (chain)\npicking this:\n  lt \\<in> LT\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "have \"\\<exists>lt\\<in>LT. must_wait s' t'' lt (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\""], ["proof (prove)\nusing this:\n  lt \\<in> LT\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT.\n       must_wait s' t'' lt\n        (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "by blast"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "}"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "have \"wset s' t'' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset s' t'' = None", "using s' t''t \\<open>wset s t'' = None\\<close>"], ["proof (prove)\nusing this:\n  redT_upd s t ta x' m' s'\n  t'' \\<noteq> t\n  wset s t'' = None\n\ngoal (1 subgoal):\n 1. wset s' t'' = None", "by(auto intro: redT_updWs_None_implies_None)"], ["proof (state)\nthis:\n  wset s' t'' = None\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "ultimately"], ["proof (chain)\npicking this:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> \\<wrong>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n  wset s' t'' = None", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> \\<wrong>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n  wset s' t'' = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "by(auto)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n      wset s' t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s' t'' lt\n               (deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s')))) \\<or>\n  (\\<exists>x ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n      waiting (wset s' t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s' t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s' $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n       final_thread s' t'))\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "case (wait x ln)"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(x, ln)\\<rfloor>\n  all_final_except s (deadlocked s)\n  waiting (wset s t'')\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from \\<open>all_final_except s (deadlocked s)\\<close> nafe"], ["proof (chain)\npicking this:\n  all_final_except s (deadlocked s)\n  \\<not> all_final_except s (deadlocked s)", "have False"], ["proof (prove)\nusing this:\n  all_final_except s (deadlocked s)\n  \\<not> all_final_except s (deadlocked s)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n      wset s' t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s' t'' lt\n               (deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s')))) \\<or>\n  (\\<exists>x ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n      waiting (wset s' t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s' t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s' $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n       final_thread s' t'))\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "case (acquire X ln l T)"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(X, ln)\\<rfloor>\n  \\<not> waiting (wset s t'')\n  0 < ln $ l\n  has_lock (locks s $ l) T\n  t'' \\<noteq> T\n  T \\<in> deadlocked s \\<or> final_thread s T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from t''t Red \\<open>thr s t'' = \\<lfloor>(X, ln)\\<rfloor>\\<close> s'"], ["proof (chain)\npicking this:\n  t'' \\<noteq> t\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t'' = \\<lfloor>(X, ln)\\<rfloor>\n  redT_upd s t ta x' m' s'", "have es't'': \"thr s' t'' = \\<lfloor>(X, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  t'' \\<noteq> t\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t'' = \\<lfloor>(X, ln)\\<rfloor>\n  redT_upd s t ta x' m' s'\n\ngoal (1 subgoal):\n 1. thr s' t'' = \\<lfloor>(X, ln)\\<rfloor>", "by(cases s)(auto dest: redT_ts_Some_inv)"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from \\<open>T \\<in> deadlocked s \\<or> final_thread s T\\<close>"], ["proof (chain)\npicking this:\n  T \\<in> deadlocked s \\<or> final_thread s T", "have \"T \\<noteq> t\""], ["proof (prove)\nusing this:\n  T \\<in> deadlocked s \\<or> final_thread s T\n\ngoal (1 subgoal):\n 1. T \\<noteq> t", "proof(rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. T \\<in> deadlocked s \\<Longrightarrow> T \\<noteq> t\n 2. final_thread s T \\<Longrightarrow> T \\<noteq> t", "assume \"T \\<in> deadlocked s\""], ["proof (state)\nthis:\n  T \\<in> deadlocked s\n\ngoal (2 subgoals):\n 1. T \\<in> deadlocked s \\<Longrightarrow> T \\<noteq> t\n 2. final_thread s T \\<Longrightarrow> T \\<noteq> t", "with Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  T \\<in> deadlocked s", "show ?thesis"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  T \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. T \\<noteq> t", "by(auto dest: red_no_deadlock)"], ["proof (state)\nthis:\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. final_thread s T \\<Longrightarrow> T \\<noteq> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. final_thread s T \\<Longrightarrow> T \\<noteq> t", "assume \"final_thread s T\""], ["proof (state)\nthis:\n  final_thread s T\n\ngoal (1 subgoal):\n 1. final_thread s T \\<Longrightarrow> T \\<noteq> t", "with Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  final_thread s T", "show ?thesis"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  final_thread s T\n\ngoal (1 subgoal):\n 1. T \\<noteq> t", "by(auto dest!: final_no_redT simp add: final_thread_def)"], ["proof (state)\nthis:\n  T \\<noteq> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "with s' tst Red \\<open>has_lock (locks s $ l) T\\<close>"], ["proof (chain)\npicking this:\n  redT_upd s t ta x' m' s'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  has_lock (locks s $ l) T\n  T \\<noteq> t", "have \"has_lock (locks s' $ l) T\""], ["proof (prove)\nusing this:\n  redT_upd s t ta x' m' s'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  has_lock (locks s $ l) T\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. has_lock (locks s' $ l) T", "by -(cases s, auto dest: redT_has_lock_inv[THEN iffD2])"], ["proof (state)\nthis:\n  has_lock (locks s' $ l) T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  has_lock (locks s' $ l) T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from s' \\<open>T \\<noteq> t\\<close>"], ["proof (chain)\npicking this:\n  redT_upd s t ta x' m' s'\n  T \\<noteq> t", "have wset: \"wset s T = None \\<Longrightarrow> wset s' T = None\""], ["proof (prove)\nusing this:\n  redT_upd s t ta x' m' s'\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. wset s T = None \\<Longrightarrow> wset s' T = None", "by(auto intro: redT_updWs_None_implies_None)"], ["proof (state)\nthis:\n  wset s T = None \\<Longrightarrow> wset s' T = None\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "{"], ["proof (state)\nthis:\n  wset s T = None \\<Longrightarrow> wset s' T = None\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "assume \"thr s T = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (state)\nthis:\n  thr s T = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "with \\<open>T \\<noteq> t\\<close> Red s' aok tst"], ["proof (chain)\npicking this:\n  T \\<noteq> t\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  redT_upd s t ta x' m' s'\n  actions_ok s t ta\n  thr s t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  thr s T = \\<lfloor>(x, no_wait_locks)\\<rfloor>", "have \"thr s' T = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  T \\<noteq> t\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  redT_upd s t ta x' m' s'\n  actions_ok s t ta\n  thr s t = \\<lfloor>(x__, no_wait_locks)\\<rfloor>\n  thr s T = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s' T = \\<lfloor>(x, no_wait_locks)\\<rfloor>", "by(auto intro: redT_updTs_Some)"], ["proof (state)\nthis:\n  thr s' T = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "}"], ["proof (state)\nthis:\n  thr s T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n  thr s' T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  thr s T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n  thr s' T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "hence \"final_thread s T \\<Longrightarrow> final_thread s' T\""], ["proof (prove)\nusing this:\n  thr s T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n  thr s' T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. final_thread s T \\<Longrightarrow> final_thread s' T", "by(auto simp add: final_thread_def intro: wset)"], ["proof (state)\nthis:\n  final_thread s T \\<Longrightarrow> final_thread s' T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  final_thread s T \\<Longrightarrow> final_thread s' T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from \\<open>\\<not> waiting (wset s t'')\\<close> s' t''t"], ["proof (chain)\npicking this:\n  \\<not> waiting (wset s t'')\n  redT_upd s t ta x' m' s'\n  t'' \\<noteq> t", "have \"\\<not> waiting (wset s' t'')\""], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n  redT_upd s t ta x' m' s'\n  t'' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s' t'')", "by(auto simp add: redT_updWs_None_implies_None redT_updWs_PostWS_imp_PostWS not_waiting_iff)"], ["proof (state)\nthis:\n  \\<not> waiting (wset s' t'')\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "ultimately"], ["proof (chain)\npicking this:\n  thr s' t'' = \\<lfloor>(X, ln)\\<rfloor>\n  has_lock (locks s' $ l) T\n  thr s T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n  thr s' T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor>\n  final_thread s T \\<Longrightarrow> final_thread s' T\n  \\<not> waiting (wset s' t'')", "have ?Acquire"], ["proof (prove)\nusing this:\n  thr s' t'' = \\<lfloor>(X, ln)\\<rfloor>\n  has_lock (locks s' $ l) T\n  thr s T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n  thr s' T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor>\n  final_thread s T \\<Longrightarrow> final_thread s' T\n  \\<not> waiting (wset s' t'')\n\ngoal (1 subgoal):\n 1. \\<exists>x l t' ln.\n       thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       \\<not> waiting (wset s' t'') \\<and>\n       0 < ln $ l \\<and>\n       has_lock (locks s' $ l) t' \\<and>\n       t' \\<noteq> t'' \\<and>\n       ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n        final_thread s' t')", "using \\<open>0 < ln $ l\\<close> \\<open>t'' \\<noteq> T\\<close> \\<open>T \\<in> deadlocked s \\<or> final_thread s T\\<close>"], ["proof (prove)\nusing this:\n  thr s' t'' = \\<lfloor>(X, ln)\\<rfloor>\n  has_lock (locks s' $ l) T\n  thr s T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor> \\<Longrightarrow>\n  thr s' T = \\<lfloor>(?xa16, no_wait_locks)\\<rfloor>\n  final_thread s T \\<Longrightarrow> final_thread s' T\n  \\<not> waiting (wset s' t'')\n  0 < ln $ l\n  t'' \\<noteq> T\n  T \\<in> deadlocked s \\<or> final_thread s T\n\ngoal (1 subgoal):\n 1. \\<exists>x l t' ln.\n       thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       \\<not> waiting (wset s' t'') \\<and>\n       0 < ln $ l \\<and>\n       has_lock (locks s' $ l) t' \\<and>\n       t' \\<noteq> t'' \\<and>\n       ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n        final_thread s' t')", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>x l t' ln.\n     thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     \\<not> waiting (wset s' t'') \\<and>\n     0 < ln $ l \\<and>\n     has_lock (locks s' $ l) t' \\<and>\n     t' \\<noteq> t'' \\<and>\n     ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n      final_thread s' t')\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x l t' ln.\n     thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     \\<not> waiting (wset s' t'') \\<and>\n     0 < ln $ l \\<and>\n     has_lock (locks s' $ l) t' \\<and>\n     t' \\<noteq> t'' \\<and>\n     ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n      final_thread s' t')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n      wset s' t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s' t'' lt\n               (deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s')))) \\<or>\n  (\\<exists>x ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n      waiting (wset s' t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s' t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s' $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n       final_thread s' t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n      wset s' t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s' t'' lt\n               (deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s')))) \\<or>\n  (\\<exists>x ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n      waiting (wset s' t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s' t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s' $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n       final_thread s' t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t' \\<in> deadlocked s'\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "case (redT_acquire x n ln)"], ["proof (state)\nthis:\n  ta = (K$ [], [], [], [], [], convert_RA ln)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t ln\n  0 < ln $ n\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "hence [simp]: \"ta = (K$ [], [], [], [], [], convert_RA ln)\"\n      and s': \"s' = (acquire_all (locks s) t ln, (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\"\n      and tst: \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\" \n      and wst: \"\\<not> waiting (wset s t)\""], ["proof (prove)\nusing this:\n  ta = (K$ [], [], [], [], [], convert_RA ln)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t ln\n  0 < ln $ n\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. (ta = (K$ [], [], [], [], [], convert_RA ln) &&&\n     s' =\n     (acquire_all (locks s) t ln,\n      (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n      interrupts s)) &&&\n    thr s t = \\<lfloor>(x, ln)\\<rfloor> &&& \\<not> waiting (wset s t)", "by auto"], ["proof (state)\nthis:\n  ta = (K$ [], [], [], [], [], convert_RA ln)\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s t)\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> t' \\<in> deadlocked s'", "from t'dead"], ["proof (chain)\npicking this:\n  t' \\<in> deadlocked s", "show ?thesis"], ["proof (prove)\nusing this:\n  t' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. t' \\<in> deadlocked s'", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> deadlocked s \\<Longrightarrow>\n       (\\<exists>x.\n           thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n           wset s' t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s' t lt\n                    (deadlocked s \\<union> deadlocked s' \\<union>\n                     final_threads s')))) \\<or>\n       (\\<exists>x ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n           waiting (wset s' t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s' t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s' $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n            final_thread s' t'))", "case (deadlocked t'')"], ["proof (state)\nthis:\n  t'' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> deadlocked s \\<Longrightarrow>\n       (\\<exists>x.\n           thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n           wset s' t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s' t lt\n                    (deadlocked s \\<union> deadlocked s' \\<union>\n                     final_threads s')))) \\<or>\n       (\\<exists>x ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n           waiting (wset s' t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s' t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s' $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n            final_thread s' t'))", "note t''dead = this"], ["proof (state)\nthis:\n  t'' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> deadlocked s \\<Longrightarrow>\n       (\\<exists>x.\n           thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n           wset s' t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s' t lt\n                    (deadlocked s \\<union> deadlocked s' \\<union>\n                     final_threads s')))) \\<or>\n       (\\<exists>x ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n           waiting (wset s' t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s' t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s' $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n            final_thread s' t'))", "with Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t'' \\<in> deadlocked s", "have t''t: \"t'' \\<noteq> t\""], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  t'' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. t'' \\<noteq> t", "by(auto dest: red_no_deadlock)"], ["proof (state)\nthis:\n  t'' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> deadlocked s \\<Longrightarrow>\n       (\\<exists>x.\n           thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n           t \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n           wset s' t = None \\<and>\n           (\\<forall>LT.\n               t \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n               \\<wrong> \\<longrightarrow>\n               (\\<exists>lt\\<in>LT.\n                   must_wait s' t lt\n                    (deadlocked s \\<union> deadlocked s' \\<union>\n                     final_threads s')))) \\<or>\n       (\\<exists>x ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n           waiting (wset s' t)) \\<or>\n       (\\<exists>x l t' ln.\n           thr s' t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> waiting (wset s' t) \\<and>\n           0 < ln $ l \\<and>\n           has_lock (locks s' $ l) t' \\<and>\n           t' \\<noteq> t \\<and>\n           ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n            final_thread s' t'))", "from t''dead"], ["proof (chain)\npicking this:\n  t'' \\<in> deadlocked s", "show ?case"], ["proof (prove)\nusing this:\n  t'' \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "proof(cases rule: deadlocked_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "case (lock X)"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>\n  wset s t'' = None\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> ?LT14\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT14.\n     must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "note clnml = \\<open>\\<And>LT. t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong> \\<Longrightarrow> \\<exists>lt \\<in> LT. must_wait s t'' lt (deadlocked s \\<union> final_threads s)\\<close>"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> ?LT \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT.\n     must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "note tst'' = \\<open>thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "with s' t''t"], ["proof (chain)\npicking this:\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n  t'' \\<noteq> t\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>", "have ts't'': \"thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n  t'' \\<noteq> t\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "{"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "fix LT"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "assume \"t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> LT \\<wrong>\""], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> LT \\<wrong>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "hence \"t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong>\""], ["proof (prove)\nusing this:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> LT \\<wrong>\n\ngoal (1 subgoal):\n 1. t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong>", "using s'"], ["proof (prove)\nusing this:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> LT \\<wrong>\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong>", "by simp"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "then"], ["proof (chain)\npicking this:\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong>", "obtain lt where lt: \"lt \\<in> LT\" and hlnft: \"must_wait s t'' lt (deadlocked s \\<union> final_threads s)\""], ["proof (prove)\nusing this:\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> LT \\<wrong>\n\ngoal (1 subgoal):\n 1. (\\<And>lt.\n        \\<lbrakk>lt \\<in> LT;\n         must_wait s t'' lt (deadlocked s \\<union> final_threads s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest: clnml)"], ["proof (state)\nthis:\n  lt \\<in> LT\n  must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from hlnft"], ["proof (chain)\npicking this:\n  must_wait s t'' lt (deadlocked s \\<union> final_threads s)", "have \"must_wait s' t'' lt (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\""], ["proof (prove)\nusing this:\n  must_wait s t'' lt (deadlocked s \\<union> final_threads s)\n\ngoal (1 subgoal):\n 1. must_wait s' t'' lt\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "proof(cases rule: must_wait_elims)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "case (lock l' T)"], ["proof (state)\nthis:\n  lt = Inl l'\n  has_lock (locks s $ l') T\n  T \\<noteq> t''\n  T \\<in> deadlocked s \\<union> final_threads s\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from \\<open>has_lock (locks s $ l') T\\<close> s'"], ["proof (chain)\npicking this:\n  has_lock (locks s $ l') T\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)", "have \"has_lock (locks s' $ l') T\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ l') T\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. has_lock (locks s' $ l') T", "by(auto intro: has_lock_has_lock_acquire_locks)"], ["proof (state)\nthis:\n  has_lock (locks s' $ l') T\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  has_lock (locks s' $ l') T\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "note \\<open>T \\<noteq> t''\\<close>"], ["proof (state)\nthis:\n  T \\<noteq> t''\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  T \\<noteq> t''\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from \\<open>T \\<in> deadlocked s \\<union> final_threads s\\<close>"], ["proof (chain)\npicking this:\n  T \\<in> deadlocked s \\<union> final_threads s", "have \"T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\""], ["proof (prove)\nusing this:\n  T \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "using subset"], ["proof (prove)\nusing this:\n  T \\<in> deadlocked s \\<union> final_threads s\n  deadlocked s \\<union> final_threads s\n  \\<subseteq> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "by blast"], ["proof (state)\nthis:\n  T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (3 subgoals):\n 1. \\<And>l t'.\n       \\<lbrakk>lt = Inl l; has_lock (locks s $ l) t'; t' \\<noteq> t'';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 3. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "ultimately"], ["proof (chain)\npicking this:\n  has_lock (locks s' $ l') T\n  T \\<noteq> t''\n  T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "show ?thesis"], ["proof (prove)\nusing this:\n  has_lock (locks s' $ l') T\n  T \\<noteq> t''\n  T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. must_wait s' t'' lt\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "unfolding \\<open>lt = Inl l'\\<close>"], ["proof (prove)\nusing this:\n  has_lock (locks s' $ l') T\n  T \\<noteq> t''\n  T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. must_wait s' t'' (Inl l')\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", ".."], ["proof (state)\nthis:\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "case (join T)"], ["proof (state)\nthis:\n  lt = Inr (Inl T)\n  not_final_thread s T\n  T \\<in> deadlocked s \\<union> final_threads s\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from \\<open>not_final_thread s T\\<close>"], ["proof (chain)\npicking this:\n  not_final_thread s T", "have \"thr s T \\<noteq> None\""], ["proof (prove)\nusing this:\n  not_final_thread s T\n\ngoal (1 subgoal):\n 1. thr s T \\<noteq> None", "by(auto simp add: not_final_thread_iff)"], ["proof (state)\nthis:\n  thr s T \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  thr s T \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from \\<open>T \\<in> deadlocked s \\<union> final_threads s\\<close>"], ["proof (chain)\npicking this:\n  T \\<in> deadlocked s \\<union> final_threads s", "have \"T \\<noteq> t\""], ["proof (prove)\nusing this:\n  T \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. T \\<noteq> t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. T \\<in> deadlocked s \\<Longrightarrow> T \\<noteq> t\n 2. T \\<in> final_threads s \\<Longrightarrow> T \\<noteq> t", "assume \"T \\<in> deadlocked s\""], ["proof (state)\nthis:\n  T \\<in> deadlocked s\n\ngoal (2 subgoals):\n 1. T \\<in> deadlocked s \\<Longrightarrow> T \\<noteq> t\n 2. T \\<in> final_threads s \\<Longrightarrow> T \\<noteq> t", "with Red"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  T \\<in> deadlocked s", "show ?thesis"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  T \\<in> deadlocked s\n\ngoal (1 subgoal):\n 1. T \\<noteq> t", "by(auto dest: red_no_deadlock)"], ["proof (state)\nthis:\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. T \\<in> final_threads s \\<Longrightarrow> T \\<noteq> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. T \\<in> final_threads s \\<Longrightarrow> T \\<noteq> t", "assume \"T \\<in> final_threads s\""], ["proof (state)\nthis:\n  T \\<in> final_threads s\n\ngoal (1 subgoal):\n 1. T \\<in> final_threads s \\<Longrightarrow> T \\<noteq> t", "with \\<open>0 < ln $ n\\<close> tst"], ["proof (chain)\npicking this:\n  0 < ln $ n\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  T \\<in> final_threads s", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ln $ n\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  T \\<in> final_threads s\n\ngoal (1 subgoal):\n 1. T \\<noteq> t", "by(auto simp add: final_thread_def)"], ["proof (state)\nthis:\n  T \\<noteq> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T \\<noteq> t\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "ultimately"], ["proof (chain)\npicking this:\n  thr s T \\<noteq> None\n  T \\<noteq> t", "have \"not_final_thread s' T\""], ["proof (prove)\nusing this:\n  thr s T \\<noteq> None\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. not_final_thread s' T", "using \\<open>not_final_thread s T\\<close> s'"], ["proof (prove)\nusing this:\n  thr s T \\<noteq> None\n  T \\<noteq> t\n  not_final_thread s T\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. not_final_thread s' T", "by(auto simp add: not_final_thread_iff)"], ["proof (state)\nthis:\n  not_final_thread s' T\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  not_final_thread s' T\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from \\<open>T \\<in> deadlocked s \\<union> final_threads s\\<close>"], ["proof (chain)\npicking this:\n  T \\<in> deadlocked s \\<union> final_threads s", "have \"T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\""], ["proof (prove)\nusing this:\n  T \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "using subset"], ["proof (prove)\nusing this:\n  T \\<in> deadlocked s \\<union> final_threads s\n  deadlocked s \\<union> final_threads s\n  \\<subseteq> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "by blast"], ["proof (state)\nthis:\n  T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inl t'); not_final_thread s t';\n        t' \\<in> deadlocked s \\<union> final_threads s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')\n 2. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "ultimately"], ["proof (chain)\npicking this:\n  not_final_thread s' T\n  T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'", "show ?thesis"], ["proof (prove)\nusing this:\n  not_final_thread s' T\n  T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. must_wait s' t'' lt\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "unfolding \\<open>lt = Inr (Inl T)\\<close>"], ["proof (prove)\nusing this:\n  not_final_thread s' T\n  T \\<in> deadlocked s \\<union> deadlocked s' \\<union> final_threads s'\n\ngoal (1 subgoal):\n 1. must_wait s' t'' (Inr (Inl T))\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", ".."], ["proof (state)\nthis:\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "case (interrupt T)"], ["proof (state)\nthis:\n  lt = Inr (Inr T)\n  all_final_except s (deadlocked s \\<union> final_threads s)\n  T \\<notin> interrupts s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "from tst wst \\<open>0 < ln $ n\\<close>"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s t)\n  0 < ln $ n", "have \"not_final_thread s t\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  \\<not> waiting (wset s t)\n  0 < ln $ n\n\ngoal (1 subgoal):\n 1. not_final_thread s t", "by(auto simp add: waiting_def not_final_thread_iff)"], ["proof (state)\nthis:\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "with \\<open>all_final_except s (deadlocked s \\<union> final_threads s)\\<close>"], ["proof (chain)\npicking this:\n  all_final_except s (deadlocked s \\<union> final_threads s)\n  not_final_thread s t", "have \"t \\<in> deadlocked s \\<union> final_threads s\""], ["proof (prove)\nusing this:\n  all_final_except s (deadlocked s \\<union> final_threads s)\n  not_final_thread s t\n\ngoal (1 subgoal):\n 1. t \\<in> deadlocked s \\<union> final_threads s", "by(rule all_final_exceptD)"], ["proof (state)\nthis:\n  t \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  t \\<in> deadlocked s \\<union> final_threads s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "have \"t \\<notin> deadlocked s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> deadlocked s", "using Red"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. t \\<notin> deadlocked s", "by(blast dest: red_no_deadlock)"], ["proof (state)\nthis:\n  t \\<notin> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "moreover"], ["proof (state)\nthis:\n  t \\<notin> deadlocked s\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "have \"\\<not> final_thread s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> final_thread s t", "using tst \\<open>0 < ln $ n\\<close>"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ n\n\ngoal (1 subgoal):\n 1. \\<not> final_thread s t", "by(auto simp add: final_thread_def)"], ["proof (state)\nthis:\n  \\<not> final_thread s t\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> deadlocked s \\<union> final_threads s\n  t \\<notin> deadlocked s\n  \\<not> final_thread s t", "have False"], ["proof (prove)\nusing this:\n  t \\<in> deadlocked s \\<union> final_threads s\n  t \\<notin> deadlocked s\n  \\<not> final_thread s t\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>lt = Inr (Inr t');\n        all_final_except s (deadlocked s \\<union> final_threads s);\n        t' \\<notin> interrupts s\\<rbrakk>\n       \\<Longrightarrow> must_wait s' t'' lt\n                          (deadlocked s \\<union> deadlocked s' \\<union>\n                           final_threads s')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. must_wait s' t'' lt\n     (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", ".."], ["proof (state)\nthis:\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "with lt"], ["proof (chain)\npicking this:\n  lt \\<in> LT\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "have \"\\<exists>lt\\<in>LT. must_wait s' t'' lt (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\""], ["proof (prove)\nusing this:\n  lt \\<in> LT\n  must_wait s' t'' lt\n   (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (1 subgoal):\n 1. \\<exists>lt\\<in>LT.\n       must_wait s' t'' lt\n        (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')", "by blast"], ["proof (state)\nthis:\n  \\<exists>lt\\<in>LT.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "}"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from \\<open>wset s t'' = None\\<close> s'"], ["proof (chain)\npicking this:\n  wset s t'' = None\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)", "have \"wset s' t'' = None\""], ["proof (prove)\nusing this:\n  wset s t'' = None\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. wset s' t'' = None", "by simp"], ["proof (state)\nthis:\n  wset s' t'' = None\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        t'' \\<turnstile> \\<langle>x, shr s\\<rangle> \\<wrong>;\n        wset s t'' = None;\n        \\<And>LT.\n           t'' \\<turnstile> \\<langle>x, shr s\\<rangle> LT\n           \\<wrong> \\<Longrightarrow>\n           \\<exists>lt\\<in>LT.\n              must_wait s t'' lt\n               (deadlocked s \\<union> final_threads s)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 3. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "ultimately"], ["proof (chain)\npicking this:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n  wset s' t'' = None", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n  wset s' t'' = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "using \\<open>thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\\<close> \\<open>t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>\\<close> s'"], ["proof (prove)\nusing this:\n  thr s' t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s'\\<rangle> ?LT16\n  \\<wrong> \\<Longrightarrow>\n  \\<exists>lt\\<in>?LT16.\n     must_wait s' t'' lt\n      (deadlocked s \\<union> deadlocked s' \\<union> final_threads s')\n  wset s' t'' = None\n  thr s t'' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  t'' \\<turnstile> \\<langle>X, shr s\\<rangle> \\<wrong>\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n      wset s' t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s' t'' lt\n               (deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s')))) \\<or>\n  (\\<exists>x ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n      waiting (wset s' t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s' t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s' $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n       final_thread s' t'))\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "case (wait X LN)"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(X, LN)\\<rfloor>\n  all_final_except s (deadlocked s)\n  waiting (wset s t'')\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "have \"all_final_except s' (deadlocked s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_final_except s' (deadlocked s)", "proof(rule all_final_exceptI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s' t \\<Longrightarrow> t \\<in> deadlocked s", "fix T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s' t \\<Longrightarrow> t \\<in> deadlocked s", "assume \"not_final_thread s' T\""], ["proof (state)\nthis:\n  not_final_thread s' T\n\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s' t \\<Longrightarrow> t \\<in> deadlocked s", "hence \"not_final_thread s T\""], ["proof (prove)\nusing this:\n  not_final_thread s' T\n\ngoal (1 subgoal):\n 1. not_final_thread s T", "using wst tst s'"], ["proof (prove)\nusing this:\n  not_final_thread s' T\n  \\<not> waiting (wset s t)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. not_final_thread s T", "by(auto simp add: not_final_thread_iff split: if_split_asm)"], ["proof (state)\nthis:\n  not_final_thread s T\n\ngoal (1 subgoal):\n 1. \\<And>t. not_final_thread s' t \\<Longrightarrow> t \\<in> deadlocked s", "with \\<open>all_final_except s (deadlocked s)\\<close> \\<open>thr s t = \\<lfloor>(x, ln)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  all_final_except s (deadlocked s)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  not_final_thread s T", "show \"T \\<in> deadlocked s\""], ["proof (prove)\nusing this:\n  all_final_except s (deadlocked s)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  not_final_thread s T\n\ngoal (1 subgoal):\n 1. T \\<in> deadlocked s", "by-(erule all_final_exceptD)"], ["proof (state)\nthis:\n  T \\<in> deadlocked s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_final_except s' (deadlocked s)\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "hence \"all_final_except s' (deadlocked s \\<union> deadlocked s')\""], ["proof (prove)\nusing this:\n  all_final_except s' (deadlocked s)\n\ngoal (1 subgoal):\n 1. all_final_except s' (deadlocked s \\<union> deadlocked s')", "by(rule all_final_except_mono') blast"], ["proof (state)\nthis:\n  all_final_except s' (deadlocked s \\<union> deadlocked s')\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "with t''t \\<open>thr s t'' = \\<lfloor>(X, LN)\\<rfloor>\\<close> \\<open>waiting (wset s t'')\\<close> s'"], ["proof (chain)\npicking this:\n  t'' \\<noteq> t\n  thr s t'' = \\<lfloor>(X, LN)\\<rfloor>\n  waiting (wset s t'')\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n  all_final_except s' (deadlocked s \\<union> deadlocked s')", "have ?Wait"], ["proof (prove)\nusing this:\n  t'' \\<noteq> t\n  thr s t'' = \\<lfloor>(X, LN)\\<rfloor>\n  waiting (wset s t'')\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n  all_final_except s' (deadlocked s \\<union> deadlocked s')\n\ngoal (1 subgoal):\n 1. \\<exists>x ln.\n       thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n       waiting (wset s' t'')", "by simp"], ["proof (state)\nthis:\n  \\<exists>x ln.\n     thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n     waiting (wset s' t'')\n\ngoal (2 subgoals):\n 1. \\<And>x ln.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        all_final_except s (deadlocked s); waiting (wset s t'')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))\n 2. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x ln.\n     thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n     waiting (wset s' t'')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n      wset s' t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s' t'' lt\n               (deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s')))) \\<or>\n  (\\<exists>x ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n      waiting (wset s' t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s' t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s' $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n       final_thread s' t'))\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "case (acquire X LN l T)"], ["proof (state)\nthis:\n  thr s t'' = \\<lfloor>(X, LN)\\<rfloor>\n  \\<not> waiting (wset s t'')\n  0 < LN $ l\n  has_lock (locks s $ l) T\n  t'' \\<noteq> T\n  T \\<in> deadlocked s \\<or> final_thread s T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from \\<open>thr s t'' = \\<lfloor>(X, LN)\\<rfloor>\\<close> t''t s'"], ["proof (chain)\npicking this:\n  thr s t'' = \\<lfloor>(X, LN)\\<rfloor>\n  t'' \\<noteq> t\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)", "have \"thr s' t'' = \\<lfloor>(X, LN)\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s t'' = \\<lfloor>(X, LN)\\<rfloor>\n  t'' \\<noteq> t\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. thr s' t'' = \\<lfloor>(X, LN)\\<rfloor>", "by(simp)"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  thr s' t'' = \\<lfloor>(X, LN)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from \\<open>T \\<in> deadlocked s \\<or> final_thread s T\\<close> s' tst"], ["proof (chain)\npicking this:\n  T \\<in> deadlocked s \\<or> final_thread s T\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>", "have \"T \\<in> deadlocked s \\<or> final_thread s' T\""], ["proof (prove)\nusing this:\n  T \\<in> deadlocked s \\<or> final_thread s T\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. T \\<in> deadlocked s \\<or> final_thread s' T", "by(clarsimp simp add: final_thread_def)"], ["proof (state)\nthis:\n  T \\<in> deadlocked s \\<or> final_thread s' T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  T \\<in> deadlocked s \\<or> final_thread s' T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "from \\<open>has_lock (locks s $ l) T\\<close> s'"], ["proof (chain)\npicking this:\n  has_lock (locks s $ l) T\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)", "have \"has_lock (locks s' $ l) T\""], ["proof (prove)\nusing this:\n  has_lock (locks s $ l) T\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. has_lock (locks s' $ l) T", "by(auto intro: has_lock_has_lock_acquire_locks)"], ["proof (state)\nthis:\n  has_lock (locks s' $ l) T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "moreover"], ["proof (state)\nthis:\n  has_lock (locks s' $ l) T\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "have \"\\<not> waiting (wset s' t'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s' t'')", "using \\<open>\\<not> waiting (wset s t'')\\<close> s'"], ["proof (prove)\nusing this:\n  \\<not> waiting (wset s t'')\n  s' =\n  (acquire_all (locks s) t ln,\n   (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. \\<not> waiting (wset s' t'')", "by simp"], ["proof (state)\nthis:\n  \\<not> waiting (wset s' t'')\n\ngoal (1 subgoal):\n 1. \\<And>x ln l t'.\n       \\<lbrakk>thr s t'' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<not> waiting (wset s t''); 0 < ln $ l; has_lock (locks s $ l) t';\n        t'' \\<noteq> t';\n        t' \\<in> deadlocked s \\<or> final_thread s t'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             thr s' t'' =\n                             \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                             t'' \\<turnstile> \\<langle>x, shr s'\\<rangle>\n                             \\<wrong> \\<and>\n                             wset s' t'' = None \\<and>\n                             (\\<forall>LT.\n                                 t'' \\<turnstile> \\<langle>x,\n                                 shr s'\\<rangle> LT\n                                 \\<wrong> \\<longrightarrow>\n                                 (\\<exists>lt\\<in>LT.\n                                     must_wait s' t'' lt\n(deadlocked s \\<union> deadlocked s' \\<union> final_threads s')))) \\<or>\n                         (\\<exists>x ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             all_final_except s'\n                              (deadlocked s \\<union> deadlocked s') \\<and>\n                             waiting (wset s' t'')) \\<or>\n                         (\\<exists>x l t' ln.\n                             thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                             \\<not> waiting (wset s' t'') \\<and>\n                             0 < ln $ l \\<and>\n                             has_lock (locks s' $ l) t' \\<and>\n                             t' \\<noteq> t'' \\<and>\n                             ((t' \\<in> deadlocked s \\<or>\n                               t' \\<in> deadlocked s') \\<or>\n                              final_thread s' t'))", "ultimately"], ["proof (chain)\npicking this:\n  thr s' t'' = \\<lfloor>(X, LN)\\<rfloor>\n  T \\<in> deadlocked s \\<or> final_thread s' T\n  has_lock (locks s' $ l) T\n  \\<not> waiting (wset s' t'')", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s' t'' = \\<lfloor>(X, LN)\\<rfloor>\n  T \\<in> deadlocked s \\<or> final_thread s' T\n  has_lock (locks s' $ l) T\n  \\<not> waiting (wset s' t'')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "using \\<open>0 < LN $ l\\<close> \\<open>t'' \\<noteq> T\\<close>"], ["proof (prove)\nusing this:\n  thr s' t'' = \\<lfloor>(X, LN)\\<rfloor>\n  T \\<in> deadlocked s \\<or> final_thread s' T\n  has_lock (locks s' $ l) T\n  \\<not> waiting (wset s' t'')\n  0 < LN $ l\n  t'' \\<noteq> T\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n        t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n        wset s' t'' = None \\<and>\n        (\\<forall>LT.\n            t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n            \\<wrong> \\<longrightarrow>\n            (\\<exists>lt\\<in>LT.\n                must_wait s' t'' lt\n                 (deadlocked s \\<union> deadlocked s' \\<union>\n                  final_threads s')))) \\<or>\n    (\\<exists>x ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n        waiting (wset s' t'')) \\<or>\n    (\\<exists>x l t' ln.\n        thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n        \\<not> waiting (wset s' t'') \\<and>\n        0 < ln $ l \\<and>\n        has_lock (locks s' $ l) t' \\<and>\n        t' \\<noteq> t'' \\<and>\n        ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n         final_thread s' t'))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n      wset s' t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s' t'' lt\n               (deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s')))) \\<or>\n  (\\<exists>x ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n      waiting (wset s' t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s' t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s' $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n       final_thread s' t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      thr s' t'' = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n      t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> \\<wrong> \\<and>\n      wset s' t'' = None \\<and>\n      (\\<forall>LT.\n          t'' \\<turnstile> \\<langle>x, shr s'\\<rangle> LT\n          \\<wrong> \\<longrightarrow>\n          (\\<exists>lt\\<in>LT.\n              must_wait s' t'' lt\n               (deadlocked s \\<union> deadlocked s' \\<union>\n                final_threads s')))) \\<or>\n  (\\<exists>x ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      all_final_except s' (deadlocked s \\<union> deadlocked s') \\<and>\n      waiting (wset s' t'')) \\<or>\n  (\\<exists>x l t' ln.\n      thr s' t'' = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n      \\<not> waiting (wset s' t'') \\<and>\n      0 < ln $ l \\<and>\n      has_lock (locks s' $ l) t' \\<and>\n      t' \\<noteq> t'' \\<and>\n      ((t' \\<in> deadlocked s \\<or> t' \\<in> deadlocked s') \\<or>\n       final_thread s' t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t' \\<in> deadlocked s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t' \\<in> deadlocked s'\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary RedT_deadlocked_subset:\n  assumes wfs: \"s \\<in> wf_state\"\n  and Red: \"s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  shows \"deadlocked s \\<subseteq> deadlocked s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deadlocked s \\<subseteq> deadlocked s'", "using Red"], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas\\<rightarrow>* s'\n\ngoal (1 subgoal):\n 1. deadlocked s \\<subseteq> deadlocked s'", "apply(induct rule: RedT_induct')"], ["proof (prove)\ngoal (2 subgoals):\n 1. deadlocked s \\<subseteq> deadlocked s\n 2. \\<And>ttas s' t ta s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        deadlocked s \\<subseteq> deadlocked s';\n        s' -t\\<triangleright>ta\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> deadlocked s \\<subseteq> deadlocked s''", "apply(unfold RedT_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. deadlocked s \\<subseteq> deadlocked s\n 2. \\<And>ttas s' t ta s''.\n       \\<lbrakk>rtrancl3p redT s ttas s';\n        deadlocked s \\<subseteq> deadlocked s';\n        s' -t\\<triangleright>ta\\<rightarrow> s''\\<rbrakk>\n       \\<Longrightarrow> deadlocked s \\<subseteq> deadlocked s''", "apply(blast dest: invariant3p_rtrancl3p[OF invariant3p_wf_state _ wfs] redT_deadlocked_subset)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}