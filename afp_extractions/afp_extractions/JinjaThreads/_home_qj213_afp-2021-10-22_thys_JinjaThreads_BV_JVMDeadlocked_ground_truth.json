{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/BV/JVMDeadlocked.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma must_sync_preserved_d:\n  assumes wf: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  and ml: \"execd_mthr.must_sync P t (xcp, frs) h\" \n  and hext: \"hext h h'\"\n  and hconf': \"hconf h'\"\n  and cs: \"\\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd>\"\n  shows \"execd_mthr.must_sync P t (xcp, frs) h'\"", "lemma can_sync_devreserp_d:\n  assumes wf: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  and cl': \"execd_mthr.can_sync P t (xcp, frs) h' L\" \n  and cs: \"\\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd>\"\n  and hext: \"hext h h'\"\n  and hconf': \"hconf h'\"\n  shows \"\\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\"", "lemma execd_preserve_deadlocked:\n  assumes wf: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  shows \"preserve_deadlocked JVM_final (mexecd P) convert_RA (correct_jvm_state \\<Phi>)\"", "lemma must_lock_d_eq_must_lock:\n  \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> execd_mthr.must_sync P t (xcp, frs) h = exec_mthr.must_sync P t (xcp, frs) h\"", "lemma can_lock_d_eq_can_lock:\n  \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L = exec_mthr.can_sync P t (xcp, frs) h L\"", "lemma exec_preserve_deadlocked:\n  assumes wf: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  shows \"preserve_deadlocked JVM_final (mexec P) convert_RA (correct_jvm_state \\<Phi>)\""], "translations": [["", "lemma must_sync_preserved_d:\n  assumes wf: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  and ml: \"execd_mthr.must_sync P t (xcp, frs) h\" \n  and hext: \"hext h h'\"\n  and hconf': \"hconf h'\"\n  and cs: \"\\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd>\"\n  shows \"execd_mthr.must_sync P t (xcp, frs) h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execd_mthr.must_sync P t (xcp, frs) h'", "proof(rule execd_mthr.must_syncI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "from ml"], ["proof (chain)\npicking this:\n  execd_mthr.must_sync P t (xcp, frs) h", "obtain ta xcp' frs' m'\n    where red: \"P,t \\<turnstile> Normal (xcp, h, frs) -ta-jvmd\\<rightarrow> Normal (xcp', m', frs')\""], ["proof (prove)\nusing this:\n  execd_mthr.must_sync P t (xcp, frs) h\n\ngoal (1 subgoal):\n 1. (\\<And>ta xcp' m' frs'.\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta-jvmd\\<rightarrow> Normal\n                 (xcp', m', frs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: execd_mthr.must_syncE)"], ["proof (state)\nthis:\n  P,t \\<turnstile> Normal\n                    (xcp, h,\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', m', frs')\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "then"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> Normal\n                    (xcp, h,\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', m', frs')", "obtain f Frs\n    where check: \"check P (xcp, h, frs)\"\n    and exec: \"(ta, xcp', m', frs') \\<in> exec P t (xcp, h, frs)\"\n    and [simp]: \"frs = f # Frs\""], ["proof (prove)\nusing this:\n  P,t \\<turnstile> Normal\n                    (xcp, h,\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', m', frs')\n\ngoal (1 subgoal):\n 1. (\\<And>f Frs.\n        \\<lbrakk>check P (xcp, h, frs);\n         (ta, xcp', m', frs') \\<in> exec P t (xcp, h, frs);\n         frs = f # Frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: jvmd_NormalE)"], ["proof (state)\nthis:\n  check P (xcp, h, frs)\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h, frs)\n  frs = f # Frs\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "from cs hext hconf'"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>\n  h \\<unlhd> h'\n  hconf h'", "have cs': \"\\<Phi> \\<turnstile> t: (xcp, h', frs) \\<surd>\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>\n  h \\<unlhd> h'\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(xcp, h', frs) \\<surd>", "by(rule correct_state_hext_mono)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, h', frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "then"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, h', frs) \\<surd>", "obtain ta \\<sigma>' where exec: \"P,t \\<turnstile> (xcp, h', frs) -ta-jvm\\<rightarrow> \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, h', frs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ta \\<sigma>'.\n        P,t \\<turnstile> (xcp, h', frs) -ta-jvm\\<rightarrow>\n        \\<sigma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: progress[OF wf])"], ["proof (state)\nthis:\n  P,t \\<turnstile> (xcp, h', frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "hence \"P,t \\<turnstile> Normal (xcp, h', frs) -ta-jvmd\\<rightarrow> Normal \\<sigma>'\""], ["proof (prove)\nusing this:\n  P,t \\<turnstile> (xcp, h', frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal (1 subgoal):\n 1. P,t \\<turnstile> Normal\n                      (xcp, h', frs) -ta-jvmd\\<rightarrow> Normal \\<sigma>'", "unfolding welltyped_commute[OF wf cs']"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> (xcp, h', frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal (1 subgoal):\n 1. P,t \\<turnstile> (xcp, h', frs) -ta-jvm\\<rightarrow> \\<sigma>'", "."], ["proof (state)\nthis:\n  P,t \\<turnstile> Normal\n                    (xcp, h', frs) -ta-jvmd\\<rightarrow> Normal \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "moreover"], ["proof (state)\nthis:\n  P,t \\<turnstile> Normal\n                    (xcp, h', frs) -ta-jvmd\\<rightarrow> Normal \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "from exec"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> (xcp, h', frs) -ta-jvm\\<rightarrow> \\<sigma>'", "have \"\\<exists>s. exec_mthr.actions_ok s t ta\""], ["proof (prove)\nusing this:\n  P,t \\<turnstile> (xcp, h', frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>s. exec_mthr.actions_ok s t ta", "by(rule exec_ta_satisfiable)"], ["proof (state)\nthis:\n  \\<exists>s. exec_mthr.actions_ok s t ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "ultimately"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> Normal\n                    (xcp, h', frs) -ta-jvmd\\<rightarrow> Normal \\<sigma>'\n  \\<exists>s. exec_mthr.actions_ok s t ta", "show \"\\<exists>ta x' m' s. mexecd P t ((xcp, frs), h') ta (x', m') \\<and> exec_mthr.actions_ok s t ta\""], ["proof (prove)\nusing this:\n  P,t \\<turnstile> Normal\n                    (xcp, h', frs) -ta-jvmd\\<rightarrow> Normal \\<sigma>'\n  \\<exists>s. exec_mthr.actions_ok s t ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta x' m' s.\n       execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n       exec_mthr.actions_ok s t ta", "by(cases \\<sigma>')(fastforce simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>ta x' m' s.\n     execd_mthr.r_syntax P t (xcp, frs) h' ta x' m' \\<and>\n     exec_mthr.actions_ok s t ta\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma can_sync_devreserp_d:\n  assumes wf: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  and cl': \"execd_mthr.can_sync P t (xcp, frs) h' L\" \n  and cs: \"\\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd>\"\n  and hext: \"hext h h'\"\n  and hconf': \"hconf h'\"\n  shows \"\\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from cl'"], ["proof (chain)\npicking this:\n  execd_mthr.can_sync P t (xcp, frs) h' L", "obtain ta xcp' frs' m'\n    where red: \"P,t \\<turnstile> Normal (xcp, h', frs) -ta-jvmd\\<rightarrow> Normal (xcp', m', frs')\"\n    and L: \"L = collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> <+> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> <+> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  execd_mthr.can_sync P t (xcp, frs) h' L\n\ngoal (1 subgoal):\n 1. (\\<And>ta xcp' m' frs'.\n        \\<lbrakk>P,t \\<turnstile> Normal\n                                   (xcp, h',\n                                    frs) -ta-jvmd\\<rightarrow> Normal\n                          (xcp', m', frs');\n         L = collect_waits ta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule execd_mthr.can_syncE, auto)"], ["proof (state)\nthis:\n  P,t \\<turnstile> Normal\n                    (xcp, h',\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', m', frs')\n  L = collect_waits ta\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "then"], ["proof (chain)\npicking this:\n  P,t \\<turnstile> Normal\n                    (xcp, h',\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', m', frs')\n  L = collect_waits ta", "obtain f Frs\n    where check: \"check P (xcp, h', frs)\"\n    and exec: \"(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\"\n    and [simp]: \"frs = f # Frs\""], ["proof (prove)\nusing this:\n  P,t \\<turnstile> Normal\n                    (xcp, h',\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', m', frs')\n  L = collect_waits ta\n\ngoal (1 subgoal):\n 1. (\\<And>f Frs.\n        \\<lbrakk>check P (xcp, h', frs);\n         (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n         frs = f # Frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: jvmd_NormalE simp add: finfun_upd_apply)"], ["proof (state)\nthis:\n  check P (xcp, h', frs)\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  frs = f # Frs\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "obtain stk loc C M pc where [simp]: \"f = (stk, loc, C, M, pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk loc C M pc.\n        f = (stk, loc, C, M, pc) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases f, blast)"], ["proof (state)\nthis:\n  f = (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from cs"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>", "obtain ST LT Ts T mxs mxl ins xt where\n    hconf:  \"hconf h\" and\n    tconf:  \"P,h \\<turnstile> t \\<surd>t\" and\n    meth:   \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins, xt)\\<rfloor> in C\" and\n    \\<Phi>:      \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    frame:  \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames: \"conf_fs P h \\<Phi> M (size Ts) T Frs\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mxs mxl ins xt ST LT.\n        \\<lbrakk>hconf h; P,h \\<turnstile> t \\<surd>t;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl,\n                         ins, xt)\\<rfloor> in C;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T Frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp add: correct_state_def dest: sees_method_fun)"], ["proof (state)\nthis:\n  hconf h\n  P,h \\<turnstile> t \\<surd>t\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T Frs\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from cs"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>", "have \"exec P t (xcp, h, f # Frs) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. exec P t (xcp, h, f # Frs) \\<noteq> {}", "by(auto dest!: progress[OF wf] simp add: exec_1_iff)"], ["proof (state)\nthis:\n  exec P t (xcp, h, f # Frs) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "with no_type_error[OF wf cs]"], ["proof (chain)\npicking this:\n  exec_d P t (xcp, h, frs) \\<noteq> TypeError\n  exec P t (xcp, h, f # Frs) \\<noteq> {}", "have check': \"check P (xcp, h, frs)\""], ["proof (prove)\nusing this:\n  exec_d P t (xcp, h, frs) \\<noteq> TypeError\n  exec P t (xcp, h, f # Frs) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. check P (xcp, h, frs)", "by(auto simp add: exec_d_def split: if_split_asm)"], ["proof (state)\nthis:\n  check P (xcp, h, frs)\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from wf"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmd where wfp: \"wf_prog wfmd P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmd. wf_prog wfmd P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: wt_jvm_progD)"], ["proof (state)\nthis:\n  wf_prog wfmd P\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from tconf hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'", "have tconf': \"P,h' \\<turnstile> t \\<surd>t\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> t \\<surd>t\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> t \\<surd>t", "by(rule tconf_hext_mono)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> t \\<surd>t\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "proof(cases xcp)"], ["proof (state)\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "case [simp]: (Some a)"], ["proof (state)\nthis:\n  xcp = \\<lfloor>a\\<rfloor>\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "with exec"], ["proof (chain)\npicking this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  xcp = \\<lfloor>a\\<rfloor>", "have [simp]: \"m' = h'\""], ["proof (prove)\nusing this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  xcp = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. m' = h'", "by(auto)"], ["proof (state)\nthis:\n  m' = h'\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from \\<open>\\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd>\\<close>"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>", "obtain D where D: \"typeof_addr h a = \\<lfloor>Class_type D\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        typeof_addr h a = \\<lfloor>Class_type D\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: correct_state_def)"], ["proof (state)\nthis:\n  typeof_addr h a = \\<lfloor>Class_type D\\<rfloor>\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "with hext"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>Class_type D\\<rfloor>", "have \"cname_of h a = cname_of h' a\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>Class_type D\\<rfloor>\n\ngoal (1 subgoal):\n 1. cname_of h a = cname_of h' a", "by(auto dest: hext_objD simp add: cname_of_def)"], ["proof (state)\nthis:\n  cname_of h a = cname_of h' a\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "with exec"], ["proof (chain)\npicking this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  cname_of h a = cname_of h' a", "have \"(ta, xcp', h, frs') \\<in> exec P t (xcp, h, frs)\""], ["proof (prove)\nusing this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  cname_of h a = cname_of h' a\n\ngoal (1 subgoal):\n 1. (ta, xcp', h, frs') \\<in> exec P t (xcp, h, frs)", "by auto"], ["proof (state)\nthis:\n  (ta, xcp', h, frs') \\<in> exec P t (xcp, h, frs)\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "moreover"], ["proof (state)\nthis:\n  (ta, xcp', h, frs') \\<in> exec P t (xcp, h, frs)\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from check D hext"], ["proof (chain)\npicking this:\n  check P (xcp, h', frs)\n  typeof_addr h a = \\<lfloor>Class_type D\\<rfloor>\n  h \\<unlhd> h'", "have \"check P (xcp, h, frs)\""], ["proof (prove)\nusing this:\n  check P (xcp, h', frs)\n  typeof_addr h a = \\<lfloor>Class_type D\\<rfloor>\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. check P (xcp, h, frs)", "by(auto simp add: check_def check_xcpt_def dest: hext_objD)"], ["proof (state)\nthis:\n  check P (xcp, h, frs)\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "ultimately"], ["proof (chain)\npicking this:\n  (ta, xcp', h, frs') \\<in> exec P t (xcp, h, frs)\n  check P (xcp, h, frs)", "have \"P,t \\<turnstile> Normal (xcp, h, frs) -ta-jvmd\\<rightarrow> Normal (xcp', h, frs')\""], ["proof (prove)\nusing this:\n  (ta, xcp', h, frs') \\<in> exec P t (xcp, h, frs)\n  check P (xcp, h, frs)\n\ngoal (1 subgoal):\n 1. P,t \\<turnstile> Normal\n                      (xcp, h,\n                       frs) -ta-jvmd\\<rightarrow> Normal (xcp', h, frs')", "by -(rule exec_1_d_NormalI, simp only: exec_d_def if_True)"], ["proof (state)\nthis:\n  P,t \\<turnstile> Normal\n                    (xcp, h,\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', h, frs')\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "with L"], ["proof (chain)\npicking this:\n  L = collect_waits ta\n  P,t \\<turnstile> Normal\n                    (xcp, h,\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', h, frs')", "have \"execd_mthr.can_sync P t (xcp, frs) h L\""], ["proof (prove)\nusing this:\n  L = collect_waits ta\n  P,t \\<turnstile> Normal\n                    (xcp, h,\n                     frs) -ta-jvmd\\<rightarrow> Normal (xcp', h, frs')\n\ngoal (1 subgoal):\n 1. execd_mthr.can_sync P t (xcp, frs) h L", "by(auto intro: execd_mthr.can_syncI)"], ["proof (state)\nthis:\n  execd_mthr.can_sync P t (xcp, frs) h L\n\ngoal (2 subgoals):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n 2. \\<And>a.\n       xcp = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "thus ?thesis"], ["proof (prove)\nusing this:\n  execd_mthr.can_sync P t (xcp, frs) h L\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "by auto"], ["proof (state)\nthis:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "case [simp]: None"], ["proof (state)\nthis:\n  xcp = None\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "note [simp] = defs1 list_all2_Cons2"], ["proof (state)\nthis:\n  correct_state ?\\<Phi> ?t \\<equiv>\n  \\<lambda>(xp, h, frs).\n     P,h \\<turnstile> ?t \\<surd>t \\<and>\n     hconf h \\<and>\n     preallocated h \\<and>\n     (case frs of [] \\<Rightarrow> True\n      | f # fs \\<Rightarrow>\n          let (stk, loc, C, M, pc) = f\n          in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs,\n                                mxl\\<^sub>0, is, xt)\\<rfloor> in C \\<and>\n                ?\\<Phi> C M ! pc = \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                conf_f P h \\<tau> is f \\<and>\n                conf_fs P h ?\\<Phi> M (length Ts) T fs \\<and>\n                conf_xcp P h xp (is ! pc))\n  conf_f ?P ?h \\<equiv>\n  \\<lambda>(ST, LT) is (stk, loc, C, M, pc).\n     ?P,?h \\<turnstile> stk [:\\<le>] ST \\<and>\n     ?P,?h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < length is\n  ?P,?T,?mxs,?mpc,?xt \\<turnstile> ?i,?pc :: ?\\<tau>s \\<equiv>\n  app ?i ?P ?mxs ?T ?pc ?mpc ?xt (?\\<tau>s ! ?pc) \\<and>\n  (\\<forall>(pc', \\<tau>')\\<in>set (eff ?i ?P ?pc ?xt (?\\<tau>s ! ?pc)).\n      ?P \\<turnstile> \\<tau>' \\<le>' ?\\<tau>s ! pc')\n  eff ?i ?P ?pc ?et ?t \\<equiv>\n  case ?t of None \\<Rightarrow> []\n  | \\<lfloor>\\<tau>\\<rfloor> \\<Rightarrow>\n      norm_eff ?i ?P ?pc \\<tau> @ xcpt_eff ?i ?P ?pc \\<tau> ?et\n  norm_eff ?i ?P ?pc ?\\<tau> \\<equiv>\n  map (\\<lambda>pc'. (pc', \\<lfloor>eff\\<^sub>i (?i, ?P, ?\\<tau>)\\<rfloor>))\n   (succs ?i ?\\<tau> ?pc)\n  app ?i ?P ?mxs ?T\\<^sub>r ?pc ?mpc ?xt ?t \\<equiv>\n  case ?t of None \\<Rightarrow> True\n  | \\<lfloor>\\<tau>\\<rfloor> \\<Rightarrow>\n      app\\<^sub>i (?i, ?P, ?pc, ?mxs, ?T\\<^sub>r, \\<tau>) \\<and>\n      xcpt_app ?i ?P ?pc ?mxs ?xt \\<tau> \\<and>\n      (\\<forall>(pc', \\<tau>')\\<in>set (eff ?i ?P ?pc ?xt ?t). pc' < ?mpc)\n  xcpt_app ?i ?P ?pc ?mxs ?xt ?\\<tau> \\<equiv>\n  \\<forall>(f, t, C, h, d)\\<in>set (relevant_entries ?P ?i ?pc ?xt).\n     (case C of None \\<Rightarrow> True\n      | \\<lfloor>C'\\<rfloor> \\<Rightarrow> is_class ?P C') \\<and>\n     d \\<le> length (fst ?\\<tau>) \\<and> d < ?mxs\n  list_all2 ?P ?xs (?y # ?ys) =\n  (\\<exists>z zs. ?xs = z # zs \\<and> ?P z ?y \\<and> list_all2 ?P zs ?ys)\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have ST: \"P,h \\<turnstile> stk [:\\<le>] ST\"\n      and LT: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\"\n      and pc: \"pc < length ins\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST &&&\n    P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT &&& pc < length ins", "by simp_all"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from wf meth pc"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  pc < length ins", "have wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  pc < length ins\n\ngoal (1 subgoal):\n 1. P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "by(rule wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "from \\<open>\\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd>\\<close>"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>", "have \"\\<exists>ta \\<sigma>'. P,t \\<turnstile> (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n       (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>'", "by(auto dest: progress[OF wf] simp del: correct_state_def split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n     (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "with exec meth"], ["proof (chain)\npicking this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n     (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>'", "have \"\\<exists>ta' \\<sigma>'. (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and> collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n     (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "proof(cases \"ins ! pc\")"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl,\n                         ins, xt)\\<rfloor> in C;\n         \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n            (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                             (ta', \\<sigma>')\n                             \\<in> exec P t (xcp, h, frs) \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             collect_cond_actions\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> collect_cond_actions\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 24 subgoals...", "case (Invoke M' n)"], ["proof (state)\nthis:\n  ins ! pc = Invoke M' n\n\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl,\n                         ins, xt)\\<rfloor> in C;\n         \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n            (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                             (ta', \\<sigma>')\n                             \\<in> exec P t (xcp, h, frs) \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             collect_cond_actions\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> collect_cond_actions\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 24 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "proof(cases \"stk ! n = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. stk ! n = Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 2. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "case True"], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (2 subgoals):\n 1. stk ! n = Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 2. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with Invoke exec meth"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  stk ! n = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "by simp"], ["proof (state)\nthis:\n  \\<exists>ta' \\<sigma>'.\n     (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "case False"], ["proof (state)\nthis:\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with check meth"], ["proof (chain)\npicking this:\n  check P (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  stk ! n \\<noteq> Null", "obtain a where a: \"stk ! n = Addr a\" and n: \"n < length stk\""], ["proof (prove)\nusing this:\n  check P (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>stk ! n = Addr a; n < length stk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: check_def is_Ref_def Invoke)"], ["proof (state)\nthis:\n  stk ! n = Addr a\n  n < length stk\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have stk: \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by(auto simp add: conf_f_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "hence \"P,h \\<turnstile> stk ! n :\\<le> ST ! n\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> ST ! n", "using n"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  n < length stk\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> ST ! n", "by(rule list_all2_nthD)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with a"], ["proof (chain)\npicking this:\n  stk ! n = Addr a\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n", "obtain ao Ta where Ta: \"typeof_addr h a = \\<lfloor>Ta\\<rfloor>\""], ["proof (prove)\nusing this:\n  stk ! n = Addr a\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. (\\<And>Ta.\n        typeof_addr h a = \\<lfloor>Ta\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: conf_def)"], ["proof (state)\nthis:\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "from hext Ta"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>", "have Ta': \"typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Ta\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with check a meth Invoke False"], ["proof (chain)\npicking this:\n  check P (xcp, h', frs)\n  stk ! n = Addr a\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  ins ! pc = Invoke M' n\n  stk ! n \\<noteq> Null\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>", "obtain D Ts' T' meth D'\n          where C: \"D = class_type_of Ta\"\n          and sees': \"P \\<turnstile> D sees M':Ts'\\<rightarrow>T' = meth in D'\"\n          and params: \"P,h' \\<turnstile> rev (take n stk) [:\\<le>] Ts'\""], ["proof (prove)\nusing this:\n  check P (xcp, h', frs)\n  stk ! n = Addr a\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  ins ! pc = Invoke M' n\n  stk ! n \\<noteq> Null\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>D Ts' T' meth D'.\n        \\<lbrakk>D = class_type_of Ta;\n         P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D';\n         P,h' \\<turnstile> rev (take n stk) [:\\<le>] Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: check_def has_method_def)"], ["proof (state)\nthis:\n  D = class_type_of Ta\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  P,h' \\<turnstile> rev (take n stk) [:\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "proof(cases \"meth\")"], ["proof (state)\ngoal (2 subgoals):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>a.\n       meth = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta' \\<sigma>'.\n          (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "case Some"], ["proof (state)\nthis:\n  meth = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>a.\n       meth = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<exists>ta' \\<sigma>'.\n          (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n          collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n          \\<subseteq> collect_locks\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n          collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n          \\<subseteq> collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n          collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n          \\<subseteq> collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with exec meth a Ta Ta' Invoke n sees' C"], ["proof (chain)\npicking this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  ins ! pc = Invoke M' n\n  n < length stk\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  D = class_type_of Ta\n  meth = \\<lfloor>a_\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  ins ! pc = Invoke M' n\n  n < length stk\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  D = class_type_of Ta\n  meth = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "by(simp add: split_beta)"], ["proof (state)\nthis:\n  \\<exists>ta' \\<sigma>'.\n     (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "case None"], ["proof (state)\nthis:\n  meth = None\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with exec meth a Ta Ta' Invoke n sees' C"], ["proof (chain)\npicking this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  ins ! pc = Invoke M' n\n  n < length stk\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  D = class_type_of Ta\n  meth = None", "obtain ta' va h'' where ta': \"ta = extTA2JVM P ta'\"\n            and va: \"(xcp', m', frs') = extRet2JVM n h'' stk loc C M pc Frs va\"\n            and exec': \"(ta', va, h'') \\<in> red_external_aggr P t a M' (rev (take n stk)) h'\""], ["proof (prove)\nusing this:\n  (ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                  xt)\\<rfloor> in C\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  ins ! pc = Invoke M' n\n  n < length stk\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  D = class_type_of Ta\n  meth = None\n\ngoal (1 subgoal):\n 1. (\\<And>ta' h'' va.\n        \\<lbrakk>ta = extTA2JVM P ta';\n         (xcp', m', frs') = extRet2JVM n h'' stk loc C M pc Frs va;\n         (ta', va, h'')\n         \\<in> red_external_aggr P t a M' (rev (take n stk)) h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  ta = extTA2JVM P ta'\n  (xcp', m', frs') = extRet2JVM n h'' stk loc C M pc Frs va\n  (ta', va, h'') \\<in> red_external_aggr P t a M' (rev (take n stk)) h'\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "from va"], ["proof (chain)\npicking this:\n  (xcp', m', frs') = extRet2JVM n h'' stk loc C M pc Frs va", "have [simp]: \"h'' = m'\""], ["proof (prove)\nusing this:\n  (xcp', m', frs') = extRet2JVM n h'' stk loc C M pc Frs va\n\ngoal (1 subgoal):\n 1. h'' = m'", "by(cases va) simp_all"], ["proof (state)\nthis:\n  h'' = m'\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "note Ta"], ["proof (state)\nthis:\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "moreover"], ["proof (state)\nthis:\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "from None sees' wfp"], ["proof (chain)\npicking this:\n  meth = None\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  wf_prog wfmd P", "have \"D'\\<bullet>M'(Ts') :: T'\""], ["proof (prove)\nusing this:\n  meth = None\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  wf_prog wfmd P\n\ngoal (1 subgoal):\n 1. D'\\<bullet>M'(Ts') :: T'", "by(auto intro: sees_wf_native)"], ["proof (state)\nthis:\n  D'\\<bullet>M'(Ts') :: T'\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with C sees' params Ta' None"], ["proof (chain)\npicking this:\n  D = class_type_of Ta\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  P,h' \\<turnstile> rev (take n stk) [:\\<le>] Ts'\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  meth = None\n  D'\\<bullet>M'(Ts') :: T'", "have \"P,h' \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\""], ["proof (prove)\nusing this:\n  D = class_type_of Ta\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  P,h' \\<turnstile> rev (take n stk) [:\\<le>] Ts'\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  meth = None\n  D'\\<bullet>M'(Ts') :: T'\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'", "by(auto simp add: external_WT'_iff confs_conv_map)"], ["proof (state)\nthis:\n  P,h' \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with wfp exec' tconf'"], ["proof (chain)\npicking this:\n  wf_prog wfmd P\n  (ta', va, h'') \\<in> red_external_aggr P t a M' (rev (take n stk)) h'\n  P,h' \\<turnstile> t \\<surd>t\n  P,h' \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'", "have red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)), h'\\<rangle> -ta'\\<rightarrow>ext \\<langle>va, m'\\<rangle>\""], ["proof (prove)\nusing this:\n  wf_prog wfmd P\n  (ta', va, h'') \\<in> red_external_aggr P t a M' (rev (take n stk)) h'\n  P,h' \\<turnstile> t \\<surd>t\n  P,h' \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n\ngoal (1 subgoal):\n 1. P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                     h'\\<rangle> -ta'\\<rightarrow>ext \\<langle>va,\n                m'\\<rangle>", "by(simp add: WT_red_external_list_conv)"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h'\\<rangle> -ta'\\<rightarrow>ext \\<langle>va,m'\\<rangle>\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> take n stk [:\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> take n stk [:\\<le>] take n ST", "by(rule list_all2_takeI)"], ["proof (state)\nthis:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "then"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST", "obtain Ts where \"map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Ts\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. (\\<And>Ts.\n        map typeof\\<^bsub>h\\<^esub> (take n stk) =\n        map Some Ts \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: confs_conv_map)"], ["proof (state)\nthis:\n  map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Ts\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "hence \"map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)\""], ["proof (prove)\nusing this:\n  map typeof\\<^bsub>h\\<^esub> (take n stk) = map Some Ts\n\ngoal (1 subgoal):\n 1. map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)", "by(simp only: rev_map[symmetric])"], ["proof (state)\nthis:\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "moreover"], ["proof (state)\nthis:\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "hence \"map typeof\\<^bsub>h'\\<^esub> (rev (take n stk)) = map Some (rev Ts)\""], ["proof (prove)\nusing this:\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n\ngoal (1 subgoal):\n 1. map typeof\\<^bsub>h'\\<^esub> (rev (take n stk)) = map Some (rev Ts)", "using hext"], ["proof (prove)\nusing this:\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. map typeof\\<^bsub>h'\\<^esub> (rev (take n stk)) = map Some (rev Ts)", "by(rule map_typeof_hext_mono)"], ["proof (state)\nthis:\n  map typeof\\<^bsub>h'\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with \\<open>P,h' \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\\<close> \\<open>D'\\<bullet>M'(Ts') :: T'\\<close> sees' C Ta' Ta"], ["proof (chain)\npicking this:\n  P,h' \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n  D'\\<bullet>M'(Ts') :: T'\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  D = class_type_of Ta\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  map typeof\\<^bsub>h'\\<^esub> (rev (take n stk)) = map Some (rev Ts)", "have \"P \\<turnstile> rev Ts [\\<le>] Ts'\""], ["proof (prove)\nusing this:\n  P,h' \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n  D'\\<bullet>M'(Ts') :: T'\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  D = class_type_of Ta\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  map typeof\\<^bsub>h'\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> rev Ts [\\<le>] Ts'", "by cases (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> rev Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n  P \\<turnstile> rev Ts [\\<le>] Ts'", "have \"P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n  P \\<turnstile> rev Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'", "using Ta C sees' params None \\<open>D'\\<bullet>M'(Ts') :: T'\\<close>"], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  map typeof\\<^bsub>h\\<^esub> (rev (take n stk)) = map Some (rev Ts)\n  P \\<turnstile> rev Ts [\\<le>] Ts'\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  D = class_type_of Ta\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  P,h' \\<turnstile> rev (take n stk) [:\\<le>] Ts'\n  meth = None\n  D'\\<bullet>M'(Ts') :: T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'", "by(auto simp add: external_WT'_iff confs_conv_map)"], ["proof (state)\nthis:\n  P,h \\<turnstile> a\\<bullet>M'(rev (take n stk)) : T'\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "from red_external_wt_hconf_hext[OF wfp red hext this tconf hconf]"], ["proof (chain)\npicking this:\n  \\<exists>ta'a va' h'''.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                      h\\<rangle> -ta'a\\<rightarrow>ext \\<langle>va',\n                 h'''\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> =\n     collect_locks \\<lbrace>ta'a\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> =\n     collect_cond_actions \\<lbrace>ta'a\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> =\n     collect_interrupts \\<lbrace>ta'a\\<rbrace>\\<^bsub>i\\<^esub>", "obtain ta'' va' h''' where \"P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),h\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',h'''\\<rangle>\"\n            and ta'': \"collect_locks \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> = collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\" \n            \"collect_cond_actions \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> = collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\"\n            \"collect_interrupts \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> = collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<exists>ta'a va' h'''.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                      h\\<rangle> -ta'a\\<rightarrow>ext \\<langle>va',\n                 h'''\\<rangle> \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> =\n     collect_locks \\<lbrace>ta'a\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> =\n     collect_cond_actions \\<lbrace>ta'a\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> =\n     collect_interrupts \\<lbrace>ta'a\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>ta'' va' h'''.\n        \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                                  h\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',\n                             h'''\\<rangle>;\n         collect_locks \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> =\n         collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n         collect_cond_actions \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> =\n         collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n         collect_interrupts \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> =\n         collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',\n              h'''\\<rangle>\n  collect_locks \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> =\n  collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n  collect_cond_actions \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> =\n  collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n  collect_interrupts \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> =\n  collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with None a Ta Invoke meth Ta' n C sees'"], ["proof (chain)\npicking this:\n  meth = None\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M: Ts__\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                    xt)\\<rfloor> in C\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  n < length stk\n  D = class_type_of Ta\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',\n              h'''\\<rangle>\n  collect_locks \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> =\n  collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n  collect_cond_actions \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> =\n  collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n  collect_interrupts \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> =\n  collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>", "have \"(extTA2JVM P ta'', extRet2JVM n h''' stk loc C M pc Frs va') \\<in> exec P t (xcp, h, frs)\""], ["proof (prove)\nusing this:\n  meth = None\n  stk ! n = Addr a\n  typeof_addr h a = \\<lfloor>Ta\\<rfloor>\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M: Ts__\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                    xt)\\<rfloor> in C\n  typeof_addr h' a = \\<lfloor>Ta\\<rfloor>\n  n < length stk\n  D = class_type_of Ta\n  P \\<turnstile> D sees M': Ts'\\<rightarrow>T' = meth in D'\n  P,t \\<turnstile> \\<langle>a\\<bullet>M'(rev (take n stk)),\n                   h\\<rangle> -ta''\\<rightarrow>ext \\<langle>va',\n              h'''\\<rangle>\n  collect_locks \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> =\n  collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n  collect_cond_actions \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> =\n  collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n  collect_interrupts \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> =\n  collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. (extTA2JVM P ta'', extRet2JVM n h''' stk loc C M pc Frs va')\n    \\<in> exec P t (xcp, h, frs)", "by(force intro: red_external_imp_red_external_aggr simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  (extTA2JVM P ta'', extRet2JVM n h''' stk loc C M pc Frs va')\n  \\<in> exec P t (xcp, h, frs)\n\ngoal (1 subgoal):\n 1. meth = None \\<Longrightarrow>\n    \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "with ta'' ta'"], ["proof (chain)\npicking this:\n  collect_locks \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> =\n  collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n  collect_cond_actions \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> =\n  collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n  collect_interrupts \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> =\n  collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n  ta = extTA2JVM P ta'\n  (extTA2JVM P ta'', extRet2JVM n h''' stk loc C M pc Frs va')\n  \\<in> exec P t (xcp, h, frs)", "show ?thesis"], ["proof (prove)\nusing this:\n  collect_locks \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> =\n  collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n  collect_cond_actions \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> =\n  collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n  collect_interrupts \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> =\n  collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n  ta = extTA2JVM P ta'\n  (extTA2JVM P ta'', extRet2JVM n h''' stk loc C M pc Frs va')\n  \\<in> exec P t (xcp, h, frs)\n\ngoal (1 subgoal):\n 1. \\<exists>ta' \\<sigma>'.\n       (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "by(fastforce simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>ta' \\<sigma>'.\n     (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' \\<sigma>'.\n     (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta' \\<sigma>'.\n     (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (23 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 6. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = ALoad\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 7. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = AStore\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 8. \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                     xt)\\<rfloor> in C;\n     \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n        (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n     ins ! pc = ALength\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                         (ta', \\<sigma>')\n                         \\<in> exec P t (xcp, h, frs) \\<and>\n                         collect_locks\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl, ins,\n                        xt)\\<rfloor> in C;\n        \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n           (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n        ins ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            (ta', \\<sigma>')\n                            \\<in> exec P t (xcp, h, frs) \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', m', frs') \\<in> exec P t (xcp, h', frs);\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(mxs, mxl,\n                         ins, xt)\\<rfloor> in C;\n         \\<exists>ta \\<sigma>'. P,t \\<turnstile>\n            (xcp, h, f # Frs) -ta-jvm\\<rightarrow> \\<sigma>';\n         ins ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                             (ta', \\<sigma>')\n                             \\<in> exec P t (xcp, h, frs) \\<and>\n                             collect_locks\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                             \\<subseteq> collect_locks\n    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                             collect_cond_actions\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                             \\<subseteq> collect_cond_actions\n    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                             collect_interrupts\n                              \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                             \\<subseteq> collect_interrupts\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\nA total of 23 subgoals...", "qed(auto 4 4 split: if_split_asm simp add: split_beta ta_upd_simps exec_1_iff intro: rev_image_eqI simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>ta' \\<sigma>'.\n     (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "with check'"], ["proof (chain)\npicking this:\n  check P (xcp, h, frs)\n  \\<exists>ta' \\<sigma>'.\n     (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "have \"\\<exists>ta' \\<sigma>'. P,t \\<turnstile> Normal (xcp, h, frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>' \\<and> collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n      collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and> collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\nusing this:\n  check P (xcp, h, frs)\n  \\<exists>ta' \\<sigma>'.\n     (ta', \\<sigma>') \\<in> exec P t (xcp, h, frs) \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>ta' \\<sigma>'.\n       P,t \\<turnstile> Normal\n                         (xcp, h,\n                          frs) -ta'-jvmd\\<rightarrow> Normal\n                 \\<sigma>' \\<and>\n       collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n       \\<subseteq> collect_locks\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n       collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n       \\<subseteq> collect_cond_actions\n                    \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n       collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n       \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae af ba.\n       \\<lbrakk>check P (xcp, h, frs);\n        ((a, aa, ab, ac, ad, b), ae, af, ba) \\<in> exec P t (xcp, h, frs);\n        collect_locks\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta' \\<sigma>'.\n                            P,t \\<turnstile> Normal\n        (xcp, h, frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>' \\<and>\n                            collect_locks\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n                            \\<subseteq> collect_locks\n   \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                            collect_cond_actions\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n                            \\<subseteq> collect_cond_actions\n   \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                            collect_interrupts\n                             \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n                            \\<subseteq> collect_interrupts\n   \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "apply(rule exI conjI)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b ae af ba.\n       \\<lbrakk>check P (xcp, h, frs);\n        ((a, aa, ab, ac, ad, b), ae, af, ba) \\<in> exec P t (xcp, h, frs);\n        collect_locks\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> P,t \\<turnstile> Normal\n     (xcp, h,\n      frs) -?ta'7 a aa ab ac ad b ae af\n             ba-jvmd\\<rightarrow> Normal\n                                   (?\\<sigma>'9 a aa ab ac ad b ae af ba)\n 2. \\<And>a aa ab ac ad b ae af ba.\n       \\<lbrakk>check P (xcp, h, frs);\n        ((a, aa, ab, ac, ad, b), ae, af, ba) \\<in> exec P t (xcp, h, frs);\n        collect_locks\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>?ta'7 a aa ab ac ad b ae af\n                                    ba\\<rbrace>\\<^bsub>l\\<^esub>\n                         \\<subseteq> collect_locks\n\\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                         collect_cond_actions\n                          \\<lbrace>?ta'7 a aa ab ac ad b ae af\n                                    ba\\<rbrace>\\<^bsub>c\\<^esub>\n                         \\<subseteq> collect_cond_actions\n\\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                         collect_interrupts\n                          \\<lbrace>?ta'7 a aa ab ac ad b ae af\n                                    ba\\<rbrace>\\<^bsub>i\\<^esub>\n                         \\<subseteq> collect_interrupts\n\\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "apply(rule exec_1_d.exec_1_d_NormalI, auto simp add: exec_d_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ta' \\<sigma>'.\n     P,t \\<turnstile> Normal\n                       (xcp, h,\n                        frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>' \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. xcp = None \\<Longrightarrow>\n    \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "with L"], ["proof (chain)\npicking this:\n  L = collect_waits ta\n  \\<exists>ta' \\<sigma>'.\n     P,t \\<turnstile> Normal\n                       (xcp, h,\n                        frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>' \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  L = collect_waits ta\n  \\<exists>ta' \\<sigma>'.\n     P,t \\<turnstile> Normal\n                       (xcp, h,\n                        frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>' \\<and>\n     collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = collect_waits ta;\n     \\<exists>ta' \\<sigma>'.\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta'-jvmd\\<rightarrow> Normal\n                  \\<sigma>' \\<and>\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n        collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                         execd_mthr.can_sync P t (xcp, frs) h L'", "apply(erule exE conjE|rule exI conjI)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta' \\<sigma>'.\n       \\<lbrakk>L = collect_waits ta;\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>';\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ?L'12 ta' \\<sigma>' \\<subseteq> L\n 2. \\<And>ta' \\<sigma>'.\n       \\<lbrakk>L = collect_waits ta;\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>';\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h\n                          (?L'12 ta' \\<sigma>')", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta' \\<sigma>'.\n       \\<lbrakk>L = collect_waits ta;\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>';\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h\n                          (?L'12 ta' \\<sigma>')\n 2. \\<And>ta' \\<sigma>'.\n       \\<lbrakk>L = collect_waits ta;\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>';\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ?L'12 ta' \\<sigma>' \\<subseteq> L", "apply(rule_tac x'=\"(fst \\<sigma>', snd (snd \\<sigma>'))\" and m'=\"fst (snd \\<sigma>')\" in execd_mthr.can_syncI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ta' \\<sigma>'.\n       \\<lbrakk>L = collect_waits ta;\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>';\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.r_syntax P t (xcp, frs) h\n                          (?ta17 ta' \\<sigma>')\n                          (fst \\<sigma>', snd (snd \\<sigma>'))\n                          (fst (snd \\<sigma>'))\n 2. \\<And>ta' \\<sigma>'.\n       \\<lbrakk>L = collect_waits ta;\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>';\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ?L'12 ta' \\<sigma>' =\n                         collect_waits (?ta17 ta' \\<sigma>')\n 3. \\<And>ta' \\<sigma>'.\n       \\<lbrakk>L = collect_waits ta;\n        P,t \\<turnstile> Normal\n                          (xcp, h,\n                           frs) -ta'-jvmd\\<rightarrow> Normal \\<sigma>';\n        collect_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n        \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n        \\<subseteq> collect_cond_actions\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n        \\<subseteq> collect_interrupts\n                     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ?L'12 ta' \\<sigma>' \\<subseteq> L", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) h L'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context JVM_typesafe begin"], ["", "lemma execd_preserve_deadlocked:\n  assumes wf: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  shows \"preserve_deadlocked JVM_final (mexecd P) convert_RA (correct_jvm_state \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexecd P) convert_RA\n     (correct_jvm_state \\<Phi>)", "proof(unfold_locales)"], ["proof (state)\ngoal (3 subgoals):\n 1. invariant3p (mexecdT P) (correct_jvm_state \\<Phi>)\n 2. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 3. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "show \"invariant3p (mexecdT P) (correct_jvm_state \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant3p (mexecdT P) (correct_jvm_state \\<Phi>)", "by(rule invariant3p_correct_jvm_state_mexecdT[OF wf])"], ["proof (state)\nthis:\n  invariant3p (mexecdT P) (correct_jvm_state \\<Phi>)\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "fix s t' ta' s' t x ln"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "assume s: \"s \\<in> correct_jvm_state \\<Phi>\"\n    and red: \"P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\"\n    and tst: \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n    and \"execd_mthr.must_sync P t x (shr s)\""], ["proof (state)\nthis:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  execd_mthr.must_sync P t x (shr s)\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "moreover"], ["proof (state)\nthis:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  execd_mthr.must_sync P t x (shr s)\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "obtain xcp frs where x [simp]: \"x = (xcp, frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs.\n        x = (xcp, frs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x, auto)"], ["proof (state)\nthis:\n  x = (xcp, frs)\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  execd_mthr.must_sync P t x (shr s)\n  x = (xcp, frs)", "have ml: \"execd_mthr.must_sync P t (xcp, frs) (shr s)\""], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  execd_mthr.must_sync P t x (shr s)\n  x = (xcp, frs)\n\ngoal (1 subgoal):\n 1. execd_mthr.must_sync P t (xcp, frs) (shr s)", "by simp"], ["proof (state)\nthis:\n  execd_mthr.must_sync P t (xcp, frs) (shr s)\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "moreover"], ["proof (state)\nthis:\n  execd_mthr.must_sync P t (xcp, frs) (shr s)\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "from s"], ["proof (chain)\npicking this:\n  s \\<in> correct_jvm_state \\<Phi>", "have cs': \"correct_state_ts \\<Phi> (thr s) (shr s)\""], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi> (thr s) (shr s)", "by(simp add: correct_jvm_state_def)"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "with tst"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  correct_state_ts \\<Phi> (thr s) (shr s)", "have \"\\<Phi> \\<turnstile> t: (xcp, shr s, frs) \\<surd>\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "moreover"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "from red"], ["proof (chain)\npicking this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'", "have \"hext (shr s) (shr s')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n\ngoal (1 subgoal):\n 1. shr s \\<unlhd> shr s'", "by(rule execd_hext)"], ["proof (state)\nthis:\n  shr s \\<unlhd> shr s'\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "moreover"], ["proof (state)\nthis:\n  shr s \\<unlhd> shr s'\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "from wf red cs'"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  correct_state_ts \\<Phi> (thr s) (shr s)", "have \"correct_state_ts \\<Phi> (thr s') (shr s')\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi> (thr s') (shr s')", "by(rule lifting_wf.redT_preserves[OF lifting_wf_correct_state_d])"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi> (thr s') (shr s')\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "from red tst"], ["proof (chain)\npicking this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>", "have \"thr s' t \\<noteq> None\""], ["proof (prove)\nusing this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s' t \\<noteq> None", "by(cases s)(cases s', rule notI, auto dest: execd_mthr.redT_thread_not_disappear)"], ["proof (state)\nthis:\n  thr s' t \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "with \\<open>correct_state_ts \\<Phi> (thr s') (shr s')\\<close>"], ["proof (chain)\npicking this:\n  correct_state_ts \\<Phi> (thr s') (shr s')\n  thr s' t \\<noteq> None", "have \"hconf (shr s')\""], ["proof (prove)\nusing this:\n  correct_state_ts \\<Phi> (thr s') (shr s')\n  thr s' t \\<noteq> None\n\ngoal (1 subgoal):\n 1. hconf (shr s')", "by(auto dest: ts_okD simp add: correct_state_def)"], ["proof (state)\nthis:\n  hconf (shr s')\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "ultimately"], ["proof (chain)\npicking this:\n  execd_mthr.must_sync P t (xcp, frs) (shr s)\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  shr s \\<unlhd> shr s'\n  hconf (shr s')", "have \"execd_mthr.must_sync P t (xcp, frs) (shr s')\""], ["proof (prove)\nusing this:\n  execd_mthr.must_sync P t (xcp, frs) (shr s)\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  shr s \\<unlhd> shr s'\n  hconf (shr s')\n\ngoal (1 subgoal):\n 1. execd_mthr.must_sync P t (xcp, frs) (shr s')", "by-(rule must_sync_preserved_d[OF wf])"], ["proof (state)\nthis:\n  execd_mthr.must_sync P t (xcp, frs) (shr s')\n\ngoal (2 subgoals):\n 1. \\<And>s t' ta' s' t x.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.must_sync P t x (shr s)\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.must_sync P t x (shr s')\n 2. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "thus \"execd_mthr.must_sync P t x (shr s')\""], ["proof (prove)\nusing this:\n  execd_mthr.must_sync P t (xcp, frs) (shr s')\n\ngoal (1 subgoal):\n 1. execd_mthr.must_sync P t x (shr s')", "by simp"], ["proof (state)\nthis:\n  execd_mthr.must_sync P t x (shr s')\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "fix s t' ta' s' t x ln L"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "assume s: \"s \\<in> correct_jvm_state \\<Phi>\"\n    and red: \"P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\"\n    and tst: \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n    and \"execd_mthr.can_sync P t x (shr s') L\""], ["proof (state)\nthis:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  execd_mthr.can_sync P t x (shr s') L\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "moreover"], ["proof (state)\nthis:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  execd_mthr.can_sync P t x (shr s') L\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "obtain xcp frs where x [simp]: \"x = (xcp, frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs.\n        x = (xcp, frs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x, auto)"], ["proof (state)\nthis:\n  x = (xcp, frs)\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  execd_mthr.can_sync P t x (shr s') L\n  x = (xcp, frs)", "have ml: \"execd_mthr.can_sync P t (xcp, frs) (shr s') L\""], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  execd_mthr.can_sync P t x (shr s') L\n  x = (xcp, frs)\n\ngoal (1 subgoal):\n 1. execd_mthr.can_sync P t (xcp, frs) (shr s') L", "by simp"], ["proof (state)\nthis:\n  execd_mthr.can_sync P t (xcp, frs) (shr s') L\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "moreover"], ["proof (state)\nthis:\n  execd_mthr.can_sync P t (xcp, frs) (shr s') L\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "from s"], ["proof (chain)\npicking this:\n  s \\<in> correct_jvm_state \\<Phi>", "have cs': \"correct_state_ts \\<Phi> (thr s) (shr s)\""], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi> (thr s) (shr s)", "by(simp add: correct_jvm_state_def)"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "with tst"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  correct_state_ts \\<Phi> (thr s) (shr s)", "have \"\\<Phi> \\<turnstile> t: (xcp, shr s, frs) \\<surd>\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "moreover"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "from red"], ["proof (chain)\npicking this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'", "have \"hext (shr s) (shr s')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n\ngoal (1 subgoal):\n 1. shr s \\<unlhd> shr s'", "by(rule execd_hext)"], ["proof (state)\nthis:\n  shr s \\<unlhd> shr s'\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "moreover"], ["proof (state)\nthis:\n  shr s \\<unlhd> shr s'\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "from red tst"], ["proof (chain)\npicking this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>", "have \"thr s' t \\<noteq> None\""], ["proof (prove)\nusing this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr s' t \\<noteq> None", "by(cases s)(cases s', rule notI, auto dest: execd_mthr.redT_thread_not_disappear)"], ["proof (state)\nthis:\n  thr s' t \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "from red cs'"], ["proof (chain)\npicking this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  correct_state_ts \\<Phi> (thr s) (shr s)", "have \"correct_state_ts \\<Phi> (thr s') (shr s')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi> (thr s') (shr s')", "by(rule lifting_wf.redT_preserves[OF lifting_wf_correct_state_d[OF wf]])"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi> (thr s') (shr s')\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "with \\<open>thr s' t \\<noteq> None\\<close>"], ["proof (chain)\npicking this:\n  thr s' t \\<noteq> None\n  correct_state_ts \\<Phi> (thr s') (shr s')", "have \"hconf (shr s')\""], ["proof (prove)\nusing this:\n  thr s' t \\<noteq> None\n  correct_state_ts \\<Phi> (thr s') (shr s')\n\ngoal (1 subgoal):\n 1. hconf (shr s')", "by(auto dest: ts_okD simp add: correct_state_def)"], ["proof (state)\nthis:\n  hconf (shr s')\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "ultimately"], ["proof (chain)\npicking this:\n  execd_mthr.can_sync P t (xcp, frs) (shr s') L\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  shr s \\<unlhd> shr s'\n  hconf (shr s')", "have \"\\<exists>L' \\<subseteq> L. execd_mthr.can_sync P t (xcp, frs) (shr s) L'\""], ["proof (prove)\nusing this:\n  execd_mthr.can_sync P t (xcp, frs) (shr s') L\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  shr s \\<unlhd> shr s'\n  hconf (shr s')\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) (shr s) L'", "by-(rule can_sync_devreserp_d[OF wf])"], ["proof (state)\nthis:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) (shr s) L'\n\ngoal (1 subgoal):\n 1. \\<And>s t' ta' s' t x L.\n       \\<lbrakk>s \\<in> correct_jvm_state \\<Phi>;\n        P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s';\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        execd_mthr.can_sync P t x (shr s') L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'\\<subseteq>L.\n                            execd_mthr.can_sync P t x (shr s) L'", "thus \"\\<exists>L' \\<subseteq> L. execd_mthr.can_sync P t x (shr s) L'\""], ["proof (prove)\nusing this:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) (shr s) L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t x (shr s) L'", "by simp"], ["proof (state)\nthis:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t x (shr s) L'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>and now everything again for the aggresive VM\\<close>"], ["", "context JVM_heap_conf_base' begin"], ["", "lemma must_lock_d_eq_must_lock:\n  \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> execd_mthr.must_sync P t (xcp, frs) h = exec_mthr.must_sync P t (xcp, frs) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.must_sync P t (xcp, frs) h =\n                      exec_mthr.must_sync P t (xcp, frs) h", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     execd_mthr.must_sync P t (xcp, frs) h\\<rbrakk>\n    \\<Longrightarrow> exec_mthr.must_sync P t (xcp, frs) h\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.must_sync P t (xcp, frs) h\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.must_sync P t (xcp, frs) h", "apply(rule exec_mthr.must_syncI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     execd_mthr.must_sync P t (xcp, frs) h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta x' m' s.\n                         exec_mthr.r_syntax P t (xcp, frs) h ta x' m' \\<and>\n                         exec_mthr.actions_ok s t ta\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.must_sync P t (xcp, frs) h\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.must_sync P t (xcp, frs) h", "apply(erule execd_mthr.must_syncE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta x' m' s.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        execd_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        exec_mthr.actions_ok s t ta; h = shr s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m' s.\n                            exec_mthr.r_syntax P t (xcp, frs) h ta x'\n                             m' \\<and>\n                            exec_mthr.actions_ok s t ta\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.must_sync P t (xcp, frs) h\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.must_sync P t (xcp, frs) h", "apply(simp only: mexec_eq_mexecd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta x' m' s.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>;\n        execd_mthr.r_syntax P t (xcp, frs) (shr s) ta x' m';\n        exec_mthr.actions_ok s t ta; h = shr s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m' sa.\n                            execd_mthr.r_syntax P t (xcp, frs) (shr s) ta x'\n                             m' \\<and>\n                            exec_mthr.actions_ok sa t ta\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.must_sync P t (xcp, frs) h\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.must_sync P t (xcp, frs) h", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.must_sync P t (xcp, frs) h\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.must_sync P t (xcp, frs) h", "apply(rule execd_mthr.must_syncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.must_sync P t (xcp, frs) h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta x' m' s.\n                         execd_mthr.r_syntax P t (xcp, frs) h ta x'\n                          m' \\<and>\n                         exec_mthr.actions_ok s t ta", "apply(erule exec_mthr.must_syncE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta x' m' s.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        exec_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        exec_mthr.actions_ok s t ta; h = shr s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m' s.\n                            execd_mthr.r_syntax P t (xcp, frs) h ta x'\n                             m' \\<and>\n                            exec_mthr.actions_ok s t ta", "apply(simp only: mexec_eq_mexecd[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta x' m' s.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>;\n        exec_mthr.r_syntax P t (xcp, frs) (shr s) ta x' m';\n        exec_mthr.actions_ok s t ta; h = shr s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta x' m' sa.\n                            exec_mthr.r_syntax P t (xcp, frs) (shr s) ta x'\n                             m' \\<and>\n                            exec_mthr.actions_ok sa t ta", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma can_lock_d_eq_can_lock:\n  \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<Phi> \\<turnstile> t: (xcp, h, frs) \\<surd> \\<rbrakk>\n  \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L = exec_mthr.can_sync P t (xcp, frs) h L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L =\n                      exec_mthr.can_sync P t (xcp, frs) h L", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     execd_mthr.can_sync P t (xcp, frs) h L\\<rbrakk>\n    \\<Longrightarrow> exec_mthr.can_sync P t (xcp, frs) h L\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.can_sync P t (xcp, frs) h L\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L", "apply(erule execd_mthr.can_syncE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta x' m'.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        execd_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        L = collect_waits ta\\<rbrakk>\n       \\<Longrightarrow> exec_mthr.can_sync P t (xcp, frs) h L\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.can_sync P t (xcp, frs) h L\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L", "apply(rule exec_mthr.can_syncI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ta x' m'.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        execd_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        L = collect_waits ta\\<rbrakk>\n       \\<Longrightarrow> exec_mthr.r_syntax P t (xcp, frs) h (?ta5 ta x' m')\n                          (?x'5 ta x' m') (?m'5 ta x' m')\n 2. \\<And>ta x' m'.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        execd_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        L = collect_waits ta\\<rbrakk>\n       \\<Longrightarrow> L = collect_waits (?ta5 ta x' m')\n 3. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.can_sync P t (xcp, frs) h L\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L", "apply(simp only: mexec_eq_mexecd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta x' m'.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        execd_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        L = collect_waits ta\\<rbrakk>\n       \\<Longrightarrow> L = collect_waits ta\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.can_sync P t (xcp, frs) h L\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L", "apply(assumption)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n     exec_mthr.can_sync P t (xcp, frs) h L\\<rbrakk>\n    \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L", "apply(erule exec_mthr.can_syncE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta x' m'.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        exec_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        L = collect_waits ta\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.can_sync P t (xcp, frs) h L", "apply(rule execd_mthr.can_syncI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ta x' m'.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        exec_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        L = collect_waits ta\\<rbrakk>\n       \\<Longrightarrow> execd_mthr.r_syntax P t (xcp, frs) h\n                          (?ta10 ta x' m') (?x'10 ta x' m') (?m'10 ta x' m')\n 2. \\<And>ta x' m'.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<Phi> \\<turnstile> t:(xcp, h, frs) \\<surd>;\n        exec_mthr.r_syntax P t (xcp, frs) h ta x' m';\n        L = collect_waits ta\\<rbrakk>\n       \\<Longrightarrow> L = collect_waits (?ta10 ta x' m')", "by(simp only: mexec_eq_mexecd)"], ["", "end"], ["", "context JVM_typesafe begin"], ["", "lemma exec_preserve_deadlocked:\n  assumes wf: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  shows \"preserve_deadlocked JVM_final (mexec P) convert_RA (correct_jvm_state \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "interpret preserve_deadlocked JVM_final \"mexecd P\" convert_RA \"correct_jvm_state \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexecd P) convert_RA\n     (correct_jvm_state \\<Phi>)", "by(rule execd_preserve_deadlocked) fact+"], ["proof (state)\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "fix s t' ta' s' t x"], ["proof (state)\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "assume s: \"s \\<in> correct_jvm_state \\<Phi>\"\n      and red: \"P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvm\\<^esub> s'\"\n      and tst: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (state)\nthis:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvm\\<^esub> s'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "obtain xcp frs where x [simp]: \"x = (xcp, frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xcp frs.\n        x = (xcp, frs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x, auto)"], ["proof (state)\nthis:\n  x = (xcp, frs)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "from s"], ["proof (chain)\npicking this:\n  s \\<in> correct_jvm_state \\<Phi>", "have css: \"correct_state_ts \\<Phi> (thr s) (shr s)\""], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi> (thr s) (shr s)", "by(simp add: correct_jvm_state_def)"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "with red"], ["proof (chain)\npicking this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvm\\<^esub> s'\n  correct_state_ts \\<Phi> (thr s) (shr s)", "have redd: \"P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvm\\<^esub> s'\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'", "by(simp add: mexecT_eq_mexecdT[OF wf])"], ["proof (state)\nthis:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "from css tst"], ["proof (chain)\npicking this:\n  correct_state_ts \\<Phi> (thr s) (shr s)\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>", "have cst: \"\\<Phi> \\<turnstile> t: (xcp, shr s, frs) \\<surd>\""], ["proof (prove)\nusing this:\n  correct_state_ts \\<Phi> (thr s) (shr s)\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "from redd"], ["proof (chain)\npicking this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'", "have cst': \"\\<Phi> \\<turnstile> t: (xcp, shr s', frs) \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "proof(cases rule: execd_mthr.redT_elims)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n 2. \\<And>x ln n.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s t'); may_acquire_all (locks s) t' ln;\n        0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t' ln,\n         (thr s(t' \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "case acquire"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x_, ln_)\\<rfloor>\n  ta' = (K$ [], [], [], [], [], convert_RA ln_)\n  \\<not> waiting (wset s t')\n  may_acquire_all (locks s) t' ln_\n  0 < ln_ $ n_\n  s' =\n  (acquire_all (locks s) t' ln_,\n   (thr s(t' \\<mapsto> (x_, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n 2. \\<And>x ln n.\n       \\<lbrakk>thr s t' = \\<lfloor>(x, ln)\\<rfloor>;\n        ta' = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s t'); may_acquire_all (locks s) t' ln;\n        0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t' ln,\n         (thr s(t' \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "with cst"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  thr s t' = \\<lfloor>(x_, ln_)\\<rfloor>\n  ta' = (K$ [], [], [], [], [], convert_RA ln_)\n  \\<not> waiting (wset s t')\n  may_acquire_all (locks s) t' ln_\n  0 < ln_ $ n_\n  s' =\n  (acquire_all (locks s) t' ln_,\n   (thr s(t' \\<mapsto> (x_, no_wait_locks)), shr s), wset s, interrupts s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  thr s t' = \\<lfloor>(x_, ln_)\\<rfloor>\n  ta' = (K$ [], [], [], [], [], convert_RA ln_)\n  \\<not> waiting (wset s t')\n  may_acquire_all (locks s) t' ln_\n  0 < ln_ $ n_\n  s' =\n  (acquire_all (locks s) t' ln_,\n   (thr s(t' \\<mapsto> (x_, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "by simp"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "case (normal X X' M' ws')"], ["proof (state)\nthis:\n  execd_mthr.r_syntax P t' X (shr s) ta' X' M'\n  thr s t' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n  exec_mthr.cond_action_oks s t' \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n  wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>\n  interrupt_actions_ok (interrupts s) \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n  redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws'\n  s' =\n  (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n    (X',\n     redT_updLns (locks s) t' no_wait_locks\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n    M'),\n   ws', redT_updIs (interrupts s) \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "obtain XCP FRS where X [simp]: \"X = (XCP, FRS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>XCP FRS.\n        X = (XCP, FRS) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases X, auto)"], ["proof (state)\nthis:\n  X = (XCP, FRS)\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "obtain XCP' FRS' where X' [simp]: \"X' = (XCP', FRS')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>XCP' FRS'.\n        X' = (XCP', FRS') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases X', auto)"], ["proof (state)\nthis:\n  X' = (XCP', FRS')\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "from \\<open>mexecd P t' (X, shr s) ta' (X', M')\\<close>"], ["proof (chain)\npicking this:\n  execd_mthr.r_syntax P t' X (shr s) ta' X' M'", "have \"P,t' \\<turnstile> Normal (XCP, shr s, FRS) -ta'-jvmd\\<rightarrow> Normal (XCP', M', FRS')\""], ["proof (prove)\nusing this:\n  execd_mthr.r_syntax P t' X (shr s) ta' X' M'\n\ngoal (1 subgoal):\n 1. P,t' \\<turnstile> Normal\n                       (XCP, shr s,\n                        FRS) -ta'-jvmd\\<rightarrow> Normal (XCP', M', FRS')", "by simp"], ["proof (state)\nthis:\n  P,t' \\<turnstile> Normal\n                     (XCP, shr s,\n                      FRS) -ta'-jvmd\\<rightarrow> Normal (XCP', M', FRS')\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "moreover"], ["proof (state)\nthis:\n  P,t' \\<turnstile> Normal\n                     (XCP, shr s,\n                      FRS) -ta'-jvmd\\<rightarrow> Normal (XCP', M', FRS')\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "from \\<open>thr s t' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\\<close> css"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  correct_state_ts \\<Phi> (thr s) (shr s)", "have \"\\<Phi> \\<turnstile> t': (XCP, shr s, FRS) \\<surd>\""], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  correct_state_ts \\<Phi> (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t':(XCP, shr s, FRS) \\<surd>", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t':(XCP, shr s, FRS) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  P,t' \\<turnstile> Normal\n                     (XCP, shr s,\n                      FRS) -ta'-jvmd\\<rightarrow> Normal (XCP', M', FRS')\n  \\<Phi> \\<turnstile> t':(XCP, shr s, FRS) \\<surd>", "have \"\\<Phi> \\<turnstile> t': (XCP, M', FRS) \\<surd>\""], ["proof (prove)\nusing this:\n  P,t' \\<turnstile> Normal\n                     (XCP, shr s,\n                      FRS) -ta'-jvmd\\<rightarrow> Normal (XCP', M', FRS')\n  \\<Phi> \\<turnstile> t':(XCP, shr s, FRS) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>", "by -(rule correct_state_heap_change[OF wf])"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "moreover"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "from lifting_wf.redT_updTs_preserves[OF lifting_wf_correct_state_d[OF wf] css, OF \\<open>mexecd P t' (X, shr s) ta' (X', M')\\<close> \\<open>thr s t' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\\<close>, of no_wait_locks] \\<open>thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  thread_oks (thr s)\n   \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n    (X', no_wait_locks)))\n   M'\n  thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>", "have \"correct_state_ts \\<Phi> (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto> (X', no_wait_locks))) M'\""], ["proof (prove)\nusing this:\n  thread_oks (thr s)\n   \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n    (X', no_wait_locks)))\n   M'\n  thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi>\n     (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n      (X', no_wait_locks)))\n     M'", "by simp"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n    (X', no_wait_locks)))\n   M'\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n    (X', no_wait_locks)))\n   M'", "have \"correct_state_ts \\<Phi> (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) M'\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n    (X', no_wait_locks)))\n   M'\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi>\n     (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) M'", "using \\<open>thr s t' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\\<close> \\<open>thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\\<close>"], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n    (X', no_wait_locks)))\n   M'\n  thr s t' = \\<lfloor>(X, no_wait_locks)\\<rfloor>\n  thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi>\n     (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) M'", "apply(auto intro!: ts_okI dest: ts_okD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t a b ln.\n       \\<lbrakk>\\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>;\n        correct_state_ts \\<Phi>\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto> ((XCP', FRS'), no_wait_locks)))\n         M';\n        thr s t' = \\<lfloor>((XCP, FRS), no_wait_locks)\\<rfloor>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t =\n        \\<lfloor>((a, b), ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(a, M', b) \\<surd>", "apply(case_tac \"t=t'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t a b ln.\n       \\<lbrakk>\\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>;\n        correct_state_ts \\<Phi>\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto> ((XCP', FRS'), no_wait_locks)))\n         M';\n        thr s t' = \\<lfloor>((XCP, FRS), no_wait_locks)\\<rfloor>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t =\n        \\<lfloor>((a, b), ln)\\<rfloor>;\n        t = t'\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(a, M', b) \\<surd>\n 2. \\<And>t a b ln.\n       \\<lbrakk>\\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>;\n        correct_state_ts \\<Phi>\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto> ((XCP', FRS'), no_wait_locks)))\n         M';\n        thr s t' = \\<lfloor>((XCP, FRS), no_wait_locks)\\<rfloor>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t =\n        \\<lfloor>((a, b), ln)\\<rfloor>;\n        t \\<noteq> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(a, M', b) \\<surd>", "apply(fastforce dest: redT_updTs_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t a b ln.\n       \\<lbrakk>\\<Phi> \\<turnstile> t':(XCP, M', FRS) \\<surd>;\n        correct_state_ts \\<Phi>\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto> ((XCP', FRS'), no_wait_locks)))\n         M';\n        thr s t' = \\<lfloor>((XCP, FRS), no_wait_locks)\\<rfloor>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t =\n        \\<lfloor>((a, b), ln)\\<rfloor>;\n        t \\<noteq> t'\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(a, M', b) \\<surd>", "apply(drule_tac t=t in ts_okD, fastforce+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) M'\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "hence \"correct_state_ts \\<Phi> (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) (shr s')\""], ["proof (prove)\nusing this:\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) M'\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi>\n     (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) (shr s')", "using \\<open>s' = (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>, (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto> (X', redT_updLns (locks s) t' no_wait_locks \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)), M'), ws', redT_updIs (interrupts s) \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<close>"], ["proof (prove)\nusing this:\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) M'\n  s' =\n  (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \\<mapsto>\n    (X',\n     redT_updLns (locks s) t' no_wait_locks\n      \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n    M'),\n   ws', redT_updIs (interrupts s) \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\n\ngoal (1 subgoal):\n 1. correct_state_ts \\<Phi>\n     (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) (shr s')", "by simp"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) (shr s')\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "moreover"], ["proof (state)\nthis:\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) (shr s')\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "from tst \\<open>thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>", "have \"redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t =\n    \\<lfloor>(x, no_wait_locks)\\<rfloor>", "by(auto intro: redT_updTs_Some)"], ["proof (state)\nthis:\n  redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t =\n  \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x x' m' ws'.\n       \\<lbrakk>execd_mthr.r_syntax P t' x (shr s) ta' x' m';\n        thr s t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>;\n        exec_mthr.cond_action_oks s t'\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta'\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) (shr s')\n  redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t =\n  \\<lfloor>(x, no_wait_locks)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  correct_state_ts \\<Phi>\n   (redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub>) (shr s')\n  redT_updTs (thr s) \\<lbrace>ta'\\<rbrace>\\<^bsub>t\\<^esub> t =\n  \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>", "by(auto dest: ts_okD)"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "{"], ["proof (state)\nthis:\n  \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "assume \"exec_mthr.must_sync P t x (shr s)\""], ["proof (state)\nthis:\n  exec_mthr.must_sync P t x (shr s)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "hence ml: \"exec_mthr.must_sync P t (xcp, frs) (shr s)\""], ["proof (prove)\nusing this:\n  exec_mthr.must_sync P t x (shr s)\n\ngoal (1 subgoal):\n 1. exec_mthr.must_sync P t (xcp, frs) (shr s)", "by simp"], ["proof (state)\nthis:\n  exec_mthr.must_sync P t (xcp, frs) (shr s)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "with cst"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  exec_mthr.must_sync P t (xcp, frs) (shr s)", "have \"execd_mthr.must_sync P t (xcp, frs) (shr s)\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  exec_mthr.must_sync P t (xcp, frs) (shr s)\n\ngoal (1 subgoal):\n 1. execd_mthr.must_sync P t (xcp, frs) (shr s)", "by(auto dest: must_lock_d_eq_must_lock[OF wf])"], ["proof (state)\nthis:\n  execd_mthr.must_sync P t (xcp, frs) (shr s)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "with s redd tst"], ["proof (chain)\npicking this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  execd_mthr.must_sync P t (xcp, frs) (shr s)", "have \"execd_mthr.must_sync P t x (shr s')\""], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  execd_mthr.must_sync P t (xcp, frs) (shr s)\n\ngoal (1 subgoal):\n 1. execd_mthr.must_sync P t x (shr s')", "unfolding x"], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>((xcp, frs), no_wait_locks)\\<rfloor>\n  execd_mthr.must_sync P t (xcp, frs) (shr s)\n\ngoal (1 subgoal):\n 1. execd_mthr.must_sync P t (xcp, frs) (shr s')", "by(rule can_lock_preserved)"], ["proof (state)\nthis:\n  execd_mthr.must_sync P t x (shr s')\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "with cst'"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n  execd_mthr.must_sync P t x (shr s')", "have \"exec_mthr.must_sync P t x (shr s')\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n  execd_mthr.must_sync P t x (shr s')\n\ngoal (1 subgoal):\n 1. exec_mthr.must_sync P t x (shr s')", "by(auto dest: must_lock_d_eq_must_lock[OF wf])"], ["proof (state)\nthis:\n  exec_mthr.must_sync P t x (shr s')\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "}"], ["proof (state)\nthis:\n  exec_mthr.must_sync P t x (shr s) \\<Longrightarrow>\n  exec_mthr.must_sync P t x (shr s')\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "note ml = this"], ["proof (state)\nthis:\n  exec_mthr.must_sync P t x (shr s) \\<Longrightarrow>\n  exec_mthr.must_sync P t x (shr s')\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "{"], ["proof (state)\nthis:\n  exec_mthr.must_sync P t x (shr s) \\<Longrightarrow>\n  exec_mthr.must_sync P t x (shr s')\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "fix L"], ["proof (state)\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "assume \"exec_mthr.can_sync P t x (shr s') L\""], ["proof (state)\nthis:\n  exec_mthr.can_sync P t x (shr s') L\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "hence cl: \"exec_mthr.can_sync P t (xcp, frs) (shr s') L\""], ["proof (prove)\nusing this:\n  exec_mthr.can_sync P t x (shr s') L\n\ngoal (1 subgoal):\n 1. exec_mthr.can_sync P t (xcp, frs) (shr s') L", "by simp"], ["proof (state)\nthis:\n  exec_mthr.can_sync P t (xcp, frs) (shr s') L\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "with cst'"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n  exec_mthr.can_sync P t (xcp, frs) (shr s') L", "have \"execd_mthr.can_sync P t (xcp, frs) (shr s') L\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s', frs) \\<surd>\n  exec_mthr.can_sync P t (xcp, frs) (shr s') L\n\ngoal (1 subgoal):\n 1. execd_mthr.can_sync P t (xcp, frs) (shr s') L", "by(auto dest: can_lock_d_eq_can_lock[OF wf])"], ["proof (state)\nthis:\n  execd_mthr.can_sync P t (xcp, frs) (shr s') L\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "with s redd tst"], ["proof (chain)\npicking this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  execd_mthr.can_sync P t (xcp, frs) (shr s') L", "have \"\\<exists>L' \\<subseteq> L. execd_mthr.can_sync P t x (shr s) L'\""], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  execd_mthr.can_sync P t (xcp, frs) (shr s') L\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t x (shr s) L'", "unfolding x"], ["proof (prove)\nusing this:\n  s \\<in> correct_jvm_state \\<Phi>\n  P \\<turnstile> s -t'\\<triangleright>ta'\\<rightarrow>\\<^bsub>jvmd\\<^esub> s'\n  thr s t = \\<lfloor>((xcp, frs), no_wait_locks)\\<rfloor>\n  execd_mthr.can_sync P t (xcp, frs) (shr s') L\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t (xcp, frs) (shr s) L'", "by(rule can_lock_devreserp)"], ["proof (state)\nthis:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t x (shr s) L'\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t x (shr s) L'", "obtain L' where \"execd_mthr.can_sync P t x (shr s) L'\" \n        and L': \"L'\\<subseteq> L\""], ["proof (prove)\nusing this:\n  \\<exists>L'\\<subseteq>L. execd_mthr.can_sync P t x (shr s) L'\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        \\<lbrakk>execd_mthr.can_sync P t x (shr s) L';\n         L' \\<subseteq> L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execd_mthr.can_sync P t x (shr s) L'\n  L' \\<subseteq> L\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "with cst"], ["proof (chain)\npicking this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  execd_mthr.can_sync P t x (shr s) L'\n  L' \\<subseteq> L", "have \"exec_mthr.can_sync P t x (shr s) L'\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<turnstile> t:(xcp, shr s, frs) \\<surd>\n  execd_mthr.can_sync P t x (shr s) L'\n  L' \\<subseteq> L\n\ngoal (1 subgoal):\n 1. exec_mthr.can_sync P t x (shr s) L'", "by(auto dest: can_lock_d_eq_can_lock[OF wf])"], ["proof (state)\nthis:\n  exec_mthr.can_sync P t x (shr s) L'\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "with L'"], ["proof (chain)\npicking this:\n  L' \\<subseteq> L\n  exec_mthr.can_sync P t x (shr s) L'", "have \"\\<exists>L' \\<subseteq> L. exec_mthr.can_sync P t x (shr s) L'\""], ["proof (prove)\nusing this:\n  L' \\<subseteq> L\n  exec_mthr.can_sync P t x (shr s) L'\n\ngoal (1 subgoal):\n 1. \\<exists>L'\\<subseteq>L. exec_mthr.can_sync P t x (shr s) L'", "by(blast)"], ["proof (state)\nthis:\n  \\<exists>L'\\<subseteq>L. exec_mthr.can_sync P t x (shr s) L'\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "}"], ["proof (state)\nthis:\n  exec_mthr.can_sync P t x (shr s') ?L17 \\<Longrightarrow>\n  \\<exists>L'\\<subseteq>?L17. exec_mthr.can_sync P t x (shr s) L'\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "note this ml"], ["proof (state)\nthis:\n  exec_mthr.can_sync P t x (shr s') ?L17 \\<Longrightarrow>\n  \\<exists>L'\\<subseteq>?L17. exec_mthr.can_sync P t x (shr s) L'\n  exec_mthr.must_sync P t x (shr s) \\<Longrightarrow>\n  exec_mthr.must_sync P t x (shr s')\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s23 \\<in> correct_jvm_state \\<Phi>;\n   P \\<turnstile> ?s23 -?t'23\\<triangleright>?ta'23\\<rightarrow>\\<^bsub>jvm\\<^esub> ?s'23;\n   thr ?s23 ?t23 = \\<lfloor>(?x23, no_wait_locks)\\<rfloor>;\n   exec_mthr.can_sync P ?t23 ?x23 (shr ?s'23) ?L20\\<rbrakk>\n  \\<Longrightarrow> \\<exists>L'\\<subseteq>?L20.\n                       exec_mthr.can_sync P ?t23 ?x23 (shr ?s23) L'\n  \\<lbrakk>?s23 \\<in> correct_jvm_state \\<Phi>;\n   P \\<turnstile> ?s23 -?t'23\\<triangleright>?ta'23\\<rightarrow>\\<^bsub>jvm\\<^esub> ?s'23;\n   thr ?s23 ?t23 = \\<lfloor>(?x23, no_wait_locks)\\<rfloor>;\n   exec_mthr.must_sync P ?t23 ?x23 (shr ?s23)\\<rbrakk>\n  \\<Longrightarrow> exec_mthr.must_sync P ?t23 ?x23 (shr ?s'23)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?s23 \\<in> correct_jvm_state \\<Phi>;\n   P \\<turnstile> ?s23 -?t'23\\<triangleright>?ta'23\\<rightarrow>\\<^bsub>jvm\\<^esub> ?s'23;\n   thr ?s23 ?t23 = \\<lfloor>(?x23, no_wait_locks)\\<rfloor>;\n   exec_mthr.can_sync P ?t23 ?x23 (shr ?s'23) ?L20\\<rbrakk>\n  \\<Longrightarrow> \\<exists>L'\\<subseteq>?L20.\n                       exec_mthr.can_sync P ?t23 ?x23 (shr ?s23) L'\n  \\<lbrakk>?s23 \\<in> correct_jvm_state \\<Phi>;\n   P \\<turnstile> ?s23 -?t'23\\<triangleright>?ta'23\\<rightarrow>\\<^bsub>jvm\\<^esub> ?s'23;\n   thr ?s23 ?t23 = \\<lfloor>(?x23, no_wait_locks)\\<rfloor>;\n   exec_mthr.must_sync P ?t23 ?x23 (shr ?s23)\\<rbrakk>\n  \\<Longrightarrow> exec_mthr.must_sync P ?t23 ?x23 (shr ?s'23)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "have \"invariant3p (mexecT P) (correct_jvm_state \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant3p (mexecT P) (correct_jvm_state \\<Phi>)", "by(rule invariant3p_correct_jvm_state_mexecT[OF wf])"], ["proof (state)\nthis:\n  invariant3p (mexecT P) (correct_jvm_state \\<Phi>)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?s23 \\<in> correct_jvm_state \\<Phi>;\n   P \\<turnstile> ?s23 -?t'23\\<triangleright>?ta'23\\<rightarrow>\\<^bsub>jvm\\<^esub> ?s'23;\n   thr ?s23 ?t23 = \\<lfloor>(?x23, no_wait_locks)\\<rfloor>;\n   exec_mthr.can_sync P ?t23 ?x23 (shr ?s'23) ?L20\\<rbrakk>\n  \\<Longrightarrow> \\<exists>L'\\<subseteq>?L20.\n                       exec_mthr.can_sync P ?t23 ?x23 (shr ?s23) L'\n  \\<lbrakk>?s23 \\<in> correct_jvm_state \\<Phi>;\n   P \\<turnstile> ?s23 -?t'23\\<triangleright>?ta'23\\<rightarrow>\\<^bsub>jvm\\<^esub> ?s'23;\n   thr ?s23 ?t23 = \\<lfloor>(?x23, no_wait_locks)\\<rfloor>;\n   exec_mthr.must_sync P ?t23 ?x23 (shr ?s23)\\<rbrakk>\n  \\<Longrightarrow> exec_mthr.must_sync P ?t23 ?x23 (shr ?s'23)\n  invariant3p (mexecT P) (correct_jvm_state \\<Phi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s23 \\<in> correct_jvm_state \\<Phi>;\n   P \\<turnstile> ?s23 -?t'23\\<triangleright>?ta'23\\<rightarrow>\\<^bsub>jvm\\<^esub> ?s'23;\n   thr ?s23 ?t23 = \\<lfloor>(?x23, no_wait_locks)\\<rfloor>;\n   exec_mthr.can_sync P ?t23 ?x23 (shr ?s'23) ?L20\\<rbrakk>\n  \\<Longrightarrow> \\<exists>L'\\<subseteq>?L20.\n                       exec_mthr.can_sync P ?t23 ?x23 (shr ?s23) L'\n  \\<lbrakk>?s23 \\<in> correct_jvm_state \\<Phi>;\n   P \\<turnstile> ?s23 -?t'23\\<triangleright>?ta'23\\<rightarrow>\\<^bsub>jvm\\<^esub> ?s'23;\n   thr ?s23 ?t23 = \\<lfloor>(?x23, no_wait_locks)\\<rfloor>;\n   exec_mthr.must_sync P ?t23 ?x23 (shr ?s23)\\<rbrakk>\n  \\<Longrightarrow> exec_mthr.must_sync P ?t23 ?x23 (shr ?s'23)\n  invariant3p (mexecT P) (correct_jvm_state \\<Phi>)\n\ngoal (1 subgoal):\n 1. preserve_deadlocked JVM_final (mexec P) convert_RA\n     (correct_jvm_state \\<Phi>)", "by(unfold_locales)"], ["proof (state)\nthis:\n  preserve_deadlocked JVM_final (mexec P) convert_RA\n   (correct_jvm_state \\<Phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}