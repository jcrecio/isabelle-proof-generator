{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWLTS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma redT_upd_\\<epsilon>_redT_upd:\n  \"redT_upd s t \\<epsilon> x' m' (redT_upd_\\<epsilon> s t x' m')\"", "lemma (in multithreaded_base) \\<tau>rtrancl3p_redT_thread_not_disappear:\n  assumes \"\\<tau>trsys.\\<tau>rtrancl3p redT \\<tau>move s ttas s'\" \"thr s t \\<noteq> None\"\n  shows \"thr s' t \\<noteq> None\"", "lemma m\\<tau>move_False: \"\\<tau>multithreaded.m\\<tau>move (\\<lambda>s ta s'. False) = (\\<lambda>s ta s'. False)\"", "lemma m\\<tau>move_silentD: \"m\\<tau>move s (t, ta) s' \\<Longrightarrow> ta = (K$ [], [], [], [], [], [])\"", "lemma m\\<tau>move_heap: \n  assumes redT: \"redT s (t, ta) s'\"\n  and m\\<tau>move: \"m\\<tau>move s (t, ta) s'\"\n  shows \"shr s' = shr s\"", "lemma \\<tau>mredT_thread_preserved:\n  \"\\<tau>mredT s s' \\<Longrightarrow> thr s t = None \\<longleftrightarrow> thr s' t = None\"", "lemma \\<tau>mRedT_thread_preserved:\n  \"\\<tau>mredT^** s s' \\<Longrightarrow> thr s t = None \\<longleftrightarrow> thr s' t = None\"", "lemma \\<tau>mtRedT_thread_preserved:\n  \"\\<tau>mredT^++ s s' \\<Longrightarrow> thr s t = None \\<longleftrightarrow> thr s' t = None\"", "lemma \\<tau>mredT_add_thread_inv:\n  assumes \\<tau>red: \"\\<tau>mredT s s'\" and tst: \"thr s t = None\"\n  shows \"\\<tau>mredT (locks s, ((thr s)(t \\<mapsto> xln), shr s), wset s, interrupts s) (locks s', ((thr s')(t \\<mapsto> xln), shr s'), wset s', interrupts s')\"", "lemma \\<tau>mRedT_add_thread_inv:\n  \"\\<lbrakk> \\<tau>mredT^** s s'; thr s t = None \\<rbrakk>\n  \\<Longrightarrow> \\<tau>mredT^** (locks s, ((thr s)(t \\<mapsto> xln), shr s), wset s, interrupts s) (locks s', ((thr s')(t \\<mapsto> xln), shr s'), wset s', interrupts s')\"", "lemma \\<tau>mtRed_add_thread_inv:\n  \"\\<lbrakk> \\<tau>mredT^++ s s'; thr s t = None \\<rbrakk>\n  \\<Longrightarrow> \\<tau>mredT^++ (locks s, ((thr s)(t \\<mapsto> xln), shr s), wset s, interrupts s) (locks s', ((thr s')(t \\<mapsto> xln), shr s'), wset s', interrupts s')\"", "lemma silent_move_into_RedT_\\<tau>_inv:\n  assumes move: \"silent_move t (x, shr s) (x', m')\"\n  and state: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"wset s t = None\"\n  shows \"\\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\"", "lemma silent_moves_into_RedT_\\<tau>_inv:\n  assumes major: \"silent_moves t (x, shr s) (x', m')\"\n  and state: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"wset s t = None\"\n  shows \"\\<tau>mredT^** s (redT_upd_\\<epsilon> s t x' m')\"", "lemma red_rtrancl_\\<tau>_heapD_inv:\n  \"\\<lbrakk> silent_moves t s s'; wfs t s \\<rbrakk> \\<Longrightarrow> snd s' = snd s\"", "lemma red_trancl_\\<tau>_heapD_inv:\n  \"\\<lbrakk> silent_movet t s s'; wfs t s \\<rbrakk> \\<Longrightarrow> snd s' = snd s\"", "lemma red_trancl_\\<tau>_into_RedT_\\<tau>_inv:\n  assumes major: \"silent_movet t (x, shr s) (x', m')\"\n  and state: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"wset s t = None\"\n  shows \"\\<tau>mredT^++ s (redT_upd_\\<epsilon> s t x' m')\"", "lemma \\<tau>diverge_into_\\<tau>mredT:\n  assumes \"\\<tau>diverge t (x, shr s)\"\n  and \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"wset s t = None\"\n  shows \"mthr.\\<tau>diverge s\"", "lemma \\<tau>diverge_\\<tau>mredTD:\n  assumes div: \"mthr.\\<tau>diverge s\"\n  and fin: \"finite (dom (thr s))\"\n  shows \"\\<exists>t x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> wset s t = None \\<and> \\<tau>diverge t (x, shr s)\"", "lemma \\<tau>mredT_preserves_final_thread:\n  \"\\<lbrakk> \\<tau>mredT s s'; final_thread s t \\<rbrakk> \\<Longrightarrow> final_thread s' t\"", "lemma \\<tau>mRedT_preserves_final_thread:\n  \"\\<lbrakk> \\<tau>mredT^** s s'; final_thread s t \\<rbrakk> \\<Longrightarrow> final_thread s' t\"", "lemma silent_moves2_silentD:\n  assumes \"rtrancl3p mthr.silent_move2 s ttas s'\"\n  and \"(t, ta) \\<in> set ttas\"\n  shows \"ta = \\<epsilon>\"", "lemma inf_step_silentD:\n  assumes step: \"trsys.inf_step mthr.silent_move2 s ttas\"\n  and lset: \"(t, ta) \\<in> lset ttas\"\n  shows \"ta = \\<epsilon>\"", "lemma m\\<mu>t_thr_dom_eq: \"m\\<mu>t m ts ts' \\<Longrightarrow> dom ts = dom ts'\"", "lemma m\\<mu>_finite_thrD:\n  assumes \"m\\<mu>t m ts ts'\"\n  shows \"finite (dom ts)\" \"finite (dom ts')\"", "lemma wf_m\\<mu>t: \"wfP (m\\<mu>t m)\"", "lemma wf_m\\<mu>: \"wfP m\\<mu>\""], "translations": [["", "lemma redT_upd_\\<epsilon>_redT_upd:\n  \"redT_upd s t \\<epsilon> x' m' (redT_upd_\\<epsilon> s t x' m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_upd s t \\<lbrace>\\<rbrace> x' m' (redT_upd_\\<epsilon> s t x' m')", "by(auto simp add: redT_updLns_def redT_updWs_def)"], ["", "context multithreaded begin"], ["", "sublocale trsys \"r t\" for t"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale mthr: trsys redT"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "subsection \\<open>The multithreaded semantics with internal actions\\<close>"], ["", "type_synonym\n  ('l,'t,'x,'m,'w,'o) \\<tau>moves =\n    \"'x \\<times> 'm \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'x \\<times> 'm \\<Rightarrow> bool\""], ["", "text \\<open>pretty printing for \\<open>\\<tau>moves\\<close>\\<close>"], ["", "print_translation \\<open>\n  let\n    fun tr' [(Const (@{type_syntax \"prod\"}, _) $ x1 $ m1),\n             (Const (@{type_syntax \"fun\"}, _) $\n               (Const (@{type_syntax \"prod\"}, _) $ \n                 (Const (@{type_syntax \"finfun\"}, _) $ l $ \n                   (Const (@{type_syntax \"list\"}, _) $ Const (@{type_syntax \"lock_action\"}, _))) $\n                 (Const (@{type_syntax \"prod\"},_) $ \n                   (Const (@{type_syntax \"list\"}, _) $ (Const (@{type_syntax \"new_thread_action\"}, _) $ t1 $ x2 $ m2)) $\n                   (Const (@{type_syntax \"prod\"}, _) $ \n                     (Const (@{type_syntax \"list\"}, _) $ (Const (@{type_syntax \"conditional_action\"}, _) $ t2)) $\n                     (Const (@{type_syntax \"prod\"}, _) $ \n                       (Const (@{type_syntax \"list\"}, _) $ (Const (@{type_syntax \"wait_set_action\"}, _) $ t3 $ w)) $\n                       (Const (@{type_syntax prod}, _) $ \n                         (Const (@{type_syntax list}, _) $ (Const (@{type_syntax \"interrupt_action\"}, _) $ t4)) $\n                         (Const (@{type_syntax \"list\"}, _) $ o1)))))) $\n               (Const (@{type_syntax \"fun\"}, _) $ \n                 (Const (@{type_syntax \"prod\"}, _) $ x3 $ m3) $\n                 (Const (@{type_syntax \"bool\"}, _))))] =\n      if x1 = x2 andalso x1 = x3 andalso m1 = m2 andalso m1 = m3 andalso t1 = t2 andalso t2 = t3 andalso t3 = t4\n      then Syntax.const (@{type_syntax \"\\<tau>moves\"}) $ l $ t1 $ x1 $ m1 $ w $ o1\n      else raise Match;\n  in [(@{type_syntax \"fun\"}, K tr')]\n  end\n\\<close>"], ["", "typ \"('l,'t,'x,'m,'w,'o) \\<tau>moves\""], ["", "locale \\<tau>multithreaded = multithreaded_base +\n  constrains final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  fixes \\<tau>move :: \"('l,'t,'x,'m,'w,'o) \\<tau>moves\""], ["", "sublocale \\<tau>multithreaded < \\<tau>trsys \"r t\" \\<tau>move for t"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context \\<tau>multithreaded begin"], ["", "inductive m\\<tau>move :: \"(('l,'t,'x,'m,'w) state, 't \\<times> ('l,'t,'x,'m,'w,'o) thread_action) trsys\"\nwhere\n  \"\\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; thr s' t = \\<lfloor>(x', ln')\\<rfloor>; \\<tau>move (x, shr s) ta (x', shr s') \\<rbrakk>\n  \\<Longrightarrow> m\\<tau>move s (t, ta) s'\""], ["", "end"], ["", "sublocale \\<tau>multithreaded < mthr: \\<tau>trsys redT m\\<tau>move"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context \\<tau>multithreaded begin"], ["", "abbreviation \\<tau>mredT :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> ('l,'t,'x,'m,'w) state \\<Rightarrow> bool\"\nwhere \"\\<tau>mredT == mthr.silent_move\""], ["", "end"], ["", "lemma (in multithreaded_base) \\<tau>rtrancl3p_redT_thread_not_disappear:\n  assumes \"\\<tau>trsys.\\<tau>rtrancl3p redT \\<tau>move s ttas s'\" \"thr s t \\<noteq> None\"\n  shows \"thr s' t \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr s' t \\<noteq> None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. thr s' t \\<noteq> None", "interpret T: \\<tau>trsys redT \\<tau>move"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. thr s' t \\<noteq> None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thr s' t \\<noteq> None", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. thr s' t = None \\<Longrightarrow> False", "assume \"thr s' t = None\""], ["proof (state)\nthis:\n  thr s' t = None\n\ngoal (1 subgoal):\n 1. thr s' t = None \\<Longrightarrow> False", "with \\<open>\\<tau>trsys.\\<tau>rtrancl3p redT \\<tau>move s ttas s'\\<close>"], ["proof (chain)\npicking this:\n  T.\\<tau>rtrancl3p s ttas s'\n  thr s' t = None", "have \"thr s t = None\""], ["proof (prove)\nusing this:\n  T.\\<tau>rtrancl3p s ttas s'\n  thr s' t = None\n\ngoal (1 subgoal):\n 1. thr s t = None", "by(induct rule: T.\\<tau>rtrancl3p.induct)(auto simp add: split_paired_all dest: redT_thread_not_disappear)"], ["proof (state)\nthis:\n  thr s t = None\n\ngoal (1 subgoal):\n 1. thr s' t = None \\<Longrightarrow> False", "with \\<open>thr s t \\<noteq> None\\<close>"], ["proof (chain)\npicking this:\n  thr s t \\<noteq> None\n  thr s t = None", "show False"], ["proof (prove)\nusing this:\n  thr s t \\<noteq> None\n  thr s t = None\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thr s' t \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma m\\<tau>move_False: \"\\<tau>multithreaded.m\\<tau>move (\\<lambda>s ta s'. False) = (\\<lambda>s ta s'. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded.m\\<tau>move (\\<lambda>s ta s'. False) =\n    (\\<lambda>s ta s'. False)", "by(auto intro!: ext elim: \\<tau>multithreaded.m\\<tau>move.cases)"], ["", "declare split_paired_Ex [simp del]"], ["", "locale \\<tau>multithreaded_wf =\n  \\<tau>multithreaded _ _ _ \\<tau>move +\n  multithreaded final r convert_RA\n  for \\<tau>move :: \"('l,'t,'x,'m,'w,'o) \\<tau>moves\" +\n  assumes \\<tau>move_heap: \"\\<lbrakk> t \\<turnstile> (x, m) -ta\\<rightarrow> (x', m'); \\<tau>move (x, m) ta (x', m') \\<rbrakk> \\<Longrightarrow> m = m'\"\n  assumes silent_tl: \"\\<tau>move s ta s' \\<Longrightarrow> ta = \\<epsilon>\"\nbegin"], ["", "lemma m\\<tau>move_silentD: \"m\\<tau>move s (t, ta) s' \\<Longrightarrow> ta = (K$ [], [], [], [], [], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m\\<tau>move s (t, ta) s' \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "by(auto elim!: m\\<tau>move.cases dest: silent_tl)"], ["", "lemma m\\<tau>move_heap: \n  assumes redT: \"redT s (t, ta) s'\"\n  and m\\<tau>move: \"m\\<tau>move s (t, ta) s'\"\n  shows \"shr s' = shr s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shr s' = shr s", "using m\\<tau>move redT"], ["proof (prove)\nusing this:\n  m\\<tau>move s (t, ta) s'\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. shr s' = shr s", "by cases(auto dest: \\<tau>move_heap elim!: redT.cases)"], ["", "lemma \\<tau>mredT_thread_preserved:\n  \"\\<tau>mredT s s' \\<Longrightarrow> thr s t = None \\<longleftrightarrow> thr s' t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>mredT s s' \\<Longrightarrow> (thr s t = None) = (thr s' t = None)", "by(auto simp add: mthr.silent_move_iff elim!: redT.cases dest!: m\\<tau>move_silentD split: if_split_asm)"], ["", "lemma \\<tau>mRedT_thread_preserved:\n  \"\\<tau>mredT^** s s' \\<Longrightarrow> thr s t = None \\<longleftrightarrow> thr s' t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mthr.silent_moves s s' \\<Longrightarrow>\n    (thr s t = None) = (thr s' t = None)", "by(induct rule: rtranclp.induct)(auto dest: \\<tau>mredT_thread_preserved[where t=t])"], ["", "lemma \\<tau>mtRedT_thread_preserved:\n  \"\\<tau>mredT^++ s s' \\<Longrightarrow> thr s t = None \\<longleftrightarrow> thr s' t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mthr.silent_movet s s' \\<Longrightarrow>\n    (thr s t = None) = (thr s' t = None)", "by(induct rule: tranclp.induct)(auto dest: \\<tau>mredT_thread_preserved[where t=t])"], ["", "lemma \\<tau>mredT_add_thread_inv:\n  assumes \\<tau>red: \"\\<tau>mredT s s'\" and tst: \"thr s t = None\"\n  shows \"\\<tau>mredT (locks s, ((thr s)(t \\<mapsto> xln), shr s), wset s, interrupts s) (locks s', ((thr s')(t \\<mapsto> xln), shr s'), wset s', interrupts s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "obtain ls ts m ws \"is\" where s: \"s = (ls, (ts, m), ws, is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls ts m ws is.\n        s = (ls, (ts, m), ws, is) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s) fastforce"], ["proof (state)\nthis:\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "obtain ls' ts' m' ws' is' where s': \"s' = (ls', (ts', m'), ws', is')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls' ts' m' ws' is'.\n        s' = (ls', (ts', m'), ws', is') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s') fastforce"], ["proof (state)\nthis:\n  s' = (ls', (ts', m'), ws', is')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "from \\<tau>red s s'"], ["proof (chain)\npicking this:\n  \\<tau>mredT s s'\n  s = (ls, (ts, m), ws, is)\n  s' = (ls', (ts', m'), ws', is')", "obtain t' where red: \"(ls, (ts, m), ws, is) -t'\\<triangleright>\\<epsilon>\\<rightarrow> (ls', (ts', m'), ws', is')\"\n    and \\<tau>: \"m\\<tau>move (ls, (ts, m), ws, is) (t', \\<epsilon>) (ls', (ts', m'), ws', is')\""], ["proof (prove)\nusing this:\n  \\<tau>mredT s s'\n  s = (ls, (ts, m), ws, is)\n  s' = (ls', (ts', m'), ws', is')\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>\\<langle>ls, (ts,\n                               m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts',\n   m'), ws', is'\\<rangle>;\n         m\\<tau>move (ls, (ts, m), ws, is) (t', \\<lbrace>\\<rbrace>)\n          (ls', (ts', m'), ws', is')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: mthr.silent_move_iff dest: m\\<tau>move_silentD)"], ["proof (state)\nthis:\n  \\<langle>ls, (ts,\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts',\n                          m'), ws', is'\\<rangle>\n  m\\<tau>move (ls, (ts, m), ws, is) (t', \\<lbrace>\\<rbrace>)\n   (ls', (ts', m'), ws', is')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "from red"], ["proof (chain)\npicking this:\n  \\<langle>ls, (ts,\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts',\n                          m'), ws', is'\\<rangle>", "have \"(ls, (ts(t \\<mapsto> xln), m), ws, is) -t'\\<triangleright>\\<epsilon>\\<rightarrow> (ls', (ts'(t \\<mapsto> xln), m'), ws', is')\""], ["proof (prove)\nusing this:\n  \\<langle>ls, (ts,\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts',\n                          m'), ws', is'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>ls, (ts(t \\<mapsto> xln),\n                  m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                            (t \\<mapsto> xln), m'), ws', is'\\<rangle>", "proof(cases rule: redT_elims)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m'a ws'a.\n       \\<lbrakk>t' \\<turnstile> \\<langle>x, shr\n       (ls, (ts, m), ws,\n        is)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'a\\<rangle>;\n        thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, m), ws, is)) t'\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, m), ws, is))\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>;\n        cond_action_oks (ls, (ts, m), ws, is) t'\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, m), ws, is)) t'\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, m), ws, is))\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset (ls, (ts, m), ws, is))\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', m'), ws', is') =\n        (redT_updLs (locks (ls, (ts, m), ws, is)) t'\n          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, m), ws, is))\n           \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\n          (t' \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, m), ws, is)) t' no_wait_locks\n            \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'a),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, m), ws, is))\n          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<langle>ls, (ts(t \\<mapsto> xln),\n m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n           (t \\<mapsto> xln), m'), ws', is'\\<rangle>\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<lbrace>\\<rbrace> = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, m), ws, is) t');\n        may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln; 0 < ln $ n;\n        (ls', (ts', m'), ws', is') =\n        (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n         (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, m), ws, is)),\n         wset (ls, (ts, m), ws, is),\n         interrupts (ls, (ts, m), ws, is))\\<rbrakk>\n       \\<Longrightarrow> \\<langle>ls, (ts(t \\<mapsto> xln),\n m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n           (t \\<mapsto> xln), m'), ws', is'\\<rangle>", "case (normal x x' m')"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x, shr (ls, (ts, m), ws,\n                                   is)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  lock_ok_las (locks (ls, (ts, m), ws, is)) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks (thr (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\n  cond_action_oks (ls, (ts, m), ws, is) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub>\n  wset_actions_ok (wset (ls, (ts, m), ws, is)) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\n  interrupt_actions_ok (interrupts (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>\n  redT_updWs t' (wset (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> ws'_\n  (ls', (ts', m'__), ws', is') =\n  (redT_updLs (locks (ls, (ts, m), ws, is)) t'\n    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr (ls, (ts, m), ws, is))\n     \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\n    (t' \\<mapsto>\n    (x',\n     redT_updLns (locks (ls, (ts, m), ws, is)) t' no_wait_locks\n      \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>)),\n    m'),\n   ws'_,\n   redT_updIs (interrupts (ls, (ts, m), ws, is))\n    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'a ws'a.\n       \\<lbrakk>t' \\<turnstile> \\<langle>x, shr\n       (ls, (ts, m), ws,\n        is)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'a\\<rangle>;\n        thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks (ls, (ts, m), ws, is)) t'\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr (ls, (ts, m), ws, is))\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>;\n        cond_action_oks (ls, (ts, m), ws, is) t'\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset (ls, (ts, m), ws, is)) t'\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts (ls, (ts, m), ws, is))\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset (ls, (ts, m), ws, is))\n         \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> ws'a;\n        (ls', (ts', m'__), ws', is') =\n        (redT_updLs (locks (ls, (ts, m), ws, is)) t'\n          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr (ls, (ts, m), ws, is))\n           \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\n          (t' \\<mapsto>\n          (x',\n           redT_updLns (locks (ls, (ts, m), ws, is)) t' no_wait_locks\n            \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'a),\n         ws'a,\n         redT_updIs (interrupts (ls, (ts, m), ws, is))\n          \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<langle>ls, (ts(t \\<mapsto> xln),\n m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n           (t \\<mapsto> xln), m'__), ws', is'\\<rangle>\n 2. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<lbrace>\\<rbrace> = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, m), ws, is) t');\n        may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln; 0 < ln $ n;\n        (ls', (ts', m'__), ws', is') =\n        (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n         (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, m), ws, is)),\n         wset (ls, (ts, m), ws, is),\n         interrupts (ls, (ts, m), ws, is))\\<rbrakk>\n       \\<Longrightarrow> \\<langle>ls, (ts(t \\<mapsto> xln),\n m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n           (t \\<mapsto> xln), m'__), ws', is'\\<rangle>", "with tst s"], ["proof (chain)\npicking this:\n  thr s t = None\n  s = (ls, (ts, m), ws, is)\n  t' \\<turnstile> \\<langle>x, shr (ls, (ts, m), ws,\n                                   is)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  lock_ok_las (locks (ls, (ts, m), ws, is)) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks (thr (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\n  cond_action_oks (ls, (ts, m), ws, is) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub>\n  wset_actions_ok (wset (ls, (ts, m), ws, is)) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\n  interrupt_actions_ok (interrupts (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>\n  redT_updWs t' (wset (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> ws'_\n  (ls', (ts', m'__), ws', is') =\n  (redT_updLs (locks (ls, (ts, m), ws, is)) t'\n    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr (ls, (ts, m), ws, is))\n     \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\n    (t' \\<mapsto>\n    (x',\n     redT_updLns (locks (ls, (ts, m), ws, is)) t' no_wait_locks\n      \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>)),\n    m'),\n   ws'_,\n   redT_updIs (interrupts (ls, (ts, m), ws, is))\n    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>)", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s t = None\n  s = (ls, (ts, m), ws, is)\n  t' \\<turnstile> \\<langle>x, shr (ls, (ts, m), ws,\n                                   is)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  lock_ok_las (locks (ls, (ts, m), ws, is)) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>\n  thread_oks (thr (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\n  cond_action_oks (ls, (ts, m), ws, is) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>c\\<^esub>\n  wset_actions_ok (wset (ls, (ts, m), ws, is)) t'\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub>\n  interrupt_actions_ok (interrupts (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>\n  redT_updWs t' (wset (ls, (ts, m), ws, is))\n   \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>w\\<^esub> ws'_\n  (ls', (ts', m'__), ws', is') =\n  (redT_updLs (locks (ls, (ts, m), ws, is)) t'\n    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>,\n   (redT_updTs (thr (ls, (ts, m), ws, is))\n     \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>t\\<^esub>\n    (t' \\<mapsto>\n    (x',\n     redT_updLns (locks (ls, (ts, m), ws, is)) t' no_wait_locks\n      \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>l\\<^esub>)),\n    m'),\n   ws'_,\n   redT_updIs (interrupts (ls, (ts, m), ws, is))\n    \\<lbrace>\\<lbrace>\\<rbrace>\\<rbrace>\\<^bsub>i\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<langle>ls, (ts(t \\<mapsto> xln),\n                  m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                            (t \\<mapsto> xln), m'__), ws', is'\\<rangle>", "by-(rule redT_normal, auto simp add: fun_upd_twist elim!: rtrancl3p_cases)"], ["proof (state)\nthis:\n  \\<langle>ls, (ts(t \\<mapsto> xln),\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                          (t \\<mapsto> xln), m'__), ws', is'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<lbrace>\\<rbrace> = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, m), ws, is) t');\n        may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln; 0 < ln $ n;\n        (ls', (ts', m'__), ws', is') =\n        (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n         (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, m), ws, is)),\n         wset (ls, (ts, m), ws, is),\n         interrupts (ls, (ts, m), ws, is))\\<rbrakk>\n       \\<Longrightarrow> \\<langle>ls, (ts(t \\<mapsto> xln),\n m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n           (t \\<mapsto> xln), m'__), ws', is'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<lbrace>\\<rbrace> = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, m), ws, is) t');\n        may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln; 0 < ln $ n;\n        (ls', (ts', m'), ws', is') =\n        (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n         (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, m), ws, is)),\n         wset (ls, (ts, m), ws, is),\n         interrupts (ls, (ts, m), ws, is))\\<rbrakk>\n       \\<Longrightarrow> \\<langle>ls, (ts(t \\<mapsto> xln),\n m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n           (t \\<mapsto> xln), m'), ws', is'\\<rangle>", "case (acquire x ln n)"], ["proof (state)\nthis:\n  thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>\n  \\<lbrace>\\<rbrace> = (K$ [], [], [], [], [], convert_RA ln)\n  \\<not> waiting (wset (ls, (ts, m), ws, is) t')\n  may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln\n  0 < ln $ n\n  (ls', (ts', m'), ws', is') =\n  (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n   (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n    shr (ls, (ts, m), ws, is)),\n   wset (ls, (ts, m), ws, is), interrupts (ls, (ts, m), ws, is))\n\ngoal (1 subgoal):\n 1. \\<And>x ln n.\n       \\<lbrakk>thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>;\n        \\<lbrace>\\<rbrace> = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset (ls, (ts, m), ws, is) t');\n        may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln; 0 < ln $ n;\n        (ls', (ts', m'), ws', is') =\n        (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n         (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n          shr (ls, (ts, m), ws, is)),\n         wset (ls, (ts, m), ws, is),\n         interrupts (ls, (ts, m), ws, is))\\<rbrakk>\n       \\<Longrightarrow> \\<langle>ls, (ts(t \\<mapsto> xln),\n m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n           (t \\<mapsto> xln), m'), ws', is'\\<rangle>", "with tst s"], ["proof (chain)\npicking this:\n  thr s t = None\n  s = (ls, (ts, m), ws, is)\n  thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>\n  \\<lbrace>\\<rbrace> = (K$ [], [], [], [], [], convert_RA ln)\n  \\<not> waiting (wset (ls, (ts, m), ws, is) t')\n  may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln\n  0 < ln $ n\n  (ls', (ts', m'), ws', is') =\n  (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n   (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n    shr (ls, (ts, m), ws, is)),\n   wset (ls, (ts, m), ws, is), interrupts (ls, (ts, m), ws, is))", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s t = None\n  s = (ls, (ts, m), ws, is)\n  thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>\n  \\<lbrace>\\<rbrace> = (K$ [], [], [], [], [], convert_RA ln)\n  \\<not> waiting (wset (ls, (ts, m), ws, is) t')\n  may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln\n  0 < ln $ n\n  (ls', (ts', m'), ws', is') =\n  (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n   (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n    shr (ls, (ts, m), ws, is)),\n   wset (ls, (ts, m), ws, is), interrupts (ls, (ts, m), ws, is))\n\ngoal (1 subgoal):\n 1. \\<langle>ls, (ts(t \\<mapsto> xln),\n                  m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                            (t \\<mapsto> xln), m'), ws', is'\\<rangle>", "unfolding \\<open>\\<epsilon> = (K$ [], [], [], [], [], convert_RA ln)\\<close>"], ["proof (prove)\nusing this:\n  thr s t = None\n  s = (ls, (ts, m), ws, is)\n  thr (ls, (ts, m), ws, is) t' = \\<lfloor>(x, ln)\\<rfloor>\n  (K$ [], [], [], [], [], convert_RA ln) =\n  (K$ [], [], [], [], [], convert_RA ln)\n  \\<not> waiting (wset (ls, (ts, m), ws, is) t')\n  may_acquire_all (locks (ls, (ts, m), ws, is)) t' ln\n  0 < ln $ n\n  (ls', (ts', m'), ws', is') =\n  (acquire_all (locks (ls, (ts, m), ws, is)) t' ln,\n   (thr (ls, (ts, m), ws, is)(t' \\<mapsto> (x, no_wait_locks)),\n    shr (ls, (ts, m), ws, is)),\n   wset (ls, (ts, m), ws, is), interrupts (ls, (ts, m), ws, is))\n\ngoal (1 subgoal):\n 1. \\<langle>ls, (ts(t \\<mapsto> xln),\n                  m), ws, is\\<rangle> -t'\\<triangleright>(K$ [], [], [], [],\n                    [],\n                    convert_RA\n                     ln)\\<rightarrow> \\<langle>ls', (ts'(t \\<mapsto> xln),\n               m'), ws', is'\\<rangle>", "by -(rule redT_acquire, auto intro: fun_upd_twist)"], ["proof (state)\nthis:\n  \\<langle>ls, (ts(t \\<mapsto> xln),\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                          (t \\<mapsto> xln), m'), ws', is'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>ls, (ts(t \\<mapsto> xln),\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                          (t \\<mapsto> xln), m'), ws', is'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "moreover"], ["proof (state)\nthis:\n  \\<langle>ls, (ts(t \\<mapsto> xln),\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                          (t \\<mapsto> xln), m'), ws', is'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "from red tst s"], ["proof (chain)\npicking this:\n  \\<langle>ls, (ts,\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts',\n                          m'), ws', is'\\<rangle>\n  thr s t = None\n  s = (ls, (ts, m), ws, is)", "have tt': \"t \\<noteq> t'\""], ["proof (prove)\nusing this:\n  \\<langle>ls, (ts,\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts',\n                          m'), ws', is'\\<rangle>\n  thr s t = None\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. t \\<noteq> t'", "by(cases) auto"], ["proof (state)\nthis:\n  t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "have \"(\\<lambda>t''. (ts(t \\<mapsto> xln)) t'' \\<noteq> None \\<and> (ts(t \\<mapsto> xln)) t'' \\<noteq> (ts'(t \\<mapsto> xln)) t'') =\n        (\\<lambda>t''. ts t'' \\<noteq> None \\<and> ts t'' \\<noteq> ts' t'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t''.\n        (ts(t \\<mapsto> xln)) t'' \\<noteq> None \\<and>\n        (ts(t \\<mapsto> xln)) t'' \\<noteq> (ts'(t \\<mapsto> xln)) t'') =\n    (\\<lambda>t''. ts t'' \\<noteq> None \\<and> ts t'' \\<noteq> ts' t'')", "using tst s"], ["proof (prove)\nusing this:\n  thr s t = None\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t''.\n        (ts(t \\<mapsto> xln)) t'' \\<noteq> None \\<and>\n        (ts(t \\<mapsto> xln)) t'' \\<noteq> (ts'(t \\<mapsto> xln)) t'') =\n    (\\<lambda>t''. ts t'' \\<noteq> None \\<and> ts t'' \\<noteq> ts' t'')", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>t''.\n      (ts(t \\<mapsto> xln)) t'' \\<noteq> None \\<and>\n      (ts(t \\<mapsto> xln)) t'' \\<noteq> (ts'(t \\<mapsto> xln)) t'') =\n  (\\<lambda>t''. ts t'' \\<noteq> None \\<and> ts t'' \\<noteq> ts' t'')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "with \\<tau> tst tt'"], ["proof (chain)\npicking this:\n  m\\<tau>move (ls, (ts, m), ws, is) (t', \\<lbrace>\\<rbrace>)\n   (ls', (ts', m'), ws', is')\n  thr s t = None\n  t \\<noteq> t'\n  (\\<lambda>t''.\n      (ts(t \\<mapsto> xln)) t'' \\<noteq> None \\<and>\n      (ts(t \\<mapsto> xln)) t'' \\<noteq> (ts'(t \\<mapsto> xln)) t'') =\n  (\\<lambda>t''. ts t'' \\<noteq> None \\<and> ts t'' \\<noteq> ts' t'')", "have \"m\\<tau>move (ls, (ts(t \\<mapsto> xln), m), ws, is) (t', \\<epsilon>) (ls', (ts'(t \\<mapsto> xln), m'), ws', is')\""], ["proof (prove)\nusing this:\n  m\\<tau>move (ls, (ts, m), ws, is) (t', \\<lbrace>\\<rbrace>)\n   (ls', (ts', m'), ws', is')\n  thr s t = None\n  t \\<noteq> t'\n  (\\<lambda>t''.\n      (ts(t \\<mapsto> xln)) t'' \\<noteq> None \\<and>\n      (ts(t \\<mapsto> xln)) t'' \\<noteq> (ts'(t \\<mapsto> xln)) t'') =\n  (\\<lambda>t''. ts t'' \\<noteq> None \\<and> ts t'' \\<noteq> ts' t'')\n\ngoal (1 subgoal):\n 1. m\\<tau>move (ls, (ts(t \\<mapsto> xln), m), ws, is)\n     (t', \\<lbrace>\\<rbrace>) (ls', (ts'(t \\<mapsto> xln), m'), ws', is')", "by cases(rule m\\<tau>move.intros, auto)"], ["proof (state)\nthis:\n  m\\<tau>move (ls, (ts(t \\<mapsto> xln), m), ws, is)\n   (t', \\<lbrace>\\<rbrace>) (ls', (ts'(t \\<mapsto> xln), m'), ws', is')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>ls, (ts(t \\<mapsto> xln),\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                          (t \\<mapsto> xln), m'), ws', is'\\<rangle>\n  m\\<tau>move (ls, (ts(t \\<mapsto> xln), m), ws, is)\n   (t', \\<lbrace>\\<rbrace>) (ls', (ts'(t \\<mapsto> xln), m'), ws', is')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>ls, (ts(t \\<mapsto> xln),\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                          (t \\<mapsto> xln), m'), ws', is'\\<rangle>\n  m\\<tau>move (ls, (ts(t \\<mapsto> xln), m), ws, is)\n   (t', \\<lbrace>\\<rbrace>) (ls', (ts'(t \\<mapsto> xln), m'), ws', is')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')", "unfolding s s'"], ["proof (prove)\nusing this:\n  \\<langle>ls, (ts(t \\<mapsto> xln),\n                m), ws, is\\<rangle> -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>ls', (ts'\n                          (t \\<mapsto> xln), m'), ws', is'\\<rangle>\n  m\\<tau>move (ls, (ts(t \\<mapsto> xln), m), ws, is)\n   (t', \\<lbrace>\\<rbrace>) (ls', (ts'(t \\<mapsto> xln), m'), ws', is')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT\n     (locks (ls, (ts, m), ws, is),\n      (thr (ls, (ts, m), ws, is)(t \\<mapsto> xln),\n       shr (ls, (ts, m), ws, is)),\n      wset (ls, (ts, m), ws, is), interrupts (ls, (ts, m), ws, is))\n     (locks (ls', (ts', m'), ws', is'),\n      (thr (ls', (ts', m'), ws', is')(t \\<mapsto> xln),\n       shr (ls', (ts', m'), ws', is')),\n      wset (ls', (ts', m'), ws', is'),\n      interrupts (ls', (ts', m'), ws', is'))", "by auto"], ["proof (state)\nthis:\n  \\<tau>mredT\n   (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n   (locks s', (thr s'(t \\<mapsto> xln), shr s'), wset s', interrupts s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>mRedT_add_thread_inv:\n  \"\\<lbrakk> \\<tau>mredT^** s s'; thr s t = None \\<rbrakk>\n  \\<Longrightarrow> \\<tau>mredT^** (locks s, ((thr s)(t \\<mapsto> xln), shr s), wset s, interrupts s) (locks s', ((thr s')(t \\<mapsto> xln), shr s'), wset s', interrupts s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mthr.silent_moves s s'; thr s t = None\\<rbrakk>\n    \\<Longrightarrow> mthr.silent_moves\n                       (locks s, (thr s(t \\<mapsto> xln), shr s), wset s,\n                        interrupts s)\n                       (locks s', (thr s'(t \\<mapsto> xln), shr s'),\n                        wset s', interrupts s')", "apply(induct rule: rtranclp_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. thr s t = None \\<Longrightarrow>\n    mthr.silent_moves\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n     (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n 2. \\<And>y z.\n       \\<lbrakk>mthr.silent_moves s y; \\<tau>mredT y z;\n        thr s t = None \\<Longrightarrow>\n        mthr.silent_moves\n         (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n         (locks y, (thr y(t \\<mapsto> xln), shr y), wset y, interrupts y);\n        thr s t = None\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_moves\n                          (locks s, (thr s(t \\<mapsto> xln), shr s), wset s,\n                           interrupts s)\n                          (locks z, (thr z(t \\<mapsto> xln), shr z), wset z,\n                           interrupts z)", "apply(blast dest: \\<tau>mRedT_thread_preserved[where t=t] \\<tau>mredT_add_thread_inv[where xln=xln] intro: rtranclp.rtrancl_into_rtrancl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>mtRed_add_thread_inv:\n  \"\\<lbrakk> \\<tau>mredT^++ s s'; thr s t = None \\<rbrakk>\n  \\<Longrightarrow> \\<tau>mredT^++ (locks s, ((thr s)(t \\<mapsto> xln), shr s), wset s, interrupts s) (locks s', ((thr s')(t \\<mapsto> xln), shr s'), wset s', interrupts s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mthr.silent_movet s s'; thr s t = None\\<rbrakk>\n    \\<Longrightarrow> mthr.silent_movet\n                       (locks s, (thr s(t \\<mapsto> xln), shr s), wset s,\n                        interrupts s)\n                       (locks s', (thr s'(t \\<mapsto> xln), shr s'),\n                        wset s', interrupts s')", "apply(induct rule: tranclp_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<tau>mredT s y; thr s t = None\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet\n                          (locks s, (thr s(t \\<mapsto> xln), shr s), wset s,\n                           interrupts s)\n                          (locks y, (thr y(t \\<mapsto> xln), shr y), wset y,\n                           interrupts y)\n 2. \\<And>y z.\n       \\<lbrakk>mthr.silent_movet s y; \\<tau>mredT y z;\n        thr s t = None \\<Longrightarrow>\n        mthr.silent_movet\n         (locks s, (thr s(t \\<mapsto> xln), shr s), wset s, interrupts s)\n         (locks y, (thr y(t \\<mapsto> xln), shr y), wset y, interrupts y);\n        thr s t = None\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet\n                          (locks s, (thr s(t \\<mapsto> xln), shr s), wset s,\n                           interrupts s)\n                          (locks z, (thr z(t \\<mapsto> xln), shr z), wset z,\n                           interrupts z)", "apply(blast dest: \\<tau>mtRedT_thread_preserved[where t=t] \\<tau>mredT_add_thread_inv[where xln=xln] intro: tranclp.trancl_into_trancl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma silent_move_into_RedT_\\<tau>_inv:\n  assumes move: \"silent_move t (x, shr s) (x', m')\"\n  and state: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"wset s t = None\"\n  shows \"\\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')", "from move"], ["proof (chain)\npicking this:\n  silent_move t (x, shr s) (x', m')", "obtain red: \"t \\<turnstile> (x, shr s) -\\<epsilon>\\<rightarrow> (x', m')\" and \\<tau>: \"\\<tau>move (x, shr s) \\<epsilon> (x', m')\""], ["proof (prove)\nusing this:\n  silent_move t (x, shr s) (x', m')\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>t \\<turnstile> \\<langle>x, shr\n    s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>;\n      \\<tau>move (x, shr s) \\<lbrace>\\<rbrace> (x', m')\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: silent_move_iff dest: silent_tl)"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>\n  \\<tau>move (x, shr s) \\<lbrace>\\<rbrace> (x', m')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')", "from red state"], ["proof (chain)\npicking this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None", "have \"s -t\\<triangleright>\\<epsilon>\\<rightarrow> redT_upd_\\<epsilon> s t x' m'\""], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. s -t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                   s t x' m'", "by -(rule redT_normal, auto simp add: redT_updLns_def o_def finfun_Diag_const2 redT_updWs_def)"], ["proof (state)\nthis:\n  s -t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon> s\n                 t x' m'\n\ngoal (1 subgoal):\n 1. \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')", "moreover"], ["proof (state)\nthis:\n  s -t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon> s\n                 t x' m'\n\ngoal (1 subgoal):\n 1. \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')", "from \\<tau> red state"], ["proof (chain)\npicking this:\n  \\<tau>move (x, shr s) \\<lbrace>\\<rbrace> (x', m')\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None", "have \"m\\<tau>move s (t, \\<epsilon>) (redT_upd_\\<epsilon> s t x' m')\""], ["proof (prove)\nusing this:\n  \\<tau>move (x, shr s) \\<lbrace>\\<rbrace> (x', m')\n  t \\<turnstile> \\<langle>x, shr s\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow> \\<langle>x', m'\\<rangle>\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. m\\<tau>move s (t, \\<lbrace>\\<rbrace>) (redT_upd_\\<epsilon> s t x' m')", "by -(rule m\\<tau>move.intros, auto dest: \\<tau>move_heap simp add: redT_updLns_def)"], ["proof (state)\nthis:\n  m\\<tau>move s (t, \\<lbrace>\\<rbrace>) (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')", "ultimately"], ["proof (chain)\npicking this:\n  s -t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon> s\n                 t x' m'\n  m\\<tau>move s (t, \\<lbrace>\\<rbrace>) (redT_upd_\\<epsilon> s t x' m')", "show ?thesis"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon> s\n                 t x' m'\n  m\\<tau>move s (t, \\<lbrace>\\<rbrace>) (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')", "by auto"], ["proof (state)\nthis:\n  \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_into_RedT_\\<tau>_inv:\n  assumes major: \"silent_moves t (x, shr s) (x', m')\"\n  and state: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"wset s t = None\"\n  shows \"\\<tau>mredT^** s (redT_upd_\\<epsilon> s t x' m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mthr.silent_moves s (redT_upd_\\<epsilon> s t x' m')", "using major"], ["proof (prove)\nusing this:\n  silent_moves t (x, shr s) (x', m')\n\ngoal (1 subgoal):\n 1. mthr.silent_moves s (redT_upd_\\<epsilon> s t x' m')", "proof(induct rule: rtranclp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. mthr.silent_moves s (redT_upd_\\<epsilon> s t x (shr s))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>silent_moves t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_moves s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_moves s (redT_upd_\\<epsilon> s t aa ba)", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. mthr.silent_moves s (redT_upd_\\<epsilon> s t x (shr s))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>silent_moves t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_moves s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_moves s (redT_upd_\\<epsilon> s t aa ba)", "with state"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None", "show ?case"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. mthr.silent_moves s (redT_upd_\\<epsilon> s t x (shr s))", "by(cases s)(auto simp add: fun_upd_idem)"], ["proof (state)\nthis:\n  mthr.silent_moves s (redT_upd_\\<epsilon> s t x (shr s))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_moves t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_moves s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_moves s (redT_upd_\\<epsilon> s t aa ba)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_moves t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_moves s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_moves s (redT_upd_\\<epsilon> s t aa ba)", "case (step x' m' x'' m'')"], ["proof (state)\nthis:\n  silent_moves t (x, shr s) (x', m')\n  silent_move t (x', m') (x'', m'')\n  mthr.silent_moves s (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_moves t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_moves s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_moves s (redT_upd_\\<epsilon> s t aa ba)", "from \\<open>silent_move t (x', m') (x'', m'')\\<close> state"], ["proof (chain)\npicking this:\n  silent_move t (x', m') (x'', m'')\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None", "have \"\\<tau>mredT (redT_upd_\\<epsilon> s t x' m') (redT_upd_\\<epsilon> (redT_upd_\\<epsilon> s t x' m') t x'' m'')\""], ["proof (prove)\nusing this:\n  silent_move t (x', m') (x'', m'')\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n     (redT_upd_\\<epsilon> (redT_upd_\\<epsilon> s t x' m') t x'' m'')", "by -(rule silent_move_into_RedT_\\<tau>_inv, auto)"], ["proof (state)\nthis:\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> (redT_upd_\\<epsilon> s t x' m') t x'' m'')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_moves t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_moves s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_moves s (redT_upd_\\<epsilon> s t aa ba)", "hence \"\\<tau>mredT (redT_upd_\\<epsilon> s t x' m') (redT_upd_\\<epsilon> s t x'' m'')\""], ["proof (prove)\nusing this:\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> (redT_upd_\\<epsilon> s t x' m') t x'' m'')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n     (redT_upd_\\<epsilon> s t x'' m'')", "by(simp)"], ["proof (state)\nthis:\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> s t x'' m'')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_moves t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_moves s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_moves s (redT_upd_\\<epsilon> s t aa ba)", "with \\<open>\\<tau>mredT^** s (redT_upd_\\<epsilon> s t x' m')\\<close>"], ["proof (chain)\npicking this:\n  mthr.silent_moves s (redT_upd_\\<epsilon> s t x' m')\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> s t x'' m'')", "show ?case"], ["proof (prove)\nusing this:\n  mthr.silent_moves s (redT_upd_\\<epsilon> s t x' m')\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> s t x'' m'')\n\ngoal (1 subgoal):\n 1. mthr.silent_moves s (redT_upd_\\<epsilon> s t x'' m'')", ".."], ["proof (state)\nthis:\n  mthr.silent_moves s (redT_upd_\\<epsilon> s t x'' m'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_rtrancl_\\<tau>_heapD_inv:\n  \"\\<lbrakk> silent_moves t s s'; wfs t s \\<rbrakk> \\<Longrightarrow> snd s' = snd s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>silent_moves t s s'; wfs t s\\<rbrakk>\n    \\<Longrightarrow> snd s' = snd s", "proof(induct rule: rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. wfs t s \\<Longrightarrow> snd s = snd s\n 2. \\<And>y z.\n       \\<lbrakk>silent_moves t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "case base"], ["proof (state)\nthis:\n  wfs t s\n\ngoal (2 subgoals):\n 1. wfs t s \\<Longrightarrow> snd s = snd s\n 2. \\<And>y z.\n       \\<lbrakk>silent_moves t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd s = snd s", ".."], ["proof (state)\nthis:\n  snd s = snd s\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>silent_moves t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>silent_moves t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "case (step s' s'')"], ["proof (state)\nthis:\n  silent_moves t s s'\n  silent_move t s' s''\n  wfs t s \\<Longrightarrow> snd s' = snd s\n  wfs t s\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>silent_moves t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "thus ?case"], ["proof (prove)\nusing this:\n  silent_moves t s s'\n  silent_move t s' s''\n  wfs t s \\<Longrightarrow> snd s' = snd s\n  wfs t s\n\ngoal (1 subgoal):\n 1. snd s'' = snd s", "by(cases s, cases s', cases s'')(auto dest: \\<tau>move_heap)"], ["proof (state)\nthis:\n  snd s'' = snd s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_trancl_\\<tau>_heapD_inv:\n  \"\\<lbrakk> silent_movet t s s'; wfs t s \\<rbrakk> \\<Longrightarrow> snd s' = snd s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>silent_movet t s s'; wfs t s\\<rbrakk>\n    \\<Longrightarrow> snd s' = snd s", "proof(induct rule: tranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>silent_move t s y; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd y = snd s\n 2. \\<And>y z.\n       \\<lbrakk>silent_movet t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "case (base s')"], ["proof (state)\nthis:\n  silent_move t s s'\n  wfs t s\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>silent_move t s y; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd y = snd s\n 2. \\<And>y z.\n       \\<lbrakk>silent_movet t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "thus ?case"], ["proof (prove)\nusing this:\n  silent_move t s s'\n  wfs t s\n\ngoal (1 subgoal):\n 1. snd s' = snd s", "by(cases s')(cases s, auto simp add: silent_move_iff dest: \\<tau>move_heap)"], ["proof (state)\nthis:\n  snd s' = snd s\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>silent_movet t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>silent_movet t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "case (step s' s'')"], ["proof (state)\nthis:\n  silent_movet t s s'\n  silent_move t s' s''\n  wfs t s \\<Longrightarrow> snd s' = snd s\n  wfs t s\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>silent_movet t s y; silent_move t y z;\n        wfs t s \\<Longrightarrow> snd y = snd s; wfs t s\\<rbrakk>\n       \\<Longrightarrow> snd z = snd s", "thus ?case"], ["proof (prove)\nusing this:\n  silent_movet t s s'\n  silent_move t s' s''\n  wfs t s \\<Longrightarrow> snd s' = snd s\n  wfs t s\n\ngoal (1 subgoal):\n 1. snd s'' = snd s", "by(cases s, cases s', cases s'')(auto simp add: silent_move_iff dest: \\<tau>move_heap)"], ["proof (state)\nthis:\n  snd s'' = snd s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_trancl_\\<tau>_into_RedT_\\<tau>_inv:\n  assumes major: \"silent_movet t (x, shr s) (x', m')\"\n  and state: \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"wset s t = None\"\n  shows \"\\<tau>mredT^++ s (redT_upd_\\<epsilon> s t x' m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')", "using major"], ["proof (prove)\nusing this:\n  silent_movet t (x, shr s) (x', m')\n\ngoal (1 subgoal):\n 1. mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')", "proof(induct rule: tranclp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       silent_move t (x, shr s) (a, b) \\<Longrightarrow>\n       mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "case (base x' m')"], ["proof (state)\nthis:\n  silent_move t (x, shr s) (x', m')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       silent_move t (x, shr s) (a, b) \\<Longrightarrow>\n       mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "thus ?case"], ["proof (prove)\nusing this:\n  silent_move t (x, shr s) (x', m')\n\ngoal (1 subgoal):\n 1. mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')", "using state"], ["proof (prove)\nusing this:\n  silent_move t (x, shr s) (x', m')\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')", "by -(rule tranclp.r_into_trancl, rule silent_move_into_RedT_\\<tau>_inv, auto)"], ["proof (state)\nthis:\n  mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "case (step x' m' x'' m'')"], ["proof (state)\nthis:\n  silent_movet t (x, shr s) (x', m')\n  silent_move t (x', m') (x'', m'')\n  mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "hence \"\\<tau>mredT^++ s (redT_upd_\\<epsilon> s t x' m')\""], ["proof (prove)\nusing this:\n  silent_movet t (x, shr s) (x', m')\n  silent_move t (x', m') (x'', m'')\n  mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')", "by blast"], ["proof (state)\nthis:\n  mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "moreover"], ["proof (state)\nthis:\n  mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "from \\<open>silent_move t (x', m') (x'', m'')\\<close> state"], ["proof (chain)\npicking this:\n  silent_move t (x', m') (x'', m'')\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None", "have \"\\<tau>mredT (redT_upd_\\<epsilon> s t x' m') (redT_upd_\\<epsilon> (redT_upd_\\<epsilon> s t x' m') t x'' m'')\""], ["proof (prove)\nusing this:\n  silent_move t (x', m') (x'', m'')\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n     (redT_upd_\\<epsilon> (redT_upd_\\<epsilon> s t x' m') t x'' m'')", "by -(rule silent_move_into_RedT_\\<tau>_inv, auto simp add: redT_updLns_def)"], ["proof (state)\nthis:\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> (redT_upd_\\<epsilon> s t x' m') t x'' m'')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "hence \"\\<tau>mredT (redT_upd_\\<epsilon> s t x' m') (redT_upd_\\<epsilon> s t x'' m'')\""], ["proof (prove)\nusing this:\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> (redT_upd_\\<epsilon> s t x' m') t x'' m'')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n     (redT_upd_\\<epsilon> s t x'' m'')", "by(simp add: redT_updLns_def)"], ["proof (state)\nthis:\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> s t x'' m'')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>silent_movet t (x, shr s) (a, b);\n        silent_move t (a, b) (aa, ba);\n        mthr.silent_movet s (redT_upd_\\<epsilon> s t a b)\\<rbrakk>\n       \\<Longrightarrow> mthr.silent_movet s (redT_upd_\\<epsilon> s t aa ba)", "ultimately"], ["proof (chain)\npicking this:\n  mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> s t x'' m'')", "show ?case"], ["proof (prove)\nusing this:\n  mthr.silent_movet s (redT_upd_\\<epsilon> s t x' m')\n  \\<tau>mredT (redT_upd_\\<epsilon> s t x' m')\n   (redT_upd_\\<epsilon> s t x'' m'')\n\ngoal (1 subgoal):\n 1. mthr.silent_movet s (redT_upd_\\<epsilon> s t x'' m'')", ".."], ["proof (state)\nthis:\n  mthr.silent_movet s (redT_upd_\\<epsilon> s t x'' m'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>diverge_into_\\<tau>mredT:\n  assumes \"\\<tau>diverge t (x, shr s)\"\n  and \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"wset s t = None\"\n  shows \"mthr.\\<tau>diverge s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mthr.\\<tau>diverge s", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>diverge t (x, shr s)\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. mthr.\\<tau>diverge s", "proof(coinduction arbitrary: s x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "case (\\<tau>diverge s x)"], ["proof (state)\nthis:\n  \\<tau>diverge t (x, shr s)\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "note tst = \\<open>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "from \\<open>\\<tau>diverge t (x, shr s)\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>diverge t (x, shr s)", "obtain x' m' where \"silent_move t (x, shr s) (x', m')\" \n    and \"\\<tau>diverge t (x', m')\""], ["proof (prove)\nusing this:\n  \\<tau>diverge t (x, shr s)\n\ngoal (1 subgoal):\n 1. (\\<And>x' m'.\n        \\<lbrakk>silent_move t (x, shr s) (x', m');\n         \\<tau>diverge t (x', m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  silent_move t (x, shr s) (x', m')\n  \\<tau>diverge t (x', m')\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "from \\<open>silent_move t (x, shr s) (x', m')\\<close> tst \\<open>wset s t = None\\<close>"], ["proof (chain)\npicking this:\n  silent_move t (x, shr s) (x', m')\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None", "have \"\\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\""], ["proof (prove)\nusing this:\n  silent_move t (x, shr s) (x', m')\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset s t = None\n\ngoal (1 subgoal):\n 1. \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')", "by(rule silent_move_into_RedT_\\<tau>_inv)"], ["proof (state)\nthis:\n  \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "have \"thr (redT_upd_\\<epsilon> s t x' m') t = \\<lfloor>(x', no_wait_locks)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr (redT_upd_\\<epsilon> s t x' m') t =\n    \\<lfloor>(x', no_wait_locks)\\<rfloor>", "using tst"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. thr (redT_upd_\\<epsilon> s t x' m') t =\n    \\<lfloor>(x', no_wait_locks)\\<rfloor>", "by(auto simp add: redT_updLns_def)"], ["proof (state)\nthis:\n  thr (redT_upd_\\<epsilon> s t x' m') t =\n  \\<lfloor>(x', no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  thr (redT_upd_\\<epsilon> s t x' m') t =\n  \\<lfloor>(x', no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "have \"wset (redT_upd_\\<epsilon> s t x' m') t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset (redT_upd_\\<epsilon> s t x' m') t = None", "using \\<open>wset s t = None\\<close>"], ["proof (prove)\nusing this:\n  wset s t = None\n\ngoal (1 subgoal):\n 1. wset (redT_upd_\\<epsilon> s t x' m') t = None", "by simp"], ["proof (state)\nthis:\n  wset (redT_upd_\\<epsilon> s t x' m') t = None\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  wset (redT_upd_\\<epsilon> s t x' m') t = None\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "from \\<open>\\<tau>diverge t (x', m')\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>diverge t (x', m')", "have \"\\<tau>diverge t (x', shr (redT_upd_\\<epsilon> s t x' m'))\""], ["proof (prove)\nusing this:\n  \\<tau>diverge t (x', m')\n\ngoal (1 subgoal):\n 1. \\<tau>diverge t (x', shr (redT_upd_\\<epsilon> s t x' m'))", "by simp"], ["proof (state)\nthis:\n  \\<tau>diverge t (x', shr (redT_upd_\\<epsilon> s t x' m'))\n\ngoal (1 subgoal):\n 1. \\<And>s xa.\n       \\<lbrakk>\\<tau>diverge t (xa, shr s);\n        thr s t = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        wset s t = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa s'.\n                            s = sa \\<and>\n                            \\<tau>mredT sa s' \\<and>\n                            ((\\<exists>s x.\n                                 s' = s \\<and>\n                                 \\<tau>diverge t (x, shr s) \\<and>\n                                 thr s t =\n                                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                 wset s t = None) \\<or>\n                             mthr.\\<tau>diverge s')", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\n  thr (redT_upd_\\<epsilon> s t x' m') t =\n  \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset (redT_upd_\\<epsilon> s t x' m') t = None\n  \\<tau>diverge t (x', shr (redT_upd_\\<epsilon> s t x' m'))", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\n  thr (redT_upd_\\<epsilon> s t x' m') t =\n  \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset (redT_upd_\\<epsilon> s t x' m') t = None\n  \\<tau>diverge t (x', shr (redT_upd_\\<epsilon> s t x' m'))\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       \\<tau>mredT s s' \\<and>\n       ((\\<exists>s x.\n            s' = s \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n            wset s t = None) \\<or>\n        mthr.\\<tau>diverge s')", "using \\<open>\\<tau>diverge t (x', m')\\<close>"], ["proof (prove)\nusing this:\n  \\<tau>mredT s (redT_upd_\\<epsilon> s t x' m')\n  thr (redT_upd_\\<epsilon> s t x' m') t =\n  \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset (redT_upd_\\<epsilon> s t x' m') t = None\n  \\<tau>diverge t (x', shr (redT_upd_\\<epsilon> s t x' m'))\n  \\<tau>diverge t (x', m')\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       s = s \\<and>\n       \\<tau>mredT s s' \\<and>\n       ((\\<exists>s x.\n            s' = s \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n            wset s t = None) \\<or>\n        mthr.\\<tau>diverge s')", "by blast"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     s = s \\<and>\n     \\<tau>mredT s s' \\<and>\n     ((\\<exists>s x.\n          s' = s \\<and>\n          \\<tau>diverge t (x, shr s) \\<and>\n          thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n          wset s t = None) \\<or>\n      mthr.\\<tau>diverge s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>diverge_\\<tau>mredTD:\n  assumes div: \"mthr.\\<tau>diverge s\"\n  and fin: \"finite (dom (thr s))\"\n  shows \"\\<exists>t x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> wset s t = None \\<and> \\<tau>diverge t (x, shr s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "using fin div"], ["proof (prove)\nusing this:\n  finite (dom (thr s))\n  mthr.\\<tau>diverge s\n\ngoal (1 subgoal):\n 1. \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "proof(induct A\\<equiv>\"dom (thr s)\" arbitrary: s rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>{} = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)\n 2. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "case empty"], ["proof (state)\nthis:\n  {} = dom (thr s)\n  mthr.\\<tau>diverge s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>{} = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)\n 2. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "from \\<open>mthr.\\<tau>diverge s\\<close>"], ["proof (chain)\npicking this:\n  mthr.\\<tau>diverge s", "obtain s' where \"\\<tau>mredT s s'\""], ["proof (prove)\nusing this:\n  mthr.\\<tau>diverge s\n\ngoal (1 subgoal):\n 1. (\\<And>s'. \\<tau>mredT s s' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  \\<tau>mredT s s'\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>{} = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)\n 2. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "with \\<open>{} = dom (thr s)\\<close>[symmetric]"], ["proof (chain)\npicking this:\n  dom (thr s) = {}\n  \\<tau>mredT s s'", "have False"], ["proof (prove)\nusing this:\n  dom (thr s) = {}\n  \\<tau>mredT s s'\n\ngoal (1 subgoal):\n 1. False", "by(auto elim!: mthr.silent_move.cases redT.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>{} = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)\n 2. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", ".."], ["proof (state)\nthis:\n  \\<exists>t x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     wset s t = None \\<and> \\<tau>diverge t (x, shr s)\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "case (insert t A)"], ["proof (state)\nthis:\n  finite A\n  t \\<notin> A\n  \\<lbrakk>A = dom (thr ?s12); mthr.\\<tau>diverge ?s12\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t x.\n                       thr ?s12 t =\n                       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                       wset ?s12 t = None \\<and>\n                       \\<tau>diverge t (x, shr ?s12)\n  insert t A = dom (thr s)\n  mthr.\\<tau>diverge s\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "note IH = \\<open>\\<And>s. \\<lbrakk> A = dom (thr s); mthr.\\<tau>diverge s \\<rbrakk>\n             \\<Longrightarrow> \\<exists>t x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> wset s t = None \\<and> \\<tau>diverge t (x, shr s)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>A = dom (thr ?s); mthr.\\<tau>diverge ?s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t x.\n                       thr ?s t =\n                       \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                       wset ?s t = None \\<and> \\<tau>diverge t (x, shr ?s)\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "from \\<open>insert t A = dom (thr s)\\<close>"], ["proof (chain)\npicking this:\n  insert t A = dom (thr s)", "obtain x ln where tst: \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\""], ["proof (prove)\nusing this:\n  insert t A = dom (thr s)\n\ngoal (1 subgoal):\n 1. (\\<And>x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: dom_def)"], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "define s' where \"s' = (locks s, ((thr s)(t := None), shr s), wset s, interrupts s)\""], ["proof (state)\nthis:\n  s' = (locks s, ((thr s)(t := None), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. \\<And>x F s.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>s.\n           \\<lbrakk>F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n           \\<Longrightarrow> \\<exists>t x.\n                                thr s t =\n                                \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                                wset s t = None \\<and>\n                                \\<tau>diverge t (x, shr s);\n        insert x F = dom (thr s); mthr.\\<tau>diverge s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t x.\n                            thr s t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            wset s t = None \\<and>\n                            \\<tau>diverge t (x, shr s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "proof(cases \"ln = no_wait_locks \\<and> \\<tau>diverge t (x, shr s) \\<and> wset s t = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ln = no_wait_locks \\<and>\n    \\<tau>diverge t (x, shr s) \\<and> wset s t = None \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)\n 2. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "case True"], ["proof (state)\nthis:\n  ln = no_wait_locks \\<and>\n  \\<tau>diverge t (x, shr s) \\<and> wset s t = None\n\ngoal (2 subgoals):\n 1. ln = no_wait_locks \\<and>\n    \\<tau>diverge t (x, shr s) \\<and> wset s t = None \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)\n 2. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "with tst"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  ln = no_wait_locks \\<and>\n  \\<tau>diverge t (x, shr s) \\<and> wset s t = None", "show ?thesis"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  ln = no_wait_locks \\<and>\n  \\<tau>diverge t (x, shr s) \\<and> wset s t = None\n\ngoal (1 subgoal):\n 1. \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>t x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     wset s t = None \\<and> \\<tau>diverge t (x, shr s)\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "case False"], ["proof (state)\nthis:\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "define xm where \"xm = (x, shr s)\""], ["proof (state)\nthis:\n  xm = (x, shr s)\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "define xm' where \"xm' = (x, shr s)\""], ["proof (state)\nthis:\n  xm' = (x, shr s)\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "have \"A = dom (thr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = dom (thr s')", "using \\<open>t \\<notin> A\\<close> \\<open>insert t A = dom (thr s)\\<close>"], ["proof (prove)\nusing this:\n  t \\<notin> A\n  insert t A = dom (thr s)\n\ngoal (1 subgoal):\n 1. A = dom (thr s')", "unfolding s'_def"], ["proof (prove)\nusing this:\n  t \\<notin> A\n  insert t A = dom (thr s)\n\ngoal (1 subgoal):\n 1. A =\n    dom (thr (locks s, ((thr s)(t := None), shr s), wset s, interrupts s))", "by auto"], ["proof (state)\nthis:\n  A = dom (thr s')\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "moreover"], ["proof (state)\nthis:\n  A = dom (thr s')\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "{"], ["proof (state)\nthis:\n  A = dom (thr s')\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "from xm'_def tst \\<open>mthr.\\<tau>diverge s\\<close> False"], ["proof (chain)\npicking this:\n  xm' = (x, shr s)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  mthr.\\<tau>diverge s\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)", "have \"\\<exists>s x. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> (ln \\<noteq> no_wait_locks \\<or> wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n                  s' = (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and> xm = (x, shr s) \\<and> \n                  mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm\""], ["proof (prove)\nusing this:\n  xm' = (x, shr s)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  mthr.\\<tau>diverge s\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)\n\ngoal (1 subgoal):\n 1. \\<exists>s x.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       (ln \\<noteq> no_wait_locks \\<or>\n        wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n       s' =\n       (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n       xm = (x, shr s) \\<and>\n       mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm", "unfolding s'_def xm_def"], ["proof (prove)\nusing this:\n  xm' = (x, shr s)\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  mthr.\\<tau>diverge s\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)\n\ngoal (1 subgoal):\n 1. \\<exists>s xa.\n       thr s t = \\<lfloor>(xa, ln)\\<rfloor> \\<and>\n       (ln \\<noteq> no_wait_locks \\<or>\n        wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n       (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) =\n       (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n       (x, shr s) = (xa, shr s) \\<and>\n       mthr.\\<tau>diverge s \\<and> silent_moves t xm' (x, shr s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s x.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     (ln \\<noteq> no_wait_locks \\<or>\n      wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n     s' =\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n     xm = (x, shr s) \\<and>\n     mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "moreover"], ["proof (state)\nthis:\n  \\<exists>s x.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     (ln \\<noteq> no_wait_locks \\<or>\n      wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n     s' =\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n     xm = (x, shr s) \\<and>\n     mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "from False"], ["proof (chain)\npicking this:\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)", "have \"wfP (if \\<tau>diverge t xm' then (\\<lambda>s s'. False) else flip (silent_move_from t xm'))\""], ["proof (prove)\nusing this:\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)\n\ngoal (1 subgoal):\n 1. wfP (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))", "using \\<tau>diverge_neq_wfP_silent_move_from[of t \"(x, shr s)\"]"], ["proof (prove)\nusing this:\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)\n  \\<tau>diverge t (x, shr s) \\<noteq>\n  wfP (flip (silent_move_from t (x, shr s)))\n\ngoal (1 subgoal):\n 1. wfP (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))", "unfolding xm'_def"], ["proof (prove)\nusing this:\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)\n  \\<tau>diverge t (x, shr s) \\<noteq>\n  wfP (flip (silent_move_from t (x, shr s)))\n\ngoal (1 subgoal):\n 1. wfP (if \\<tau>diverge t (x, shr s) then \\<lambda>s s'. False\n         else flip (silent_move_from t (x, shr s)))", "by(auto)"], ["proof (state)\nthis:\n  wfP (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n       else flip (silent_move_from t xm'))\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>s x.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     (ln \\<noteq> no_wait_locks \\<or>\n      wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n     s' =\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n     xm = (x, shr s) \\<and>\n     mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm\n  wfP (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n       else flip (silent_move_from t xm'))", "have \"mthr.\\<tau>diverge s'\""], ["proof (prove)\nusing this:\n  \\<exists>s x.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     (ln \\<noteq> no_wait_locks \\<or>\n      wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n     s' =\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n     xm = (x, shr s) \\<and>\n     mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm\n  wfP (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n       else flip (silent_move_from t xm'))\n\ngoal (1 subgoal):\n 1. mthr.\\<tau>diverge s'", "proof(coinduct s' xm rule: mthr.\\<tau>diverge_trancl_measure_coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "case (\\<tau>diverge s' xm)"], ["proof (state)\nthis:\n  \\<exists>s x.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     (ln \\<noteq> no_wait_locks \\<or>\n      wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n     s' =\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n     xm = (x, shr s) \\<and>\n     mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm\n\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "then"], ["proof (chain)\npicking this:\n  \\<exists>s x.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     (ln \\<noteq> no_wait_locks \\<or>\n      wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n     s' =\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n     xm = (x, shr s) \\<and>\n     mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm", "obtain s x where tst: \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n          and blocked: \"ln \\<noteq> no_wait_locks \\<or> wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\"\n          and s'_def: \"s' = (locks s, ((thr s)(t := None), shr s), wset s, interrupts s)\"\n          and xm_def: \"xm = (x, shr s)\"\n          and xmxm': \"silent_moves t xm' (x, shr s)\"\n          and \"mthr.\\<tau>diverge s\""], ["proof (prove)\nusing this:\n  \\<exists>s x.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     (ln \\<noteq> no_wait_locks \\<or>\n      wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n     s' =\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) \\<and>\n     xm = (x, shr s) \\<and>\n     mthr.\\<tau>diverge s \\<and> silent_moves t xm' xm\n\ngoal (1 subgoal):\n 1. (\\<And>s x.\n        \\<lbrakk>thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n         ln \\<noteq> no_wait_locks \\<or>\n         wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm';\n         s' = (locks s, ((thr s)(t := None), shr s), wset s, interrupts s);\n         xm = (x, shr s); silent_moves t xm' (x, shr s);\n         mthr.\\<tau>diverge s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n  s' = (locks s, ((thr s)(t := None), shr s), wset s, interrupts s)\n  xm = (x, shr s)\n  silent_moves t xm' (x, shr s)\n  mthr.\\<tau>diverge s\n\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "from \\<open>mthr.\\<tau>diverge s\\<close>"], ["proof (chain)\npicking this:\n  mthr.\\<tau>diverge s", "obtain s'' where \"\\<tau>mredT s s''\" \"mthr.\\<tau>diverge s''\""], ["proof (prove)\nusing this:\n  mthr.\\<tau>diverge s\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>\\<tau>mredT s s''; mthr.\\<tau>diverge s''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  \\<tau>mredT s s''\n  mthr.\\<tau>diverge s''\n\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "from \\<open>\\<tau>mredT s s''\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>mredT s s''", "obtain t' ta where \"s -t'\\<triangleright>ta\\<rightarrow> s''\" and \"m\\<tau>move s (t', ta) s''\""], ["proof (prove)\nusing this:\n  \\<tau>mredT s s''\n\ngoal (1 subgoal):\n 1. (\\<And>t' ta.\n        \\<lbrakk>s -t'\\<triangleright>ta\\<rightarrow> s'';\n         m\\<tau>move s (t', ta) s''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s -t'\\<triangleright>ta\\<rightarrow> s''\n  m\\<tau>move s (t', ta) s''\n\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "then"], ["proof (chain)\npicking this:\n  s -t'\\<triangleright>ta\\<rightarrow> s''\n  m\\<tau>move s (t', ta) s''", "obtain x' x'' m'' where red: \"t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>\"\n          and tst': \"thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\" \n          and aoe: \"actions_ok s t' ta\"\n          and s'': \"redT_upd s t' ta x'' m'' s''\""], ["proof (prove)\nusing this:\n  s -t'\\<triangleright>ta\\<rightarrow> s''\n  m\\<tau>move s (t', ta) s''\n\ngoal (1 subgoal):\n 1. (\\<And>x' x'' m''.\n        \\<lbrakk>t' \\<turnstile> \\<langle>x', shr\n         s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n         thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>;\n         actions_ok s t' ta; redT_upd s t' ta x'' m'' s''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases(fastforce elim: m\\<tau>move.cases)+"], ["proof (state)\nthis:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  actions_ok s t' ta\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "from \\<open>m\\<tau>move s (t', ta) s''\\<close>"], ["proof (chain)\npicking this:\n  m\\<tau>move s (t', ta) s''", "have [simp]: \"ta = \\<epsilon>\""], ["proof (prove)\nusing this:\n  m\\<tau>move s (t', ta) s''\n\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "by(auto elim!: m\\<tau>move.cases dest!: silent_tl)"], ["proof (state)\nthis:\n  ta = \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "hence wst': \"wset s t' = None\""], ["proof (prove)\nusing this:\n  ta = \\<lbrace>\\<rbrace>\n\ngoal (1 subgoal):\n 1. wset s t' = None", "using aoe"], ["proof (prove)\nusing this:\n  ta = \\<lbrace>\\<rbrace>\n  actions_ok s t' ta\n\ngoal (1 subgoal):\n 1. wset s t' = None", "by auto"], ["proof (state)\nthis:\n  wset s t' = None\n\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "from \\<open>m\\<tau>move s (t', ta) s''\\<close> tst' s''"], ["proof (chain)\npicking this:\n  m\\<tau>move s (t', ta) s''\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  redT_upd s t' ta x'' m'' s''", "have \"\\<tau>move (x', shr s) \\<epsilon> (x'', m'')\""], ["proof (prove)\nusing this:\n  m\\<tau>move s (t', ta) s''\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')", "by(auto elim: m\\<tau>move.cases)"], ["proof (state)\nthis:\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<exists>sa x.\n          thr sa t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset sa t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s =\n          (locks sa, ((thr sa)(t := None), shr sa), wset sa,\n           interrupts sa) \\<and>\n          ta = (x, shr sa) \\<and>\n          mthr.\\<tau>diverge sa \\<and>\n          silent_moves t xm' ta \\<Longrightarrow>\n       \\<exists>s' t'.\n          ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n            else flip (silent_move_from t xm'))\n            t' ta \\<and>\n           s' = s \\<or>\n           mthr.silent_movet s s') \\<and>\n          ((\\<exists>s x.\n               thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n               (ln \\<noteq> no_wait_locks \\<or>\n                wset s t \\<noteq> None \\<or>\n                \\<not> \\<tau>diverge t xm') \\<and>\n               s' =\n               (locks s, ((thr s)(t := None), shr s), wset s,\n                interrupts s) \\<and>\n               t' = (x, shr s) \\<and>\n               mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n           mthr.\\<tau>diverge s')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "proof(cases \"t' = t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "case False"], ["proof (state)\nthis:\n  t' \\<noteq> t\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "with tst' wst'"], ["proof (chain)\npicking this:\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s t' = None\n  t' \\<noteq> t", "have \"thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\"\n            \"wset s' t' = None\" \"shr s' = shr s\""], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s t' = None\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor> &&&\n    wset s' t' = None &&& shr s' = shr s", "unfolding s'_def"], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s t' = None\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. thr (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) t' =\n    \\<lfloor>(x', no_wait_locks)\\<rfloor> &&&\n    wset (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) t' =\n    None &&&\n    shr (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) = shr s", "by auto"], ["proof (state)\nthis:\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  shr s' = shr s\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "with red"], ["proof (chain)\npicking this:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  shr s' = shr s", "have \"s' -t'\\<triangleright>\\<epsilon>\\<rightarrow> redT_upd_\\<epsilon> s' t' x'' m''\""], ["proof (prove)\nusing this:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  shr s' = shr s\n\ngoal (1 subgoal):\n 1. s' -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                     s' t' x'' m''", "by -(rule redT_normal, auto simp add: redT_updLns_def o_def finfun_Diag_const2 redT_updWs_def)"], ["proof (state)\nthis:\n  s' -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                   s' t' x'' m''\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  s' -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                   s' t' x'' m''\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "from \\<open>\\<tau>move (x', shr s) \\<epsilon> (x'', m'')\\<close> \\<open>thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\\<close> \\<open>shr s' = shr s\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  shr s' = shr s", "have \"m\\<tau>move s' (t', ta) (redT_upd_\\<epsilon> s' t' x'' m'')\""], ["proof (prove)\nusing this:\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  shr s' = shr s\n\ngoal (1 subgoal):\n 1. m\\<tau>move s' (t', ta) (redT_upd_\\<epsilon> s' t' x'' m'')", "by -(rule m\\<tau>move.intros, auto)"], ["proof (state)\nthis:\n  m\\<tau>move s' (t', ta) (redT_upd_\\<epsilon> s' t' x'' m'')\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "ultimately"], ["proof (chain)\npicking this:\n  s' -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                   s' t' x'' m''\n  m\\<tau>move s' (t', ta) (redT_upd_\\<epsilon> s' t' x'' m'')", "have \"\\<tau>mredT s' (redT_upd_\\<epsilon> s' t' x'' m'')\""], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                   s' t' x'' m''\n  m\\<tau>move s' (t', ta) (redT_upd_\\<epsilon> s' t' x'' m'')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT s' (redT_upd_\\<epsilon> s' t' x'' m'')", "unfolding \\<open>ta = \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  s' -t'\\<triangleright>\\<lbrace>\\<rbrace>\\<rightarrow> redT_upd_\\<epsilon>\n                   s' t' x'' m''\n  m\\<tau>move s' (t', \\<lbrace>\\<rbrace>)\n   (redT_upd_\\<epsilon> s' t' x'' m'')\n\ngoal (1 subgoal):\n 1. \\<tau>mredT s' (redT_upd_\\<epsilon> s' t' x'' m'')", "by(rule mthr.silent_move.intros)"], ["proof (state)\nthis:\n  \\<tau>mredT s' (redT_upd_\\<epsilon> s' t' x'' m'')\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "hence \"\\<tau>mredT^++ s' (redT_upd_\\<epsilon> s' t' x'' m'')\""], ["proof (prove)\nusing this:\n  \\<tau>mredT s' (redT_upd_\\<epsilon> s' t' x'' m'')\n\ngoal (1 subgoal):\n 1. mthr.silent_movet s' (redT_upd_\\<epsilon> s' t' x'' m'')", ".."], ["proof (state)\nthis:\n  mthr.silent_movet s' (redT_upd_\\<epsilon> s' t' x'' m'')\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  mthr.silent_movet s' (redT_upd_\\<epsilon> s' t' x'' m'')\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "have \"thr s'' t = \\<lfloor>(x, ln)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr s'' t = \\<lfloor>(x, ln)\\<rfloor>", "using tst \\<open>t' \\<noteq> t\\<close> s''"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  t' \\<noteq> t\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. thr s'' t = \\<lfloor>(x, ln)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  thr s'' t = \\<lfloor>(x, ln)\\<rfloor>\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  thr s'' t = \\<lfloor>(x, ln)\\<rfloor>\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "from \\<open>\\<tau>move (x', shr s) \\<epsilon> (x'', m'')\\<close> red"], ["proof (chain)\npicking this:\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>", "have [simp]: \"m'' = shr s\""], ["proof (prove)\nusing this:\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>\n\ngoal (1 subgoal):\n 1. m'' = shr s", "by(auto dest: \\<tau>move_heap)"], ["proof (state)\nthis:\n  m'' = shr s\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "hence \"shr s = shr s''\""], ["proof (prove)\nusing this:\n  m'' = shr s\n\ngoal (1 subgoal):\n 1. shr s = shr s''", "using s''"], ["proof (prove)\nusing this:\n  m'' = shr s\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. shr s = shr s''", "by(auto)"], ["proof (state)\nthis:\n  shr s = shr s''\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "have \"ln \\<noteq> no_wait_locks \\<or> wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln \\<noteq> no_wait_locks \\<or>\n    wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'", "using blocked s''"], ["proof (prove)\nusing this:\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. ln \\<noteq> no_wait_locks \\<or>\n    wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'", "by(auto simp add: redT_updWs_def elim!: rtrancl3p_cases)"], ["proof (state)\nthis:\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "have \"redT_upd_\\<epsilon> s' t' x'' m'' = (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_upd_\\<epsilon> s' t' x'' m'' =\n    (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')", "unfolding s'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_upd_\\<epsilon>\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) t' x''\n     m'' =\n    (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')", "using tst s'' \\<open>t' \\<noteq> t\\<close>"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  redT_upd s t' ta x'' m'' s''\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. redT_upd_\\<epsilon>\n     (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) t' x''\n     m'' =\n    (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')", "by(auto intro: ext elim!: rtrancl3p_cases simp add: redT_updLns_def redT_updWs_def)"], ["proof (state)\nthis:\n  redT_upd_\\<epsilon> s' t' x'' m'' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')\n 2. t' \\<noteq> t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "ultimately"], ["proof (chain)\npicking this:\n  mthr.silent_movet s' (redT_upd_\\<epsilon> s' t' x'' m'')\n  thr s'' t = \\<lfloor>(x, ln)\\<rfloor>\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n  redT_upd_\\<epsilon> s' t' x'' m'' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')", "show ?thesis"], ["proof (prove)\nusing this:\n  mthr.silent_movet s' (redT_upd_\\<epsilon> s' t' x'' m'')\n  thr s'' t = \\<lfloor>(x, ln)\\<rfloor>\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n  redT_upd_\\<epsilon> s' t' x'' m'' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "using \\<open>mthr.\\<tau>diverge s''\\<close> xmxm'"], ["proof (prove)\nusing this:\n  mthr.silent_movet s' (redT_upd_\\<epsilon> s' t' x'' m'')\n  thr s'' t = \\<lfloor>(x, ln)\\<rfloor>\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n  redT_upd_\\<epsilon> s' t' x'' m'' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n  mthr.\\<tau>diverge s''\n  silent_moves t xm' (x, shr s)\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "unfolding \\<open>shr s = shr s''\\<close>"], ["proof (prove)\nusing this:\n  mthr.silent_movet s' (redT_upd_\\<epsilon> s' t' x'' m'')\n  thr s'' t = \\<lfloor>(x, ln)\\<rfloor>\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s'' t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n  redT_upd_\\<epsilon> s' t' x'' m'' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n  mthr.\\<tau>diverge s''\n  silent_moves t xm' (x, shr s'')\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "by blast"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n       else flip (silent_move_from t xm'))\n       t' xm \\<and>\n      s' = s' \\<or>\n      mthr.silent_movet s' s') \\<and>\n     ((\\<exists>s x.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s' =\n          (locks s, ((thr s)(t := None), shr s), wset s,\n           interrupts s) \\<and>\n          t' = (x, shr s) \\<and>\n          mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n      mthr.\\<tau>diverge s')\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "case True"], ["proof (state)\nthis:\n  t' = t\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "with tst tst' wst' blocked"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s t' = None\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n  t' = t", "have \"\\<not> \\<tau>diverge t xm'\"\n            and [simp]: \"x' = x\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s t' = None\n  ln \\<noteq> no_wait_locks \\<or>\n  wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm'\n  t' = t\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau>diverge t xm' &&& x' = x", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<tau>diverge t xm'\n  x' = x\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  \\<not> \\<tau>diverge t xm'\n  x' = x\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "from red \\<open>\\<tau>move (x', shr s) \\<epsilon> (x'', m'')\\<close> True"], ["proof (chain)\npicking this:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n  t' = t", "have \"silent_move t (x, shr s) (x'', m'')\""], ["proof (prove)\nusing this:\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n  t' = t\n\ngoal (1 subgoal):\n 1. silent_move t (x, shr s) (x'', m'')", "by auto"], ["proof (state)\nthis:\n  silent_move t (x, shr s) (x'', m'')\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "with xmxm'"], ["proof (chain)\npicking this:\n  silent_moves t xm' (x, shr s)\n  silent_move t (x, shr s) (x'', m'')", "have \"silent_move_from t xm' (x, shr s) (x'', m'')\""], ["proof (prove)\nusing this:\n  silent_moves t xm' (x, shr s)\n  silent_move t (x, shr s) (x'', m'')\n\ngoal (1 subgoal):\n 1. silent_move_from t xm' (x, shr s) (x'', m'')", "by(rule silent_move_fromI)"], ["proof (state)\nthis:\n  silent_move_from t xm' (x, shr s) (x'', m'')\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> \\<tau>diverge t xm'\n  x' = x\n  silent_move_from t xm' (x, shr s) (x'', m'')", "have \"(if \\<tau>diverge t xm' then \\<lambda>s s'. False else flip (silent_move_from t xm')) (x'', m'') xm\""], ["proof (prove)\nusing this:\n  \\<not> \\<tau>diverge t xm'\n  x' = x\n  silent_move_from t xm' (x, shr s) (x'', m'')\n\ngoal (1 subgoal):\n 1. (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n     else flip (silent_move_from t xm'))\n     (x'', m'') xm", "by(auto simp add: flip_conv xm_def)"], ["proof (state)\nthis:\n  (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n   else flip (silent_move_from t xm'))\n   (x'', m'') xm\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n   else flip (silent_move_from t xm'))\n   (x'', m'') xm\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "have \"thr s'' t = \\<lfloor>(x'', ln)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr s'' t = \\<lfloor>(x'', ln)\\<rfloor>", "using tst True s''"], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n  t' = t\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. thr s'' t = \\<lfloor>(x'', ln)\\<rfloor>", "by(auto simp add: redT_updLns_def)"], ["proof (state)\nthis:\n  thr s'' t = \\<lfloor>(x'', ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  thr s'' t = \\<lfloor>(x'', ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "from \\<open>\\<tau>move (x', shr s) \\<epsilon> (x'', m'')\\<close> red"], ["proof (chain)\npicking this:\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>", "have [simp]: \"m'' = shr s\""], ["proof (prove)\nusing this:\n  \\<tau>move (x', shr s) \\<lbrace>\\<rbrace> (x'', m'')\n  t' \\<turnstile> \\<langle>x', shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'', m''\\<rangle>\n\ngoal (1 subgoal):\n 1. m'' = shr s", "by(auto dest: \\<tau>move_heap)"], ["proof (state)\nthis:\n  m'' = shr s\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "hence \"shr s = shr s''\""], ["proof (prove)\nusing this:\n  m'' = shr s\n\ngoal (1 subgoal):\n 1. shr s = shr s''", "using s''"], ["proof (prove)\nusing this:\n  m'' = shr s\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. shr s = shr s''", "by auto"], ["proof (state)\nthis:\n  shr s = shr s''\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "have \"s' = (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' =\n    (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')", "using True s''"], ["proof (prove)\nusing this:\n  t' = t\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. s' =\n    (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')", "unfolding s'_def"], ["proof (prove)\nusing this:\n  t' = t\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) =\n    (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')", "by(auto intro: ext elim!: rtrancl3p_cases simp add: redT_updLns_def redT_updWs_def)"], ["proof (state)\nthis:\n  s' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  s' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "have \"(x'', m'') = (x'', shr s'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x'', m'') = (x'', shr s'')", "using s''"], ["proof (prove)\nusing this:\n  redT_upd s t' ta x'' m'' s''\n\ngoal (1 subgoal):\n 1. (x'', m'') = (x'', shr s'')", "by auto"], ["proof (state)\nthis:\n  (x'', m'') = (x'', shr s'')\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "moreover"], ["proof (state)\nthis:\n  (x'', m'') = (x'', shr s'')\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "from xmxm' \\<open>silent_move t (x, shr s) (x'', m'')\\<close>"], ["proof (chain)\npicking this:\n  silent_moves t xm' (x, shr s)\n  silent_move t (x, shr s) (x'', m'')", "have \"silent_moves t xm' (x'', shr s'')\""], ["proof (prove)\nusing this:\n  silent_moves t xm' (x, shr s)\n  silent_move t (x, shr s) (x'', m'')\n\ngoal (1 subgoal):\n 1. silent_moves t xm' (x'', shr s'')", "unfolding \\<open>m'' = shr s\\<close> \\<open>shr s = shr s''\\<close>"], ["proof (prove)\nusing this:\n  silent_moves t xm' (x, shr s'')\n  silent_move t (x, shr s'') (x'', shr s'')\n\ngoal (1 subgoal):\n 1. silent_moves t xm' (x'', shr s'')", "by auto"], ["proof (state)\nthis:\n  silent_moves t xm' (x'', shr s'')\n\ngoal (1 subgoal):\n 1. t' = t \\<Longrightarrow>\n    \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "ultimately"], ["proof (chain)\npicking this:\n  (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n   else flip (silent_move_from t xm'))\n   (x'', m'') xm\n  thr s'' t = \\<lfloor>(x'', ln)\\<rfloor>\n  s' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n  (x'', m'') = (x'', shr s'')\n  silent_moves t xm' (x'', shr s'')", "show ?thesis"], ["proof (prove)\nusing this:\n  (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n   else flip (silent_move_from t xm'))\n   (x'', m'') xm\n  thr s'' t = \\<lfloor>(x'', ln)\\<rfloor>\n  s' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n  (x'', m'') = (x'', shr s'')\n  silent_moves t xm' (x'', shr s'')\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "using \\<open>\\<not> \\<tau>diverge t xm'\\<close> \\<open>mthr.\\<tau>diverge s''\\<close>"], ["proof (prove)\nusing this:\n  (if \\<tau>diverge t xm' then \\<lambda>s s'. False\n   else flip (silent_move_from t xm'))\n   (x'', m'') xm\n  thr s'' t = \\<lfloor>(x'', ln)\\<rfloor>\n  s' =\n  (locks s'', ((thr s'')(t := None), shr s''), wset s'', interrupts s'')\n  (x'', m'') = (x'', shr s'')\n  silent_moves t xm' (x'', shr s'')\n  \\<not> \\<tau>diverge t xm'\n  mthr.\\<tau>diverge s''\n\ngoal (1 subgoal):\n 1. \\<exists>s' t'.\n       ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n         else flip (silent_move_from t xm'))\n         t' xm \\<and>\n        s' = s' \\<or>\n        mthr.silent_movet s' s') \\<and>\n       ((\\<exists>s x.\n            thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n            (ln \\<noteq> no_wait_locks \\<or>\n             wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n            s' =\n            (locks s, ((thr s)(t := None), shr s), wset s,\n             interrupts s) \\<and>\n            t' = (x, shr s) \\<and>\n            mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n        mthr.\\<tau>diverge s')", "by blast"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n       else flip (silent_move_from t xm'))\n       t' xm \\<and>\n      s' = s' \\<or>\n      mthr.silent_movet s' s') \\<and>\n     ((\\<exists>s x.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s' =\n          (locks s, ((thr s)(t := None), shr s), wset s,\n           interrupts s) \\<and>\n          t' = (x, shr s) \\<and>\n          mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n      mthr.\\<tau>diverge s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s' t'.\n     ((if \\<tau>diverge t xm' then \\<lambda>s s'. False\n       else flip (silent_move_from t xm'))\n       t' xm \\<and>\n      s' = s' \\<or>\n      mthr.silent_movet s' s') \\<and>\n     ((\\<exists>s x.\n          thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n          (ln \\<noteq> no_wait_locks \\<or>\n           wset s t \\<noteq> None \\<or> \\<not> \\<tau>diverge t xm') \\<and>\n          s' =\n          (locks s, ((thr s)(t := None), shr s), wset s,\n           interrupts s) \\<and>\n          t' = (x, shr s) \\<and>\n          mthr.\\<tau>diverge s \\<and> silent_moves t xm' t') \\<or>\n      mthr.\\<tau>diverge s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mthr.\\<tau>diverge s'\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "}"], ["proof (state)\nthis:\n  mthr.\\<tau>diverge s'\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "ultimately"], ["proof (chain)\npicking this:\n  A = dom (thr s')\n  mthr.\\<tau>diverge s'", "have \"\\<exists>t x. thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> wset s' t = None \\<and> \\<tau>diverge t (x, shr s')\""], ["proof (prove)\nusing this:\n  A = dom (thr s')\n  mthr.\\<tau>diverge s'\n\ngoal (1 subgoal):\n 1. \\<exists>t x.\n       thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s' t = None \\<and> \\<tau>diverge t (x, shr s')", "by(rule IH)"], ["proof (state)\nthis:\n  \\<exists>t x.\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     wset s' t = None \\<and> \\<tau>diverge t (x, shr s')\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>t x.\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     wset s' t = None \\<and> \\<tau>diverge t (x, shr s')", "obtain t' x' where \"thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\"\n      and \"wset s' t' = None\" and \"\\<tau>diverge t' (x', shr s')\""], ["proof (prove)\nusing this:\n  \\<exists>t x.\n     thr s' t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     wset s' t = None \\<and> \\<tau>diverge t (x, shr s')\n\ngoal (1 subgoal):\n 1. (\\<And>t' x'.\n        \\<lbrakk>thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>;\n         wset s' t' = None; \\<tau>diverge t' (x', shr s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  \\<tau>diverge t' (x', shr s')\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "moreover"], ["proof (state)\nthis:\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  \\<tau>diverge t' (x', shr s')\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  \\<tau>diverge t' (x', shr s')", "have \"t' \\<noteq> t\""], ["proof (prove)\nusing this:\n  \\<not> (ln = no_wait_locks \\<and>\n          \\<tau>diverge t (x, shr s) \\<and> wset s t = None)\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  \\<tau>diverge t' (x', shr s')\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t", "by(auto simp add: s'_def)"], ["proof (state)\nthis:\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "ultimately"], ["proof (chain)\npicking this:\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  \\<tau>diverge t' (x', shr s')\n  t' \\<noteq> t", "have \"thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\" \"wset s t' = None\" \"\\<tau>diverge t' (x', shr s)\""], ["proof (prove)\nusing this:\n  thr s' t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s' t' = None\n  \\<tau>diverge t' (x', shr s')\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor> &&&\n    wset s t' = None &&& \\<tau>diverge t' (x', shr s)", "unfolding s'_def"], ["proof (prove)\nusing this:\n  thr (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) t' =\n  \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset (locks s, ((thr s)(t := None), shr s), wset s, interrupts s) t' =\n  None\n  \\<tau>diverge t'\n   (x', shr (locks s, ((thr s)(t := None), shr s), wset s, interrupts s))\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor> &&&\n    wset s t' = None &&& \\<tau>diverge t' (x', shr s)", "by auto"], ["proof (state)\nthis:\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s t' = None\n  \\<tau>diverge t' (x', shr s)\n\ngoal (1 subgoal):\n 1. \\<not> (ln = no_wait_locks \\<and>\n            \\<tau>diverge t (x, shr s) \\<and>\n            wset s t = None) \\<Longrightarrow>\n    \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  thr s t' = \\<lfloor>(x', no_wait_locks)\\<rfloor>\n  wset s t' = None\n  \\<tau>diverge t' (x', shr s)\n\ngoal (1 subgoal):\n 1. \\<exists>t x.\n       thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       wset s t = None \\<and> \\<tau>diverge t (x, shr s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>t x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     wset s t = None \\<and> \\<tau>diverge t (x, shr s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t x.\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     wset s t = None \\<and> \\<tau>diverge t (x, shr s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>mredT_preserves_final_thread:\n  \"\\<lbrakk> \\<tau>mredT s s'; final_thread s t \\<rbrakk> \\<Longrightarrow> final_thread s' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>mredT s s'; final_thread s t\\<rbrakk>\n    \\<Longrightarrow> final_thread s' t", "by(auto elim: mthr.silent_move.cases intro: redT_preserves_final_thread)"], ["", "lemma \\<tau>mRedT_preserves_final_thread:\n  \"\\<lbrakk> \\<tau>mredT^** s s'; final_thread s t \\<rbrakk> \\<Longrightarrow> final_thread s' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mthr.silent_moves s s'; final_thread s t\\<rbrakk>\n    \\<Longrightarrow> final_thread s' t", "by(induct rule: rtranclp.induct)(blast intro: \\<tau>mredT_preserves_final_thread)+"], ["", "lemma silent_moves2_silentD:\n  assumes \"rtrancl3p mthr.silent_move2 s ttas s'\"\n  and \"(t, ta) \\<in> set ttas\"\n  shows \"ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  mthr.silent_moves2 s ttas s'\n  (t, ta) \\<in> set ttas\n\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "by(induct)(auto simp add: mthr.silent_move2_def dest: m\\<tau>move_silentD)"], ["", "lemma inf_step_silentD:\n  assumes step: \"trsys.inf_step mthr.silent_move2 s ttas\"\n  and lset: \"(t, ta) \\<in> lset ttas\"\n  shows \"ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "using lset step"], ["proof (prove)\nusing this:\n  (t, ta) \\<in> lset ttas\n  trsys.inf_step mthr.silent_move2 s ttas\n\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "by(induct arbitrary: s rule: lset_induct)(fastforce elim: trsys.inf_step.cases simp add: mthr.silent_move2_def dest: m\\<tau>move_silentD)+"], ["", "end"], ["", "subsection \\<open>The multithreaded semantics with a well-founded relation on states\\<close>"], ["", "locale multithreaded_base_measure = multithreaded_base +\n  constrains final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  fixes \\<mu> :: \"('x \\<times> 'm) \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> bool\"\nbegin"], ["", "inductive m\\<mu>t :: \"'m \\<Rightarrow> ('l,'t,'x) thread_info \\<Rightarrow> ('l,'t,'x) thread_info \\<Rightarrow> bool\"\nfor m and ts and ts'\nwhere\n  m\\<mu>tI:\n  \"\\<And>ln. \\<lbrakk> finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>; ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m); \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t' \\<rbrakk>\n  \\<Longrightarrow> m\\<mu>t m ts ts'\""], ["", "definition m\\<mu> :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> ('l,'t,'x,'m,'w) state \\<Rightarrow> bool\"\nwhere \"m\\<mu> s s' \\<longleftrightarrow> shr s = shr s' \\<and> m\\<mu>t (shr s) (thr s) (thr s')\""], ["", "lemma m\\<mu>t_thr_dom_eq: \"m\\<mu>t m ts ts' \\<Longrightarrow> dom ts = dom ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m\\<mu>t m ts ts' \\<Longrightarrow> dom ts = dom ts'", "apply(erule m\\<mu>t.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x x' ln' ln.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t'\\<rbrakk>\n       \\<Longrightarrow> dom ts = dom ts'", "apply(rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x x' ln' ln.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t'\\<rbrakk>\n       \\<Longrightarrow> dom ts \\<subseteq> dom ts'\n 2. \\<And>t x x' ln' ln.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t'\\<rbrakk>\n       \\<Longrightarrow> dom ts' \\<subseteq> dom ts", "apply(rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x x' ln' ln xa.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t';\n        xa \\<in> dom ts\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> dom ts'\n 2. \\<And>t x x' ln' ln.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t'\\<rbrakk>\n       \\<Longrightarrow> dom ts' \\<subseteq> dom ts", "apply(case_tac \"xa = t\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x x' ln' ln xa.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t';\n        xa \\<in> dom ts; xa = t\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> dom ts'\n 2. \\<And>t x x' ln' ln xa.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t';\n        xa \\<in> dom ts; xa \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> dom ts'\n 3. \\<And>t x x' ln' ln.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t'\\<rbrakk>\n       \\<Longrightarrow> dom ts' \\<subseteq> dom ts", "apply(auto)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x x' ln' ln.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t'\\<rbrakk>\n       \\<Longrightarrow> dom ts' \\<subseteq> dom ts", "apply(rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x x' ln' ln xa.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t';\n        xa \\<in> dom ts'\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> dom ts", "apply(case_tac \"xa = t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x x' ln' ln xa.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t';\n        xa \\<in> dom ts'; xa = t\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> dom ts\n 2. \\<And>t x x' ln' ln xa.\n       \\<lbrakk>finite (dom ts); ts t = \\<lfloor>(x, ln)\\<rfloor>;\n        ts' t = \\<lfloor>(x', ln')\\<rfloor>; \\<mu> (x, m) (x', m);\n        \\<And>t'. t' \\<noteq> t \\<Longrightarrow> ts t' = ts' t';\n        xa \\<in> dom ts'; xa \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> dom ts", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma m\\<mu>_finite_thrD:\n  assumes \"m\\<mu>t m ts ts'\"\n  shows \"finite (dom ts)\" \"finite (dom ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom ts) &&& finite (dom ts')", "using assms"], ["proof (prove)\nusing this:\n  m\\<mu>t m ts ts'\n\ngoal (1 subgoal):\n 1. finite (dom ts) &&& finite (dom ts')", "by(simp_all add: m\\<mu>t_thr_dom_eq[symmetric])(auto elim: m\\<mu>t.cases)"], ["", "end"], ["", "locale multithreaded_base_measure_wf = multithreaded_base_measure +\n  constrains final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \\<mu> :: \"('x \\<times> 'm) \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> bool\"\n  assumes wf_\\<mu>: \"wfP \\<mu>\"\nbegin"], ["", "lemma wf_m\\<mu>t: \"wfP (m\\<mu>t m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (m\\<mu>t m)", "unfolding wfP_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q)", "proof(intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "fix Q :: \"('l,'t,'x) thread_info set\" and ts"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "assume \"ts \\<in> Q\""], ["proof (state)\nthis:\n  ts \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "show \"\\<exists>z\\<in>Q. \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "proof(cases \"finite (dom ts)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n 2. infinite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "case False"], ["proof (state)\nthis:\n  infinite (dom ts)\n\ngoal (2 subgoals):\n 1. finite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n 2. infinite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "hence \"\\<forall>y. m\\<mu>t m y ts \\<longrightarrow> y \\<notin> Q\""], ["proof (prove)\nusing this:\n  infinite (dom ts)\n\ngoal (1 subgoal):\n 1. \\<forall>y. m\\<mu>t m y ts \\<longrightarrow> y \\<notin> Q", "by(auto dest: m\\<mu>_finite_thrD)"], ["proof (state)\nthis:\n  \\<forall>y. m\\<mu>t m y ts \\<longrightarrow> y \\<notin> Q\n\ngoal (2 subgoals):\n 1. finite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n 2. infinite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y. m\\<mu>t m y ts \\<longrightarrow> y \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "using \\<open>ts \\<in> Q\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y. m\\<mu>t m y ts \\<longrightarrow> y \\<notin> Q\n  ts \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "by blast"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q. \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n\ngoal (1 subgoal):\n 1. finite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "case True"], ["proof (state)\nthis:\n  finite (dom ts)\n\ngoal (1 subgoal):\n 1. finite (dom ts) \\<Longrightarrow>\n    \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (dom ts)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "using \\<open>ts \\<in> Q\\<close>"], ["proof (prove)\nusing this:\n  finite (dom ts)\n  ts \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "proof(induct A\\<equiv>\"dom ts\" arbitrary: ts Q rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts Q.\n       \\<lbrakk>{} = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n 2. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "case empty"], ["proof (state)\nthis:\n  {} = dom ts\n  ts \\<in> Q\n\ngoal (2 subgoals):\n 1. \\<And>ts Q.\n       \\<lbrakk>{} = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n 2. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "hence \"dom ts = {}\""], ["proof (prove)\nusing this:\n  {} = dom ts\n  ts \\<in> Q\n\ngoal (1 subgoal):\n 1. dom ts = {}", "by simp"], ["proof (state)\nthis:\n  dom ts = {}\n\ngoal (2 subgoals):\n 1. \\<And>ts Q.\n       \\<lbrakk>{} = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n 2. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "with \\<open>ts \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  ts \\<in> Q\n  dom ts = {}", "show ?case"], ["proof (prove)\nusing this:\n  ts \\<in> Q\n  dom ts = {}\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "by(auto elim: m\\<mu>t.cases)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q. \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "case (insert t A)"], ["proof (state)\nthis:\n  finite A\n  t \\<notin> A\n  \\<lbrakk>A = dom ?ts12; ?ts12 \\<in> ?Q12\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z\\<in>?Q12.\n                       \\<forall>y.\n                          m\\<mu>t m y z \\<longrightarrow> y \\<notin> ?Q12\n  insert t A = dom ts\n  ts \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "note IH = \\<open>\\<And>ts Q. \\<lbrakk>A = dom ts; ts \\<in> Q\\<rbrakk> \\<Longrightarrow> \\<exists>z\\<in>Q. \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>A = dom ?ts; ?ts \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z\\<in>?Q.\n                       \\<forall>y.\n                          m\\<mu>t m y z \\<longrightarrow> y \\<notin> ?Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "define Q' where \"Q' = {ts. ts t = None \\<and> (\\<exists>xln. ts(t \\<mapsto> xln) \\<in> Q)}\""], ["proof (state)\nthis:\n  Q' = {ts. ts t = None \\<and> (\\<exists>xln. ts(t \\<mapsto> xln) \\<in> Q)}\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "let ?ts' = \"ts(t := None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "from \\<open>insert t A = dom ts\\<close> \\<open>t \\<notin> A\\<close>"], ["proof (chain)\npicking this:\n  insert t A = dom ts\n  t \\<notin> A", "have \"A = dom ?ts'\""], ["proof (prove)\nusing this:\n  insert t A = dom ts\n  t \\<notin> A\n\ngoal (1 subgoal):\n 1. A = dom (ts(t := None))", "by auto"], ["proof (state)\nthis:\n  A = dom (ts(t := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  A = dom (ts(t := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "from \\<open>insert t A = dom ts\\<close>"], ["proof (chain)\npicking this:\n  insert t A = dom ts", "obtain xln where \"ts t = \\<lfloor>xln\\<rfloor>\""], ["proof (prove)\nusing this:\n  insert t A = dom ts\n\ngoal (1 subgoal):\n 1. (\\<And>xln.\n        ts t = \\<lfloor>xln\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"ts t\") auto"], ["proof (state)\nthis:\n  ts t = \\<lfloor>xln\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "hence \"ts(t \\<mapsto> xln) = ts\""], ["proof (prove)\nusing this:\n  ts t = \\<lfloor>xln\\<rfloor>\n\ngoal (1 subgoal):\n 1. ts(t \\<mapsto> xln) = ts", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  ts(t \\<mapsto> xln) = ts\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "with \\<open>ts \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  ts \\<in> Q\n  ts(t \\<mapsto> xln) = ts", "have \"ts(t \\<mapsto> xln) \\<in> Q\""], ["proof (prove)\nusing this:\n  ts \\<in> Q\n  ts(t \\<mapsto> xln) = ts\n\ngoal (1 subgoal):\n 1. ts(t \\<mapsto> xln) \\<in> Q", "by(auto)"], ["proof (state)\nthis:\n  ts(t \\<mapsto> xln) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "hence \"?ts' \\<in> Q'\""], ["proof (prove)\nusing this:\n  ts(t \\<mapsto> xln) \\<in> Q\n\ngoal (1 subgoal):\n 1. ts(t := None) \\<in> Q'", "unfolding Q'_def"], ["proof (prove)\nusing this:\n  ts(t \\<mapsto> xln) \\<in> Q\n\ngoal (1 subgoal):\n 1. ts(t := None)\n    \\<in> {ts.\n           ts t = None \\<and> (\\<exists>xln. ts(t \\<mapsto> xln) \\<in> Q)}", "by(auto simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  ts(t := None) \\<in> Q'\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "ultimately"], ["proof (chain)\npicking this:\n  A = dom (ts(t := None))\n  ts(t := None) \\<in> Q'", "have \"\\<exists>z\\<in>Q'. \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q'\""], ["proof (prove)\nusing this:\n  A = dom (ts(t := None))\n  ts(t := None) \\<in> Q'\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q'.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q'", "by(rule IH)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q'.\n     \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q'\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>Q'.\n     \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q'", "obtain ts' where \"ts' \\<in> Q'\" \n        and min: \"\\<And>ts''. m\\<mu>t m ts'' ts' \\<Longrightarrow> ts'' \\<notin> Q'\""], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>Q'.\n     \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'.\n        \\<lbrakk>ts' \\<in> Q';\n         \\<And>ts''.\n            m\\<mu>t m ts'' ts' \\<Longrightarrow> ts'' \\<notin> Q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ts' \\<in> Q'\n  m\\<mu>t m ?ts''12 ts' \\<Longrightarrow> ?ts''12 \\<notin> Q'\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "from \\<open>ts' \\<in> Q'\\<close>"], ["proof (chain)\npicking this:\n  ts' \\<in> Q'", "obtain x' ln' where \"ts' t = None\" \"ts'(t \\<mapsto> (x', ln')) \\<in> Q\""], ["proof (prove)\nusing this:\n  ts' \\<in> Q'\n\ngoal (1 subgoal):\n 1. (\\<And>x' ln'.\n        \\<lbrakk>ts' t = None; ts'(t \\<mapsto> (x', ln')) \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Q'_def"], ["proof (prove)\nusing this:\n  ts'\n  \\<in> {ts. ts t = None \\<and> (\\<exists>xln. ts(t \\<mapsto> xln) \\<in> Q)}\n\ngoal (1 subgoal):\n 1. (\\<And>x' ln'.\n        \\<lbrakk>ts' t = None; ts'(t \\<mapsto> (x', ln')) \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ts' t = None\n  ts'(t \\<mapsto> (x', ln')) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "define Q'' where \"Q'' = {(x, m)|x. \\<exists>ln. ts'(t \\<mapsto> (x, ln)) \\<in> Q}\""], ["proof (state)\nthis:\n  Q'' = {(x, m) |x. \\<exists>ln. ts'(t \\<mapsto> (x, ln)) \\<in> Q}\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "from \\<open>ts'(t \\<mapsto> (x', ln')) \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  ts'(t \\<mapsto> (x', ln')) \\<in> Q", "have \"(x', m) \\<in> Q''\""], ["proof (prove)\nusing this:\n  ts'(t \\<mapsto> (x', ln')) \\<in> Q\n\ngoal (1 subgoal):\n 1. (x', m) \\<in> Q''", "unfolding Q''_def"], ["proof (prove)\nusing this:\n  ts'(t \\<mapsto> (x', ln')) \\<in> Q\n\ngoal (1 subgoal):\n 1. (x', m) \\<in> {(x, m) |x. \\<exists>ln. ts'(t \\<mapsto> (x, ln)) \\<in> Q}", "by blast"], ["proof (state)\nthis:\n  (x', m) \\<in> Q''\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "hence \"\\<exists>xm''\\<in>Q''. \\<forall>xm'''. \\<mu> xm''' xm'' \\<longrightarrow> xm''' \\<notin> Q''\""], ["proof (prove)\nusing this:\n  (x', m) \\<in> Q''\n\ngoal (1 subgoal):\n 1. \\<exists>xm''\\<in>Q''.\n       \\<forall>xm'''. \\<mu> xm''' xm'' \\<longrightarrow> xm''' \\<notin> Q''", "by(rule wf_\\<mu>[unfolded wfP_eq_minimal, rule_format])"], ["proof (state)\nthis:\n  \\<exists>xm''\\<in>Q''.\n     \\<forall>xm'''. \\<mu> xm''' xm'' \\<longrightarrow> xm''' \\<notin> Q''\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "then"], ["proof (chain)\npicking this:\n  \\<exists>xm''\\<in>Q''.\n     \\<forall>xm'''. \\<mu> xm''' xm'' \\<longrightarrow> xm''' \\<notin> Q''", "obtain xm'' where \"xm'' \\<in> Q''\" and min': \"\\<And>xm'''. \\<mu> xm''' xm'' \\<Longrightarrow> xm''' \\<notin> Q''\""], ["proof (prove)\nusing this:\n  \\<exists>xm''\\<in>Q''.\n     \\<forall>xm'''. \\<mu> xm''' xm'' \\<longrightarrow> xm''' \\<notin> Q''\n\ngoal (1 subgoal):\n 1. (\\<And>xm''.\n        \\<lbrakk>xm'' \\<in> Q'';\n         \\<And>xm'''.\n            \\<mu> xm''' xm'' \\<Longrightarrow> xm''' \\<notin> Q''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xm'' \\<in> Q''\n  \\<mu> ?xm'''12 xm'' \\<Longrightarrow> ?xm'''12 \\<notin> Q''\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "from \\<open>xm'' \\<in> Q''\\<close>"], ["proof (chain)\npicking this:\n  xm'' \\<in> Q''", "obtain x'' ln'' where \"xm'' = (x'', m)\" \"ts'(t \\<mapsto> (x'', ln'')) \\<in> Q\""], ["proof (prove)\nusing this:\n  xm'' \\<in> Q''\n\ngoal (1 subgoal):\n 1. (\\<And>x'' ln''.\n        \\<lbrakk>xm'' = (x'', m);\n         ts'(t \\<mapsto> (x'', ln'')) \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Q''_def"], ["proof (prove)\nusing this:\n  xm'' \\<in> {(x, m) |x. \\<exists>ln. ts'(t \\<mapsto> (x, ln)) \\<in> Q}\n\ngoal (1 subgoal):\n 1. (\\<And>x'' ln''.\n        \\<lbrakk>xm'' = (x'', m);\n         ts'(t \\<mapsto> (x'', ln'')) \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xm'' = (x'', m)\n  ts'(t \\<mapsto> (x'', ln'')) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  xm'' = (x'', m)\n  ts'(t \\<mapsto> (x'', ln'')) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "{"], ["proof (state)\nthis:\n  xm'' = (x'', m)\n  ts'(t \\<mapsto> (x'', ln'')) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "fix ts''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "assume \"m\\<mu>t m ts'' (ts'(t \\<mapsto> (x'', ln'')))\""], ["proof (state)\nthis:\n  m\\<mu>t m ts'' (ts'(t \\<mapsto> (x'', ln'')))\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "then"], ["proof (chain)\npicking this:\n  m\\<mu>t m ts'' (ts'(t \\<mapsto> (x'', ln'')))", "obtain T X'' LN'' X' LN'\n          where \"finite (dom ts'')\" \"ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>\" \n          and \"(ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>\" \"\\<mu> (X'', m) (X', m)\"\n          and eq: \"\\<And>t'. t' \\<noteq> T \\<Longrightarrow> ts'' t' = (ts'(t \\<mapsto> (x'', ln''))) t'\""], ["proof (prove)\nusing this:\n  m\\<mu>t m ts'' (ts'(t \\<mapsto> (x'', ln'')))\n\ngoal (1 subgoal):\n 1. (\\<And>T X'' LN'' X' LN'.\n        \\<lbrakk>finite (dom ts''); ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>;\n         (ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>;\n         \\<mu> (X'', m) (X', m);\n         \\<And>t'.\n            t' \\<noteq> T \\<Longrightarrow>\n            ts'' t' = (ts'(t \\<mapsto> (x'', ln''))) t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases) blast"], ["proof (state)\nthis:\n  finite (dom ts'')\n  ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>\n  (ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>\n  \\<mu> (X'', m) (X', m)\n  ?t'12 \\<noteq> T \\<Longrightarrow>\n  ts'' ?t'12 = (ts'(t \\<mapsto> (x'', ln''))) ?t'12\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "have \"ts'' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts'' \\<notin> Q", "proof(cases \"T = t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. T = t \\<Longrightarrow> ts'' \\<notin> Q\n 2. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "case True"], ["proof (state)\nthis:\n  T = t\n\ngoal (2 subgoals):\n 1. T = t \\<Longrightarrow> ts'' \\<notin> Q\n 2. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "from True \\<open>(ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  T = t\n  (ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>", "have \"X' = x''\""], ["proof (prove)\nusing this:\n  T = t\n  (ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>\n\ngoal (1 subgoal):\n 1. X' = x''", "by simp"], ["proof (state)\nthis:\n  X' = x''\n\ngoal (2 subgoals):\n 1. T = t \\<Longrightarrow> ts'' \\<notin> Q\n 2. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "with \\<open>\\<mu> (X'', m) (X', m)\\<close>"], ["proof (chain)\npicking this:\n  \\<mu> (X'', m) (X', m)\n  X' = x''", "have \"(X'', m) \\<notin> Q''\""], ["proof (prove)\nusing this:\n  \\<mu> (X'', m) (X', m)\n  X' = x''\n\ngoal (1 subgoal):\n 1. (X'', m) \\<notin> Q''", "by(auto dest: min'[unfolded \\<open>xm'' = (x'', m)\\<close>])"], ["proof (state)\nthis:\n  (X'', m) \\<notin> Q''\n\ngoal (2 subgoals):\n 1. T = t \\<Longrightarrow> ts'' \\<notin> Q\n 2. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "hence \"\\<forall>ln. ts'(t \\<mapsto> (X'', ln)) \\<notin> Q\""], ["proof (prove)\nusing this:\n  (X'', m) \\<notin> Q''\n\ngoal (1 subgoal):\n 1. \\<forall>ln. ts'(t \\<mapsto> (X'', ln)) \\<notin> Q", "by(simp add: Q''_def)"], ["proof (state)\nthis:\n  \\<forall>ln. ts'(t \\<mapsto> (X'', ln)) \\<notin> Q\n\ngoal (2 subgoals):\n 1. T = t \\<Longrightarrow> ts'' \\<notin> Q\n 2. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  \\<forall>ln. ts'(t \\<mapsto> (X'', ln)) \\<notin> Q\n\ngoal (2 subgoals):\n 1. T = t \\<Longrightarrow> ts'' \\<notin> Q\n 2. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "from \\<open>ts' t = None\\<close> eq True"], ["proof (chain)\npicking this:\n  ts' t = None\n  ?t'12 \\<noteq> T \\<Longrightarrow>\n  ts'' ?t'12 = (ts'(t \\<mapsto> (x'', ln''))) ?t'12\n  T = t", "have \"ts''(t := None) = ts'\""], ["proof (prove)\nusing this:\n  ts' t = None\n  ?t'12 \\<noteq> T \\<Longrightarrow>\n  ts'' ?t'12 = (ts'(t \\<mapsto> (x'', ln''))) ?t'12\n  T = t\n\ngoal (1 subgoal):\n 1. ts''(t := None) = ts'", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  ts''(t := None) = ts'\n\ngoal (2 subgoals):\n 1. T = t \\<Longrightarrow> ts'' \\<notin> Q\n 2. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "with \\<open>ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>\\<close> True"], ["proof (chain)\npicking this:\n  ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>\n  T = t\n  ts''(t := None) = ts'", "have ts'': \"ts'' = ts'(t \\<mapsto> (X'', LN''))\""], ["proof (prove)\nusing this:\n  ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>\n  T = t\n  ts''(t := None) = ts'\n\ngoal (1 subgoal):\n 1. ts'' = ts'(t \\<mapsto> (X'', LN''))", "by(auto intro!: ext)"], ["proof (state)\nthis:\n  ts'' = ts'(t \\<mapsto> (X'', LN''))\n\ngoal (2 subgoals):\n 1. T = t \\<Longrightarrow> ts'' \\<notin> Q\n 2. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>ln. ts'(t \\<mapsto> (X'', ln)) \\<notin> Q\n  ts'' = ts'(t \\<mapsto> (X'', LN''))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ln. ts'(t \\<mapsto> (X'', ln)) \\<notin> Q\n  ts'' = ts'(t \\<mapsto> (X'', LN''))\n\ngoal (1 subgoal):\n 1. ts'' \\<notin> Q", "by blast"], ["proof (state)\nthis:\n  ts'' \\<notin> Q\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "case False"], ["proof (state)\nthis:\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "from \\<open>finite (dom ts'')\\<close>"], ["proof (chain)\npicking this:\n  finite (dom ts'')", "have \"finite (dom (ts''(t := None)))\""], ["proof (prove)\nusing this:\n  finite (dom ts'')\n\ngoal (1 subgoal):\n 1. finite (dom (ts''(t := None)))", "by simp"], ["proof (state)\nthis:\n  finite (dom (ts''(t := None)))\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  finite (dom (ts''(t := None)))\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "from \\<open>ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>\\<close> False"], ["proof (chain)\npicking this:\n  ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>\n  T \\<noteq> t", "have \"(ts''(t := None)) T = \\<lfloor>(X'', LN'')\\<rfloor>\""], ["proof (prove)\nusing this:\n  ts'' T = \\<lfloor>(X'', LN'')\\<rfloor>\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. (ts''(t := None)) T = \\<lfloor>(X'', LN'')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  (ts''(t := None)) T = \\<lfloor>(X'', LN'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "moreover"], ["proof (state)\nthis:\n  (ts''(t := None)) T = \\<lfloor>(X'', LN'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "from \\<open>(ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>\\<close> False"], ["proof (chain)\npicking this:\n  (ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>\n  T \\<noteq> t", "have \"ts' T = \\<lfloor>(X', LN')\\<rfloor>\""], ["proof (prove)\nusing this:\n  (ts'(t \\<mapsto> (x'', ln''))) T = \\<lfloor>(X', LN')\\<rfloor>\n  T \\<noteq> t\n\ngoal (1 subgoal):\n 1. ts' T = \\<lfloor>(X', LN')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  ts' T = \\<lfloor>(X', LN')\\<rfloor>\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "ultimately"], ["proof (chain)\npicking this:\n  finite (dom (ts''(t := None)))\n  (ts''(t := None)) T = \\<lfloor>(X'', LN'')\\<rfloor>\n  ts' T = \\<lfloor>(X', LN')\\<rfloor>", "have \"m\\<mu>t m (ts''(t := None)) ts'\""], ["proof (prove)\nusing this:\n  finite (dom (ts''(t := None)))\n  (ts''(t := None)) T = \\<lfloor>(X'', LN'')\\<rfloor>\n  ts' T = \\<lfloor>(X', LN')\\<rfloor>\n\ngoal (1 subgoal):\n 1. m\\<mu>t m (ts''(t := None)) ts'", "using \\<open>\\<mu> (X'', m) (X', m)\\<close>"], ["proof (prove)\nusing this:\n  finite (dom (ts''(t := None)))\n  (ts''(t := None)) T = \\<lfloor>(X'', LN'')\\<rfloor>\n  ts' T = \\<lfloor>(X', LN')\\<rfloor>\n  \\<mu> (X'', m) (X', m)\n\ngoal (1 subgoal):\n 1. m\\<mu>t m (ts''(t := None)) ts'", "proof(rule m\\<mu>tI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'. t' \\<noteq> T \\<Longrightarrow> (ts''(t := None)) t' = ts' t'", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'. t' \\<noteq> T \\<Longrightarrow> (ts''(t := None)) t' = ts' t'", "assume \"t' \\<noteq> T\""], ["proof (state)\nthis:\n  t' \\<noteq> T\n\ngoal (1 subgoal):\n 1. \\<And>t'. t' \\<noteq> T \\<Longrightarrow> (ts''(t := None)) t' = ts' t'", "with eq[OF False[symmetric]] eq[OF this] \\<open>ts' t = None\\<close>"], ["proof (chain)\npicking this:\n  ts'' t = (ts'(t \\<mapsto> (x'', ln''))) t\n  ts'' t' = (ts'(t \\<mapsto> (x'', ln''))) t'\n  ts' t = None\n  t' \\<noteq> T", "show \"(ts''(t := None)) t' = ts' t'\""], ["proof (prove)\nusing this:\n  ts'' t = (ts'(t \\<mapsto> (x'', ln''))) t\n  ts'' t' = (ts'(t \\<mapsto> (x'', ln''))) t'\n  ts' t = None\n  t' \\<noteq> T\n\ngoal (1 subgoal):\n 1. (ts''(t := None)) t' = ts' t'", "by auto"], ["proof (state)\nthis:\n  (ts''(t := None)) t' = ts' t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m\\<mu>t m (ts''(t := None)) ts'\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "hence \"ts''(t := None) \\<notin> Q'\""], ["proof (prove)\nusing this:\n  m\\<mu>t m (ts''(t := None)) ts'\n\ngoal (1 subgoal):\n 1. ts''(t := None) \\<notin> Q'", "by(rule min)"], ["proof (state)\nthis:\n  ts''(t := None) \\<notin> Q'\n\ngoal (1 subgoal):\n 1. T \\<noteq> t \\<Longrightarrow> ts'' \\<notin> Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts''(t := None) \\<notin> Q'\n\ngoal (1 subgoal):\n 1. ts'' \\<notin> Q", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. ts'' \\<in> Q \\<Longrightarrow> ts''(t := None) \\<in> Q'", "assume \"ts'' \\<in> Q\""], ["proof (state)\nthis:\n  ts'' \\<in> Q\n\ngoal (1 subgoal):\n 1. ts'' \\<in> Q \\<Longrightarrow> ts''(t := None) \\<in> Q'", "from eq[OF False[symmetric]]"], ["proof (chain)\npicking this:\n  ts'' t = (ts'(t \\<mapsto> (x'', ln''))) t", "have \"ts'' t = \\<lfloor>(x'', ln'')\\<rfloor>\""], ["proof (prove)\nusing this:\n  ts'' t = (ts'(t \\<mapsto> (x'', ln''))) t\n\ngoal (1 subgoal):\n 1. ts'' t = \\<lfloor>(x'', ln'')\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  ts'' t = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. ts'' \\<in> Q \\<Longrightarrow> ts''(t := None) \\<in> Q'", "hence ts'': \"ts''(t \\<mapsto> (x'', ln'')) = ts''\""], ["proof (prove)\nusing this:\n  ts'' t = \\<lfloor>(x'', ln'')\\<rfloor>\n\ngoal (1 subgoal):\n 1. ts''(t \\<mapsto> (x'', ln'')) = ts''", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  ts''(t \\<mapsto> (x'', ln'')) = ts''\n\ngoal (1 subgoal):\n 1. ts'' \\<in> Q \\<Longrightarrow> ts''(t := None) \\<in> Q'", "from \\<open>ts'' \\<in> Q\\<close>"], ["proof (chain)\npicking this:\n  ts'' \\<in> Q", "have \"ts''(t \\<mapsto> (x'', ln'')) \\<in> Q\""], ["proof (prove)\nusing this:\n  ts'' \\<in> Q\n\ngoal (1 subgoal):\n 1. ts''(t \\<mapsto> (x'', ln'')) \\<in> Q", "unfolding ts''"], ["proof (prove)\nusing this:\n  ts'' \\<in> Q\n\ngoal (1 subgoal):\n 1. ts'' \\<in> Q", "."], ["proof (state)\nthis:\n  ts''(t \\<mapsto> (x'', ln'')) \\<in> Q\n\ngoal (1 subgoal):\n 1. ts'' \\<in> Q \\<Longrightarrow> ts''(t := None) \\<in> Q'", "thus \"ts''(t := None) \\<in> Q'\""], ["proof (prove)\nusing this:\n  ts''(t \\<mapsto> (x'', ln'')) \\<in> Q\n\ngoal (1 subgoal):\n 1. ts''(t := None) \\<in> Q'", "unfolding Q'_def"], ["proof (prove)\nusing this:\n  ts''(t \\<mapsto> (x'', ln'')) \\<in> Q\n\ngoal (1 subgoal):\n 1. ts''(t := None)\n    \\<in> {ts.\n           ts t = None \\<and> (\\<exists>xln. ts(t \\<mapsto> xln) \\<in> Q)}", "by auto"], ["proof (state)\nthis:\n  ts''(t := None) \\<in> Q'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ts'' \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ts'' \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "}"], ["proof (state)\nthis:\n  m\\<mu>t m ?ts''14 (ts'(t \\<mapsto> (x'', ln''))) \\<Longrightarrow>\n  ?ts''14 \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<And>x F ts Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>ts Q.\n           \\<lbrakk>F = dom ts; ts \\<in> Q\\<rbrakk>\n           \\<Longrightarrow> \\<exists>z\\<in>Q.\n                                \\<forall>y.\n                                   m\\<mu>t m y z \\<longrightarrow>\n                                   y \\<notin> Q;\n        insert x F = dom ts; ts \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "ultimately"], ["proof (chain)\npicking this:\n  xm'' = (x'', m)\n  ts'(t \\<mapsto> (x'', ln'')) \\<in> Q\n  m\\<mu>t m ?ts''14 (ts'(t \\<mapsto> (x'', ln''))) \\<Longrightarrow>\n  ?ts''14 \\<notin> Q", "show ?case"], ["proof (prove)\nusing this:\n  xm'' = (x'', m)\n  ts'(t \\<mapsto> (x'', ln'')) \\<in> Q\n  m\\<mu>t m ?ts''14 (ts'(t \\<mapsto> (x'', ln''))) \\<Longrightarrow>\n  ?ts''14 \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Q.\n       \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q", "by blast"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q. \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q. \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Q. \\<forall>y. m\\<mu>t m y z \\<longrightarrow> y \\<notin> Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_m\\<mu>: \"wfP m\\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP m\\<mu>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP m\\<mu>", "have \"wf (inv_image (same_fst (\\<lambda>m. True) (\\<lambda>m. {(ts, ts'). m\\<mu>t m ts ts'})) (\\<lambda>s. (shr s, thr s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image\n         (same_fst (\\<lambda>m. True)\n           (\\<lambda>m. {(ts, ts'). m\\<mu>t m ts ts'}))\n         (\\<lambda>s. (shr s, thr s)))", "by(rule wf_inv_image)(rule wf_same_fst, rule wf_m\\<mu>t[unfolded wfP_def])"], ["proof (state)\nthis:\n  wf (inv_image\n       (same_fst (\\<lambda>m. True)\n         (\\<lambda>m. {(ts, ts'). m\\<mu>t m ts ts'}))\n       (\\<lambda>s. (shr s, thr s)))\n\ngoal (1 subgoal):\n 1. wfP m\\<mu>", "also"], ["proof (state)\nthis:\n  wf (inv_image\n       (same_fst (\\<lambda>m. True)\n         (\\<lambda>m. {(ts, ts'). m\\<mu>t m ts ts'}))\n       (\\<lambda>s. (shr s, thr s)))\n\ngoal (1 subgoal):\n 1. wfP m\\<mu>", "have \"inv_image (same_fst (\\<lambda>m. True) (\\<lambda>m. {(ts, ts'). m\\<mu>t m ts ts'})) (\\<lambda>s. (shr s, thr s)) = {(s, s'). m\\<mu> s s'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_image\n     (same_fst (\\<lambda>m. True)\n       (\\<lambda>m. {(ts, ts'). m\\<mu>t m ts ts'}))\n     (\\<lambda>s. (shr s, thr s)) =\n    {(x, y). m\\<mu> x y}", "by(auto simp add: m\\<mu>_def same_fst_def)"], ["proof (state)\nthis:\n  inv_image\n   (same_fst (\\<lambda>m. True) (\\<lambda>m. {(ts, ts'). m\\<mu>t m ts ts'}))\n   (\\<lambda>s. (shr s, thr s)) =\n  {(x, y). m\\<mu> x y}\n\ngoal (1 subgoal):\n 1. wfP m\\<mu>", "finally"], ["proof (chain)\npicking this:\n  wf {(x, y). m\\<mu> x y}", "show ?thesis"], ["proof (prove)\nusing this:\n  wf {(x, y). m\\<mu> x y}\n\ngoal (1 subgoal):\n 1. wfP m\\<mu>", "by(simp add: wfP_def)"], ["proof (state)\nthis:\n  wfP m\\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}