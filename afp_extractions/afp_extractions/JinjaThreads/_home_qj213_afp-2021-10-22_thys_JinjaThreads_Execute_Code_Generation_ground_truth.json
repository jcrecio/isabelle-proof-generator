{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/Code_Generation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma insort_insert_key_code [code]:\n  \"insort_insert_key f x xs = \n  (if List.member (map f xs) (f x) then xs else insort_key f x xs)\"", "lemma eq_i_o_conv_single: \"eq_i_o = Predicate.single\"", "lemma eq_o_i_conv_single: \"eq_o_i = Predicate.single\"", "lemma sup_case_exp_case_exp_same:\n  \"sup_class.sup \n    (case_exp cNew cNewArray cCast cInstanceOf cVal cBinOp cVar cLAss cAAcc cAAss cALen cFAcc cFAss cCAS cCall cBlock cSync cInSync cSeq cCond cWhile cThrow cTry e)\n    (case_exp cNew' cNewArray' cCast' cInstanceOf' cVal' cBinOp' cVar' cLAss' cAAcc' cAAss' cALen' cFAcc' cFAss' cCAS' cCall' cBlock' cSync' cInSync' cSeq' cCond' cWhile' cThrow' cTry' e) =\n  (case e of\n    new C \\<Rightarrow> sup_class.sup (cNew C) (cNew' C)\n  | newArray T e \\<Rightarrow> sup_class.sup (cNewArray T e) (cNewArray' T e)\n  | Cast T e \\<Rightarrow> sup_class.sup (cCast T e) (cCast' T e)\n  | InstanceOf e T \\<Rightarrow> sup_class.sup (cInstanceOf e T) (cInstanceOf' e T)\n  | Val v \\<Rightarrow> sup_class.sup (cVal v) (cVal' v)\n  | BinOp e bop e' \\<Rightarrow> sup_class.sup (cBinOp e bop e') (cBinOp' e bop e')\n  | Var V \\<Rightarrow> sup_class.sup (cVar V) (cVar' V)\n  | LAss V e \\<Rightarrow> sup_class.sup (cLAss V e) (cLAss' V e)\n  | AAcc a e \\<Rightarrow> sup_class.sup (cAAcc a e) (cAAcc' a e)\n  | AAss a i e \\<Rightarrow> sup_class.sup (cAAss a i e) (cAAss' a i e)\n  | ALen a \\<Rightarrow> sup_class.sup (cALen a) (cALen' a)\n  | FAcc e F D \\<Rightarrow> sup_class.sup (cFAcc e F D) (cFAcc' e F D)\n  | FAss e F D e' \\<Rightarrow> sup_class.sup (cFAss e F D e') (cFAss' e F D e')\n  | CompareAndSwap e D F e' e'' \\<Rightarrow> sup_class.sup (cCAS e D F e' e'') (cCAS' e D F e' e'')\n  | Call e M es \\<Rightarrow> sup_class.sup (cCall e M es) (cCall' e M es)\n  | Block V T vo e \\<Rightarrow> sup_class.sup (cBlock V T vo e) (cBlock' V T vo e)\n  | Synchronized v e e' \\<Rightarrow> sup_class.sup (cSync v e e') (cSync' v e e')\n  | InSynchronized v a e \\<Rightarrow> sup_class.sup (cInSync v a e) (cInSync' v a e)\n  | Seq e e' \\<Rightarrow> sup_class.sup (cSeq e e') (cSeq' e e')\n  | Cond b e e' \\<Rightarrow> sup_class.sup (cCond b e e') (cCond' b e e')\n  | While b e \\<Rightarrow> sup_class.sup (cWhile b e) (cWhile' b e)\n  | throw e \\<Rightarrow> sup_class.sup (cThrow e) (cThrow' e)\n  | TryCatch e C V e' \\<Rightarrow> sup_class.sup (cTry e C V e') (cTry' e C V e'))\"", "lemma sup_case_exp_case_exp_other:\n  fixes p :: \"'a :: semilattice_sup\" shows\n  \"sup_class.sup \n    (case_exp cNew cNewArray cCast cInstanceOf cVal cBinOp cVar cLAss cAAcc cAAss cALen cFAcc cFAss cCAS cCall cBlock cSync cInSync cSeq cCond cWhile cThrow cTry e)\n    (sup_class.sup (case_exp cNew' cNewArray' cCast' cInstanceOf' cVal' cBinOp' cVar' cLAss' cAAcc' cAAss' cALen' cFAcc' cFAss' cCAS' cCall' cBlock' cSync' cInSync' cSeq' cCond' cWhile' cThrow' cTry' e) p) =\n  sup_class.sup (case e of\n    new C \\<Rightarrow> sup_class.sup (cNew C) (cNew' C)\n  | newArray T e \\<Rightarrow> sup_class.sup (cNewArray T e) (cNewArray' T e)\n  | Cast T e \\<Rightarrow> sup_class.sup (cCast T e) (cCast' T e)\n  | InstanceOf e T \\<Rightarrow> sup_class.sup (cInstanceOf e T) (cInstanceOf' e T)\n  | Val v \\<Rightarrow> sup_class.sup (cVal v) (cVal' v)\n  | BinOp e bop e' \\<Rightarrow> sup_class.sup (cBinOp e bop e') (cBinOp' e bop e')\n  | Var V \\<Rightarrow> sup_class.sup (cVar V) (cVar' V)\n  | LAss V e \\<Rightarrow> sup_class.sup (cLAss V e) (cLAss' V e)\n  | AAcc a e \\<Rightarrow> sup_class.sup (cAAcc a e) (cAAcc' a e)\n  | AAss a i e \\<Rightarrow> sup_class.sup (cAAss a i e) (cAAss' a i e)\n  | ALen a \\<Rightarrow> sup_class.sup (cALen a) (cALen' a)\n  | FAcc e F D \\<Rightarrow> sup_class.sup (cFAcc e F D) (cFAcc' e F D)\n  | FAss e F D e' \\<Rightarrow> sup_class.sup (cFAss e F D e') (cFAss' e F D e')\n  | CompareAndSwap e D F e' e'' \\<Rightarrow> sup_class.sup (cCAS e D F e' e'') (cCAS' e D F e' e'')\n  | Call e M es \\<Rightarrow> sup_class.sup (cCall e M es) (cCall' e M es)\n  | Block V T vo e \\<Rightarrow> sup_class.sup (cBlock V T vo e) (cBlock' V T vo e)\n  | Synchronized v e e' \\<Rightarrow> sup_class.sup (cSync v e e') (cSync' v e e')\n  | InSynchronized v a e \\<Rightarrow> sup_class.sup (cInSync v a e) (cInSync' v a e)\n  | Seq e e' \\<Rightarrow> sup_class.sup (cSeq e e') (cSeq' e e')\n  | Cond b e e' \\<Rightarrow> sup_class.sup (cCond b e e') (cCond' b e e')\n  | While b e \\<Rightarrow> sup_class.sup (cWhile b e) (cWhile' b e)\n  | throw e \\<Rightarrow> sup_class.sup (cThrow e) (cThrow' e)\n  | TryCatch e C V e' \\<Rightarrow> sup_class.sup (cTry e C V e') (cTry' e C V e')) p\"", "lemma sup_bot1: \"sup_class.sup bot a = (a :: 'a :: {semilattice_sup, order_bot})\"", "lemma sup_bot2: \"sup_class.sup a bot = (a :: 'a :: {semilattice_sup, order_bot})\"", "lemma sup_case_val_case_val_same:\n  \"sup_class.sup (case_val cUnit cNull cBool cIntg cAddr v) (case_val cUnit' cNull' cBool' cIntg' cAddr' v) =\n   (case v of\n     Unit \\<Rightarrow> sup_class.sup cUnit cUnit'\n   | Null \\<Rightarrow> sup_class.sup cNull cNull'\n   | Bool b \\<Rightarrow> sup_class.sup (cBool b) (cBool' b)\n   | Intg i \\<Rightarrow> sup_class.sup (cIntg i) (cIntg' i)\n   | Addr a \\<Rightarrow> sup_class.sup (cAddr a) (cAddr' a))\"", "lemma sup_case_bool_case_bool_same:\n  \"sup_class.sup (case_bool t f b) (case_bool t' f' b) =\n  (if b then sup_class.sup t t' else sup_class.sup f f')\"", "lemmas predicate_code_inline [code_unfold] =\n  Predicate.single_bind Predicate.bind_single split\n  eq_i_o_conv_single eq_o_i_conv_single\n  sup_case_exp_case_exp_same sup_case_exp_case_exp_other unit.case\n  sup_bot1 sup_bot2 sup_case_val_case_val_same sup_case_bool_case_bool_same", "lemma op_case_ty_case_ty_same:\n  \"f (case_ty cVoid cBoolean cInteger cNT cClass cArray e)\n     (case_ty cVoid' cBoolean' cInteger' cNT' cClass' cArray' e) =\n  (case e of\n     Void \\<Rightarrow> f cVoid cVoid'\n   | Boolean \\<Rightarrow> f cBoolean cBoolean'\n   | Integer \\<Rightarrow> f cInteger cInteger'\n   | NT \\<Rightarrow> f cNT cNT'\n   | Class C \\<Rightarrow> f (cClass C) (cClass' C)\n   | Array T \\<Rightarrow> f (cArray T) (cArray' T))\"", "lemma op_case_bop_case_bop_same:\n  \"f (case_bop cEq cNotEq cLessThan cLessOrEqual cGreaterThan cGreaterOrEqual cAdd cSubtract cMult cDiv cMod cBinAnd cBinOr cBinXor cShiftLeft cShiftRightZeros cShiftRightSigned bop)\n     (case_bop cEq' cNotEq' cLessThan' cLessOrEqual' cGreaterThan' cGreaterOrEqual' cAdd' cSubtract' cMult' cDiv' cMod' cBinAnd' cBinOr' cBinXor' cShiftLeft' cShiftRightZeros' cShiftRightSigned' bop)\n  = case_bop (f cEq cEq') (f cNotEq cNotEq') (f cLessThan cLessThan') (f cLessOrEqual cLessOrEqual') (f cGreaterThan cGreaterThan') (f cGreaterOrEqual cGreaterOrEqual') (f cAdd cAdd') (f cSubtract cSubtract') (f cMult cMult') (f cDiv cDiv') (f cMod cMod') (f cBinAnd cBinAnd') (f cBinOr cBinOr') (f cBinXor cBinXor') (f cShiftLeft cShiftLeft') (f cShiftRightZeros cShiftRightZeros') (f cShiftRightSigned cShiftRightSigned') bop\"", "lemma sup_case_bop_case_bop_other [code_unfold]:\n  fixes p :: \"'a :: semilattice_sup\" shows\n  \"sup_class.sup (case_bop cEq cNotEq cLessThan cLessOrEqual cGreaterThan cGreaterOrEqual cAdd cSubtract cMult cDiv cMod cBinAnd cBinOr cBinXor cShiftLeft cShiftRightZeros cShiftRightSigned bop)\n     (sup_class.sup (case_bop cEq' cNotEq' cLessThan' cLessOrEqual' cGreaterThan' cGreaterOrEqual' cAdd' cSubtract' cMult' cDiv' cMod' cBinAnd' cBinOr' cBinXor' cShiftLeft' cShiftRightZeros' cShiftRightSigned' bop) p)\n  = sup_class.sup (case_bop (sup_class.sup cEq cEq') (sup_class.sup cNotEq cNotEq') (sup_class.sup cLessThan cLessThan') (sup_class.sup cLessOrEqual cLessOrEqual') (sup_class.sup cGreaterThan cGreaterThan') (sup_class.sup cGreaterOrEqual cGreaterOrEqual') (sup_class.sup cAdd cAdd') (sup_class.sup cSubtract cSubtract') (sup_class.sup cMult cMult') (sup_class.sup cDiv cDiv') (sup_class.sup cMod cMod') (sup_class.sup cBinAnd cBinAnd') (sup_class.sup cBinOr cBinOr') (sup_class.sup cBinXor cBinXor') (sup_class.sup cShiftLeft cShiftLeft') (sup_class.sup cShiftRightZeros cShiftRightZeros') (sup_class.sup cShiftRightSigned cShiftRightSigned') bop) p\""], "translations": [["", "lemma insort_insert_key_code [code]:\n  \"insort_insert_key f x xs = \n  (if List.member (map f xs) (f x) then xs else insort_key f x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insort_insert_key f x xs =\n    (if List.member (map f xs) (f x) then xs else insort_key f x xs)", "by(simp add: insort_insert_key_def List.member_def split del: if_split)"], ["", "text \\<open>equations on predicate operations for code inlining\\<close>"], ["", "lemma eq_i_o_conv_single: \"eq_i_o = Predicate.single\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_i_o = Predicate.single", "by(rule ext)(simp add: Predicate.single_bind eq.equation)"], ["", "lemma eq_o_i_conv_single: \"eq_o_i = Predicate.single\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_o_i = Predicate.single", "by(rule ext)(simp add: Predicate.single_bind eq.equation)"], ["", "lemma sup_case_exp_case_exp_same:\n  \"sup_class.sup \n    (case_exp cNew cNewArray cCast cInstanceOf cVal cBinOp cVar cLAss cAAcc cAAss cALen cFAcc cFAss cCAS cCall cBlock cSync cInSync cSeq cCond cWhile cThrow cTry e)\n    (case_exp cNew' cNewArray' cCast' cInstanceOf' cVal' cBinOp' cVar' cLAss' cAAcc' cAAss' cALen' cFAcc' cFAss' cCAS' cCall' cBlock' cSync' cInSync' cSeq' cCond' cWhile' cThrow' cTry' e) =\n  (case e of\n    new C \\<Rightarrow> sup_class.sup (cNew C) (cNew' C)\n  | newArray T e \\<Rightarrow> sup_class.sup (cNewArray T e) (cNewArray' T e)\n  | Cast T e \\<Rightarrow> sup_class.sup (cCast T e) (cCast' T e)\n  | InstanceOf e T \\<Rightarrow> sup_class.sup (cInstanceOf e T) (cInstanceOf' e T)\n  | Val v \\<Rightarrow> sup_class.sup (cVal v) (cVal' v)\n  | BinOp e bop e' \\<Rightarrow> sup_class.sup (cBinOp e bop e') (cBinOp' e bop e')\n  | Var V \\<Rightarrow> sup_class.sup (cVar V) (cVar' V)\n  | LAss V e \\<Rightarrow> sup_class.sup (cLAss V e) (cLAss' V e)\n  | AAcc a e \\<Rightarrow> sup_class.sup (cAAcc a e) (cAAcc' a e)\n  | AAss a i e \\<Rightarrow> sup_class.sup (cAAss a i e) (cAAss' a i e)\n  | ALen a \\<Rightarrow> sup_class.sup (cALen a) (cALen' a)\n  | FAcc e F D \\<Rightarrow> sup_class.sup (cFAcc e F D) (cFAcc' e F D)\n  | FAss e F D e' \\<Rightarrow> sup_class.sup (cFAss e F D e') (cFAss' e F D e')\n  | CompareAndSwap e D F e' e'' \\<Rightarrow> sup_class.sup (cCAS e D F e' e'') (cCAS' e D F e' e'')\n  | Call e M es \\<Rightarrow> sup_class.sup (cCall e M es) (cCall' e M es)\n  | Block V T vo e \\<Rightarrow> sup_class.sup (cBlock V T vo e) (cBlock' V T vo e)\n  | Synchronized v e e' \\<Rightarrow> sup_class.sup (cSync v e e') (cSync' v e e')\n  | InSynchronized v a e \\<Rightarrow> sup_class.sup (cInSync v a e) (cInSync' v a e)\n  | Seq e e' \\<Rightarrow> sup_class.sup (cSeq e e') (cSeq' e e')\n  | Cond b e e' \\<Rightarrow> sup_class.sup (cCond b e e') (cCond' b e e')\n  | While b e \\<Rightarrow> sup_class.sup (cWhile b e) (cWhile' b e)\n  | throw e \\<Rightarrow> sup_class.sup (cThrow e) (cThrow' e)\n  | TryCatch e C V e' \\<Rightarrow> sup_class.sup (cTry e C V e') (cTry' e C V e'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of new x \\<Rightarrow> cNew x\n     | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n     | Cast x xa \\<Rightarrow> cCast x xa\n     | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n     | Val x \\<Rightarrow> cVal x\n     | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow> cBinOp x xa xb\n     | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n     | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n     | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n     | x\\<bullet>length \\<Rightarrow> cALen x\n     | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n     | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n     | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n         cCAS x xa xb xc xd\n     | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n     | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n     | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n     | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n     | x;; xa \\<Rightarrow> cSeq x xa\n     | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n     | while (x) xa \\<Rightarrow> cWhile x xa\n     | throw x \\<Rightarrow> cThrow x\n     | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n    (case e of new x \\<Rightarrow> cNew' x\n     | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n     | Cast x xa \\<Rightarrow> cCast' x xa\n     | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n     | Val x \\<Rightarrow> cVal' x\n     | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n         cBinOp' x xa xb\n     | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n     | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n     | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n     | x\\<bullet>length \\<Rightarrow> cALen' x\n     | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n     | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n     | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n         cCAS' x xa xb xc xd\n     | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n     | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n     | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n     | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n     | x;; xa \\<Rightarrow> cSeq' x xa\n     | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n     | while (x) xa \\<Rightarrow> cWhile' x xa\n     | throw x \\<Rightarrow> cThrow' x\n     | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n    (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n     | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n         cNewArray T e \\<squnion> cNewArray' T e\n     | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n     | e instanceof T \\<Rightarrow>\n         cInstanceOf e T \\<squnion> cInstanceOf' e T\n     | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n     | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n         cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n     | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n     | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n     | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n     | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n         cAAss a i e \\<squnion> cAAss' a i e\n     | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n     | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n     | e\\<bullet>F{D} := e' \\<Rightarrow>\n         cFAss e F D e' \\<squnion> cFAss' e F D e'\n     | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n         cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n     | e\\<bullet>M(es) \\<Rightarrow> cCall e M es \\<squnion> cCall' e M es\n     | {V:T=vo; e} \\<Rightarrow> cBlock V T vo e \\<squnion> cBlock' V T vo e\n     | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n         cSync v e e' \\<squnion> cSync' v e e'\n     | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n         cInSync v a e \\<squnion> cInSync' v a e\n     | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n     | if (b) e else e' \\<Rightarrow> cCond b e e' \\<squnion> cCond' b e e'\n     | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n     | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n     | try e catch(C V) e' \\<Rightarrow>\n         cTry e C V e' \\<squnion> cTry' e C V e')", "apply(cases e)"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>x1.\n       e = new x1 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 2. \\<And>x21 x22.\n       e = newA x21\\<lfloor>x22\\<rceil> \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 3. \\<And>x31 x32.\n       e = Cast x31 x32 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 4. \\<And>x41 x42.\n       e = x41 instanceof x42 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 5. \\<And>x5.\n       e = Val x5 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 6. \\<And>x61 x62 x63.\n       e = x61 \\<guillemotleft>x62\\<guillemotright> x63 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 7. \\<And>x7.\n       e = Var x7 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 8. \\<And>x81 x82.\n       e = x81:=x82 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 9. \\<And>x91 x92.\n       e = x91\\<lfloor>x92\\<rceil> \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       (case e of new x \\<Rightarrow> cNew' x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n        | Cast x xa \\<Rightarrow> cCast' x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n        | Val x \\<Rightarrow> cVal' x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp' x xa xb\n        | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen' x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS' x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n        | x;; xa \\<Rightarrow> cSeq' x xa\n        | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n        | while (x) xa \\<Rightarrow> cWhile' x xa\n        | throw x \\<Rightarrow> cThrow' x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e')\n 10. \\<And>x101 x102 x103.\n        e = x101\\<lfloor>x102\\<rceil> := x103 \\<Longrightarrow>\n        (case e of new x \\<Rightarrow> cNew x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n         | Cast x xa \\<Rightarrow> cCast x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n         | Val x \\<Rightarrow> cVal x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp x xa xb\n         | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n         | x;; xa \\<Rightarrow> cSeq x xa\n         | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n         | while (x) xa \\<Rightarrow> cWhile x xa\n         | throw x \\<Rightarrow> cThrow x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n        (case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) =\n        (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n         | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n             cNewArray T e \\<squnion> cNewArray' T e\n         | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n         | e instanceof T \\<Rightarrow>\n             cInstanceOf e T \\<squnion> cInstanceOf' e T\n         | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n         | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n             cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n         | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n         | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n         | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n         | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n             cAAss a i e \\<squnion> cAAss' a i e\n         | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n         | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n         | e\\<bullet>F{D} := e' \\<Rightarrow>\n             cFAss e F D e' \\<squnion> cFAss' e F D e'\n         | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n             cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n         | e\\<bullet>M(es) \\<Rightarrow>\n             cCall e M es \\<squnion> cCall' e M es\n         | {V:T=vo; e} \\<Rightarrow>\n             cBlock V T vo e \\<squnion> cBlock' V T vo e\n         | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n             cSync v e e' \\<squnion> cSync' v e e'\n         | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n             cInSync v a e \\<squnion> cInSync' v a e\n         | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n         | if (b) e else e' \\<Rightarrow>\n             cCond b e e' \\<squnion> cCond' b e e'\n         | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n         | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n         | try e catch(C V) e' \\<Rightarrow>\n             cTry e C V e' \\<squnion> cTry' e C V e')\nA total of 23 subgoals...", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sup_case_exp_case_exp_other:\n  fixes p :: \"'a :: semilattice_sup\" shows\n  \"sup_class.sup \n    (case_exp cNew cNewArray cCast cInstanceOf cVal cBinOp cVar cLAss cAAcc cAAss cALen cFAcc cFAss cCAS cCall cBlock cSync cInSync cSeq cCond cWhile cThrow cTry e)\n    (sup_class.sup (case_exp cNew' cNewArray' cCast' cInstanceOf' cVal' cBinOp' cVar' cLAss' cAAcc' cAAss' cALen' cFAcc' cFAss' cCAS' cCall' cBlock' cSync' cInSync' cSeq' cCond' cWhile' cThrow' cTry' e) p) =\n  sup_class.sup (case e of\n    new C \\<Rightarrow> sup_class.sup (cNew C) (cNew' C)\n  | newArray T e \\<Rightarrow> sup_class.sup (cNewArray T e) (cNewArray' T e)\n  | Cast T e \\<Rightarrow> sup_class.sup (cCast T e) (cCast' T e)\n  | InstanceOf e T \\<Rightarrow> sup_class.sup (cInstanceOf e T) (cInstanceOf' e T)\n  | Val v \\<Rightarrow> sup_class.sup (cVal v) (cVal' v)\n  | BinOp e bop e' \\<Rightarrow> sup_class.sup (cBinOp e bop e') (cBinOp' e bop e')\n  | Var V \\<Rightarrow> sup_class.sup (cVar V) (cVar' V)\n  | LAss V e \\<Rightarrow> sup_class.sup (cLAss V e) (cLAss' V e)\n  | AAcc a e \\<Rightarrow> sup_class.sup (cAAcc a e) (cAAcc' a e)\n  | AAss a i e \\<Rightarrow> sup_class.sup (cAAss a i e) (cAAss' a i e)\n  | ALen a \\<Rightarrow> sup_class.sup (cALen a) (cALen' a)\n  | FAcc e F D \\<Rightarrow> sup_class.sup (cFAcc e F D) (cFAcc' e F D)\n  | FAss e F D e' \\<Rightarrow> sup_class.sup (cFAss e F D e') (cFAss' e F D e')\n  | CompareAndSwap e D F e' e'' \\<Rightarrow> sup_class.sup (cCAS e D F e' e'') (cCAS' e D F e' e'')\n  | Call e M es \\<Rightarrow> sup_class.sup (cCall e M es) (cCall' e M es)\n  | Block V T vo e \\<Rightarrow> sup_class.sup (cBlock V T vo e) (cBlock' V T vo e)\n  | Synchronized v e e' \\<Rightarrow> sup_class.sup (cSync v e e') (cSync' v e e')\n  | InSynchronized v a e \\<Rightarrow> sup_class.sup (cInSync v a e) (cInSync' v a e)\n  | Seq e e' \\<Rightarrow> sup_class.sup (cSeq e e') (cSeq' e e')\n  | Cond b e e' \\<Rightarrow> sup_class.sup (cCond b e e') (cCond' b e e')\n  | While b e \\<Rightarrow> sup_class.sup (cWhile b e) (cWhile' b e)\n  | throw e \\<Rightarrow> sup_class.sup (cThrow e) (cThrow' e)\n  | TryCatch e C V e' \\<Rightarrow> sup_class.sup (cTry e C V e') (cTry' e C V e')) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of new x \\<Rightarrow> cNew x\n     | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n     | Cast x xa \\<Rightarrow> cCast x xa\n     | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n     | Val x \\<Rightarrow> cVal x\n     | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow> cBinOp x xa xb\n     | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n     | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n     | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n     | x\\<bullet>length \\<Rightarrow> cALen x\n     | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n     | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n     | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n         cCAS x xa xb xc xd\n     | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n     | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n     | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n     | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n     | x;; xa \\<Rightarrow> cSeq x xa\n     | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n     | while (x) xa \\<Rightarrow> cWhile x xa\n     | throw x \\<Rightarrow> cThrow x\n     | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n    ((case e of new x \\<Rightarrow> cNew' x\n      | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n      | Cast x xa \\<Rightarrow> cCast' x xa\n      | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n      | Val x \\<Rightarrow> cVal' x\n      | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n          cBinOp' x xa xb\n      | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n      | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n      | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n      | x\\<bullet>length \\<Rightarrow> cALen' x\n      | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n      | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n      | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n          cCAS' x xa xb xc xd\n      | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n      | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n      | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n      | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n      | x;; xa \\<Rightarrow> cSeq' x xa\n      | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n      | while (x) xa \\<Rightarrow> cWhile' x xa\n      | throw x \\<Rightarrow> cThrow' x\n      | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n     p) =\n    (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n     | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n         cNewArray T e \\<squnion> cNewArray' T e\n     | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n     | e instanceof T \\<Rightarrow>\n         cInstanceOf e T \\<squnion> cInstanceOf' e T\n     | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n     | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n         cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n     | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n     | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n     | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n     | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n         cAAss a i e \\<squnion> cAAss' a i e\n     | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n     | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n     | e\\<bullet>F{D} := e' \\<Rightarrow>\n         cFAss e F D e' \\<squnion> cFAss' e F D e'\n     | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n         cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n     | e\\<bullet>M(es) \\<Rightarrow> cCall e M es \\<squnion> cCall' e M es\n     | {V:T=vo; e} \\<Rightarrow> cBlock V T vo e \\<squnion> cBlock' V T vo e\n     | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n         cSync v e e' \\<squnion> cSync' v e e'\n     | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n         cInSync v a e \\<squnion> cInSync' v a e\n     | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n     | if (b) e else e' \\<Rightarrow> cCond b e e' \\<squnion> cCond' b e e'\n     | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n     | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n     | try e catch(C V) e' \\<Rightarrow>\n         cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n    p", "apply(cases e)"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>x1.\n       e = new x1 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 2. \\<And>x21 x22.\n       e = newA x21\\<lfloor>x22\\<rceil> \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 3. \\<And>x31 x32.\n       e = Cast x31 x32 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 4. \\<And>x41 x42.\n       e = x41 instanceof x42 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 5. \\<And>x5.\n       e = Val x5 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 6. \\<And>x61 x62 x63.\n       e = x61 \\<guillemotleft>x62\\<guillemotright> x63 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 7. \\<And>x7.\n       e = Var x7 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 8. \\<And>x81 x82.\n       e = x81:=x82 \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 9. \\<And>x91 x92.\n       e = x91\\<lfloor>x92\\<rceil> \\<Longrightarrow>\n       (case e of new x \\<Rightarrow> cNew x\n        | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n        | Cast x xa \\<Rightarrow> cCast x xa\n        | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n        | Val x \\<Rightarrow> cVal x\n        | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n            cBinOp x xa xb\n        | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n        | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n        | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n        | x\\<bullet>length \\<Rightarrow> cALen x\n        | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n        | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n        | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n            cCAS x xa xb xc xd\n        | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n        | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n        | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n        | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n        | x;; xa \\<Rightarrow> cSeq x xa\n        | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n        | while (x) xa \\<Rightarrow> cWhile x xa\n        | throw x \\<Rightarrow> cThrow x\n        | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n       ((case e of new x \\<Rightarrow> cNew' x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n         | Cast x xa \\<Rightarrow> cCast' x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n         | Val x \\<Rightarrow> cVal' x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp' x xa xb\n         | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen' x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS' x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n         | x;; xa \\<Rightarrow> cSeq' x xa\n         | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n         | while (x) xa \\<Rightarrow> cWhile' x xa\n         | throw x \\<Rightarrow> cThrow' x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n        p) =\n       (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n        | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n            cNewArray T e \\<squnion> cNewArray' T e\n        | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n        | e instanceof T \\<Rightarrow>\n            cInstanceOf e T \\<squnion> cInstanceOf' e T\n        | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n        | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n            cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n        | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n        | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n        | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n        | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n            cAAss a i e \\<squnion> cAAss' a i e\n        | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n        | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n        | e\\<bullet>F{D} := e' \\<Rightarrow>\n            cFAss e F D e' \\<squnion> cFAss' e F D e'\n        | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n            cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n        | e\\<bullet>M(es) \\<Rightarrow>\n            cCall e M es \\<squnion> cCall' e M es\n        | {V:T=vo; e} \\<Rightarrow>\n            cBlock V T vo e \\<squnion> cBlock' V T vo e\n        | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n            cSync v e e' \\<squnion> cSync' v e e'\n        | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n            cInSync v a e \\<squnion> cInSync' v a e\n        | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n        | if (b) e else e' \\<Rightarrow>\n            cCond b e e' \\<squnion> cCond' b e e'\n        | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n        | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n        | try e catch(C V) e' \\<Rightarrow>\n            cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n       p\n 10. \\<And>x101 x102 x103.\n        e = x101\\<lfloor>x102\\<rceil> := x103 \\<Longrightarrow>\n        (case e of new x \\<Rightarrow> cNew x\n         | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray x xa\n         | Cast x xa \\<Rightarrow> cCast x xa\n         | x instanceof xa \\<Rightarrow> cInstanceOf x xa\n         | Val x \\<Rightarrow> cVal x\n         | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n             cBinOp x xa xb\n         | Var x \\<Rightarrow> cVar x | x:=xa \\<Rightarrow> cLAss x xa\n         | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc x xa\n         | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss x xa xb\n         | x\\<bullet>length \\<Rightarrow> cALen x\n         | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc x xa xb\n         | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss x xa xb xc\n         | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n             cCAS x xa xb xc xd\n         | x\\<bullet>xa(xb) \\<Rightarrow> cCall x xa xb\n         | {x:xa=xb; xc} \\<Rightarrow> cBlock x xa xb xc\n         | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync x xa xb\n         | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync x xa xb\n         | x;; xa \\<Rightarrow> cSeq x xa\n         | if (x) xa else xb \\<Rightarrow> cCond x xa xb\n         | while (x) xa \\<Rightarrow> cWhile x xa\n         | throw x \\<Rightarrow> cThrow x\n         | try x catch(xa xb) xc \\<Rightarrow> cTry x xa xb xc) \\<squnion>\n        ((case e of new x \\<Rightarrow> cNew' x\n          | newA x\\<lfloor>xa\\<rceil> \\<Rightarrow> cNewArray' x xa\n          | Cast x xa \\<Rightarrow> cCast' x xa\n          | x instanceof xa \\<Rightarrow> cInstanceOf' x xa\n          | Val x \\<Rightarrow> cVal' x\n          | x \\<guillemotleft>xa\\<guillemotright> xb \\<Rightarrow>\n              cBinOp' x xa xb\n          | Var x \\<Rightarrow> cVar' x | x:=xa \\<Rightarrow> cLAss' x xa\n          | x\\<lfloor>xa\\<rceil> \\<Rightarrow> cAAcc' x xa\n          | x\\<lfloor>xa\\<rceil> := xb \\<Rightarrow> cAAss' x xa xb\n          | x\\<bullet>length \\<Rightarrow> cALen' x\n          | x\\<bullet>xa{xb} \\<Rightarrow> cFAcc' x xa xb\n          | x\\<bullet>xa{xb} := xc \\<Rightarrow> cFAss' x xa xb xc\n          | x\\<bullet>compareAndSwap(xa\\<bullet>xb, xc, xd) \\<Rightarrow>\n              cCAS' x xa xb xc xd\n          | x\\<bullet>xa(xb) \\<Rightarrow> cCall' x xa xb\n          | {x:xa=xb; xc} \\<Rightarrow> cBlock' x xa xb xc\n          | sync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cSync' x xa xb\n          | insync\\<^bsub>x\\<^esub> (xa) xb \\<Rightarrow> cInSync' x xa xb\n          | x;; xa \\<Rightarrow> cSeq' x xa\n          | if (x) xa else xb \\<Rightarrow> cCond' x xa xb\n          | while (x) xa \\<Rightarrow> cWhile' x xa\n          | throw x \\<Rightarrow> cThrow' x\n          | try x catch(xa xb) xc \\<Rightarrow> cTry' x xa xb xc) \\<squnion>\n         p) =\n        (case e of new C \\<Rightarrow> cNew C \\<squnion> cNew' C\n         | newA T\\<lfloor>e\\<rceil> \\<Rightarrow>\n             cNewArray T e \\<squnion> cNewArray' T e\n         | Cast T e \\<Rightarrow> cCast T e \\<squnion> cCast' T e\n         | e instanceof T \\<Rightarrow>\n             cInstanceOf e T \\<squnion> cInstanceOf' e T\n         | Val v \\<Rightarrow> cVal v \\<squnion> cVal' v\n         | e \\<guillemotleft>bop\\<guillemotright> e' \\<Rightarrow>\n             cBinOp e bop e' \\<squnion> cBinOp' e bop e'\n         | Var V \\<Rightarrow> cVar V \\<squnion> cVar' V\n         | V:=e \\<Rightarrow> cLAss V e \\<squnion> cLAss' V e\n         | a\\<lfloor>e\\<rceil> \\<Rightarrow> cAAcc a e \\<squnion> cAAcc' a e\n         | a\\<lfloor>i\\<rceil> := e \\<Rightarrow>\n             cAAss a i e \\<squnion> cAAss' a i e\n         | a\\<bullet>length \\<Rightarrow> cALen a \\<squnion> cALen' a\n         | e\\<bullet>F{D} \\<Rightarrow> cFAcc e F D \\<squnion> cFAcc' e F D\n         | e\\<bullet>F{D} := e' \\<Rightarrow>\n             cFAss e F D e' \\<squnion> cFAss' e F D e'\n         | e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'') \\<Rightarrow>\n             cCAS e D F e' e'' \\<squnion> cCAS' e D F e' e''\n         | e\\<bullet>M(es) \\<Rightarrow>\n             cCall e M es \\<squnion> cCall' e M es\n         | {V:T=vo; e} \\<Rightarrow>\n             cBlock V T vo e \\<squnion> cBlock' V T vo e\n         | sync\\<^bsub>v\\<^esub> (e) e' \\<Rightarrow>\n             cSync v e e' \\<squnion> cSync' v e e'\n         | insync\\<^bsub>v\\<^esub> (a) e \\<Rightarrow>\n             cInSync v a e \\<squnion> cInSync' v a e\n         | e;; e' \\<Rightarrow> cSeq e e' \\<squnion> cSeq' e e'\n         | if (b) e else e' \\<Rightarrow>\n             cCond b e e' \\<squnion> cCond' b e e'\n         | while (b) e \\<Rightarrow> cWhile b e \\<squnion> cWhile' b e\n         | throw e \\<Rightarrow> cThrow e \\<squnion> cThrow' e\n         | try e catch(C V) e' \\<Rightarrow>\n             cTry e C V e' \\<squnion> cTry' e C V e') \\<squnion>\n        p\nA total of 23 subgoals...", "apply(simp_all add: inf_sup_aci sup.assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sup_bot1: \"sup_class.sup bot a = (a :: 'a :: {semilattice_sup, order_bot})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<squnion> a = a", "by(rule sup_absorb2)auto"], ["", "lemma sup_bot2: \"sup_class.sup a bot = (a :: 'a :: {semilattice_sup, order_bot})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> \\<bottom> = a", "by(rule sup_absorb1) auto"], ["", "lemma sup_case_val_case_val_same:\n  \"sup_class.sup (case_val cUnit cNull cBool cIntg cAddr v) (case_val cUnit' cNull' cBool' cIntg' cAddr' v) =\n   (case v of\n     Unit \\<Rightarrow> sup_class.sup cUnit cUnit'\n   | Null \\<Rightarrow> sup_class.sup cNull cNull'\n   | Bool b \\<Rightarrow> sup_class.sup (cBool b) (cBool' b)\n   | Intg i \\<Rightarrow> sup_class.sup (cIntg i) (cIntg' i)\n   | Addr a \\<Rightarrow> sup_class.sup (cAddr a) (cAddr' a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case v of Unit \\<Rightarrow> cUnit | Null \\<Rightarrow> cNull\n     | Bool x \\<Rightarrow> cBool x | Intg x \\<Rightarrow> cIntg x\n     | Addr x \\<Rightarrow> cAddr x) \\<squnion>\n    (case v of Unit \\<Rightarrow> cUnit' | Null \\<Rightarrow> cNull'\n     | Bool x \\<Rightarrow> cBool' x | Intg x \\<Rightarrow> cIntg' x\n     | Addr x \\<Rightarrow> cAddr' x) =\n    (case v of Unit \\<Rightarrow> cUnit \\<squnion> cUnit'\n     | Null \\<Rightarrow> cNull \\<squnion> cNull'\n     | Bool b \\<Rightarrow> cBool b \\<squnion> cBool' b\n     | Intg i \\<Rightarrow> cIntg i \\<squnion> cIntg' i\n     | Addr a \\<Rightarrow> cAddr a \\<squnion> cAddr' a)", "apply(cases v)"], ["proof (prove)\ngoal (5 subgoals):\n 1. v = Unit \\<Longrightarrow>\n    (case v of Unit \\<Rightarrow> cUnit | Null \\<Rightarrow> cNull\n     | Bool x \\<Rightarrow> cBool x | Intg x \\<Rightarrow> cIntg x\n     | Addr x \\<Rightarrow> cAddr x) \\<squnion>\n    (case v of Unit \\<Rightarrow> cUnit' | Null \\<Rightarrow> cNull'\n     | Bool x \\<Rightarrow> cBool' x | Intg x \\<Rightarrow> cIntg' x\n     | Addr x \\<Rightarrow> cAddr' x) =\n    (case v of Unit \\<Rightarrow> cUnit \\<squnion> cUnit'\n     | Null \\<Rightarrow> cNull \\<squnion> cNull'\n     | Bool b \\<Rightarrow> cBool b \\<squnion> cBool' b\n     | Intg i \\<Rightarrow> cIntg i \\<squnion> cIntg' i\n     | Addr a \\<Rightarrow> cAddr a \\<squnion> cAddr' a)\n 2. v = Null \\<Longrightarrow>\n    (case v of Unit \\<Rightarrow> cUnit | Null \\<Rightarrow> cNull\n     | Bool x \\<Rightarrow> cBool x | Intg x \\<Rightarrow> cIntg x\n     | Addr x \\<Rightarrow> cAddr x) \\<squnion>\n    (case v of Unit \\<Rightarrow> cUnit' | Null \\<Rightarrow> cNull'\n     | Bool x \\<Rightarrow> cBool' x | Intg x \\<Rightarrow> cIntg' x\n     | Addr x \\<Rightarrow> cAddr' x) =\n    (case v of Unit \\<Rightarrow> cUnit \\<squnion> cUnit'\n     | Null \\<Rightarrow> cNull \\<squnion> cNull'\n     | Bool b \\<Rightarrow> cBool b \\<squnion> cBool' b\n     | Intg i \\<Rightarrow> cIntg i \\<squnion> cIntg' i\n     | Addr a \\<Rightarrow> cAddr a \\<squnion> cAddr' a)\n 3. \\<And>x3.\n       v = Bool x3 \\<Longrightarrow>\n       (case v of Unit \\<Rightarrow> cUnit | Null \\<Rightarrow> cNull\n        | Bool x \\<Rightarrow> cBool x | Intg x \\<Rightarrow> cIntg x\n        | Addr x \\<Rightarrow> cAddr x) \\<squnion>\n       (case v of Unit \\<Rightarrow> cUnit' | Null \\<Rightarrow> cNull'\n        | Bool x \\<Rightarrow> cBool' x | Intg x \\<Rightarrow> cIntg' x\n        | Addr x \\<Rightarrow> cAddr' x) =\n       (case v of Unit \\<Rightarrow> cUnit \\<squnion> cUnit'\n        | Null \\<Rightarrow> cNull \\<squnion> cNull'\n        | Bool b \\<Rightarrow> cBool b \\<squnion> cBool' b\n        | Intg i \\<Rightarrow> cIntg i \\<squnion> cIntg' i\n        | Addr a \\<Rightarrow> cAddr a \\<squnion> cAddr' a)\n 4. \\<And>x4.\n       v = Intg x4 \\<Longrightarrow>\n       (case v of Unit \\<Rightarrow> cUnit | Null \\<Rightarrow> cNull\n        | Bool x \\<Rightarrow> cBool x | Intg x \\<Rightarrow> cIntg x\n        | Addr x \\<Rightarrow> cAddr x) \\<squnion>\n       (case v of Unit \\<Rightarrow> cUnit' | Null \\<Rightarrow> cNull'\n        | Bool x \\<Rightarrow> cBool' x | Intg x \\<Rightarrow> cIntg' x\n        | Addr x \\<Rightarrow> cAddr' x) =\n       (case v of Unit \\<Rightarrow> cUnit \\<squnion> cUnit'\n        | Null \\<Rightarrow> cNull \\<squnion> cNull'\n        | Bool b \\<Rightarrow> cBool b \\<squnion> cBool' b\n        | Intg i \\<Rightarrow> cIntg i \\<squnion> cIntg' i\n        | Addr a \\<Rightarrow> cAddr a \\<squnion> cAddr' a)\n 5. \\<And>x5.\n       v = Addr x5 \\<Longrightarrow>\n       (case v of Unit \\<Rightarrow> cUnit | Null \\<Rightarrow> cNull\n        | Bool x \\<Rightarrow> cBool x | Intg x \\<Rightarrow> cIntg x\n        | Addr x \\<Rightarrow> cAddr x) \\<squnion>\n       (case v of Unit \\<Rightarrow> cUnit' | Null \\<Rightarrow> cNull'\n        | Bool x \\<Rightarrow> cBool' x | Intg x \\<Rightarrow> cIntg' x\n        | Addr x \\<Rightarrow> cAddr' x) =\n       (case v of Unit \\<Rightarrow> cUnit \\<squnion> cUnit'\n        | Null \\<Rightarrow> cNull \\<squnion> cNull'\n        | Bool b \\<Rightarrow> cBool b \\<squnion> cBool' b\n        | Intg i \\<Rightarrow> cIntg i \\<squnion> cIntg' i\n        | Addr a \\<Rightarrow> cAddr a \\<squnion> cAddr' a)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sup_case_bool_case_bool_same:\n  \"sup_class.sup (case_bool t f b) (case_bool t' f' b) =\n  (if b then sup_class.sup t t' else sup_class.sup f f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case b of True \\<Rightarrow> t | False \\<Rightarrow> f) \\<squnion>\n    (case b of True \\<Rightarrow> t' | False \\<Rightarrow> f') =\n    (if b then t \\<squnion> t' else f \\<squnion> f')", "by simp"], ["", "lemmas predicate_code_inline [code_unfold] =\n  Predicate.single_bind Predicate.bind_single split\n  eq_i_o_conv_single eq_o_i_conv_single\n  sup_case_exp_case_exp_same sup_case_exp_case_exp_other unit.case\n  sup_bot1 sup_bot2 sup_case_val_case_val_same sup_case_bool_case_bool_same"], ["", "lemma op_case_ty_case_ty_same:\n  \"f (case_ty cVoid cBoolean cInteger cNT cClass cArray e)\n     (case_ty cVoid' cBoolean' cInteger' cNT' cClass' cArray' e) =\n  (case e of\n     Void \\<Rightarrow> f cVoid cVoid'\n   | Boolean \\<Rightarrow> f cBoolean cBoolean'\n   | Integer \\<Rightarrow> f cInteger cInteger'\n   | NT \\<Rightarrow> f cNT cNT'\n   | Class C \\<Rightarrow> f (cClass C) (cClass' C)\n   | Array T \\<Rightarrow> f (cArray T) (cArray' T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (case e of Void \\<Rightarrow> cVoid | Boolean \\<Rightarrow> cBoolean\n       | Integer \\<Rightarrow> cInteger | NT \\<Rightarrow> cNT\n       | Class x \\<Rightarrow> cClass x\n       | x\\<lfloor>\\<rceil> \\<Rightarrow> cArray x)\n     (case e of Void \\<Rightarrow> cVoid' | Boolean \\<Rightarrow> cBoolean'\n      | Integer \\<Rightarrow> cInteger' | NT \\<Rightarrow> cNT'\n      | Class x \\<Rightarrow> cClass' x\n      | x\\<lfloor>\\<rceil> \\<Rightarrow> cArray' x) =\n    (case e of Void \\<Rightarrow> f cVoid cVoid'\n     | Boolean \\<Rightarrow> f cBoolean cBoolean'\n     | Integer \\<Rightarrow> f cInteger cInteger'\n     | NT \\<Rightarrow> f cNT cNT'\n     | Class C \\<Rightarrow> f (cClass C) (cClass' C)\n     | T\\<lfloor>\\<rceil> \\<Rightarrow> f (cArray T) (cArray' T))", "by(simp split: ty.split)"], ["", "declare op_case_ty_case_ty_same[where f=\"sup_class.sup\", code_unfold]"], ["", "lemma op_case_bop_case_bop_same:\n  \"f (case_bop cEq cNotEq cLessThan cLessOrEqual cGreaterThan cGreaterOrEqual cAdd cSubtract cMult cDiv cMod cBinAnd cBinOr cBinXor cShiftLeft cShiftRightZeros cShiftRightSigned bop)\n     (case_bop cEq' cNotEq' cLessThan' cLessOrEqual' cGreaterThan' cGreaterOrEqual' cAdd' cSubtract' cMult' cDiv' cMod' cBinAnd' cBinOr' cBinXor' cShiftLeft' cShiftRightZeros' cShiftRightSigned' bop)\n  = case_bop (f cEq cEq') (f cNotEq cNotEq') (f cLessThan cLessThan') (f cLessOrEqual cLessOrEqual') (f cGreaterThan cGreaterThan') (f cGreaterOrEqual cGreaterOrEqual') (f cAdd cAdd') (f cSubtract cSubtract') (f cMult cMult') (f cDiv cDiv') (f cMod cMod') (f cBinAnd cBinAnd') (f cBinOr cBinOr') (f cBinXor cBinXor') (f cShiftLeft cShiftLeft') (f cShiftRightZeros cShiftRightZeros') (f cShiftRightSigned cShiftRightSigned') bop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n       | LessThan \\<Rightarrow> cLessThan\n       | LessOrEqual \\<Rightarrow> cLessOrEqual\n       | GreaterThan \\<Rightarrow> cGreaterThan\n       | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual\n       | Add \\<Rightarrow> cAdd | Subtract \\<Rightarrow> cSubtract\n       | Mult \\<Rightarrow> cMult | Div \\<Rightarrow> cDiv\n       | Mod \\<Rightarrow> cMod | BinAnd \\<Rightarrow> cBinAnd\n       | BinOr \\<Rightarrow> cBinOr | BinXor \\<Rightarrow> cBinXor\n       | ShiftLeft \\<Rightarrow> cShiftLeft\n       | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n       | ShiftRightSigned \\<Rightarrow> cShiftRightSigned)\n     (case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') =\n    (case bop of Eq \\<Rightarrow> f cEq cEq'\n     | NotEq \\<Rightarrow> f cNotEq cNotEq'\n     | LessThan \\<Rightarrow> f cLessThan cLessThan'\n     | LessOrEqual \\<Rightarrow> f cLessOrEqual cLessOrEqual'\n     | GreaterThan \\<Rightarrow> f cGreaterThan cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow> f cGreaterOrEqual cGreaterOrEqual'\n     | Add \\<Rightarrow> f cAdd cAdd'\n     | Subtract \\<Rightarrow> f cSubtract cSubtract'\n     | Mult \\<Rightarrow> f cMult cMult' | Div \\<Rightarrow> f cDiv cDiv'\n     | Mod \\<Rightarrow> f cMod cMod'\n     | BinAnd \\<Rightarrow> f cBinAnd cBinAnd'\n     | BinOr \\<Rightarrow> f cBinOr cBinOr'\n     | BinXor \\<Rightarrow> f cBinXor cBinXor'\n     | ShiftLeft \\<Rightarrow> f cShiftLeft cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow> f cShiftRightZeros cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         f cShiftRightSigned cShiftRightSigned')", "by(simp split: bop.split)"], ["", "lemma sup_case_bop_case_bop_other [code_unfold]:\n  fixes p :: \"'a :: semilattice_sup\" shows\n  \"sup_class.sup (case_bop cEq cNotEq cLessThan cLessOrEqual cGreaterThan cGreaterOrEqual cAdd cSubtract cMult cDiv cMod cBinAnd cBinOr cBinXor cShiftLeft cShiftRightZeros cShiftRightSigned bop)\n     (sup_class.sup (case_bop cEq' cNotEq' cLessThan' cLessOrEqual' cGreaterThan' cGreaterOrEqual' cAdd' cSubtract' cMult' cDiv' cMod' cBinAnd' cBinOr' cBinXor' cShiftLeft' cShiftRightZeros' cShiftRightSigned' bop) p)\n  = sup_class.sup (case_bop (sup_class.sup cEq cEq') (sup_class.sup cNotEq cNotEq') (sup_class.sup cLessThan cLessThan') (sup_class.sup cLessOrEqual cLessOrEqual') (sup_class.sup cGreaterThan cGreaterThan') (sup_class.sup cGreaterOrEqual cGreaterOrEqual') (sup_class.sup cAdd cAdd') (sup_class.sup cSubtract cSubtract') (sup_class.sup cMult cMult') (sup_class.sup cDiv cDiv') (sup_class.sup cMod cMod') (sup_class.sup cBinAnd cBinAnd') (sup_class.sup cBinOr cBinOr') (sup_class.sup cBinXor cBinXor') (sup_class.sup cShiftLeft cShiftLeft') (sup_class.sup cShiftRightZeros cShiftRightZeros') (sup_class.sup cShiftRightSigned cShiftRightSigned') bop) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p", "apply(cases bop)"], ["proof (prove)\ngoal (17 subgoals):\n 1. bop = Eq \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 2. bop = NotEq \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 3. bop = LessThan \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 4. bop = LessOrEqual \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 5. bop = GreaterThan \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 6. bop = GreaterOrEqual \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 7. bop = Add \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 8. bop = Subtract \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 9. bop = Mult \\<Longrightarrow>\n    (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n     | LessThan \\<Rightarrow> cLessThan\n     | LessOrEqual \\<Rightarrow> cLessOrEqual\n     | GreaterThan \\<Rightarrow> cGreaterThan\n     | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual | Add \\<Rightarrow> cAdd\n     | Subtract \\<Rightarrow> cSubtract | Mult \\<Rightarrow> cMult\n     | Div \\<Rightarrow> cDiv | Mod \\<Rightarrow> cMod\n     | BinAnd \\<Rightarrow> cBinAnd | BinOr \\<Rightarrow> cBinOr\n     | BinXor \\<Rightarrow> cBinXor | ShiftLeft \\<Rightarrow> cShiftLeft\n     | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n     | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n    ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n      | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n      | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n     p) =\n    (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n     | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n     | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n     | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n     | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n     | GreaterOrEqual \\<Rightarrow>\n         cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n     | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n     | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n     | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n     | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n     | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n     | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n     | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n     | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n     | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n     | ShiftRightZeros \\<Rightarrow>\n         cShiftRightZeros \\<squnion> cShiftRightZeros'\n     | ShiftRightSigned \\<Rightarrow>\n         cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n    p\n 10. bop = Div \\<Longrightarrow>\n     (case bop of Eq \\<Rightarrow> cEq | NotEq \\<Rightarrow> cNotEq\n      | LessThan \\<Rightarrow> cLessThan\n      | LessOrEqual \\<Rightarrow> cLessOrEqual\n      | GreaterThan \\<Rightarrow> cGreaterThan\n      | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual\n      | Add \\<Rightarrow> cAdd | Subtract \\<Rightarrow> cSubtract\n      | Mult \\<Rightarrow> cMult | Div \\<Rightarrow> cDiv\n      | Mod \\<Rightarrow> cMod | BinAnd \\<Rightarrow> cBinAnd\n      | BinOr \\<Rightarrow> cBinOr | BinXor \\<Rightarrow> cBinXor\n      | ShiftLeft \\<Rightarrow> cShiftLeft\n      | ShiftRightZeros \\<Rightarrow> cShiftRightZeros\n      | ShiftRightSigned \\<Rightarrow> cShiftRightSigned) \\<squnion>\n     ((case bop of Eq \\<Rightarrow> cEq' | NotEq \\<Rightarrow> cNotEq'\n       | LessThan \\<Rightarrow> cLessThan'\n       | LessOrEqual \\<Rightarrow> cLessOrEqual'\n       | GreaterThan \\<Rightarrow> cGreaterThan'\n       | GreaterOrEqual \\<Rightarrow> cGreaterOrEqual'\n       | Add \\<Rightarrow> cAdd' | Subtract \\<Rightarrow> cSubtract'\n       | Mult \\<Rightarrow> cMult' | Div \\<Rightarrow> cDiv'\n       | Mod \\<Rightarrow> cMod' | BinAnd \\<Rightarrow> cBinAnd'\n       | BinOr \\<Rightarrow> cBinOr' | BinXor \\<Rightarrow> cBinXor'\n       | ShiftLeft \\<Rightarrow> cShiftLeft'\n       | ShiftRightZeros \\<Rightarrow> cShiftRightZeros'\n       | ShiftRightSigned \\<Rightarrow> cShiftRightSigned') \\<squnion>\n      p) =\n     (case bop of Eq \\<Rightarrow> cEq \\<squnion> cEq'\n      | NotEq \\<Rightarrow> cNotEq \\<squnion> cNotEq'\n      | LessThan \\<Rightarrow> cLessThan \\<squnion> cLessThan'\n      | LessOrEqual \\<Rightarrow> cLessOrEqual \\<squnion> cLessOrEqual'\n      | GreaterThan \\<Rightarrow> cGreaterThan \\<squnion> cGreaterThan'\n      | GreaterOrEqual \\<Rightarrow>\n          cGreaterOrEqual \\<squnion> cGreaterOrEqual'\n      | Add \\<Rightarrow> cAdd \\<squnion> cAdd'\n      | Subtract \\<Rightarrow> cSubtract \\<squnion> cSubtract'\n      | Mult \\<Rightarrow> cMult \\<squnion> cMult'\n      | Div \\<Rightarrow> cDiv \\<squnion> cDiv'\n      | Mod \\<Rightarrow> cMod \\<squnion> cMod'\n      | BinAnd \\<Rightarrow> cBinAnd \\<squnion> cBinAnd'\n      | BinOr \\<Rightarrow> cBinOr \\<squnion> cBinOr'\n      | BinXor \\<Rightarrow> cBinXor \\<squnion> cBinXor'\n      | ShiftLeft \\<Rightarrow> cShiftLeft \\<squnion> cShiftLeft'\n      | ShiftRightZeros \\<Rightarrow>\n          cShiftRightZeros \\<squnion> cShiftRightZeros'\n      | ShiftRightSigned \\<Rightarrow>\n          cShiftRightSigned \\<squnion> cShiftRightSigned') \\<squnion>\n     p\nA total of 17 subgoals...", "apply(simp_all add: inf_sup_aci sup.assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare op_case_bop_case_bop_same[where f=\"sup_class.sup\", code_unfold]"], ["", "end"]]}