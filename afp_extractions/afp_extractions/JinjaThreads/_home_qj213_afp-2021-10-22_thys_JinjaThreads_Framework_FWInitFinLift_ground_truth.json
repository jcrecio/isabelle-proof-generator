{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWInitFinLift.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma convert_obs_initial_convert_TA_initial: \n  \"convert_obs_initial (convert_TA_initial ta) = convert_TA_initial (convert_obs_initial ta)\"", "lemma convert_TA_initial_inject [simp]:\n  \"convert_TA_initial ta = convert_TA_initial ta' \\<longleftrightarrow> ta = ta'\"", "lemma multithreaded_init_fin: \"multithreaded init_fin_final init_fin\"", "lemma init_fin_\\<tau>move_simps [simp]:\n  \"init_fin_\\<tau>move ((PreStart, x), m) ta x'm' = False\"\n  \"init_fin_\\<tau>move xm ta ((PreStart, x'), m') = False\"\n  \"init_fin_\\<tau>move ((Running, x), m) ta ((s, x'), m') \\<longleftrightarrow>\n   (\\<exists>ta'. ta = convert_TA_initial (convert_obs_initial ta') \\<and> s = Running \\<and> \\<tau>move (x, m) ta' (x', m'))\"\n  \"init_fin_\\<tau>move ((s, x), m) ta ((Running, x'), m') \\<longleftrightarrow> \n   s = Running \\<and> (\\<exists>ta'. ta = convert_TA_initial (convert_obs_initial ta') \\<and> \\<tau>move (x, m) ta' (x', m'))\"\n  \"init_fin_\\<tau>move ((Finished, x), m) ta x'm' = False\"\n  \"init_fin_\\<tau>move xm ta ((Finished, x'), m') = False\"", "lemma init_fin_silent_move_RunningI:\n  assumes \"silent_move t (x, m) (x', m')\"\n  shows \"\\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move ((Running, x), m) ((Running, x'), m')\"", "lemma init_fin_silent_moves_RunningI:\n  assumes \"silent_moves t (x, m) (x', m')\"\n  shows \"\\<tau>trsys.silent_moves (init_fin t) init_fin_\\<tau>move ((Running, x), m) ((Running, x'), m')\"", "lemma init_fin_silent_moveD:\n  assumes \"\\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move ((s, x), m) ((s', x'), m')\"\n  shows \"silent_move t (x, m) (x', m') \\<and> s = s' \\<and> s' = Running\"", "lemma init_fin_silent_movesD:\n  assumes \"\\<tau>trsys.silent_moves (init_fin t) init_fin_\\<tau>move ((s, x), m) ((s', x'), m')\"\n  shows \"silent_moves t (x, m) (x', m') \\<and> s = s'\"", "lemma init_fin_\\<tau>divergeD:\n  assumes \"\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move ((status, x), m)\"\n  shows \"\\<tau>diverge t (x, m) \\<and> status = Running\"", "lemma init_fin_\\<tau>diverge_RunningI:\n  assumes \"\\<tau>diverge t (x, m)\"\n  shows \"\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move ((Running, x), m)\"", "lemma init_fin_\\<tau>diverge_conv:\n  \"\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move ((status, x), m) \\<longleftrightarrow>\n   \\<tau>diverge t (x, m) \\<and> status = Running\"", "lemma init_fin_\\<tau>moves_False:\n  \"\\<tau>multithreaded.init_fin_\\<tau>move (\\<lambda>_ _ _. False) = (\\<lambda>_ _ _. False)\"", "lemma \\<tau>multithreaded_wf_init_fin:\n  \"\\<tau>multithreaded_wf init_fin_final init_fin init_fin_\\<tau>move\"", "lemma lifting_inv_init_fin_lift_inv:\n  \"lifting_inv init_fin_final init_fin (init_fin_lift_inv P)\"", "lemma lifting_wf_init_fin_lift:\n  \"lifting_wf init_fin_final init_fin (init_fin_lift P)\"", "lemma (in if_lifting_wf) if_lifting_inv:\n  \"if_lifting_inv final r (\\<lambda>_::unit. P)\"", "lemma redT_silent_move_invariant:\n  \"\\<lbrakk> \\<tau>mredT s s'; ts_inv P Is (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_inv P Is (thr s') (shr s')\"", "lemma redT_silent_moves_invariant:\n  \"\\<lbrakk> mthr.silent_moves s s'; ts_inv P Is (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_inv P Is (thr s') (shr s')\"", "lemma redT_\\<tau>rtrancl3p_invariant:\n  \"\\<lbrakk> mthr.\\<tau>rtrancl3p s ttas s'; ts_inv P Is (thr s) (shr s) \\<rbrakk>\n  \\<Longrightarrow> ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) ttas))) (thr s') (shr s')\"", "lemma redT_silent_move_preserves:\n  \"\\<lbrakk> \\<tau>mredT s s'; ts_ok P (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_ok P (thr s') (shr s')\"", "lemma redT_silent_moves_preserves:\n  \"\\<lbrakk> mthr.silent_moves s s'; ts_ok P (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_ok P (thr s') (shr s')\"", "lemma redT_\\<tau>rtrancl3p_preserves:\n  \"\\<lbrakk> mthr.\\<tau>rtrancl3p s ttas s'; ts_ok P (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_ok P (thr s') (shr s')\"", "lemma ts_ok_init_fin_lift_init_fin_lift_state [simp]:\n  \"ts_ok (init_fin_lift P) (thr (init_fin_lift_state s \\<sigma>)) (shr (init_fin_lift_state s \\<sigma>)) \\<longleftrightarrow> ts_ok P (thr \\<sigma>) (shr \\<sigma>)\"", "lemma ts_inv_init_fin_lift_inv_init_fin_lift_state [simp]:\n  \"ts_inv (init_fin_lift_inv P) I (thr (init_fin_lift_state s \\<sigma>)) (shr (init_fin_lift_state s \\<sigma>)) \\<longleftrightarrow> \n   ts_inv P I (thr \\<sigma>) (shr \\<sigma>)\"", "lemma init_fin_lift_state_conv_simps:\n  shows shr_init_fin_lift_state: \"shr (init_fin_lift_state s \\<sigma>) = shr \\<sigma>\"\n  and locks_init_fin_lift_state: \"locks (init_fin_lift_state s \\<sigma>) = locks \\<sigma>\"\n  and wset_init_fin_lift_state: \"wset (init_fin_lift_state s \\<sigma>) = wset \\<sigma>\"\n  and interrupts_init_fin_lift_stae: \"interrupts (init_fin_lift_state s \\<sigma>) = interrupts \\<sigma>\"\n  and thr_init_fin_list_state: \n  \"thr (init_fin_lift_state s \\<sigma>) t = map_option (\\<lambda>(x, ln). ((s, x), ln)) (thr \\<sigma> t)\"", "lemma thr_init_fin_list_state': \n  \"thr (init_fin_lift_state s \\<sigma>) = map_option (\\<lambda>(x, ln). ((s, x), ln)) \\<circ> thr \\<sigma>\"", "lemma init_fin_descend_thr_Some_conv [simp]:\n  \"\\<And>ln. ts t = \\<lfloor>((status, x), ln)\\<rfloor> \\<Longrightarrow> init_fin_descend_thr ts t = \\<lfloor>(x, ln)\\<rfloor>\"", "lemma init_fin_descend_thr_None_conv [simp]:\n  \"ts t = None \\<Longrightarrow> init_fin_descend_thr ts t = None\"", "lemma init_fin_descend_thr_eq_None [simp]:\n  \"init_fin_descend_thr ts t = None \\<longleftrightarrow> ts t = None\"", "lemma init_fin_descend_state_simps [simp]:\n  \"init_fin_descend_state (ls, (ts, m), ws, is) = (ls, (init_fin_descend_thr ts, m), ws, is)\"\n  \"locks (init_fin_descend_state s) = locks s\"\n  \"thr (init_fin_descend_state s) = init_fin_descend_thr (thr s)\"\n  \"shr (init_fin_descend_state s) = shr s\"\n  \"wset (init_fin_descend_state s) = wset s\"\n  \"interrupts (init_fin_descend_state s) = interrupts s\"", "lemma init_fin_descend_thr_update [simp]:\n  \"init_fin_descend_thr (ts(t := v)) = (init_fin_descend_thr ts)(t := map_option (\\<lambda>((status, x), ln). (x, ln)) v)\"", "lemma ts_ok_init_fin_descend_state: \n  \"ts_ok P (init_fin_descend_thr ts) = ts_ok (init_fin_lift P) ts\"", "lemma free_thread_id_init_fin_descend_thr [simp]: \n  \"free_thread_id (init_fin_descend_thr ts) = free_thread_id ts\"", "lemma redT_updT'_init_fin_descend_thr_eq_None [simp]:\n  \"redT_updT' (init_fin_descend_thr ts) nt t = None \\<longleftrightarrow> redT_updT' ts nt t = None\"", "lemma thread_ok_init_fin_descend_thr [simp]: \n  \"thread_ok (init_fin_descend_thr ts) nta = thread_ok ts nta\"", "lemma threads_ok_init_fin_descend_thr [simp]:\n  \"thread_oks (init_fin_descend_thr ts) ntas = thread_oks ts ntas\"", "lemma init_fin_descend_thr_redT_updT [simp]:\n  \"init_fin_descend_thr (redT_updT ts (convert_new_thread_action (Pair status) nt)) =\n   redT_updT (init_fin_descend_thr ts) nt\"", "lemma init_fin_descend_thr_redT_updTs [simp]:\n  \"init_fin_descend_thr (redT_updTs ts (map (convert_new_thread_action (Pair status)) nts)) =\n   redT_updTs (init_fin_descend_thr ts) nts\"", "lemma cond_action_ok_init_fin_descend_stateI [simp]:\n  \"final_thread.cond_action_ok init_fin_final s t ct \\<Longrightarrow> cond_action_ok (init_fin_descend_state s) t ct\"", "lemma cond_action_oks_init_fin_descend_stateI [simp]:\n  \"final_thread.cond_action_oks init_fin_final s t cts \\<Longrightarrow> cond_action_oks (init_fin_descend_state s) t cts\"", "lemma length_lift_start_obs [simp]: \"length (lift_start_obs t obs) = Suc (length obs)\"", "lemma set_lift_start_obs [simp]:\n  \"set (lift_start_obs t obs) =\n   insert (t, InitialThreadAction) ((Pair t \\<circ> NormalAction) ` set obs)\"", "lemma distinct_lift_start_obs [simp]: \"distinct (lift_start_obs t obs) = distinct obs\""], "translations": [["", "lemma convert_obs_initial_convert_TA_initial: \n  \"convert_obs_initial (convert_TA_initial ta) = convert_TA_initial (convert_obs_initial ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_obs_initial (convert_TA_initial ta) =\n    convert_TA_initial (convert_obs_initial ta)", "by(simp add: convert_obs_initial_def)"], ["", "lemma convert_TA_initial_inject [simp]:\n  \"convert_TA_initial ta = convert_TA_initial ta' \\<longleftrightarrow> ta = ta'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (convert_TA_initial ta = convert_TA_initial ta') = (ta = ta')", "by(cases ta)(cases ta', auto)"], ["", "context final_thread begin"], ["", "primrec init_fin_final :: \"status \\<times> 'x \\<Rightarrow> bool\"\nwhere \"init_fin_final (status, x) \\<longleftrightarrow> status = Finished \\<and> final x\""], ["", "end"], ["", "context multithreaded_base begin"], ["", "inductive init_fin :: \"('l,'t,status \\<times> 'x,'m,'w,'o action) semantics\" (\"_ \\<turnstile> _ -_\\<rightarrow>i _\" [50,0,0,51] 51)\nwhere\n  NormalAction:\n  \"t \\<turnstile> \\<langle>x, m\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \n  \\<Longrightarrow> t \\<turnstile> ((Running, x), m) -convert_TA_initial (convert_obs_initial ta)\\<rightarrow>i ((Running, x'), m')\"\n\n| InitialThreadAction:\n  \"t \\<turnstile> ((PreStart, x), m) -\\<lbrace>InitialThreadAction\\<rbrace>\\<rightarrow>i ((Running, x), m)\"\n\n| ThreadFinishAction:\n  \"final x \\<Longrightarrow> t \\<turnstile> ((Running, x), m) -\\<lbrace>ThreadFinishAction\\<rbrace>\\<rightarrow>i ((Finished, x), m)\""], ["", "end"], ["", "declare split_paired_Ex [simp del]"], ["", "inductive_simps (in multithreaded_base) init_fin_simps [simp]:\n  \"t \\<turnstile> ((Finished, x), m) -ta\\<rightarrow>i xm'\"\n  \"t \\<turnstile> ((PreStart, x), m) -ta\\<rightarrow>i xm'\"\n  \"t \\<turnstile> ((Running, x), m) -ta\\<rightarrow>i xm'\"\n  \"t \\<turnstile> xm -ta\\<rightarrow>i ((Finished, x'), m')\"\n  \"t \\<turnstile> xm -ta\\<rightarrow>i ((Running, x'), m')\"\n  \"t \\<turnstile> xm -ta\\<rightarrow>i ((PreStart, x'), m')\""], ["", "declare split_paired_Ex [simp]"], ["", "context multithreaded begin"], ["", "lemma multithreaded_init_fin: \"multithreaded init_fin_final init_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded init_fin_final init_fin", "by(unfold_locales)(fastforce simp add: init_fin.simps convert_obs_initial_def ta_upd_simps dest: new_thread_memory)+"], ["", "end"], ["", "locale if_multithreaded_base = multithreaded_base +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\""], ["", "sublocale if_multithreaded_base < \"if\": multithreaded_base\n  \"init_fin_final\"\n  \"init_fin\"\n  \"map NormalAction \\<circ> convert_RA\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "locale if_multithreaded = if_multithreaded_base + multithreaded +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\""], ["", "sublocale if_multithreaded < \"if\": multithreaded\n  \"init_fin_final\"\n  \"init_fin\"\n  \"map NormalAction \\<circ> convert_RA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded init_fin_final init_fin", "by(rule multithreaded_init_fin)"], ["", "context \\<tau>multithreaded begin"], ["", "inductive init_fin_\\<tau>move :: \"('l,'t,status \\<times> 'x,'m,'w,'o action) \\<tau>moves\"\nwhere\n  \"\\<tau>move (x, m) ta (x', m') \n  \\<Longrightarrow> init_fin_\\<tau>move ((Running, x), m) (convert_TA_initial (convert_obs_initial ta)) ((Running, x'), m')\""], ["", "lemma init_fin_\\<tau>move_simps [simp]:\n  \"init_fin_\\<tau>move ((PreStart, x), m) ta x'm' = False\"\n  \"init_fin_\\<tau>move xm ta ((PreStart, x'), m') = False\"\n  \"init_fin_\\<tau>move ((Running, x), m) ta ((s, x'), m') \\<longleftrightarrow>\n   (\\<exists>ta'. ta = convert_TA_initial (convert_obs_initial ta') \\<and> s = Running \\<and> \\<tau>move (x, m) ta' (x', m'))\"\n  \"init_fin_\\<tau>move ((s, x), m) ta ((Running, x'), m') \\<longleftrightarrow> \n   s = Running \\<and> (\\<exists>ta'. ta = convert_TA_initial (convert_obs_initial ta') \\<and> \\<tau>move (x, m) ta' (x', m'))\"\n  \"init_fin_\\<tau>move ((Finished, x), m) ta x'm' = False\"\n  \"init_fin_\\<tau>move xm ta ((Finished, x'), m') = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (init_fin_\\<tau>move ((PreStart, x), m) ta x'm' = False &&&\n     init_fin_\\<tau>move xm ta ((PreStart, x'), m') = False &&&\n     init_fin_\\<tau>move ((Running, x), m) ta ((s, x'), m') =\n     (\\<exists>ta'.\n         ta = convert_TA_initial (convert_obs_initial ta') \\<and>\n         s = Running \\<and> \\<tau>move (x, m) ta' (x', m'))) &&&\n    init_fin_\\<tau>move ((s, x), m) ta ((Running, x'), m') =\n    (s = Running \\<and>\n     (\\<exists>ta'.\n         ta = convert_TA_initial (convert_obs_initial ta') \\<and>\n         \\<tau>move (x, m) ta' (x', m'))) &&&\n    init_fin_\\<tau>move ((Finished, x), m) ta x'm' = False &&&\n    init_fin_\\<tau>move xm ta ((Finished, x'), m') = False", "by(simp_all add: init_fin_\\<tau>move.simps)"], ["", "lemma init_fin_silent_move_RunningI:\n  assumes \"silent_move t (x, m) (x', m')\"\n  shows \"\\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move ((Running, x), m) ((Running, x'), m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move\n     ((Running, x), m) ((Running, x'), m')", "using assms"], ["proof (prove)\nusing this:\n  silent_move t (x, m) (x', m')\n\ngoal (1 subgoal):\n 1. \\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move\n     ((Running, x), m) ((Running, x'), m')", "by(cases)(auto intro: \\<tau>trsys.silent_move.intros init_fin.NormalAction)"], ["", "lemma init_fin_silent_moves_RunningI:\n  assumes \"silent_moves t (x, m) (x', m')\"\n  shows \"\\<tau>trsys.silent_moves (init_fin t) init_fin_\\<tau>move ((Running, x), m) ((Running, x'), m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>trsys.silent_move (init_fin t)\n      init_fin_\\<tau>move)\\<^sup>*\\<^sup>*\n     ((Running, x), m) ((Running, x'), m')", "using assms"], ["proof (prove)\nusing this:\n  silent_moves t (x, m) (x', m')\n\ngoal (1 subgoal):\n 1. (\\<tau>trsys.silent_move (init_fin t)\n      init_fin_\\<tau>move)\\<^sup>*\\<^sup>*\n     ((Running, x), m) ((Running, x'), m')", "by(induct rule: rtranclp_induct2)(auto elim: rtranclp.rtrancl_into_rtrancl intro: init_fin_silent_move_RunningI)"], ["", "lemma init_fin_silent_moveD:\n  assumes \"\\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move ((s, x), m) ((s', x'), m')\"\n  shows \"silent_move t (x, m) (x', m') \\<and> s = s' \\<and> s' = Running\""], ["proof (prove)\ngoal (1 subgoal):\n 1. silent_move t (x, m) (x', m') \\<and> s = s' \\<and> s' = Running", "using assms"], ["proof (prove)\nusing this:\n  \\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move ((s, x), m)\n   ((s', x'), m')\n\ngoal (1 subgoal):\n 1. silent_move t (x, m) (x', m') \\<and> s = s' \\<and> s' = Running", "by(auto elim!: \\<tau>trsys.silent_move.cases init_fin.cases)"], ["", "lemma init_fin_silent_movesD:\n  assumes \"\\<tau>trsys.silent_moves (init_fin t) init_fin_\\<tau>move ((s, x), m) ((s', x'), m')\"\n  shows \"silent_moves t (x, m) (x', m') \\<and> s = s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. silent_moves t (x, m) (x', m') \\<and> s = s'", "using assms"], ["proof (prove)\nusing this:\n  (\\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move)\\<^sup>*\\<^sup>*\n   ((s, x), m) ((s', x'), m')\n\ngoal (1 subgoal):\n 1. silent_moves t (x, m) (x', m') \\<and> s = s'", "by(induct \"((s, x), m)\" \"((s', x'), m')\" arbitrary: s' x' m')\n  (auto 7 2 simp only: dest!: init_fin_silent_moveD intro: rtranclp.rtrancl_into_rtrancl)"], ["", "lemma init_fin_\\<tau>divergeD:\n  assumes \"\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move ((status, x), m)\"\n  shows \"\\<tau>diverge t (x, m) \\<and> status = Running\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>diverge t (x, m) \\<and> status = Running", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>diverge t (x, m)\n 2. status = Running", "from assms"], ["proof (chain)\npicking this:\n  \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n   ((status, x), m)", "show \"status = Running\""], ["proof (prove)\nusing this:\n  \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n   ((status, x), m)\n\ngoal (1 subgoal):\n 1. status = Running", "by(cases rule: \\<tau>trsys.\\<tau>diverge.cases[consumes 1])(auto dest: init_fin_silent_moveD)"], ["proof (state)\nthis:\n  status = Running\n\ngoal (1 subgoal):\n 1. \\<tau>diverge t (x, m)", "moreover"], ["proof (state)\nthis:\n  status = Running\n\ngoal (1 subgoal):\n 1. \\<tau>diverge t (x, m)", "define xm where \"xm = (x, m)\""], ["proof (state)\nthis:\n  xm = (x, m)\n\ngoal (1 subgoal):\n 1. \\<tau>diverge t (x, m)", "ultimately"], ["proof (chain)\npicking this:\n  status = Running\n  xm = (x, m)", "have \"\\<exists>x m. xm = (x, m) \\<and> \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move ((Running, x), m)\""], ["proof (prove)\nusing this:\n  status = Running\n  xm = (x, m)\n\ngoal (1 subgoal):\n 1. \\<exists>x m.\n       xm = (x, m) \\<and>\n       \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n        ((Running, x), m)", "using assms"], ["proof (prove)\nusing this:\n  status = Running\n  xm = (x, m)\n  \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n   ((status, x), m)\n\ngoal (1 subgoal):\n 1. \\<exists>x m.\n       xm = (x, m) \\<and>\n       \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n        ((Running, x), m)", "by blast"], ["proof (state)\nthis:\n  \\<exists>x m.\n     xm = (x, m) \\<and>\n     \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n      ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<tau>diverge t (x, m)", "thus \"\\<tau>diverge t xm\""], ["proof (prove)\nusing this:\n  \\<exists>x m.\n     xm = (x, m) \\<and>\n     \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n      ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<tau>diverge t xm", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa m.\n          x = (xa, m) \\<and>\n          \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n           ((Running, xa), m) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          silent_move t s s' \\<and>\n          ((\\<exists>x m.\n               s' = (x, m) \\<and>\n               \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n                ((Running, x), m)) \\<or>\n           \\<tau>diverge t s')", "case (\\<tau>diverge xm)"], ["proof (state)\nthis:\n  \\<exists>x m.\n     xm = (x, m) \\<and>\n     \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n      ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa m.\n          x = (xa, m) \\<and>\n          \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n           ((Running, xa), m) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          silent_move t s s' \\<and>\n          ((\\<exists>x m.\n               s' = (x, m) \\<and>\n               \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n                ((Running, x), m)) \\<or>\n           \\<tau>diverge t s')", "then"], ["proof (chain)\npicking this:\n  \\<exists>x m.\n     xm = (x, m) \\<and>\n     \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n      ((Running, x), m)", "obtain x m \n      where diverge: \"\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move ((Running, x), m)\" \n      and xm: \"xm = (x, m)\""], ["proof (prove)\nusing this:\n  \\<exists>x m.\n     xm = (x, m) \\<and>\n     \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n      ((Running, x), m)\n\ngoal (1 subgoal):\n 1. (\\<And>x m.\n        \\<lbrakk>\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n                  ((Running, x), m);\n         xm = (x, m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n   ((Running, x), m)\n  xm = (x, m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa m.\n          x = (xa, m) \\<and>\n          \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n           ((Running, xa), m) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          silent_move t s s' \\<and>\n          ((\\<exists>x m.\n               s' = (x, m) \\<and>\n               \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n                ((Running, x), m)) \\<or>\n           \\<tau>diverge t s')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n   ((Running, x), m)\n  xm = (x, m)\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       xm = s \\<and>\n       silent_move t s s' \\<and>\n       ((\\<exists>x m.\n            s' = (x, m) \\<and>\n            \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n             ((Running, x), m)) \\<or>\n        \\<tau>diverge t s')", "by(cases rule:\\<tau>trsys.\\<tau>diverge.cases[consumes 1])(auto dest!: init_fin_silent_moveD)"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     xm = s \\<and>\n     silent_move t s s' \\<and>\n     ((\\<exists>x m.\n          s' = (x, m) \\<and>\n          \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n           ((Running, x), m)) \\<or>\n      \\<tau>diverge t s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>diverge t xm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma init_fin_\\<tau>diverge_RunningI:\n  assumes \"\\<tau>diverge t (x, m)\"\n  shows \"\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move ((Running, x), m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n     ((Running, x), m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n     ((Running, x), m)", "define sxm where \"sxm = ((Running, x), m)\""], ["proof (state)\nthis:\n  sxm = ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n     ((Running, x), m)", "with assms"], ["proof (chain)\npicking this:\n  \\<tau>diverge t (x, m)\n  sxm = ((Running, x), m)", "have \"\\<exists>x m. \\<tau>diverge t (x, m) \\<and> sxm = ((Running, x), m)\""], ["proof (prove)\nusing this:\n  \\<tau>diverge t (x, m)\n  sxm = ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<exists>x m. \\<tau>diverge t (x, m) \\<and> sxm = ((Running, x), m)", "by blast"], ["proof (state)\nthis:\n  \\<exists>x m. \\<tau>diverge t (x, m) \\<and> sxm = ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n     ((Running, x), m)", "thus \"\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move sxm\""], ["proof (prove)\nusing this:\n  \\<exists>x m. \\<tau>diverge t (x, m) \\<and> sxm = ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move sxm", "proof(coinduct rule: \\<tau>trsys.\\<tau>diverge.coinduct[consumes 1, case_names \\<tau>diverge])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa m.\n          \\<tau>diverge t (xa, m) \\<and>\n          x = ((Running, xa), m) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          \\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move s\n           s' \\<and>\n          ((\\<exists>x m.\n               \\<tau>diverge t (x, m) \\<and> s' = ((Running, x), m)) \\<or>\n           \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move s')", "case (\\<tau>diverge sxm)"], ["proof (state)\nthis:\n  \\<exists>x m. \\<tau>diverge t (x, m) \\<and> sxm = ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa m.\n          \\<tau>diverge t (xa, m) \\<and>\n          x = ((Running, xa), m) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          \\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move s\n           s' \\<and>\n          ((\\<exists>x m.\n               \\<tau>diverge t (x, m) \\<and> s' = ((Running, x), m)) \\<or>\n           \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move s')", "then"], ["proof (chain)\npicking this:\n  \\<exists>x m. \\<tau>diverge t (x, m) \\<and> sxm = ((Running, x), m)", "obtain x m where \"\\<tau>diverge t (x, m)\" and \"sxm = ((Running, x), m)\""], ["proof (prove)\nusing this:\n  \\<exists>x m. \\<tau>diverge t (x, m) \\<and> sxm = ((Running, x), m)\n\ngoal (1 subgoal):\n 1. (\\<And>x m.\n        \\<lbrakk>\\<tau>diverge t (x, m); sxm = ((Running, x), m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<tau>diverge t (x, m)\n  sxm = ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa m.\n          \\<tau>diverge t (xa, m) \\<and>\n          x = ((Running, xa), m) \\<Longrightarrow>\n       \\<exists>s s'.\n          x = s \\<and>\n          \\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move s\n           s' \\<and>\n          ((\\<exists>x m.\n               \\<tau>diverge t (x, m) \\<and> s' = ((Running, x), m)) \\<or>\n           \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move s')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<tau>diverge t (x, m)\n  sxm = ((Running, x), m)\n\ngoal (1 subgoal):\n 1. \\<exists>s s'.\n       sxm = s \\<and>\n       \\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move s s' \\<and>\n       ((\\<exists>x m.\n            \\<tau>diverge t (x, m) \\<and> s' = ((Running, x), m)) \\<or>\n        \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move s')", "by(cases)(auto intro: init_fin_silent_move_RunningI)"], ["proof (state)\nthis:\n  \\<exists>s s'.\n     sxm = s \\<and>\n     \\<tau>trsys.silent_move (init_fin t) init_fin_\\<tau>move s s' \\<and>\n     ((\\<exists>x m.\n          \\<tau>diverge t (x, m) \\<and> s' = ((Running, x), m)) \\<or>\n      \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move sxm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma init_fin_\\<tau>diverge_conv:\n  \"\\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move ((status, x), m) \\<longleftrightarrow>\n   \\<tau>diverge t (x, m) \\<and> status = Running\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>trsys.\\<tau>diverge (init_fin t) init_fin_\\<tau>move\n     ((status, x), m) =\n    (\\<tau>diverge t (x, m) \\<and> status = Running)", "by(blast intro: init_fin_\\<tau>diverge_RunningI dest: init_fin_\\<tau>divergeD)"], ["", "end"], ["", "lemma init_fin_\\<tau>moves_False:\n  \"\\<tau>multithreaded.init_fin_\\<tau>move (\\<lambda>_ _ _. False) = (\\<lambda>_ _ _. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded.init_fin_\\<tau>move (\\<lambda>_ _ _. False) =\n    (\\<lambda>_ _ _. False)", "by(simp add: fun_eq_iff \\<tau>multithreaded.init_fin_\\<tau>move.simps)"], ["", "locale if_\\<tau>multithreaded = if_multithreaded_base + \\<tau>multithreaded +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \\<tau>move :: \"('l,'t,'x,'m,'w,'o) \\<tau>moves\""], ["", "sublocale if_\\<tau>multithreaded < \"if\": \\<tau>multithreaded\n  \"init_fin_final\"\n  \"init_fin\"\n  \"map NormalAction \\<circ> convert_RA\"\n  \"init_fin_\\<tau>move\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "locale if_\\<tau>multithreaded_wf = if_multithreaded_base + \\<tau>multithreaded_wf +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \\<tau>move :: \"('l,'t,'x,'m,'w,'o) \\<tau>moves\""], ["", "sublocale if_\\<tau>multithreaded_wf < if_multithreaded"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_multithreaded final r", "by unfold_locales"], ["", "sublocale if_\\<tau>multithreaded_wf < if_\\<tau>multithreaded"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context \\<tau>multithreaded_wf begin"], ["", "lemma \\<tau>multithreaded_wf_init_fin:\n  \"\\<tau>multithreaded_wf init_fin_final init_fin init_fin_\\<tau>move\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf init_fin_final init_fin init_fin_\\<tau>move", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf init_fin_final init_fin init_fin_\\<tau>move", "interpret \"if\": multithreaded init_fin_final init_fin \"map NormalAction \\<circ> convert_RA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded init_fin_final init_fin", "by(rule multithreaded_init_fin)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf init_fin_final init_fin init_fin_\\<tau>move", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf init_fin_final init_fin init_fin_\\<tau>move", "proof(unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>if.r_syntax t x m ta x' m';\n        init_fin_\\<tau>move (x, m) ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       init_fin_\\<tau>move s ta s' \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "fix t x m ta x' m'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>if.r_syntax t x m ta x' m';\n        init_fin_\\<tau>move (x, m) ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       init_fin_\\<tau>move s ta s' \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "assume \"init_fin_\\<tau>move (x, m) ta (x', m')\" \"t \\<turnstile> (x, m) -ta\\<rightarrow>i (x', m')\""], ["proof (state)\nthis:\n  init_fin_\\<tau>move (x, m) ta (x', m')\n  if.r_syntax t x m ta x' m'\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>if.r_syntax t x m ta x' m';\n        init_fin_\\<tau>move (x, m) ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       init_fin_\\<tau>move s ta s' \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "thus \"m = m'\""], ["proof (prove)\nusing this:\n  init_fin_\\<tau>move (x, m) ta (x', m')\n  if.r_syntax t x m ta x' m'\n\ngoal (1 subgoal):\n 1. m = m'", "by(cases)(auto dest: \\<tau>move_heap)"], ["proof (state)\nthis:\n  m = m'\n\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       init_fin_\\<tau>move s ta s' \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       init_fin_\\<tau>move s ta s' \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "fix s ta s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       init_fin_\\<tau>move s ta s' \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "assume \"init_fin_\\<tau>move s ta s'\""], ["proof (state)\nthis:\n  init_fin_\\<tau>move s ta s'\n\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       init_fin_\\<tau>move s ta s' \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>", "thus \"ta = \\<epsilon>\""], ["proof (prove)\nusing this:\n  init_fin_\\<tau>move s ta s'\n\ngoal (1 subgoal):\n 1. ta = \\<lbrace>\\<rbrace>", "by(cases)(auto dest: silent_tl)"], ["proof (state)\nthis:\n  ta = \\<lbrace>\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>multithreaded_wf init_fin_final init_fin init_fin_\\<tau>move\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale if_\\<tau>multithreaded_wf < \"if\": \\<tau>multithreaded_wf\n  \"init_fin_final\"\n  \"init_fin\"\n  \"map NormalAction \\<circ> convert_RA\"\n  \"init_fin_\\<tau>move\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf init_fin_final init_fin init_fin_\\<tau>move", "by(rule \\<tau>multithreaded_wf_init_fin)"], ["", "primrec init_fin_lift_inv :: \"('i \\<Rightarrow> 't \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool) \\<Rightarrow> 'i \\<Rightarrow> 't \\<Rightarrow> status \\<times> 'x \\<Rightarrow> 'm \\<Rightarrow> bool\"\nwhere \"init_fin_lift_inv P I t (s, x) = P I t x\""], ["", "context lifting_inv begin"], ["", "lemma lifting_inv_init_fin_lift_inv:\n  \"lifting_inv init_fin_final init_fin (init_fin_lift_inv P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_inv init_fin_final init_fin (init_fin_lift_inv P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lifting_inv init_fin_final init_fin (init_fin_lift_inv P)", "interpret \"if\": multithreaded init_fin_final init_fin \"map NormalAction \\<circ> convert_RA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded init_fin_final init_fin", "by(rule multithreaded_init_fin)"], ["proof (state)\ngoal (1 subgoal):\n 1. lifting_inv init_fin_final init_fin (init_fin_lift_inv P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_inv init_fin_final init_fin (init_fin_lift_inv P)", "by(unfold_locales)(fastforce elim!: init_fin.cases dest: invariant_red invariant_NewThread invariant_other)+"], ["proof (state)\nthis:\n  lifting_inv init_fin_final init_fin (init_fin_lift_inv P)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale if_lifting_inv =\n  if_multithreaded +\n  lifting_inv +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and P :: \"'i \\<Rightarrow> 't \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool\""], ["", "sublocale if_lifting_inv < \"if\": lifting_inv\n  init_fin_final\n  init_fin\n  \"map NormalAction \\<circ> convert_RA\"\n  \"init_fin_lift_inv P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_inv init_fin_final init_fin (init_fin_lift_inv P)", "by(rule lifting_inv_init_fin_lift_inv)"], ["", "primrec init_fin_lift :: \"('t \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool) \\<Rightarrow> 't \\<Rightarrow> status \\<times> 'x \\<Rightarrow> 'm \\<Rightarrow> bool\"\nwhere \"init_fin_lift P t (s, x) = P t x\""], ["", "context lifting_wf begin"], ["", "lemma lifting_wf_init_fin_lift:\n  \"lifting_wf init_fin_final init_fin (init_fin_lift P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf init_fin_final init_fin (init_fin_lift P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lifting_wf init_fin_final init_fin (init_fin_lift P)", "interpret \"if\": multithreaded init_fin_final init_fin \"map NormalAction \\<circ> convert_RA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded init_fin_final init_fin", "by(rule multithreaded_init_fin)"], ["proof (state)\ngoal (1 subgoal):\n 1. lifting_wf init_fin_final init_fin (init_fin_lift P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf init_fin_final init_fin (init_fin_lift P)", "by(unfold_locales)(fastforce elim!: init_fin.cases dest: dest: preserves_red preserves_other preserves_NewThread)+"], ["proof (state)\nthis:\n  lifting_wf init_fin_final init_fin (init_fin_lift P)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale if_lifting_wf =\n  if_multithreaded +\n  lifting_wf +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and P :: \"'t \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool\""], ["", "sublocale if_lifting_wf < \"if\": lifting_wf \n  init_fin_final\n  init_fin\n  \"map NormalAction \\<circ> convert_RA\"\n  \"init_fin_lift P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf init_fin_final init_fin (init_fin_lift P)", "by(rule lifting_wf_init_fin_lift)"], ["", "lemma (in if_lifting_wf) if_lifting_inv:\n  \"if_lifting_inv final r (\\<lambda>_::unit. P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_lifting_inv final r (\\<lambda>_. P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if_lifting_inv final r (\\<lambda>_. P)", "interpret lifting_inv final r convert_RA  \"\\<lambda>_ :: unit. P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_inv final r (\\<lambda>_. P)", "by(rule lifting_inv)"], ["proof (state)\ngoal (1 subgoal):\n 1. if_lifting_inv final r (\\<lambda>_. P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_lifting_inv final r (\\<lambda>_. P)", "by unfold_locales"], ["proof (state)\nthis:\n  if_lifting_inv final r (\\<lambda>_. P)\n\ngoal:\nNo subgoals!", "qed"], ["", "locale \\<tau>lifting_inv = \\<tau>multithreaded_wf +\n  lifting_inv +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \\<tau>move :: \"('l,'t,'x,'m,'w,'o) \\<tau>moves\"\n  and P :: \"'i \\<Rightarrow> 't \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool\"\nbegin"], ["", "lemma redT_silent_move_invariant:\n  \"\\<lbrakk> \\<tau>mredT s s'; ts_inv P Is (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_inv P Is (thr s') (shr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>mredT s s'; ts_inv P Is (thr s) (shr s)\\<rbrakk>\n    \\<Longrightarrow> ts_inv P Is (thr s') (shr s')", "by(auto dest!: redT_invariant m\\<tau>move_silentD)"], ["", "lemma redT_silent_moves_invariant:\n  \"\\<lbrakk> mthr.silent_moves s s'; ts_inv P Is (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_inv P Is (thr s') (shr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mthr.silent_moves s s'; ts_inv P Is (thr s) (shr s)\\<rbrakk>\n    \\<Longrightarrow> ts_inv P Is (thr s') (shr s')", "by(induct rule: rtranclp_induct)(auto dest: redT_silent_move_invariant)"], ["", "lemma redT_\\<tau>rtrancl3p_invariant:\n  \"\\<lbrakk> mthr.\\<tau>rtrancl3p s ttas s'; ts_inv P Is (thr s) (shr s) \\<rbrakk>\n  \\<Longrightarrow> ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) ttas))) (thr s') (shr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mthr.\\<tau>rtrancl3p s ttas s';\n     ts_inv P Is (thr s) (shr s)\\<rbrakk>\n    \\<Longrightarrow> ts_inv P\n                       (upd_invs Is P\n                         (concat (map (thr_a \\<circ> snd) ttas)))\n                       (thr s') (shr s')", "proof(induct arbitrary: Is rule: mthr.\\<tau>rtrancl3p.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s Is.\n       ts_inv P Is (thr s) (shr s) \\<Longrightarrow>\n       ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) [])))\n        (thr s) (shr s)\n 2. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; \\<not> m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) (tl # tls))))\n                          (thr s'') (shr s'')\n 3. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) tls)))\n                          (thr s'') (shr s'')", "case \\<tau>rtrancl3p_refl"], ["proof (state)\nthis:\n  ts_inv P Is (thr s_) (shr s_)\n\ngoal (3 subgoals):\n 1. \\<And>s Is.\n       ts_inv P Is (thr s) (shr s) \\<Longrightarrow>\n       ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) [])))\n        (thr s) (shr s)\n 2. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; \\<not> m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) (tl # tls))))\n                          (thr s'') (shr s'')\n 3. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) tls)))\n                          (thr s'') (shr s'')", "thus ?case"], ["proof (prove)\nusing this:\n  ts_inv P Is (thr s_) (shr s_)\n\ngoal (1 subgoal):\n 1. ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) []))) (thr s_)\n     (shr s_)", "by simp"], ["proof (state)\nthis:\n  ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) []))) (thr s_)\n   (shr s_)\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; \\<not> m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) (tl # tls))))\n                          (thr s'') (shr s'')\n 2. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) tls)))\n                          (thr s'') (shr s'')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; \\<not> m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) (tl # tls))))\n                          (thr s'') (shr s'')\n 2. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) tls)))\n                          (thr s'') (shr s'')", "case (\\<tau>rtrancl3p_step s s' tls s'' tl)"], ["proof (state)\nthis:\n  redT s tl s'\n  \\<not> m\\<tau>move s tl s'\n  mthr.\\<tau>rtrancl3p s' tls s''\n  ts_inv P ?Is12 (thr s') (shr s') \\<Longrightarrow>\n  ts_inv P (upd_invs ?Is12 P (concat (map (thr_a \\<circ> snd) tls)))\n   (thr s'') (shr s'')\n  ts_inv P Is (thr s) (shr s)\n\ngoal (2 subgoals):\n 1. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; \\<not> m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) (tl # tls))))\n                          (thr s'') (shr s'')\n 2. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) tls)))\n                          (thr s'') (shr s'')", "thus ?case"], ["proof (prove)\nusing this:\n  redT s tl s'\n  \\<not> m\\<tau>move s tl s'\n  mthr.\\<tau>rtrancl3p s' tls s''\n  ts_inv P ?Is12 (thr s') (shr s') \\<Longrightarrow>\n  ts_inv P (upd_invs ?Is12 P (concat (map (thr_a \\<circ> snd) tls)))\n   (thr s'') (shr s'')\n  ts_inv P Is (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) (tl # tls))))\n     (thr s'') (shr s'')", "by(cases tl)(force dest: redT_invariant)"], ["proof (state)\nthis:\n  ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) (tl # tls))))\n   (thr s'') (shr s'')\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) tls)))\n                          (thr s'') (shr s'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) tls)))\n                          (thr s'') (shr s'')", "case (\\<tau>rtrancl3p_\\<tau>step s s' tls s'' tl)"], ["proof (state)\nthis:\n  redT s tl s'\n  m\\<tau>move s tl s'\n  mthr.\\<tau>rtrancl3p s' tls s''\n  ts_inv P ?Is12 (thr s') (shr s') \\<Longrightarrow>\n  ts_inv P (upd_invs ?Is12 P (concat (map (thr_a \\<circ> snd) tls)))\n   (thr s'') (shr s'')\n  ts_inv P Is (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. \\<And>s s' tls s'' tl Is.\n       \\<lbrakk>redT s tl s'; m\\<tau>move s tl s';\n        mthr.\\<tau>rtrancl3p s' tls s'';\n        \\<And>Is.\n           ts_inv P Is (thr s') (shr s') \\<Longrightarrow>\n           ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n            (thr s'') (shr s'');\n        ts_inv P Is (thr s) (shr s)\\<rbrakk>\n       \\<Longrightarrow> ts_inv P\n                          (upd_invs Is P\n                            (concat (map (thr_a \\<circ> snd) tls)))\n                          (thr s'') (shr s'')", "thus ?case"], ["proof (prove)\nusing this:\n  redT s tl s'\n  m\\<tau>move s tl s'\n  mthr.\\<tau>rtrancl3p s' tls s''\n  ts_inv P ?Is12 (thr s') (shr s') \\<Longrightarrow>\n  ts_inv P (upd_invs ?Is12 P (concat (map (thr_a \\<circ> snd) tls)))\n   (thr s'') (shr s'')\n  ts_inv P Is (thr s) (shr s)\n\ngoal (1 subgoal):\n 1. ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls)))\n     (thr s'') (shr s'')", "by(cases tl)(force dest: redT_invariant m\\<tau>move_silentD)"], ["proof (state)\nthis:\n  ts_inv P (upd_invs Is P (concat (map (thr_a \\<circ> snd) tls))) (thr s'')\n   (shr s'')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale \\<tau>lifting_wf = \\<tau>multithreaded +\n  lifting_wf +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\" \n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and \\<tau>move :: \"('l,'t,'x,'m,'w,'o) \\<tau>moves\"\n  and P :: \"'t \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool\"\nbegin"], ["", "lemma redT_silent_move_preserves:\n  \"\\<lbrakk> \\<tau>mredT s s'; ts_ok P (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_ok P (thr s') (shr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>mredT s s'; ts_ok P (thr s) (shr s)\\<rbrakk>\n    \\<Longrightarrow> ts_ok P (thr s') (shr s')", "by(auto dest: redT_preserves)"], ["", "lemma redT_silent_moves_preserves:\n  \"\\<lbrakk> mthr.silent_moves s s'; ts_ok P (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_ok P (thr s') (shr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mthr.silent_moves s s'; ts_ok P (thr s) (shr s)\\<rbrakk>\n    \\<Longrightarrow> ts_ok P (thr s') (shr s')", "by(induct rule: rtranclp.induct)(auto dest: redT_silent_move_preserves)"], ["", "lemma redT_\\<tau>rtrancl3p_preserves:\n  \"\\<lbrakk> mthr.\\<tau>rtrancl3p s ttas s'; ts_ok P (thr s) (shr s) \\<rbrakk> \\<Longrightarrow> ts_ok P (thr s') (shr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mthr.\\<tau>rtrancl3p s ttas s';\n     ts_ok P (thr s) (shr s)\\<rbrakk>\n    \\<Longrightarrow> ts_ok P (thr s') (shr s')", "by(induct rule: mthr.\\<tau>rtrancl3p.induct)(auto dest: redT_silent_moves_preserves redT_preserves)"], ["", "end"], ["", "definition init_fin_lift_state :: \"status \\<Rightarrow> ('l,'t,'x,'m,'w) state \\<Rightarrow> ('l,'t,status \\<times> 'x,'m,'w) state\"\nwhere \"init_fin_lift_state s \\<sigma> = (locks \\<sigma>, (\\<lambda>t. map_option (\\<lambda>(x, ln). ((s, x), ln)) (thr \\<sigma> t), shr \\<sigma>), wset \\<sigma>, interrupts \\<sigma>)\""], ["", "definition init_fin_descend_thr :: \"('l,'t,'status \\<times> 'x) thread_info \\<Rightarrow> ('l,'t,'x) thread_info\"\nwhere \"init_fin_descend_thr ts = map_option (\\<lambda>((s, x), ln). (x, ln)) \\<circ> ts\""], ["", "definition init_fin_descend_state :: \"('l,'t,'status \\<times> 'x,'m,'w) state \\<Rightarrow> ('l,'t,'x,'m,'w) state\"\nwhere \"init_fin_descend_state \\<sigma> = (locks \\<sigma>, (init_fin_descend_thr (thr \\<sigma>), shr \\<sigma>), wset \\<sigma>, interrupts \\<sigma>)\""], ["", "lemma ts_ok_init_fin_lift_init_fin_lift_state [simp]:\n  \"ts_ok (init_fin_lift P) (thr (init_fin_lift_state s \\<sigma>)) (shr (init_fin_lift_state s \\<sigma>)) \\<longleftrightarrow> ts_ok P (thr \\<sigma>) (shr \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ok (init_fin_lift P) (thr (init_fin_lift_state s \\<sigma>))\n     (shr (init_fin_lift_state s \\<sigma>)) =\n    ts_ok P (thr \\<sigma>) (shr \\<sigma>)", "by(auto simp add: init_fin_lift_state_def intro!: ts_okI dest: ts_okD)"], ["", "lemma ts_inv_init_fin_lift_inv_init_fin_lift_state [simp]:\n  \"ts_inv (init_fin_lift_inv P) I (thr (init_fin_lift_state s \\<sigma>)) (shr (init_fin_lift_state s \\<sigma>)) \\<longleftrightarrow> \n   ts_inv P I (thr \\<sigma>) (shr \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_inv (init_fin_lift_inv P) I (thr (init_fin_lift_state s \\<sigma>))\n     (shr (init_fin_lift_state s \\<sigma>)) =\n    ts_inv P I (thr \\<sigma>) (shr \\<sigma>)", "by(auto simp add: init_fin_lift_state_def intro!: ts_invI dest: ts_invD)"], ["", "lemma init_fin_lift_state_conv_simps:\n  shows shr_init_fin_lift_state: \"shr (init_fin_lift_state s \\<sigma>) = shr \\<sigma>\"\n  and locks_init_fin_lift_state: \"locks (init_fin_lift_state s \\<sigma>) = locks \\<sigma>\"\n  and wset_init_fin_lift_state: \"wset (init_fin_lift_state s \\<sigma>) = wset \\<sigma>\"\n  and interrupts_init_fin_lift_stae: \"interrupts (init_fin_lift_state s \\<sigma>) = interrupts \\<sigma>\"\n  and thr_init_fin_list_state: \n  \"thr (init_fin_lift_state s \\<sigma>) t = map_option (\\<lambda>(x, ln). ((s, x), ln)) (thr \\<sigma> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shr (init_fin_lift_state s \\<sigma>) = shr \\<sigma> &&&\n     locks (init_fin_lift_state s \\<sigma>) = locks \\<sigma>) &&&\n    wset (init_fin_lift_state s \\<sigma>) = wset \\<sigma> &&&\n    interrupts (init_fin_lift_state s \\<sigma>) = interrupts \\<sigma> &&&\n    thr (init_fin_lift_state s \\<sigma>) t =\n    map_option (\\<lambda>(x, ln). ((s, x), ln)) (thr \\<sigma> t)", "by(simp_all add: init_fin_lift_state_def)"], ["", "lemma thr_init_fin_list_state': \n  \"thr (init_fin_lift_state s \\<sigma>) = map_option (\\<lambda>(x, ln). ((s, x), ln)) \\<circ> thr \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr (init_fin_lift_state s \\<sigma>) =\n    map_option (\\<lambda>(x, ln). ((s, x), ln)) \\<circ> thr \\<sigma>", "by(simp add: fun_eq_iff thr_init_fin_list_state)"], ["", "lemma init_fin_descend_thr_Some_conv [simp]:\n  \"\\<And>ln. ts t = \\<lfloor>((status, x), ln)\\<rfloor> \\<Longrightarrow> init_fin_descend_thr ts t = \\<lfloor>(x, ln)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       ts t = \\<lfloor>((status, x), ln)\\<rfloor> \\<Longrightarrow>\n       init_fin_descend_thr ts t = \\<lfloor>(x, ln)\\<rfloor>", "by(simp add: init_fin_descend_thr_def)"], ["", "lemma init_fin_descend_thr_None_conv [simp]:\n  \"ts t = None \\<Longrightarrow> init_fin_descend_thr ts t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts t = None \\<Longrightarrow> init_fin_descend_thr ts t = None", "by(simp add: init_fin_descend_thr_def)"], ["", "lemma init_fin_descend_thr_eq_None [simp]:\n  \"init_fin_descend_thr ts t = None \\<longleftrightarrow> ts t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (init_fin_descend_thr ts t = None) = (ts t = None)", "by(simp add: init_fin_descend_thr_def)"], ["", "lemma init_fin_descend_state_simps [simp]:\n  \"init_fin_descend_state (ls, (ts, m), ws, is) = (ls, (init_fin_descend_thr ts, m), ws, is)\"\n  \"locks (init_fin_descend_state s) = locks s\"\n  \"thr (init_fin_descend_state s) = init_fin_descend_thr (thr s)\"\n  \"shr (init_fin_descend_state s) = shr s\"\n  \"wset (init_fin_descend_state s) = wset s\"\n  \"interrupts (init_fin_descend_state s) = interrupts s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (init_fin_descend_state (ls, (ts, m), ws, is) =\n     (ls, (init_fin_descend_thr ts, m), ws, is) &&&\n     locks (init_fin_descend_state s) = locks s &&&\n     thr (init_fin_descend_state s) = init_fin_descend_thr (thr s)) &&&\n    shr (init_fin_descend_state s) = shr s &&&\n    wset (init_fin_descend_state s) = wset s &&&\n    interrupts (init_fin_descend_state s) = interrupts s", "by(simp_all add: init_fin_descend_state_def)"], ["", "lemma init_fin_descend_thr_update [simp]:\n  \"init_fin_descend_thr (ts(t := v)) = (init_fin_descend_thr ts)(t := map_option (\\<lambda>((status, x), ln). (x, ln)) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_fin_descend_thr (ts(t := v)) = (init_fin_descend_thr ts)\n    (t := map_option (\\<lambda>((status, x), ln). (x, ln)) v)", "by(simp add: init_fin_descend_thr_def fun_eq_iff)"], ["", "lemma ts_ok_init_fin_descend_state: \n  \"ts_ok P (init_fin_descend_thr ts) = ts_ok (init_fin_lift P) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ok P (init_fin_descend_thr ts) = ts_ok (init_fin_lift P) ts", "by(rule ext)(auto 4 3 intro!: ts_okI dest: ts_okD simp add: init_fin_descend_thr_def)"], ["", "lemma free_thread_id_init_fin_descend_thr [simp]: \n  \"free_thread_id (init_fin_descend_thr ts) = free_thread_id ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_thread_id (init_fin_descend_thr ts) = free_thread_id ts", "by(simp add: free_thread_id.simps fun_eq_iff)"], ["", "lemma redT_updT'_init_fin_descend_thr_eq_None [simp]:\n  \"redT_updT' (init_fin_descend_thr ts) nt t = None \\<longleftrightarrow> redT_updT' ts nt t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (redT_updT' (init_fin_descend_thr ts) nt t = None) =\n    (redT_updT' ts nt t = None)", "by(cases nt) simp_all"], ["", "lemma thread_ok_init_fin_descend_thr [simp]: \n  \"thread_ok (init_fin_descend_thr ts) nta = thread_ok ts nta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_ok (init_fin_descend_thr ts) nta = thread_ok ts nta", "by(cases nta) simp_all"], ["", "lemma threads_ok_init_fin_descend_thr [simp]:\n  \"thread_oks (init_fin_descend_thr ts) ntas = thread_oks ts ntas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thread_oks (init_fin_descend_thr ts) ntas = thread_oks ts ntas", "by(induct ntas arbitrary: ts)(auto elim!: thread_oks_ts_change[THEN iffD1, rotated 1])"], ["", "lemma init_fin_descend_thr_redT_updT [simp]:\n  \"init_fin_descend_thr (redT_updT ts (convert_new_thread_action (Pair status) nt)) =\n   redT_updT (init_fin_descend_thr ts) nt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_fin_descend_thr\n     (redT_updT ts (convert_new_thread_action (Pair status) nt)) =\n    redT_updT (init_fin_descend_thr ts) nt", "by(cases nt) simp_all"], ["", "lemma init_fin_descend_thr_redT_updTs [simp]:\n  \"init_fin_descend_thr (redT_updTs ts (map (convert_new_thread_action (Pair status)) nts)) =\n   redT_updTs (init_fin_descend_thr ts) nts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_fin_descend_thr\n     (redT_updTs ts (map (convert_new_thread_action (Pair status)) nts)) =\n    redT_updTs (init_fin_descend_thr ts) nts", "by(induct nts arbitrary: ts) simp_all"], ["", "context final_thread begin"], ["", "lemma cond_action_ok_init_fin_descend_stateI [simp]:\n  \"final_thread.cond_action_ok init_fin_final s t ct \\<Longrightarrow> cond_action_ok (init_fin_descend_state s) t ct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.cond_action_ok init_fin_final s t ct \\<Longrightarrow>\n    cond_action_ok (init_fin_descend_state s) t ct", "by(cases ct)(auto simp add: final_thread.cond_action_ok.simps init_fin_descend_thr_def)"], ["", "lemma cond_action_oks_init_fin_descend_stateI [simp]:\n  \"final_thread.cond_action_oks init_fin_final s t cts \\<Longrightarrow> cond_action_oks (init_fin_descend_state s) t cts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.cond_action_oks init_fin_final s t cts \\<Longrightarrow>\n    cond_action_oks (init_fin_descend_state s) t cts", "by(induct cts)(simp_all add: final_thread.cond_action_oks.simps cond_action_ok_init_fin_descend_stateI)"], ["", "end"], ["", "definition lift_start_obs :: \"'t \\<Rightarrow> 'o list \\<Rightarrow> ('t \\<times> 'o action) list\"\nwhere \"lift_start_obs t obs = (t, InitialThreadAction) # map (\\<lambda>ob. (t, NormalAction ob)) obs\""], ["", "lemma length_lift_start_obs [simp]: \"length (lift_start_obs t obs) = Suc (length obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lift_start_obs t obs) = Suc (length obs)", "by(simp add: lift_start_obs_def)"], ["", "lemma set_lift_start_obs [simp]:\n  \"set (lift_start_obs t obs) =\n   insert (t, InitialThreadAction) ((Pair t \\<circ> NormalAction) ` set obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (lift_start_obs t obs) =\n    insert (t, InitialThreadAction)\n     ((Pair t \\<circ> NormalAction) ` set obs)", "by(auto simp add: lift_start_obs_def o_def)"], ["", "lemma distinct_lift_start_obs [simp]: \"distinct (lift_start_obs t obs) = distinct obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (lift_start_obs t obs) = distinct obs", "by(auto simp add: lift_start_obs_def distinct_map intro: inj_onI)"], ["", "end"]]}