{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/SC_Interp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma sc_J_typesafe:\n  \"J_typesafe addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\"", "lemma sc_JVM_typesafe:\n  \"JVM_typesafe addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\"", "lemma compP2_compP1_convs:\n  \"is_type (compP2 (compP1 P)) = is_type P\"\n  \"is_class (compP2 (compP1 P)) = is_class P\"\n  \"sc.addr_loc_type (compP2 (compP1 P)) = sc.addr_loc_type P\"\n  \"sc.conf (compP2 (compP1 P)) = sc.conf P\"", "lemma sc_J_JVM_conf_read:\n  \"J_JVM_conf_read addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\""], "translations": [["", "lemma sc_J_typesafe:\n  \"J_typesafe addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J_typesafe (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P", "by unfold_locales"], ["", "lemma sc_JVM_typesafe:\n  \"JVM_typesafe addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_typesafe (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P", "by unfold_locales"], ["", "lemma compP2_compP1_convs:\n  \"is_type (compP2 (compP1 P)) = is_type P\"\n  \"is_class (compP2 (compP1 P)) = is_class P\"\n  \"sc.addr_loc_type (compP2 (compP1 P)) = sc.addr_loc_type P\"\n  \"sc.conf (compP2 (compP1 P)) = sc.conf P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_type (compP2 (compP1 P)) = is_type P &&&\n     is_class (compP2 (compP1 P)) = is_class P) &&&\n    sc.addr_loc_type (compP2 (compP1 P)) = sc.addr_loc_type P &&&\n    sc.conf (compP2 (compP1 P)) = sc.conf P", "by(simp_all add: compP2_def heap_base.compP_conf heap_base.compP_addr_loc_type fun_eq_iff split: addr_loc.splits)"], ["", "lemma sc_J_JVM_conf_read:\n  \"J_JVM_conf_read addr2thread_id thread_id2addr sc_empty (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J_JVM_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P", "apply(rule J_JVM_conf_read.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. J1_JVM_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty\n     (sc_allocate P) sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     (compP1 P)", "apply(rule J1_JVM_conf_read.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     (compP2 (compP1 P))", "apply(rule JVM_conf_read.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     (compP2 (compP1 P))\n 2. JVM_heap_conf (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) (compP2 (compP1 P))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. JVM_heap_conf (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) (compP2 (compP1 P))\n 2. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     (compP2 (compP1 P))", "apply(rule JVM_heap_conf.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. JVM_heap_conf_base' (\\<lambda>x. x) (\\<lambda>x. x) (sc_allocate P)\n     sc_typeof_addr sc_heap_write (compP2 (compP1 P))\n 2. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) (compP2 (compP1 P))\n 3. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     (compP2 (compP1 P))", "apply(rule JVM_heap_conf_base'.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) (sc_allocate P) sc_typeof_addr\n     sc_heap_write (compP2 (compP1 P))\n 2. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) (compP2 (compP1 P))\n 3. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P)\n     (compP2 (compP1 P))", "apply(unfold compP2_def compP1_def compP_heap compP_heap_conf compP_heap_conf_read)"], ["proof (prove)\ngoal (3 subgoals):\n 1. heap (\\<lambda>x. x) (\\<lambda>x. x) (sc_allocate P) sc_typeof_addr\n     sc_heap_write P\n 2. heap_conf (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_write (sc_hconf P) P\n 3. heap_conf_read (\\<lambda>x. x) (\\<lambda>x. x) sc_empty (sc_allocate P)\n     sc_typeof_addr sc_heap_read sc_heap_write (sc_hconf P) P", "apply unfold_locales"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}