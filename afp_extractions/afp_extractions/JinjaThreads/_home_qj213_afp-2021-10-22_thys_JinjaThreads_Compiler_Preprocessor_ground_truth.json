{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/Preprocessor.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma fixes is_lub\n  shows WT_compP: \"is_lub,P,E \\<turnstile> e :: T \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> e :: T\"\n  and WTs_compP: \"is_lub,P,E \\<turnstile> es [::] Ts \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> es [::] Ts\"", "lemma fixes is_lub\n  shows Anno_compP: \"is_lub,P,E \\<turnstile> e \\<leadsto> e' \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> e \\<leadsto> e'\"\n  and Annos_compP: \"is_lub,P,E \\<turnstile> es [\\<leadsto>] es' \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> es [\\<leadsto>] es'\"", "lemma annotate_prog_code_eq_annotate_prog:\n  assumes wf: \"wf_J_prog (annotate_prog_code P)\"\n  shows \"annotate_prog_code P = annotate_prog P\""], "translations": [["", "lemma fixes is_lub\n  shows WT_compP: \"is_lub,P,E \\<turnstile> e :: T \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> e :: T\"\n  and WTs_compP: \"is_lub,P,E \\<turnstile> es [::] Ts \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> es [::] Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_lub,P,E \\<turnstile> e :: T \\<Longrightarrow>\n     is_lub,compP f P,E \\<turnstile> e :: T) &&&\n    (is_lub,P,E \\<turnstile> es [::] Ts \\<Longrightarrow>\n     is_lub,compP f P,E \\<turnstile> es [::] Ts)", "proof(induct rule: WT_WTs.inducts)"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>C E.\n       is_class P C \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> new C :: Class C\n 2. \\<And>E e T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: Integer;\n        is_lub,compP f P,E \\<turnstile> e :: Integer;\n        is_type P (T\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> newA T\\<lfloor>e\\<rceil> :: T\\<lfloor>\\<rceil>\n 3. \\<And>E e T U.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: T;\n        is_lub,compP f P,E \\<turnstile> e :: T;\n        P \\<turnstile> U \\<le> T \\<or> P \\<turnstile> T \\<le> U;\n        is_type P U\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> Cast U e :: U\n 4. \\<And>E e T U.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: T;\n        is_lub,compP f P,E \\<turnstile> e :: T;\n        P \\<turnstile> U \\<le> T \\<or> P \\<turnstile> T \\<le> U;\n        is_type P U; is_refT U\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e instanceof U :: Boolean\n 5. \\<And>v T E.\n       typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> Val v :: T\n 6. \\<And>E V T.\n       E V = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> Var V :: T\n 7. \\<And>E e1 T1 e2 T2 bop T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e1 :: T1;\n        is_lub,compP f P,E \\<turnstile> e1 :: T1;\n        is_lub,P,E \\<turnstile> e2 :: T2;\n        is_lub,compP f P,E \\<turnstile> e2 :: T2;\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e1 \\<guillemotleft>bop\\<guillemotright> e2 :: T\n 8. \\<And>E V T e T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; is_lub,P,E \\<turnstile> e :: T';\n        is_lub,compP f P,E \\<turnstile> e :: T'; P \\<turnstile> T' \\<le> T;\n        V \\<noteq> this\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> V:=e :: Void\n 9. \\<And>E a T i.\n       \\<lbrakk>is_lub,P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n        is_lub,compP f P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n        is_lub,P,E \\<turnstile> i :: Integer;\n        is_lub,compP f P,E \\<turnstile> i :: Integer\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> a\\<lfloor>i\\<rceil> :: T\n 10. \\<And>E a T i e T'.\n        \\<lbrakk>is_lub,P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n         is_lub,compP f P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n         is_lub,P,E \\<turnstile> i :: Integer;\n         is_lub,compP f P,E \\<turnstile> i :: Integer;\n         is_lub,P,E \\<turnstile> e :: T';\n         is_lub,compP f P,E \\<turnstile> e :: T';\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> is_lub,compP f\n                                  P,E \\<turnstile> a\\<lfloor>i\\<rceil> := e :: Void\nA total of 24 subgoals...", "case (WTCall E e U C M Ts T meth D es Ts')"], ["proof (state)\nthis:\n  is_lub,P,E \\<turnstile> e :: U\n  is_lub,compP f P,E \\<turnstile> e :: U\n  class_type_of' U = \\<lfloor>C\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = meth in D\n  is_lub,P,E \\<turnstile> es [::] Ts'\n  is_lub,compP f P,E \\<turnstile> es [::] Ts'\n  P \\<turnstile> Ts' [\\<le>] Ts\n\ngoal (24 subgoals):\n 1. \\<And>C E.\n       is_class P C \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> new C :: Class C\n 2. \\<And>E e T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: Integer;\n        is_lub,compP f P,E \\<turnstile> e :: Integer;\n        is_type P (T\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> newA T\\<lfloor>e\\<rceil> :: T\\<lfloor>\\<rceil>\n 3. \\<And>E e T U.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: T;\n        is_lub,compP f P,E \\<turnstile> e :: T;\n        P \\<turnstile> U \\<le> T \\<or> P \\<turnstile> T \\<le> U;\n        is_type P U\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> Cast U e :: U\n 4. \\<And>E e T U.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: T;\n        is_lub,compP f P,E \\<turnstile> e :: T;\n        P \\<turnstile> U \\<le> T \\<or> P \\<turnstile> T \\<le> U;\n        is_type P U; is_refT U\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e instanceof U :: Boolean\n 5. \\<And>v T E.\n       typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> Val v :: T\n 6. \\<And>E V T.\n       E V = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> Var V :: T\n 7. \\<And>E e1 T1 e2 T2 bop T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e1 :: T1;\n        is_lub,compP f P,E \\<turnstile> e1 :: T1;\n        is_lub,P,E \\<turnstile> e2 :: T2;\n        is_lub,compP f P,E \\<turnstile> e2 :: T2;\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e1 \\<guillemotleft>bop\\<guillemotright> e2 :: T\n 8. \\<And>E V T e T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; is_lub,P,E \\<turnstile> e :: T';\n        is_lub,compP f P,E \\<turnstile> e :: T'; P \\<turnstile> T' \\<le> T;\n        V \\<noteq> this\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> V:=e :: Void\n 9. \\<And>E a T i.\n       \\<lbrakk>is_lub,P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n        is_lub,compP f P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n        is_lub,P,E \\<turnstile> i :: Integer;\n        is_lub,compP f P,E \\<turnstile> i :: Integer\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> a\\<lfloor>i\\<rceil> :: T\n 10. \\<And>E a T i e T'.\n        \\<lbrakk>is_lub,P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n         is_lub,compP f P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n         is_lub,P,E \\<turnstile> i :: Integer;\n         is_lub,compP f P,E \\<turnstile> i :: Integer;\n         is_lub,P,E \\<turnstile> e :: T';\n         is_lub,compP f P,E \\<turnstile> e :: T';\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> is_lub,compP f\n                                  P,E \\<turnstile> a\\<lfloor>i\\<rceil> := e :: Void\nA total of 24 subgoals...", "from \\<open>P \\<turnstile> C sees M: Ts\\<rightarrow>T = meth in D\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = meth in D", "have \"compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T) meth in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = meth in D\n\ngoal (1 subgoal):\n 1. compP f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T)\n            meth in D", "by(auto dest: sees_method_compP[where f=f])"], ["proof (state)\nthis:\n  compP f\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T)\n          meth in D\n\ngoal (24 subgoals):\n 1. \\<And>C E.\n       is_class P C \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> new C :: Class C\n 2. \\<And>E e T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: Integer;\n        is_lub,compP f P,E \\<turnstile> e :: Integer;\n        is_type P (T\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> newA T\\<lfloor>e\\<rceil> :: T\\<lfloor>\\<rceil>\n 3. \\<And>E e T U.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: T;\n        is_lub,compP f P,E \\<turnstile> e :: T;\n        P \\<turnstile> U \\<le> T \\<or> P \\<turnstile> T \\<le> U;\n        is_type P U\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> Cast U e :: U\n 4. \\<And>E e T U.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: T;\n        is_lub,compP f P,E \\<turnstile> e :: T;\n        P \\<turnstile> U \\<le> T \\<or> P \\<turnstile> T \\<le> U;\n        is_type P U; is_refT U\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e instanceof U :: Boolean\n 5. \\<And>v T E.\n       typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> Val v :: T\n 6. \\<And>E V T.\n       E V = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> Var V :: T\n 7. \\<And>E e1 T1 e2 T2 bop T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e1 :: T1;\n        is_lub,compP f P,E \\<turnstile> e1 :: T1;\n        is_lub,P,E \\<turnstile> e2 :: T2;\n        is_lub,compP f P,E \\<turnstile> e2 :: T2;\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e1 \\<guillemotleft>bop\\<guillemotright> e2 :: T\n 8. \\<And>E V T e T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; is_lub,P,E \\<turnstile> e :: T';\n        is_lub,compP f P,E \\<turnstile> e :: T'; P \\<turnstile> T' \\<le> T;\n        V \\<noteq> this\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> V:=e :: Void\n 9. \\<And>E a T i.\n       \\<lbrakk>is_lub,P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n        is_lub,compP f P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n        is_lub,P,E \\<turnstile> i :: Integer;\n        is_lub,compP f P,E \\<turnstile> i :: Integer\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> a\\<lfloor>i\\<rceil> :: T\n 10. \\<And>E a T i e T'.\n        \\<lbrakk>is_lub,P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n         is_lub,compP f P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n         is_lub,P,E \\<turnstile> i :: Integer;\n         is_lub,compP f P,E \\<turnstile> i :: Integer;\n         is_lub,P,E \\<turnstile> e :: T';\n         is_lub,compP f P,E \\<turnstile> e :: T';\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> is_lub,compP f\n                                  P,E \\<turnstile> a\\<lfloor>i\\<rceil> := e :: Void\nA total of 24 subgoals...", "with WTCall"], ["proof (chain)\npicking this:\n  is_lub,P,E \\<turnstile> e :: U\n  is_lub,compP f P,E \\<turnstile> e :: U\n  class_type_of' U = \\<lfloor>C\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = meth in D\n  is_lub,P,E \\<turnstile> es [::] Ts'\n  is_lub,compP f P,E \\<turnstile> es [::] Ts'\n  P \\<turnstile> Ts' [\\<le>] Ts\n  compP f\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T)\n          meth in D", "show ?case"], ["proof (prove)\nusing this:\n  is_lub,P,E \\<turnstile> e :: U\n  is_lub,compP f P,E \\<turnstile> e :: U\n  class_type_of' U = \\<lfloor>C\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = meth in D\n  is_lub,P,E \\<turnstile> es [::] Ts'\n  is_lub,compP f P,E \\<turnstile> es [::] Ts'\n  P \\<turnstile> Ts' [\\<le>] Ts\n  compP f\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option (f D M Ts T)\n          meth in D\n\ngoal (1 subgoal):\n 1. is_lub,compP f P,E \\<turnstile> e\\<bullet>M(es) :: T", "by(auto)"], ["proof (state)\nthis:\n  is_lub,compP f P,E \\<turnstile> e\\<bullet>M(es) :: T\n\ngoal (23 subgoals):\n 1. \\<And>C E.\n       is_class P C \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> new C :: Class C\n 2. \\<And>E e T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: Integer;\n        is_lub,compP f P,E \\<turnstile> e :: Integer;\n        is_type P (T\\<lfloor>\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> newA T\\<lfloor>e\\<rceil> :: T\\<lfloor>\\<rceil>\n 3. \\<And>E e T U.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: T;\n        is_lub,compP f P,E \\<turnstile> e :: T;\n        P \\<turnstile> U \\<le> T \\<or> P \\<turnstile> T \\<le> U;\n        is_type P U\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> Cast U e :: U\n 4. \\<And>E e T U.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e :: T;\n        is_lub,compP f P,E \\<turnstile> e :: T;\n        P \\<turnstile> U \\<le> T \\<or> P \\<turnstile> T \\<le> U;\n        is_type P U; is_refT U\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e instanceof U :: Boolean\n 5. \\<And>v T E.\n       typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> Val v :: T\n 6. \\<And>E V T.\n       E V = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       is_lub,compP f P,E \\<turnstile> Var V :: T\n 7. \\<And>E e1 T1 e2 T2 bop T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e1 :: T1;\n        is_lub,compP f P,E \\<turnstile> e1 :: T1;\n        is_lub,P,E \\<turnstile> e2 :: T2;\n        is_lub,compP f P,E \\<turnstile> e2 :: T2;\n        P \\<turnstile> T1\\<guillemotleft>bop\\<guillemotright>T2 :: T\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e1 \\<guillemotleft>bop\\<guillemotright> e2 :: T\n 8. \\<And>E V T e T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; is_lub,P,E \\<turnstile> e :: T';\n        is_lub,compP f P,E \\<turnstile> e :: T'; P \\<turnstile> T' \\<le> T;\n        V \\<noteq> this\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> V:=e :: Void\n 9. \\<And>E a T i.\n       \\<lbrakk>is_lub,P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n        is_lub,compP f P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n        is_lub,P,E \\<turnstile> i :: Integer;\n        is_lub,compP f P,E \\<turnstile> i :: Integer\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> a\\<lfloor>i\\<rceil> :: T\n 10. \\<And>E a T i e T'.\n        \\<lbrakk>is_lub,P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n         is_lub,compP f P,E \\<turnstile> a :: T\\<lfloor>\\<rceil>;\n         is_lub,P,E \\<turnstile> i :: Integer;\n         is_lub,compP f P,E \\<turnstile> i :: Integer;\n         is_lub,P,E \\<turnstile> e :: T';\n         is_lub,compP f P,E \\<turnstile> e :: T';\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> is_lub,compP f\n                                  P,E \\<turnstile> a\\<lfloor>i\\<rceil> := e :: Void\nA total of 23 subgoals...", "qed(auto simp del: fun_upd_apply)"], ["", "lemma fixes is_lub\n  shows Anno_compP: \"is_lub,P,E \\<turnstile> e \\<leadsto> e' \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> e \\<leadsto> e'\"\n  and Annos_compP: \"is_lub,P,E \\<turnstile> es [\\<leadsto>] es' \\<Longrightarrow> is_lub,compP f P,E \\<turnstile> es [\\<leadsto>] es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_lub,P,E \\<turnstile> e \\<leadsto> e' \\<Longrightarrow>\n     is_lub,compP f P,E \\<turnstile> e \\<leadsto> e') &&&\n    (is_lub,P,E \\<turnstile> es [\\<leadsto>] es' \\<Longrightarrow>\n     is_lub,compP f P,E \\<turnstile> es [\\<leadsto>] es')", "apply(induct rule: Anno_Annos.inducts)"], ["proof (prove)\ngoal (29 subgoals):\n 1. \\<And>E C. is_lub,compP f P,E \\<turnstile> new C \\<leadsto> new C\n 2. \\<And>E i i' T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> i \\<leadsto> i';\n        is_lub,compP f P,E \\<turnstile> i \\<leadsto> i'\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> newA T\\<lfloor>i\\<rceil> \\<leadsto> newA T\\<lfloor>i'\\<rceil>\n 3. \\<And>E e e' C.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e \\<leadsto> e';\n        is_lub,compP f P,E \\<turnstile> e \\<leadsto> e'\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> Cast C\n             e \\<leadsto> Cast C e'\n 4. \\<And>E e e' T.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e \\<leadsto> e';\n        is_lub,compP f P,E \\<turnstile> e \\<leadsto> e'\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e instanceof T \\<leadsto> e' instanceof T\n 5. \\<And>E v. is_lub,compP f P,E \\<turnstile> Val v \\<leadsto> Val v\n 6. \\<And>E V T.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        V \\<noteq> Annotate.super\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> Var V \\<leadsto> Var V\n 7. \\<And>E V C T fm D.\n       \\<lbrakk>E V = None; V \\<noteq> Annotate.super;\n        E this = \\<lfloor>Class C\\<rfloor>;\n        P \\<turnstile> C sees V:T (fm) in D\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> Var\n             V \\<leadsto> Var this\\<bullet>V{D}\n 8. \\<And>E e1 e1' e2 e2' bop.\n       \\<lbrakk>is_lub,P,E \\<turnstile> e1 \\<leadsto> e1';\n        is_lub,compP f P,E \\<turnstile> e1 \\<leadsto> e1';\n        is_lub,P,E \\<turnstile> e2 \\<leadsto> e2';\n        is_lub,compP f P,E \\<turnstile> e2 \\<leadsto> e2'\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> e1 \\<guillemotleft>bop\\<guillemotright> e2 \\<leadsto> e1' \\<guillemotleft>bop\\<guillemotright> e2'\n 9. \\<And>E V T e e'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; V \\<noteq> Annotate.super;\n        is_lub,P,E \\<turnstile> e \\<leadsto> e';\n        is_lub,compP f P,E \\<turnstile> e \\<leadsto> e'\\<rbrakk>\n       \\<Longrightarrow> is_lub,compP f\n                                 P,E \\<turnstile> V:=e \\<leadsto> V:=e'\n 10. \\<And>E V C T fm D e e'.\n        \\<lbrakk>E V = None; V \\<noteq> Annotate.super;\n         E this = \\<lfloor>Class C\\<rfloor>;\n         P \\<turnstile> C sees V:T (fm) in D;\n         is_lub,P,E \\<turnstile> e \\<leadsto> e';\n         is_lub,compP f P,E \\<turnstile> e \\<leadsto> e'\\<rbrakk>\n        \\<Longrightarrow> is_lub,compP f\n                                  P,E \\<turnstile> V:=e \\<leadsto> Var\n                              this\\<bullet>V{D} := e'\nA total of 29 subgoals...", "apply(auto intro: Anno_Annos.intros simp del: fun_upd_apply dest: WT_compP simp add: compC_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma annotate_prog_code_eq_annotate_prog:\n  assumes wf: \"wf_J_prog (annotate_prog_code P)\"\n  shows \"annotate_prog_code P = annotate_prog P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "let ?wf_md = \"\\<lambda>_ _ (_,_,_,_,body). set (block_types body) \\<subseteq> types P\""], ["proof (state)\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "from wf"], ["proof (chain)\npicking this:\n  wf_J_prog (annotate_prog_code P)", "have \"wf_prog ?wf_md (annotate_prog_code P)\""], ["proof (prove)\nusing this:\n  wf_J_prog (annotate_prog_code P)\n\ngoal (1 subgoal):\n 1. wf_prog\n     (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n         set (block_types body) \\<subseteq> types P)\n     (annotate_prog_code P)", "unfolding annotate_prog_code_def"], ["proof (prove)\nusing this:\n  wf_J_prog (compP (annotate_Mb_code P) P)\n\ngoal (1 subgoal):\n 1. wf_prog\n     (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n         set (block_types body) \\<subseteq> types P)\n     (compP (annotate_Mb_code P) P)", "by(rule wf_prog_lift)(auto dest!: WT_block_types_is_type[OF wf[unfolded annotate_prog_code_def]] simp add: wf_J_mdecl_def)"], ["proof (state)\nthis:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   (annotate_prog_code P)\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "hence wf': \"wf_prog ?wf_md P\""], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   (annotate_prog_code P)\n\ngoal (1 subgoal):\n 1. wf_prog\n     (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n         set (block_types body) \\<subseteq> types P)\n     P", "unfolding annotate_prog_code_def [abs_def]"], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   (compP (annotate_Mb_code P) P)\n\ngoal (1 subgoal):\n 1. wf_prog\n     (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n         set (block_types body) \\<subseteq> types P)\n     P", "proof(rule wf_prog_compPD)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C M Ts T m.\n       \\<lbrakk>compP (annotate_Mb_code P)\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code\n                                 P C M Ts T m\\<rfloor> in C;\n        wf_mdecl\n         (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n             set (block_types body) \\<subseteq> types P)\n         (compP (annotate_Mb_code P) P) C\n         (M, Ts, T,\n          \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl\n                          (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n                              set (block_types body) \\<subseteq> types P)\n                          P C (M, Ts, T, \\<lfloor>m\\<rfloor>)", "fix C M Ts T m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C M Ts T m.\n       \\<lbrakk>compP (annotate_Mb_code P)\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code\n                                 P C M Ts T m\\<rfloor> in C;\n        wf_mdecl\n         (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n             set (block_types body) \\<subseteq> types P)\n         (compP (annotate_Mb_code P) P) C\n         (M, Ts, T,\n          \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl\n                          (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n                              set (block_types body) \\<subseteq> types P)\n                          P C (M, Ts, T, \\<lfloor>m\\<rfloor>)", "assume \"compP (annotate_Mb_code P) P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor> in C\"\n      and \"wf_mdecl ?wf_md (compP (annotate_Mb_code P) P) C (M, Ts, T, \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\""], ["proof (state)\nthis:\n  compP (annotate_Mb_code P)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code P C\n                   M Ts T m\\<rfloor> in C\n  wf_mdecl\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   (compP (annotate_Mb_code P) P) C\n   (M, Ts, T, \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>C M Ts T m.\n       \\<lbrakk>compP (annotate_Mb_code P)\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code\n                                 P C M Ts T m\\<rfloor> in C;\n        wf_mdecl\n         (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n             set (block_types body) \\<subseteq> types P)\n         (compP (annotate_Mb_code P) P) C\n         (M, Ts, T,\n          \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl\n                          (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n                              set (block_types body) \\<subseteq> types P)\n                          P C (M, Ts, T, \\<lfloor>m\\<rfloor>)", "moreover"], ["proof (state)\nthis:\n  compP (annotate_Mb_code P)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code P C\n                   M Ts T m\\<rfloor> in C\n  wf_mdecl\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   (compP (annotate_Mb_code P) P) C\n   (M, Ts, T, \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>C M Ts T m.\n       \\<lbrakk>compP (annotate_Mb_code P)\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code\n                                 P C M Ts T m\\<rfloor> in C;\n        wf_mdecl\n         (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n             set (block_types body) \\<subseteq> types P)\n         (compP (annotate_Mb_code P) P) C\n         (M, Ts, T,\n          \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl\n                          (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n                              set (block_types body) \\<subseteq> types P)\n                          P C (M, Ts, T, \\<lfloor>m\\<rfloor>)", "obtain pns body where \"m = (pns, body)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pns body.\n        m = (pns, body) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (pns, body)\n\ngoal (1 subgoal):\n 1. \\<And>C M Ts T m.\n       \\<lbrakk>compP (annotate_Mb_code P)\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code\n                                 P C M Ts T m\\<rfloor> in C;\n        wf_mdecl\n         (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n             set (block_types body) \\<subseteq> types P)\n         (compP (annotate_Mb_code P) P) C\n         (M, Ts, T,\n          \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl\n                          (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n                              set (block_types body) \\<subseteq> types P)\n                          P C (M, Ts, T, \\<lfloor>m\\<rfloor>)", "ultimately"], ["proof (chain)\npicking this:\n  compP (annotate_Mb_code P)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code P C\n                   M Ts T m\\<rfloor> in C\n  wf_mdecl\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   (compP (annotate_Mb_code P) P) C\n   (M, Ts, T, \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\n  m = (pns, body)", "show \"wf_mdecl ?wf_md P C (M, Ts, T, \\<lfloor>m\\<rfloor>)\""], ["proof (prove)\nusing this:\n  compP (annotate_Mb_code P)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>annotate_Mb_code P C\n                   M Ts T m\\<rfloor> in C\n  wf_mdecl\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   (compP (annotate_Mb_code P) P) C\n   (M, Ts, T, \\<lfloor>annotate_Mb_code P C M Ts T m\\<rfloor>)\n  m = (pns, body)\n\ngoal (1 subgoal):\n 1. wf_mdecl\n     (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n         set (block_types body) \\<subseteq> types P)\n     P C (M, Ts, T, \\<lfloor>m\\<rfloor>)", "by(fastforce simp add: annotate_Mb_code_def annotate_code_def wf_mdecl_def THE_default_def the_equality Anno_code_def split: if_split_asm dest: Anno_block_types)"], ["proof (state)\nthis:\n  wf_mdecl\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P C (M, Ts, T, \\<lfloor>m\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "{"], ["proof (state)\nthis:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "fix C D fs ms M Ts T pns body"], ["proof (state)\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "assume \"(C, D, fs, ms) \\<in> set (classes P)\"\n      and \"(M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>) \\<in> set ms\""], ["proof (state)\nthis:\n  (C, D, fs, ms) \\<in> set (classes P)\n  (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>) \\<in> set ms\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "from \\<open>(C, D, fs, ms) \\<in> set (classes P)\\<close>"], ["proof (chain)\npicking this:\n  (C, D, fs, ms) \\<in> set (classes P)", "have \"class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\""], ["proof (prove)\nusing this:\n  (C, D, fs, ms) \\<in> set (classes P)\n\ngoal (1 subgoal):\n 1. class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "using wf'"], ["proof (prove)\nusing this:\n  (C, D, fs, ms) \\<in> set (classes P)\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P\n\ngoal (1 subgoal):\n 1. class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "by(cases P)(auto simp add: wf_prog_def dest: map_of_SomeI)"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "with wf'"], ["proof (chain)\npicking this:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "have sees: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in C\""], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                    body)\\<rfloor> in C", "using \\<open>(M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>) \\<in> set ms\\<close>"], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>) \\<in> set ms\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                    body)\\<rfloor> in C", "by(rule mdecl_visible)"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "from sees_method_compP[OF this, where f=\"annotate_Mb_code P\"]"], ["proof (chain)\npicking this:\n  compP (annotate_Mb_code P)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option\n          (annotate_Mb_code P C M Ts T) \\<lfloor>(pns, body)\\<rfloor> in C", "have sees': \"annotate_prog_code P \\<turnstile> C sees M:Ts\\<rightarrow>T = \\<lfloor>(pns, annotate_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body)\\<rfloor> in C\""], ["proof (prove)\nusing this:\n  compP (annotate_Mb_code P)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option\n          (annotate_Mb_code P C M Ts T) \\<lfloor>(pns, body)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. annotate_prog_code\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                     annotate_code P\n                      [this \\<mapsto> Class C, pns [\\<mapsto>] Ts]\n                      body)\\<rfloor> in C", "unfolding annotate_prog_code_def annotate_Mb_code_def"], ["proof (prove)\nusing this:\n  compP\n   (\\<lambda>uu uua uuaa uuaaa uuaaaa.\n       (case uuaaaa of\n        (pns, e) \\<Rightarrow>\n          \\<lambda>P C M Ts T.\n             (pns, annotate_code P [this # pns [\\<mapsto>] Class C # Ts] e))\n        P uu uua uuaa uuaaa)\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = map_option\n          (\\<lambda>uu.\n              (case uu of\n               (pns, e) \\<Rightarrow>\n                 \\<lambda>P C M Ts T.\n                    (pns,\n                     annotate_code P [this # pns [\\<mapsto>] Class C # Ts]\n                      e))\n               P C M Ts T)\n          \\<lfloor>(pns, body)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. compP\n     (\\<lambda>uu uua uuaa uuaaa uuaaaa.\n         (case uuaaaa of\n          (pns, e) \\<Rightarrow>\n            \\<lambda>P C M Ts T.\n               (pns,\n                annotate_code P [this # pns [\\<mapsto>] Class C # Ts] e))\n          P uu uua uuaa uuaaa)\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                     annotate_code P\n                      [this \\<mapsto> Class C, pns [\\<mapsto>] Ts]\n                      body)\\<rfloor> in C", "by(auto)"], ["proof (state)\nthis:\n  annotate_prog_code\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   annotate_code P\n                    [this \\<mapsto> Class C, pns [\\<mapsto>] Ts]\n                    body)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "with wf"], ["proof (chain)\npicking this:\n  wf_J_prog (annotate_prog_code P)\n  annotate_prog_code\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   annotate_code P\n                    [this \\<mapsto> Class C, pns [\\<mapsto>] Ts]\n                    body)\\<rfloor> in C", "have \"wf_mdecl wf_J_mdecl (annotate_prog_code P) C (M, Ts, T, \\<lfloor>(pns, annotate_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body)\\<rfloor>)\""], ["proof (prove)\nusing this:\n  wf_J_prog (annotate_prog_code P)\n  annotate_prog_code\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   annotate_code P\n                    [this \\<mapsto> Class C, pns [\\<mapsto>] Ts]\n                    body)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. wf_mdecl wf_J_mdecl (annotate_prog_code P) C\n     (M, Ts, T,\n      \\<lfloor>(pns,\n                annotate_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts]\n                 body)\\<rfloor>)", "by(rule sees_wf_mdecl)"], ["proof (state)\nthis:\n  wf_mdecl wf_J_mdecl (annotate_prog_code P) C\n   (M, Ts, T,\n    \\<lfloor>(pns,\n              annotate_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts]\n               body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "hence \"set Ts \\<subseteq> types P\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_J_mdecl (annotate_prog_code P) C\n   (M, Ts, T,\n    \\<lfloor>(pns,\n              annotate_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts]\n               body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. set Ts \\<subseteq> types P", "by(auto simp add: wf_mdecl_def annotate_prog_code_def)"], ["proof (state)\nthis:\n  set Ts \\<subseteq> types P\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "moreover"], ["proof (state)\nthis:\n  set Ts \\<subseteq> types P\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "from sees"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in C", "have \"is_class P C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. is_class P C", "by(rule sees_method_is_class)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "moreover"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "from wf' sees"], ["proof (chain)\npicking this:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in C", "have \"wf_mdecl ?wf_md P C (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\""], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                  body)\\<rfloor> in C\n\ngoal (1 subgoal):\n 1. wf_mdecl\n     (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n         set (block_types body) \\<subseteq> types P)\n     P C (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)", "by(rule sees_wf_mdecl)"], ["proof (state)\nthis:\n  wf_mdecl\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P C (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "hence \"set (block_types body) \\<subseteq> types P\""], ["proof (prove)\nusing this:\n  wf_mdecl\n   (\\<lambda>_ _ (uu_, uu_, uu_, uu_, body).\n       set (block_types body) \\<subseteq> types P)\n   P C (M, Ts, T, \\<lfloor>(pns, body)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. set (block_types body) \\<subseteq> types P", "by(simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  set (block_types body) \\<subseteq> types P\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "ultimately"], ["proof (chain)\npicking this:\n  set Ts \\<subseteq> types P\n  is_class P C\n  set (block_types body) \\<subseteq> types P", "have \"ran [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] \\<union> set (block_types body) \\<subseteq> types P\""], ["proof (prove)\nusing this:\n  set Ts \\<subseteq> types P\n  is_class P C\n  set (block_types body) \\<subseteq> types P\n\ngoal (1 subgoal):\n 1. ran [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] \\<union>\n    set (block_types body)\n    \\<subseteq> types P", "by(auto simp add: ran_def wf_mdecl_def map_upds_def split: if_split_asm dest!: map_of_SomeD set_zip_rightD)"], ["proof (state)\nthis:\n  ran [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] \\<union>\n  set (block_types body)\n  \\<subseteq> types P\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "hence \"annotate_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body = annotate P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body\""], ["proof (prove)\nusing this:\n  ran [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] \\<union>\n  set (block_types body)\n  \\<subseteq> types P\n\ngoal (1 subgoal):\n 1. annotate_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body =\n    annotate P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body", "unfolding annotate_code_def annotate_def"], ["proof (prove)\nusing this:\n  ran [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] \\<union>\n  set (block_types body)\n  \\<subseteq> types P\n\ngoal (1 subgoal):\n 1. THE_default body\n     (Anno_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body) =\n    THE_default body\n     (Anno' P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body)", "by -(rule arg_cong[where f=\"THE_default body\"], auto intro!: ext intro: Anno_code_into_Anno[OF wf'] Anno_into_Anno_code[OF wf'])"], ["proof (state)\nthis:\n  annotate_code P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body =\n  annotate P [this \\<mapsto> Class C, pns [\\<mapsto>] Ts] body\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?C3, ?D3, ?fs3, ?ms3) \\<in> set (classes P);\n   (?M3, ?Ts3, ?T3, \\<lfloor>(?pns3, ?body3)\\<rfloor>)\n   \\<in> set ?ms3\\<rbrakk>\n  \\<Longrightarrow> annotate_code P\n                     [this \\<mapsto> Class ?C3, ?pns3 [\\<mapsto>] ?Ts3]\n                     ?body3 =\n                    annotate P\n                     [this \\<mapsto> Class ?C3, ?pns3 [\\<mapsto>] ?Ts3]\n                     ?body3\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?C3, ?D3, ?fs3, ?ms3) \\<in> set (classes P);\n   (?M3, ?Ts3, ?T3, \\<lfloor>(?pns3, ?body3)\\<rfloor>)\n   \\<in> set ?ms3\\<rbrakk>\n  \\<Longrightarrow> annotate_code P\n                     [this \\<mapsto> Class ?C3, ?pns3 [\\<mapsto>] ?Ts3]\n                     ?body3 =\n                    annotate P\n                     [this \\<mapsto> Class ?C3, ?pns3 [\\<mapsto>] ?Ts3]\n                     ?body3\n\ngoal (1 subgoal):\n 1. annotate_prog_code P = annotate_prog P", "unfolding annotate_prog_code_def annotate_prog_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?C3, ?D3, ?fs3, ?ms3) \\<in> set (classes P);\n   (?M3, ?Ts3, ?T3, \\<lfloor>(?pns3, ?body3)\\<rfloor>)\n   \\<in> set ?ms3\\<rbrakk>\n  \\<Longrightarrow> annotate_code P\n                     [this \\<mapsto> Class ?C3, ?pns3 [\\<mapsto>] ?Ts3]\n                     ?body3 =\n                    annotate P\n                     [this \\<mapsto> Class ?C3, ?pns3 [\\<mapsto>] ?Ts3]\n                     ?body3\n\ngoal (1 subgoal):\n 1. compP (annotate_Mb_code P) P = compP (annotate_Mb P) P", "by(cases P)(auto simp add: compC_def compM_def annotate_Mb_def annotate_Mb_code_def map_option_case)"], ["proof (state)\nthis:\n  annotate_prog_code P = annotate_prog P\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}