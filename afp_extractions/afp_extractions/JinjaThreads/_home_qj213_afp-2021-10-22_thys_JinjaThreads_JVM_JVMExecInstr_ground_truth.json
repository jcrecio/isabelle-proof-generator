{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/JVM/JVMExecInstr.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma eq_extRet2JVM_conv [simp]:\n  \"(xcp, h', frs') = extRet2JVM n h stk loc C M pc frs va \\<longleftrightarrow> \n   h' = h \\<and> (case va of RetVal v \\<Rightarrow> xcp = None \\<and> frs' = (v # drop (Suc n) stk, loc, C, M, pc + 1) # frs\n                      | RetExc a \\<Rightarrow> xcp = \\<lfloor>a\\<rfloor> \\<and> frs' = (stk, loc, C, M, pc) # frs\n                      | RetStaySame \\<Rightarrow> xcp = None \\<and> frs' = (stk, loc, C, M, pc) # frs)\""], "translations": [["", "lemma eq_extRet2JVM_conv [simp]:\n  \"(xcp, h', frs') = extRet2JVM n h stk loc C M pc frs va \\<longleftrightarrow> \n   h' = h \\<and> (case va of RetVal v \\<Rightarrow> xcp = None \\<and> frs' = (v # drop (Suc n) stk, loc, C, M, pc + 1) # frs\n                      | RetExc a \\<Rightarrow> xcp = \\<lfloor>a\\<rfloor> \\<and> frs' = (stk, loc, C, M, pc) # frs\n                      | RetStaySame \\<Rightarrow> xcp = None \\<and> frs' = (stk, loc, C, M, pc) # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xcp, h', frs') = extRet2JVM n h stk loc C M pc frs va) =\n    (h' = h \\<and>\n     (case va of\n      RetVal v \\<Rightarrow>\n        xcp = None \\<and>\n        frs' = (v # drop (Suc n) stk, loc, C, M, pc + 1) # frs\n      | RetExc a \\<Rightarrow>\n          xcp = \\<lfloor>a\\<rfloor> \\<and> frs' = (stk, loc, C, M, pc) # frs\n      | RetStaySame \\<Rightarrow>\n          xcp = None \\<and> frs' = (stk, loc, C, M, pc) # frs))", "by(cases va) auto"], ["", "definition extNTA2JVM :: \"'addr jvm_prog \\<Rightarrow> (cname \\<times> mname \\<times> 'addr) \\<Rightarrow> 'addr jvm_thread_state\"\nwhere \"extNTA2JVM P \\<equiv> (\\<lambda>(C, M, a). let (D,M',Ts,meth) = method P C M; (mxs,mxl0,ins,xt) = the meth\n                                   in (None, [([],Addr a # replicate mxl0 undefined_value, D, M, 0)]))\""], ["", "abbreviation extTA2JVM :: \n  \"'addr jvm_prog \\<Rightarrow> ('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'heap) jvm_thread_action\"\nwhere \"extTA2JVM P \\<equiv> convert_extTA (extNTA2JVM P)\""], ["", "context JVM_heap_base begin"], ["", "primrec exec_instr ::\n  \"'addr instr \\<Rightarrow> 'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> 'addr val list \\<Rightarrow> 'addr val list\n  \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> pc \\<Rightarrow> 'addr frame list \\<Rightarrow>\n    (('addr, 'thread_id, 'heap) jvm_thread_action \\<times> ('addr, 'heap) jvm_state) set\"\nwhere\nexec_instr_Load:\n \"exec_instr (Load n) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n      {(\\<epsilon>, (None, h, ((loc ! n) # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n\n| \"exec_instr (Store n) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n      {(\\<epsilon>, (None, h, (tl stk, loc[n:=hd stk], C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n\n| exec_instr_Push:\n \"exec_instr (Push v) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n      {(\\<epsilon>, (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs))}\"\n\n| exec_instr_New:\n \"exec_instr (New C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n  (let HA = allocate h (Class_type C)\n   in if HA = {} then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n      else (\\<lambda>(h', a). (\\<lbrace>NewHeapElem a (Class_type C)\\<rbrace>, None, h', (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1)#frs)) ` HA)\"\n\n| exec_instr_NewArray:\n  \"exec_instr (NewArray T) P t h stk loc C0 M0 pc frs =\n  (let si = the_Intg (hd stk);\n       i = nat (sint si)\n   in (if si <s 0\n       then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NegativeArraySize\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n        else let HA = allocate h (Array_type T i)\n             in if HA = {} then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n                else (\\<lambda>(h', a). (\\<lbrace>NewHeapElem a (Array_type T i)\\<rbrace>, None, h', (Addr a # tl stk, loc, C0, M0, pc + 1) # frs)) ` HA))\"\n\n| exec_instr_ALoad:\n  \"exec_instr ALoad P t h stk loc C0 M0 pc frs =\n   (let i = the_Intg (hd stk);\n        va = hd (tl stk);\n        a = the_Addr va;\n        len = alen_of_htype (the (typeof_addr h a))\n    in (if va = Null then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n        else if i <s 0 \\<or> int len \\<le> sint i then\n             {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt ArrayIndexOutOfBounds\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n        else {(\\<lbrace>ReadMem a (ACell (nat (sint i))) v\\<rbrace>, None, h, (v # tl (tl stk), loc, C0, M0, pc + 1) # frs) | v. \n              heap_read h a (ACell (nat (sint i))) v }))\"\n\n| exec_instr_AStore:\n  \"exec_instr AStore P t h stk loc C0 M0 pc frs =\n  (let ve = hd stk;\n       vi = hd (tl stk);\n       va = hd (tl (tl stk))\n   in (if va = Null then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n       else (let i = the_Intg vi;\n                 idx = nat (sint i);\n                 a = the_Addr va;\n                 hT = the (typeof_addr h a);\n                 T = ty_of_htype hT;\n                 len = alen_of_htype hT;\n                 U = the (typeof\\<^bsub>h\\<^esub> ve)\n             in (if i <s 0 \\<or> int len \\<le> sint i then\n                      {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt ArrayIndexOutOfBounds\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n                 else if P \\<turnstile> U \\<le> the_Array T then \n                      {(\\<lbrace>WriteMem a (ACell idx) ve\\<rbrace>, None, h', (tl (tl (tl stk)), loc, C0, M0, pc+1) # frs)\n                       | h'. heap_write h a (ACell idx) ve h'}\n                 else {(\\<epsilon>, (\\<lfloor>addr_of_sys_xcpt ArrayStore\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs))}))))\"\n\n| exec_instr_ALength:\n  \"exec_instr ALength P t h stk loc C0 M0 pc frs =\n   {(\\<epsilon>, (let va = hd stk\n         in if va = Null\n            then (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)\n            else (None, h, (Intg (word_of_int (int (alen_of_htype (the (typeof_addr h (the_Addr va)))))) # tl stk, loc, C0, M0, pc+1) # frs)))}\"\n\n| \"exec_instr (Getfield F C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n   (let v = hd stk\n    in if v = Null then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n       else let a = the_Addr v\n            in {(\\<lbrace>ReadMem a (CField C F) v'\\<rbrace>, None, h, (v' # (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs) | v'.\n                heap_read h a (CField C F) v'})\"\n\n| \"exec_instr (Putfield F C) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n  (let v = hd stk;\n       r = hd (tl stk)\n   in if r = Null then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)}\n      else let a = the_Addr r\n           in {(\\<lbrace>WriteMem a (CField C F) v\\<rbrace>, None, h', (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs) | h'.\n               heap_write h a (CField C F) v h'})\"\n\n| \"exec_instr (CAS F C) P t h stk loc C0 M0 pc frs =\n  (let v'' = hd stk; v' = hd (tl stk); v = hd (tl (tl stk))\n   in if v = Null then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n      else let a = the_Addr v\n           in {(\\<lbrace>ReadMem a (CField C F) v', WriteMem a (CField C F) v''\\<rbrace>, None, h', (Bool True # tl (tl (tl stk)), loc, C0, M0, pc + 1) # frs) | h' .\n                heap_read h a (CField C F) v' \\<and> heap_write h a (CField C F) v'' h'} \\<union>\n              {(\\<lbrace>ReadMem a (CField C F) v''\\<rbrace>, None, h, (Bool False # tl (tl (tl stk)), loc, C0, M0, pc + 1) # frs) | v''.\n                heap_read h a (CField C F) v'' \\<and> v'' \\<noteq> v'})\"\n\n| \"exec_instr (Checkcast T) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n  {(\\<epsilon>, let U = the (typeof\\<^bsub>h\\<^esub> (hd stk))\n       in if P \\<turnstile> U \\<le> T then (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)\n          else (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs))}\"\n\n| \"exec_instr (Instanceof T) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n  {(\\<epsilon>, None, h, (Bool (hd stk \\<noteq> Null \\<and> P \\<turnstile> the (typeof\\<^bsub>h\\<^esub> (hd stk)) \\<le> T) # tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)}\"\n\n| exec_instr_Invoke:\n \"exec_instr (Invoke M n) P t h stk loc C0 M0 pc frs =\n  (let ps = rev (take n stk);\n       r = stk ! n;\n       a = the_Addr r;\n       T = the (typeof_addr h a)\n   in (if r = Null then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C0, M0, pc) # frs)}\n       else \n         let C = class_type_of T;\n             (D,M',Ts,meth)= method P C M\n         in case meth of \n               Native \\<Rightarrow>\n               {(extTA2JVM P ta, extRet2JVM n h' stk loc C0 M0 pc frs va) | ta va h'.\n                (ta, va, h') \\<in> red_external_aggr P t a M ps h}\n            | \\<lfloor>(mxs,mxl\\<^sub>0,ins,xt)\\<rfloor> \\<Rightarrow>\n              let f' = ([],[r]@ps@(replicate mxl\\<^sub>0 undefined_value),D,M,0)\n              in {(\\<epsilon>, None, h, f' # (stk, loc, C0, M0, pc) # frs)}))\"\n\n| \"exec_instr Return P t h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc frs =\n  {(\\<epsilon>, (if frs=[] then (None, h, []) else \n       let v = hd stk\\<^sub>0; \n           (stk,loc,C,m,pc) = hd frs;\n           n = length (fst (snd (method P C\\<^sub>0 M\\<^sub>0)))\n       in (None, h, (v#(drop (n+1) stk),loc,C,m,pc+1)#tl frs)) )}\"\n\n| \"exec_instr Pop P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n      {(\\<epsilon>, (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs) )}\"\n\n| \"exec_instr Dup P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n      {(\\<epsilon>, (None, h, (hd stk # stk, loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs) )}\"\n\n| \"exec_instr Swap P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs = \n      {(\\<epsilon>, (None, h, (hd (tl stk) # hd stk # tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc+1)#frs) )}\"\n\n| \"exec_instr (BinOpInstr bop) P t h stk loc C0 M0 pc frs =\n  {(\\<epsilon>, \n   case the (binop bop (hd (tl stk)) (hd stk)) of\n     Inl v \\<Rightarrow> (None, h, (v # tl (tl stk), loc, C0, M0, pc+1) # frs)\n   | Inr a \\<Rightarrow> (Some a, h, (stk, loc, C0, M0, pc) # frs))}\"\n\n| \"exec_instr (IfFalse i) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n  {(\\<epsilon>, (let pc' = if hd stk = Bool False then nat(int pc+i) else pc+1\n        in (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc')#frs)) )}\"\n\n| exec_instr_Goto:\n \"exec_instr (Goto i) P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n      {(\\<epsilon>, (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, nat(int pc+i))#frs) )}\"\n\n| \"exec_instr ThrowExc P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n  {(\\<epsilon>, (let xp' = if hd stk = Null then \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor> else \\<lfloor>the_Addr(hd stk)\\<rfloor>\n        in (xp', h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc)#frs)) )}\"\n\n| exec_instr_MEnter:\n \"exec_instr MEnter P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n  {let v = hd stk\n   in if v = Null\n      then (\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)\n      else (\\<lbrace>Lock\\<rightarrow>the_Addr v, SyncLock (the_Addr v)\\<rbrace>, None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs)}\"\n\n| exec_instr_MExit:\n \"exec_instr MExit P t h stk loc C\\<^sub>0 M\\<^sub>0 pc frs =\n  (let v = hd stk\n   in if v = Null\n      then {(\\<epsilon>, \\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc)#frs)}\n      else {(\\<lbrace>Unlock\\<rightarrow>the_Addr v, SyncUnlock (the_Addr v)\\<rbrace>, None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1) # frs),\n            (\\<lbrace>UnlockFail\\<rightarrow>the_Addr v\\<rbrace>, \\<lfloor>addr_of_sys_xcpt IllegalMonitorState\\<rfloor>, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc) # frs)})\""], ["", "end"], ["", "end"]]}