{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/MM/JMM_Common.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma heap_copy_loc_not_New: assumes \"heap_copy_loc a a' al h ob h'\"\n  shows \"NewHeapElem a'' x \\<in> set ob \\<Longrightarrow> False\"", "lemma heap_copies_not_New:\n  assumes \"heap_copies a a' als h obs h'\" \n  and \"NewHeapElem a'' x \\<in> set obs\"\n  shows \"False\"", "lemma heap_clone_New_same_addr_same:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"obs ! i = NewHeapElem a'' x\" \"i < length obs\"\n  and \"obs ! j = NewHeapElem a'' x'\" \"j < length obs\"\n  shows \"i = j\"", "lemma red_external_New_same_addr_same:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; \n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = NewHeapElem a' x; i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! j = NewHeapElem a' x'; j < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> i = j\"", "lemma red_external_aggr_New_same_addr_same:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = NewHeapElem a' x; i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! j = NewHeapElem a' x'; j < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> i = j\"", "lemma heap_copy_loc_read_typeable:\n  assumes \"heap_copy_loc a a' al h obs h'\"\n  and \"ReadMem ad al' v \\<in> set obs\"\n  and \"P,h \\<turnstile> a@al : T\"\n  shows \"ad = a \\<and> al'= al\"", "lemma heap_copies_read_typeable:\n  assumes \"heap_copies a a' als h obs h'\"\n  and \"ReadMem ad al' v \\<in> set obs\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts\"\n  shows \"ad = a \\<and> al' \\<in> set als\"", "lemma heap_clone_read_typeable:\n  assumes clone: \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and read: \"ReadMem ad al v \\<in> set obs\"\n  shows \"ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\"", "lemma red_external_read_mem_typeable:\n  assumes red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and read: \"ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  shows \"\\<exists>T'. P,h \\<turnstile> ad@al : T'\"", "lemma heap_clone_typeof_addrD:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"hconf h\"\n  shows \"NewHeapElem a'' x \\<in> set obs \\<Longrightarrow> a'' = a' \\<and> typeof_addr h' a' = Some x\"", "lemma red_external_New_typeof_addrD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; hconf h \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = Some x\"", "lemma red_external_aggr_New_typeof_addrD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     is_native P (the (typeof_addr h a)) M; hconf h \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = Some x\"", "lemma heap_copy_loc_non_speculative_typeable:\n  assumes copy: \"heap_copy_loc ad ad' al h obs h'\"\n  and sc: \"non_speculative P vs (llist_of (map NormalAction obs))\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  and wt: \"P,h \\<turnstile> ad@al : T\" \"P,h \\<turnstile> ad'@al : T\"\n  shows \"heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs h'\"", "lemma heap_copy_loc_non_speculative_vs_conf:\n  assumes copy: \"heap_copy_loc ad ad' al h obs h'\"\n  and sc: \"non_speculative P vs (llist_of (take n (map NormalAction obs)))\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  and wt: \"P,h \\<turnstile> ad@al : T\" \"P,h \\<turnstile> ad'@al : T\"\n  shows \"vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\"", "lemma heap_copies_non_speculative_typeable:\n  assumes \"heap_copies ad ad' als h obs h'\"\n  and \"non_speculative P vs (llist_of (map NormalAction obs))\"\n  and \"vs_conf P h vs\"\n  and \"hconf h\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad@al : T) als Ts\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad'@al : T) als Ts\"\n  shows \"heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h obs h'\"", "lemma heap_copies_non_speculative_vs_conf:\n  assumes \"heap_copies ad ad' als h obs h'\"\n  and \"non_speculative P vs (llist_of (take n (map NormalAction obs)))\"\n  and \"vs_conf P h vs\"\n  and \"hconf h\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad@al : T) als Ts\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad'@al : T) als Ts\"\n  shows \"vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\"", "lemma heap_clone_non_speculative_typeable_Some:\n  assumes clone: \"heap_clone P h ad h' \\<lfloor>(obs, ad')\\<rfloor>\"\n  and sc: \"non_speculative P vs (llist_of (map NormalAction obs))\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  shows \"heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write P h ad h' \\<lfloor>(obs, ad')\\<rfloor>\"", "lemma heap_clone_non_speculative_vs_conf_Some:\n  assumes clone: \"heap_clone P h ad h' \\<lfloor>(obs, ad')\\<rfloor>\"\n  and sc: \"non_speculative P vs (llist_of (take n (map NormalAction obs)))\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  shows \"vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\"", "lemma heap_clone_non_speculative_typeable_None:\n  assumes \"heap_clone P h ad h' None\"\n  shows \"heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write P h ad h' None\"", "lemma red_external_non_speculative_typeable:\n  assumes red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and sc: \"non_speculative P Vs (llist_of (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\"\n  and vs: \"vs_conf P h Vs\"\n  and hconf: \"hconf h\"\n  shows \"heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr (heap_read_typed P) heap_write P t h a M vs ta va h'\"", "lemma red_external_non_speculative_vs_conf:\n  assumes red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and sc: \"non_speculative P Vs (llist_of (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"\n  and vs: \"vs_conf P h Vs\"\n  and hconf: \"hconf h\"\n  shows \"vs_conf P h' (w_values P Vs (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"", "lemma red_external_aggr_non_speculative_typeable:\n  assumes red: \"(ta, va, h') \\<in> red_external_aggr P t a M vs h\"\n  and sc: \"non_speculative P Vs (llist_of (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\"\n  and vs: \"vs_conf P h Vs\"\n  and hconf: \"hconf h\"\n  and native: \"is_native P (the (typeof_addr h a)) M\"\n  shows \"(ta, va, h') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr (heap_read_typed P) heap_write P t a M vs h\"", "lemma red_external_aggr_non_speculative_vs_conf:\n  assumes red: \"(ta, va, h') \\<in> red_external_aggr P t a M vs h\"\n  and sc: \"non_speculative P Vs (llist_of (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"\n  and vs: \"vs_conf P h Vs\"\n  and hconf: \"hconf h\"\n  and native: \"is_native P (the (typeof_addr h a)) M\"\n  shows \"vs_conf P h' (w_values P Vs (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"", "lemma heap_copy_loc_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and vs: \"vs_conf P h vs\"\n  and type: \"P,h \\<turnstile> a@al : T\" \"P,h \\<turnstile> a'@al : T\"\n  and hconf: \"hconf h\"\n  and copy: \"heap_copy_loc a a' al h obs h'\"\n  and i: \"i < length obs\"\n  and read: \"obs ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\"\n  shows \"\\<exists>obs' h''. heap_copy_loc a a' al h obs' h'' \\<and> i < length obs' \\<and> take i obs' = take i obs \\<and> \n                    obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs \\<and> \n                    non_speculative P vs (llist_of (map NormalAction obs'))\"", "lemma heap_copies_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and copies: \"heap_copies a a' als h obs h'\"\n  and vs: \"vs_conf P h vs\"\n  and type1: \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts\"\n  and type2: \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts\"\n  and hconf: \"hconf h\"\n  and i: \"i < length obs\"\n  and read: \"obs ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\"\n  and ns: \"non_speculative P vs (llist_of (map NormalAction (take i obs)))\"\n  shows \"\\<exists>obs' h''. heap_copies a a' als h obs' h'' \\<and> i < length obs' \\<and> take i obs' = take i obs \\<and> \n                    obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs\"\n  (is \"?concl als h obs vs i\")", "lemma heap_clone_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and clone: \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  and i: \"i < length obs\"\n  and read: \"obs ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\"\n  and ns: \"non_speculative P vs (llist_of (map NormalAction (take i obs)))\"\n  shows \"\\<exists>obs' h''. heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and> i < length obs' \\<and> take i obs' = take i obs \\<and> \n                    obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs\"", "lemma red_external_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and vs: \"vs_conf P (shr s) vs\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'), shr s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\"\n  and aok: \"final_thread.actions_ok final s t ta\"\n  and hconf: \"hconf (shr s)\"\n  and i: \"i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and read: \"\\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (a'', al'')\"\n  and ns: \"non_speculative P vs (llist_of (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"\n  shows \"\\<exists>ta'' va'' h''. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'), shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'', h''\\<rangle> \\<and> final_thread.actions_ok final s t ta'' \\<and>\n                         i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and> take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> = take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and> \n                         \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v' \\<and> length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemma red_external_aggr_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and vs: \"vs_conf P (shr s) vs\"\n  and red: \"(ta, va, h') \\<in> red_external_aggr P t a M vs' (shr s)\"\n  and native: \"is_native P (the (typeof_addr (shr s) a)) M\"\n  and aok: \"final_thread.actions_ok final s t ta\"\n  and hconf: \"hconf (shr s)\"\n  and i: \"i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and read: \"\\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (a'', al'')\"\n  and ns: \"non_speculative P vs (llist_of (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"\n  shows \"\\<exists>ta'' va'' h''. (ta'', va'', h'') \\<in> red_external_aggr P t a M vs' (shr s) \\<and> final_thread.actions_ok final s t ta'' \\<and>\n                         i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and> take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> = take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and> \n                         \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v' \\<and> length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemma heap_copy_loc_allocated_same:\n  assumes \"heap_copy_loc a a' al h obs h'\"\n  shows \"allocated h' = allocated h\"", "lemma heap_copy_loc_allocated_mono:\n  \"heap_copy_loc a a' al h obs h' \\<Longrightarrow> allocated h \\<subseteq> allocated h'\"", "lemma heap_copies_allocated_same:\n  assumes \"heap_copies a a' al h obs h'\"\n  shows \"allocated h' = allocated h\"", "lemma heap_copies_allocated_mono:\n  \"heap_copies a a' al h obs h' \\<Longrightarrow> allocated h \\<subseteq> allocated h'\"", "lemma heap_clone_allocated_mono:\n  assumes \"heap_clone P h a h' aobs\"\n  shows \"allocated h \\<subseteq> allocated h'\"", "lemma red_external_allocated_mono:\n  assumes \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  shows \"allocated h \\<subseteq> allocated h'\"", "lemma red_external_aggr_allocated_mono:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; is_native P (the (typeof_addr h a)) M \\<rbrakk>\n  \\<Longrightarrow> allocated h \\<subseteq> allocated h'\"", "lemma heap_clone_allocatedD:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"NewHeapElem a'' x \\<in> set obs\"\n  shows \"a'' \\<in> allocated h' \\<and> a'' \\<notin> allocated h\"", "lemma red_external_allocatedD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> a' \\<in> allocated h' \\<and> a' \\<notin> allocated h\"", "lemma red_external_aggr_allocatedD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     is_native P (the (typeof_addr h a)) M \\<rbrakk>\n  \\<Longrightarrow> a' \\<in> allocated h' \\<and> a' \\<notin> allocated h\"", "lemma heap_clone_NewHeapElemD:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"ad \\<in> allocated h'\"\n  and \"ad \\<notin> allocated h\"\n  shows \"\\<exists>CTn. NewHeapElem ad CTn \\<in> set obs\"", "lemma heap_clone_fail_allocated_same:\n  assumes \"heap_clone P h a h' None\"\n  shows \"allocated h' = allocated h\"", "lemma red_external_NewHeapElemD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; a' \\<in> allocated h'; a' \\<notin> allocated h \\<rbrakk>\n  \\<Longrightarrow> \\<exists>CTn. NewHeapElem a' CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemma red_external_aggr_NewHeapElemD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; a' \\<in> allocated h'; a' \\<notin> allocated h;\n     is_native P (the (typeof_addr h a)) M \\<rbrakk>\n  \\<Longrightarrow> \\<exists>CTn. NewHeapElem a' CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemma binop_known_addrs:\n  assumes ok: \"start_heap_ok\"\n  shows \"binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor> \\<Longrightarrow> ka_Val v \\<subseteq> ka_Val v1 \\<union> ka_Val v2 \\<union> set start_addrs\"\n  and \"binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor> \\<Longrightarrow> a \\<in> ka_Val v1 \\<union> ka_Val v2 \\<union> set start_addrs\"", "lemma heap_copy_loc_known_addrs_ReadMem:\n  assumes \"heap_copy_loc a a' al h ob h'\"\n  and \"ReadMem ad al' v \\<in> set ob\"\n  shows \"ad = a\"", "lemma heap_copies_known_addrs_ReadMem:\n  assumes \"heap_copies a a' als h obs h'\"\n  and \"ReadMem ad al v \\<in> set obs\"\n  shows \"ad = a\"", "lemma heap_clone_known_addrs_ReadMem:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"ReadMem ad al v \\<in> set obs\"\n  shows \"ad = a\"", "lemma red_external_known_addrs_ReadMem:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>; ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> ad \\<in> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs\"", "lemma red_external_aggr_known_addrs_ReadMem:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> ad \\<in> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs\"", "lemma heap_copy_loc_known_addrs_WriteMem:\n  assumes \"heap_copy_loc a a' al h ob h'\"\n  and \"ob ! n = WriteMem ad al' (Addr a'')\" \"n < length ob\"\n  shows \"a'' \\<in> new_obs_addrs (take n ob)\"", "lemma heap_copies_known_addrs_WriteMem:\n  assumes \"heap_copies a a' als h obs h'\"\n  and \"obs ! n = WriteMem ad al (Addr a'')\" \"n < length obs\"\n  shows \"a'' \\<in> new_obs_addrs (take n obs)\"", "lemma heap_clone_known_addrs_WriteMem:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"obs ! n = WriteMem ad al (Addr a'')\" \"n < length obs\"\n  shows \"a'' \\<in> new_obs_addrs (take n obs)\"", "lemma red_external_known_addrs_WriteMem:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>; \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! n = WriteMem ad al (Addr a'); n < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> a' \\<in> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs \\<union> new_obs_addrs (take n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\"", "lemma red_external_aggr_known_addrs_WriteMem:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! n = WriteMem ad al (Addr a'); n < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> a' \\<in> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs \\<union> new_obs_addrs (take n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\"", "lemma red_external_known_addrs_mono:\n  assumes ok: \"start_heap_ok\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  shows \"(case va of RetVal v \\<Rightarrow> ka_Val v | RetExc a \\<Rightarrow> {a} | RetStaySame \\<Rightarrow> {}) \\<subseteq> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs \\<union> new_obs_addrs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemma red_external_aggr_known_addrs_mono:\n  assumes ok: \"start_heap_ok\"\n  and red: \"(ta, va, h') \\<in> red_external_aggr P t a M vs h\" \"is_native P (the (typeof_addr h a)) M\"\n  shows \"(case va of RetVal v \\<Rightarrow> ka_Val v | RetExc a \\<Rightarrow> {a} | RetStaySame \\<Rightarrow> {}) \\<subseteq> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs \\<union> new_obs_addrs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemma red_external_NewThread_idD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> t' = addr2thread_id a \\<and> a' = a\"", "lemma red_external_aggr_NewThread_idD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \n     NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> t' = addr2thread_id a \\<and> a' = a\"", "lemma heap_copy_loc_New_type_match:\n  \"\\<lbrakk> h.heap_copy_loc a a' al h obs h'; NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\"", "lemma heap_copies_New_type_match:\n  \"\\<lbrakk> h.heap_copies a a' als h obs h'; NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\"", "lemma heap_clone_New_type_match:\n  \"\\<lbrakk> h.heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>; NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\"", "lemma red_external_New_type_match:\n  \"\\<lbrakk> h.red_external P t a M vs h ta va h'; NewHeapElem ad CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\"", "lemma red_external_aggr_New_type_match:\n  \"\\<lbrakk> (ta, va, h') \\<in> h.red_external_aggr P t a M vs h; NewHeapElem ad CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], "translations": [["", "lemma heap_copy_loc_not_New: assumes \"heap_copy_loc a a' al h ob h'\"\n  shows \"NewHeapElem a'' x \\<in> set ob \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NewHeapElem a'' x \\<in> set ob \\<Longrightarrow> False", "using assms"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n\ngoal (1 subgoal):\n 1. NewHeapElem a'' x \\<in> set ob \\<Longrightarrow> False", "by(auto elim: heap_copy_loc.cases)"], ["", "lemma heap_copies_not_New:\n  assumes \"heap_copies a a' als h obs h'\" \n  and \"NewHeapElem a'' x \\<in> set obs\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  heap_copies a a' als h obs h'\n  NewHeapElem a'' x \\<in> set obs\n\ngoal (1 subgoal):\n 1. False", "by induct(auto dest: heap_copy_loc_not_New)"], ["", "lemma heap_clone_New_same_addr_same:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"obs ! i = NewHeapElem a'' x\" \"i < length obs\"\n  and \"obs ! j = NewHeapElem a'' x'\" \"j < length obs\"\n  shows \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n  obs ! i = NewHeapElem a'' x\n  i < length obs\n  obs ! j = NewHeapElem a'' x'\n  j < length obs\n\ngoal (1 subgoal):\n 1. i = j", "apply cases"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs ! i = NewHeapElem a'' x; i < length obs;\n        obs ! j = NewHeapElem a'' x'; j < length obs;\n        obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> i = j\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs ! i = NewHeapElem a'' x; i < length obs;\n        obs ! j = NewHeapElem a'' x'; j < length obs;\n        obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> i = j", "apply(fastforce simp add: nth_Cons' gr0_conv_Suc in_set_conv_nth split: if_split_asm dest: heap_copies_not_New)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red_external_New_same_addr_same:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; \n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = NewHeapElem a' x; i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! j = NewHeapElem a' x'; j < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = NewHeapElem a' x;\n     i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! j = NewHeapElem a' x';\n     j < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> i = j", "by(auto elim!: red_external.cases simp add: nth_Cons' split: if_split_asm dest: heap_clone_New_same_addr_same)"], ["", "lemma red_external_aggr_New_same_addr_same:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = NewHeapElem a' x; i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n    \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! j = NewHeapElem a' x'; j < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = NewHeapElem a' x;\n     i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! j = NewHeapElem a' x';\n     j < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> i = j", "by(auto simp add: external_WT_defs.simps red_external_aggr_def nth_Cons' split: if_split_asm if_split_asm dest: heap_clone_New_same_addr_same)"], ["", "lemma heap_copy_loc_read_typeable:\n  assumes \"heap_copy_loc a a' al h obs h'\"\n  and \"ReadMem ad al' v \\<in> set obs\"\n  and \"P,h \\<turnstile> a@al : T\"\n  shows \"ad = a \\<and> al'= al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ad = a \\<and> al' = al", "using assms"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h obs h'\n  ReadMem ad al' v \\<in> set obs\n  P,h \\<turnstile> a@al : T\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' = al", "by cases auto"], ["", "lemma heap_copies_read_typeable:\n  assumes \"heap_copies a a' als h obs h'\"\n  and \"ReadMem ad al' v \\<in> set obs\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts\"\n  shows \"ad = a \\<and> al' \\<in> set als\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ad = a \\<and> al' \\<in> set als", "using assms"], ["proof (prove)\nusing this:\n  heap_copies a a' als h obs h'\n  ReadMem ad al' v \\<in> set obs\n  list_all2 (addr_loc_type P h a) als Ts\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' \\<in> set als", "proof(induct arbitrary: Ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h Ts.\n       \\<lbrakk>ReadMem ad al' v \\<in> set [];\n        list_all2 (addr_loc_type P h a) [] Ts\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and> al' \\<in> set []\n 2. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>ReadMem ad al' v \\<in> set obs;\n            list_all2 (addr_loc_type P h' a) als Ts\\<rbrakk>\n           \\<Longrightarrow> ad = a \\<and> al' \\<in> set als;\n        ReadMem ad al' v \\<in> set (ob @ obs);\n        list_all2 (addr_loc_type P h a) (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and> al' \\<in> set (al # als)", "case Nil"], ["proof (state)\nthis:\n  ReadMem ad al' v \\<in> set []\n  list_all2 (addr_loc_type P h_ a) [] Ts\n\ngoal (2 subgoals):\n 1. \\<And>h Ts.\n       \\<lbrakk>ReadMem ad al' v \\<in> set [];\n        list_all2 (addr_loc_type P h a) [] Ts\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and> al' \\<in> set []\n 2. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>ReadMem ad al' v \\<in> set obs;\n            list_all2 (addr_loc_type P h' a) als Ts\\<rbrakk>\n           \\<Longrightarrow> ad = a \\<and> al' \\<in> set als;\n        ReadMem ad al' v \\<in> set (ob @ obs);\n        list_all2 (addr_loc_type P h a) (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and> al' \\<in> set (al # als)", "thus ?case"], ["proof (prove)\nusing this:\n  ReadMem ad al' v \\<in> set []\n  list_all2 (addr_loc_type P h_ a) [] Ts\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' \\<in> set []", "by simp"], ["proof (state)\nthis:\n  ad = a \\<and> al' \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>ReadMem ad al' v \\<in> set obs;\n            list_all2 (addr_loc_type P h' a) als Ts\\<rbrakk>\n           \\<Longrightarrow> ad = a \\<and> al' \\<in> set als;\n        ReadMem ad al' v \\<in> set (ob @ obs);\n        list_all2 (addr_loc_type P h a) (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and> al' \\<in> set (al # als)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>ReadMem ad al' v \\<in> set obs;\n            list_all2 (addr_loc_type P h' a) als Ts\\<rbrakk>\n           \\<Longrightarrow> ad = a \\<and> al' \\<in> set als;\n        ReadMem ad al' v \\<in> set (ob @ obs);\n        list_all2 (addr_loc_type P h a) (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and> al' \\<in> set (al # als)", "case (Cons al h ob h' als obs h'')"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h ob h'\n  heap_copies a a' als h' obs h''\n  \\<lbrakk>ReadMem ad al' v \\<in> set obs;\n   list_all2 (addr_loc_type P h' a) als ?Ts17\\<rbrakk>\n  \\<Longrightarrow> ad = a \\<and> al' \\<in> set als\n  ReadMem ad al' v \\<in> set (ob @ obs)\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>ReadMem ad al' v \\<in> set obs;\n            list_all2 (addr_loc_type P h' a) als Ts\\<rbrakk>\n           \\<Longrightarrow> ad = a \\<and> al' \\<in> set als;\n        ReadMem ad al' v \\<in> set (ob @ obs);\n        list_all2 (addr_loc_type P h a) (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and> al' \\<in> set (al # als)", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) (al # als) Ts\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) (al # als) Ts", "obtain T Ts' where Ts [simp]: \"Ts = T # Ts'\"\n    and \"P,h \\<turnstile> a@al : T\" \n    and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts'.\n        \\<lbrakk>Ts = T # Ts'; P,h \\<turnstile> a@al : T;\n         list_all2 (addr_loc_type P h a) als Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: list_all2_Cons1)"], ["proof (state)\nthis:\n  Ts = T # Ts'\n  P,h \\<turnstile> a@al : T\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts.\n           \\<lbrakk>ReadMem ad al' v \\<in> set obs;\n            list_all2 (addr_loc_type P h' a) als Ts\\<rbrakk>\n           \\<Longrightarrow> ad = a \\<and> al' \\<in> set als;\n        ReadMem ad al' v \\<in> set (ob @ obs);\n        list_all2 (addr_loc_type P h a) (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and> al' \\<in> set (al # als)", "from \\<open>ReadMem ad al' v \\<in> set (ob @ obs)\\<close>"], ["proof (chain)\npicking this:\n  ReadMem ad al' v \\<in> set (ob @ obs)", "show ?case"], ["proof (prove)\nusing this:\n  ReadMem ad al' v \\<in> set (ob @ obs)\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' \\<in> set (al # als)", "unfolding set_append Un_iff"], ["proof (prove)\nusing this:\n  ReadMem ad al' v \\<in> set ob \\<or> ReadMem ad al' v \\<in> set obs\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' \\<in> set (al # als)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ReadMem ad al' v \\<in> set ob \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)\n 2. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "assume \"ReadMem ad al' v \\<in> set ob\""], ["proof (state)\nthis:\n  ReadMem ad al' v \\<in> set ob\n\ngoal (2 subgoals):\n 1. ReadMem ad al' v \\<in> set ob \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)\n 2. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "with \\<open>heap_copy_loc a a' al h ob h'\\<close>"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h ob h'\n  ReadMem ad al' v \\<in> set ob", "have \"ad = a \\<and> al'= al\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n  ReadMem ad al' v \\<in> set ob\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' = al", "using \\<open>P,h \\<turnstile> a@al : T\\<close>"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n  ReadMem ad al' v \\<in> set ob\n  P,h \\<turnstile> a@al : T\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' = al", "by(rule heap_copy_loc_read_typeable)"], ["proof (state)\nthis:\n  ad = a \\<and> al' = al\n\ngoal (2 subgoals):\n 1. ReadMem ad al' v \\<in> set ob \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)\n 2. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ad = a \\<and> al' = al\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' \\<in> set (al # als)", "by simp"], ["proof (state)\nthis:\n  ad = a \\<and> al' \\<in> set (al # als)\n\ngoal (1 subgoal):\n 1. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "assume \"ReadMem ad al' v \\<in> set obs\""], ["proof (state)\nthis:\n  ReadMem ad al' v \\<in> set obs\n\ngoal (1 subgoal):\n 1. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "moreover"], ["proof (state)\nthis:\n  ReadMem ad al' v \\<in> set obs\n\ngoal (1 subgoal):\n 1. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "from \\<open>heap_copy_loc a a' al h ob h'\\<close>"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h ob h'", "have \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_copy_loc)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "from \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts'\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) als Ts'", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a) als Ts'", "by(rule List.list_all2_mono)(rule addr_loc_type_hext_mono[OF _ \\<open>h \\<unlhd> h'\\<close>])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a) als Ts'\n\ngoal (1 subgoal):\n 1. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "ultimately"], ["proof (chain)\npicking this:\n  ReadMem ad al' v \\<in> set obs\n  list_all2 (addr_loc_type P h' a) als Ts'", "have \"ad = a \\<and> al' \\<in> set als\""], ["proof (prove)\nusing this:\n  ReadMem ad al' v \\<in> set obs\n  list_all2 (addr_loc_type P h' a) als Ts'\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' \\<in> set als", "by(rule Cons)"], ["proof (state)\nthis:\n  ad = a \\<and> al' \\<in> set als\n\ngoal (1 subgoal):\n 1. ReadMem ad al' v \\<in> set obs \\<Longrightarrow>\n    ad = a \\<and> al' \\<in> set (al # als)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ad = a \\<and> al' \\<in> set als\n\ngoal (1 subgoal):\n 1. ad = a \\<and> al' \\<in> set (al # als)", "by simp"], ["proof (state)\nthis:\n  ad = a \\<and> al' \\<in> set (al # als)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ad = a \\<and> al' \\<in> set (al # als)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_clone_read_typeable:\n  assumes clone: \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and read: \"ReadMem ad al v \\<in> set obs\"\n  shows \"ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "using clone"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n\ngoal (1 subgoal):\n 1. ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "case (ObjClone C H' FDTs obs')"], ["proof (state)\nthis:\n  obs = NewHeapElem a' (Class_type C) # obs'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (H', a') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) H' obs'\n   h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "let ?als = \"map (\\<lambda>((F, D), Tm). CField D F) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "note \\<open>heap_copies a a' ?als H' obs' h'\\<close>"], ["proof (state)\nthis:\n  heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) H' obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "moreover"], ["proof (state)\nthis:\n  heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) H' obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "from \\<open>obs = NewHeapElem a' (Class_type C) # obs'\\<close> read"], ["proof (chain)\npicking this:\n  obs = NewHeapElem a' (Class_type C) # obs'\n  ReadMem ad al v \\<in> set obs", "have \"ReadMem ad al v \\<in> set obs'\""], ["proof (prove)\nusing this:\n  obs = NewHeapElem a' (Class_type C) # obs'\n  ReadMem ad al v \\<in> set obs\n\ngoal (1 subgoal):\n 1. ReadMem ad al v \\<in> set obs'", "by simp"], ["proof (state)\nthis:\n  ReadMem ad al v \\<in> set obs'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "moreover"], ["proof (state)\nthis:\n  ReadMem ad al v \\<in> set obs'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "from \\<open>(H', a') \\<in> allocate h (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (H', a') \\<in> allocate h (Class_type C)", "have \"h \\<unlhd> H'\""], ["proof (prove)\nusing this:\n  (H', a') \\<in> allocate h (Class_type C)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> H'", "by(rule hext_allocate)"], ["proof (state)\nthis:\n  h \\<unlhd> H'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "hence \"typeof_addr H' a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> H'\n\ngoal (1 subgoal):\n 1. typeof_addr H' a = \\<lfloor>Class_type C\\<rfloor>", "using \\<open>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close>"], ["proof (prove)\nusing this:\n  h \\<unlhd> H'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr H' a = \\<lfloor>Class_type C\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr H' a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "hence type: \"list_all2 (\\<lambda>al T. P,H' \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr H' a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P H' a)\n     (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "using \\<open>P \\<turnstile> C has_fields FDTs\\<close>"], ["proof (prove)\nusing this:\n  typeof_addr H' a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P H' a)\n     (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  typeof_addr H' a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,H' \\<turnstile> a@(case x of\n                            (x, xa) \\<Rightarrow>\n                              (case x of\n                               (F, D) \\<Rightarrow> \\<lambda>Tm. CField D F)\n                               xa) : (case x of\n(FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) H' obs' h'\n  ReadMem ad al v \\<in> set obs'\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "have \"ad = a \\<and> al \\<in> set ?als\""], ["proof (prove)\nusing this:\n  heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) H' obs' h'\n  ReadMem ad al v \\<in> set obs'\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (1 subgoal):\n 1. ad = a \\<and>\n    al \\<in> set (map (\\<lambda>((F, D), Tm). CField D F) FDTs)", "by(rule heap_copies_read_typeable)"], ["proof (state)\nthis:\n  ad = a \\<and> al \\<in> set (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "hence [simp]: \"ad = a\" and \"al \\<in> set ?als\""], ["proof (prove)\nusing this:\n  ad = a \\<and> al \\<in> set (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n\ngoal (1 subgoal):\n 1. ad = a &&& al \\<in> set (map (\\<lambda>((F, D), Tm). CField D F) FDTs)", "by simp_all"], ["proof (state)\nthis:\n  ad = a\n  al \\<in> set (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "then"], ["proof (chain)\npicking this:\n  ad = a\n  al \\<in> set (map (\\<lambda>((F, D), Tm). CField D F) FDTs)", "obtain F D T where [simp]: \"al = CField D F\" and \"((F, D), T) \\<in> set FDTs\""], ["proof (prove)\nusing this:\n  ad = a\n  al \\<in> set (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n\ngoal (1 subgoal):\n 1. (\\<And>D F T.\n        \\<lbrakk>al = CField D F; ((F, D), T) \\<in> set FDTs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  al = CField D F\n  ((F, D), T) \\<in> set FDTs\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "with type \\<open>h \\<unlhd> H'\\<close> \\<open>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  h \\<unlhd> H'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  al = CField D F\n  ((F, D), T) \\<in> set FDTs", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  h \\<unlhd> H'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  al = CField D F\n  ((F, D), T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set FDTs.\n     P,H' \\<turnstile> a@(case x of\n                          (x, xa) \\<Rightarrow>\n                            (case x of\n                             (F, D) \\<Rightarrow> \\<lambda>Tm. CField D F)\n                             xa) : (case x of\n                                    (FD, T) \\<Rightarrow>\nfst (the (map_of FDTs FD)))\n  h \\<unlhd> H'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  al = CField D F\n  ((F, D), T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "by(fastforce elim!: ballE[where x=\"((F, D), T)\"] addr_loc_type.cases dest: typeof_addr_hext_mono intro: addr_loc_type.intros)"], ["proof (state)\nthis:\n  ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "case (ArrClone T n H' FDTs obs')"], ["proof (state)\nthis:\n  obs = NewHeapElem a' (Array_type T n) # obs'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  (H', a') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) H'\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "note FDTs = \\<open>P \\<turnstile> Object has_fields FDTs\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "note \\<open>heap_copies a a' ?als H' obs' h'\\<close>"], ["proof (state)\nthis:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) H'\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "moreover"], ["proof (state)\nthis:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) H'\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "from \\<open>obs = NewHeapElem a' (Array_type T n) # obs'\\<close> read"], ["proof (chain)\npicking this:\n  obs = NewHeapElem a' (Array_type T n) # obs'\n  ReadMem ad al v \\<in> set obs", "have \"ReadMem ad al v \\<in> set obs'\""], ["proof (prove)\nusing this:\n  obs = NewHeapElem a' (Array_type T n) # obs'\n  ReadMem ad al v \\<in> set obs\n\ngoal (1 subgoal):\n 1. ReadMem ad al v \\<in> set obs'", "by simp"], ["proof (state)\nthis:\n  ReadMem ad al v \\<in> set obs'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "moreover"], ["proof (state)\nthis:\n  ReadMem ad al v \\<in> set obs'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "from \\<open>(H', a') \\<in> allocate h (Array_type T n)\\<close>"], ["proof (chain)\npicking this:\n  (H', a') \\<in> allocate h (Array_type T n)", "have \"h \\<unlhd> H'\""], ["proof (prove)\nusing this:\n  (H', a') \\<in> allocate h (Array_type T n)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> H'", "by(rule hext_allocate)"], ["proof (state)\nthis:\n  h \\<unlhd> H'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "with \\<open>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  h \\<unlhd> H'", "have type': \"typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  h \\<unlhd> H'\n\ngoal (1 subgoal):\n 1. typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>", "by(auto dest: typeof_addr_hext_mono hext_arrD)"], ["proof (state)\nthis:\n  typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "hence type: \"list_all2 (\\<lambda>al T. P,H' \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P H' a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "using FDTs"], ["proof (prove)\nusing this:\n  typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P H' a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) H'\n   obs' h'\n  ReadMem ad al v \\<in> set obs'\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)", "have \"ad = a \\<and> al \\<in> set ?als\""], ["proof (prove)\nusing this:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) H'\n   obs' h'\n  ReadMem ad al v \\<in> set obs'\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. ad = a \\<and>\n    al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n                  map ACell [0..<n])", "by(rule heap_copies_read_typeable)"], ["proof (state)\nthis:\n  ad = a \\<and>\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n                map ACell [0..<n])\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "hence [simp]: \"ad = a\" and \"al \\<in> set ?als\""], ["proof (prove)\nusing this:\n  ad = a \\<and>\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n                map ACell [0..<n])\n\ngoal (1 subgoal):\n 1. ad = a &&&\n    al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n                  map ACell [0..<n])", "by simp_all"], ["proof (state)\nthis:\n  ad = a\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n                map ACell [0..<n])\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "hence \"al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) \\<or> al \\<in> set (map ACell [0..<n])\""], ["proof (prove)\nusing this:\n  ad = a\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n                map ACell [0..<n])\n\ngoal (1 subgoal):\n 1. al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) \\<or>\n    al \\<in> set (map ACell [0..<n])", "by simp"], ["proof (state)\nthis:\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) \\<or>\n  al \\<in> set (map ACell [0..<n])\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> ad = a \\<and>\n                         (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "thus ?thesis"], ["proof (prove)\nusing this:\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) \\<or>\n  al \\<in> set (map ACell [0..<n])\n\ngoal (1 subgoal):\n 1. ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F)\n                   FDTs) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. al \\<in> set (map ACell [0..<n]) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "assume \"al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\""], ["proof (state)\nthis:\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n\ngoal (2 subgoals):\n 1. al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F)\n                   FDTs) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. al \\<in> set (map ACell [0..<n]) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "then"], ["proof (chain)\npicking this:\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)", "obtain F D Tfm where [simp]: \"al = CField D F\" and \"((F, D), Tfm) \\<in> set FDTs\""], ["proof (prove)\nusing this:\n  al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n\ngoal (1 subgoal):\n 1. (\\<And>D F Tfm.\n        \\<lbrakk>al = CField D F; ((F, D), Tfm) \\<in> set FDTs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  al = CField D F\n  ((F, D), Tfm) \\<in> set FDTs\n\ngoal (2 subgoals):\n 1. al \\<in> set (map (\\<lambda>((F, D), Tfm). CField D F)\n                   FDTs) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n 2. al \\<in> set (map ACell [0..<n]) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "with type type' \\<open>h \\<unlhd> H'\\<close> \\<open>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>\n  h \\<unlhd> H'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  al = CField D F\n  ((F, D), Tfm) \\<in> set FDTs", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>\n  h \\<unlhd> H'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  al = CField D F\n  ((F, D), Tfm) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "by(fastforce elim!: ballE[where x=\"((F, D), Tfm)\"] addr_loc_type.cases intro: addr_loc_type.intros simp add: list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv)"], ["proof (state)\nthis:\n  ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n\ngoal (1 subgoal):\n 1. al \\<in> set (map ACell [0..<n]) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. al \\<in> set (map ACell [0..<n]) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "assume \"al \\<in> set (map ACell [0..<n])\""], ["proof (state)\nthis:\n  al \\<in> set (map ACell [0..<n])\n\ngoal (1 subgoal):\n 1. al \\<in> set (map ACell [0..<n]) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "then"], ["proof (chain)\npicking this:\n  al \\<in> set (map ACell [0..<n])", "obtain n' where [simp]: \"al = ACell n'\" and \"n' < n\""], ["proof (prove)\nusing this:\n  al \\<in> set (map ACell [0..<n])\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>al = ACell n'; n' < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  al = ACell n'\n  n' < n\n\ngoal (1 subgoal):\n 1. al \\<in> set (map ACell [0..<n]) \\<Longrightarrow>\n    ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "with type type' \\<open>h \\<unlhd> H'\\<close> \\<open>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>\n  h \\<unlhd> H'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  al = ACell n'\n  n' < n", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P H' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  typeof_addr H' a = \\<lfloor>Array_type T n\\<rfloor>\n  h \\<unlhd> H'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  al = ACell n'\n  n' < n\n\ngoal (1 subgoal):\n 1. ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')", "by(fastforce dest: list_all2_nthD[where p=n'] elim: addr_loc_type.cases intro: addr_loc_type.intros)"], ["proof (state)\nthis:\n  ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ad = a \\<and> (\\<exists>T'. P,h \\<turnstile> ad@al : T')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_external_read_mem_typeable:\n  assumes red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and read: \"ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  shows \"\\<exists>T'. P,h \\<turnstile> ad@al : T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T'. P,h \\<turnstile> ad@al : T'", "using red read"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>T'. P,h \\<turnstile> ad@al : T'", "by cases(fastforce dest: heap_clone_read_typeable intro: addr_loc_type.intros)+"], ["", "end"], ["", "context heap_conf begin"], ["", "lemma heap_clone_typeof_addrD:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"hconf h\"\n  shows \"NewHeapElem a'' x \\<in> set obs \\<Longrightarrow> a'' = a' \\<and> typeof_addr h' a' = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NewHeapElem a'' x \\<in> set obs \\<Longrightarrow>\n    a'' = a' \\<and> typeof_addr h' a' = \\<lfloor>x\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. NewHeapElem a'' x \\<in> set obs \\<Longrightarrow>\n    a'' = a' \\<and> typeof_addr h' a' = \\<lfloor>x\\<rfloor>", "by(fastforce elim!: heap_clone.cases dest: allocate_SomeD hext_heap_copies heap_copies_not_New typeof_addr_is_type elim: hext_objD hext_arrD)"], ["", "lemma red_external_New_typeof_addrD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; hconf h \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     hconf h\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>x\\<rfloor>", "by(erule red_external.cases)(auto dest: heap_clone_typeof_addrD)"], ["", "lemma red_external_aggr_New_typeof_addrD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     is_native P (the (typeof_addr h a)) M; hconf h \\<rbrakk>\n  \\<Longrightarrow> typeof_addr h' a' = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     is_native P (the (typeof_addr h a)) M; hconf h\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>x\\<rfloor>", "apply(auto simp add: is_native.simps external_WT_defs.simps red_external_aggr_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>obs a'a.\n       \\<lbrakk>NewHeapElem a' x \\<in> set obs; hconf h;\n        P \\<turnstile> class_type_of\n                        (the (typeof_addr h\n                               a)) sees clone: []\\<rightarrow>Class\n                         Object = Native in Object;\n        M = clone; ta = (K$ [], [], [], [], [], obs);\n        va = RetVal (Addr a'a);\n        heap_clone P h a h' \\<lfloor>(obs, a'a)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> typeof_addr h' a' = \\<lfloor>x\\<rfloor>", "apply(blast dest: heap_clone_typeof_addrD)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context heap_conf begin"], ["", "lemma heap_copy_loc_non_speculative_typeable:\n  assumes copy: \"heap_copy_loc ad ad' al h obs h'\"\n  and sc: \"non_speculative P vs (llist_of (map NormalAction obs))\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  and wt: \"P,h \\<turnstile> ad@al : T\" \"P,h \\<turnstile> ad'@al : T\"\n  shows \"heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs\n     h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs\n     h'", "from copy"], ["proof (chain)\npicking this:\n  heap_copy_loc ad ad' al h obs h'", "obtain v where obs: \"obs = [ReadMem ad al v, WriteMem ad' al v]\"\n    and read: \"heap_read h ad al v\" and \"write\": \"heap_write h ad' al v h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc ad ad' al h obs h'\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>obs = [ReadMem ad al v, WriteMem ad' al v];\n         heap_read h ad al v; heap_write h ad' al v h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  obs = [ReadMem ad al v, WriteMem ad' al v]\n  heap_read h ad al v\n  heap_write h ad' al v h'\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs\n     h'", "from obs sc"], ["proof (chain)\npicking this:\n  obs = [ReadMem ad al v, WriteMem ad' al v]\n  non_speculative P vs (llist_of (map NormalAction obs))", "have \"v \\<in> vs (ad, al)\""], ["proof (prove)\nusing this:\n  obs = [ReadMem ad al v, WriteMem ad' al v]\n  non_speculative P vs (llist_of (map NormalAction obs))\n\ngoal (1 subgoal):\n 1. v \\<in> vs (ad, al)", "by auto"], ["proof (state)\nthis:\n  v \\<in> vs (ad, al)\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs\n     h'", "with vs wt"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  v \\<in> vs (ad, al)", "have v: \"P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  v \\<in> vs (ad, al)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> T", "by(blast dest: vs_confD addr_loc_type_fun)+"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs\n     h'", "with read wt"], ["proof (chain)\npicking this:\n  heap_read h ad al v\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  P,h \\<turnstile> v :\\<le> T", "have \"heap_read_typed P h ad al v\""], ["proof (prove)\nusing this:\n  heap_read h ad al v\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. heap_read_typed P h ad al v", "by(auto intro: heap_read_typedI dest: addr_loc_type_fun)"], ["proof (state)\nthis:\n  heap_read_typed P h ad al v\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs\n     h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  heap_read_typed P h ad al v\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs\n     h'", "using \"write\""], ["proof (prove)\nusing this:\n  heap_read_typed P h ad al v\n  heap_write h ad' al v h'\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs\n     h'", "unfolding obs"], ["proof (prove)\nusing this:\n  heap_read_typed P h ad al v\n  heap_write h ad' al v h'\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h\n     [ReadMem ad al v, WriteMem ad' al v] h'", "by(rule heap_base.heap_copy_loc.intros)"], ["proof (state)\nthis:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h obs h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_copy_loc_non_speculative_vs_conf:\n  assumes copy: \"heap_copy_loc ad ad' al h obs h'\"\n  and sc: \"non_speculative P vs (llist_of (take n (map NormalAction obs)))\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  and wt: \"P,h \\<turnstile> ad@al : T\" \"P,h \\<turnstile> ad'@al : T\"\n  shows \"vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "from copy"], ["proof (chain)\npicking this:\n  heap_copy_loc ad ad' al h obs h'", "obtain v where obs: \"obs = [ReadMem ad al v, WriteMem ad' al v]\"\n    and read: \"heap_read h ad al v\" and \"write\": \"heap_write h ad' al v h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc ad ad' al h obs h'\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>obs = [ReadMem ad al v, WriteMem ad' al v];\n         heap_read h ad al v; heap_write h ad' al v h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  obs = [ReadMem ad al v, WriteMem ad' al v]\n  heap_read h ad al v\n  heap_write h ad' al v h'\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "from \"write\""], ["proof (chain)\npicking this:\n  heap_write h ad' al v h'", "have hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_write h ad' al v h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_write)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with vs"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  h \\<unlhd> h'", "have vs': \"vs_conf P h' vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. vs_conf P h' vs", "by(rule vs_conf_hext)"], ["proof (state)\nthis:\n  vs_conf P h' vs\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "proof(cases \"n > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "case True"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with obs sc"], ["proof (chain)\npicking this:\n  obs = [ReadMem ad al v, WriteMem ad' al v]\n  non_speculative P vs (llist_of (take n (map NormalAction obs)))\n  0 < n", "have \"v \\<in> vs (ad, al)\""], ["proof (prove)\nusing this:\n  obs = [ReadMem ad al v, WriteMem ad' al v]\n  non_speculative P vs (llist_of (take n (map NormalAction obs)))\n  0 < n\n\ngoal (1 subgoal):\n 1. v \\<in> vs (ad, al)", "by(auto simp add: take_Cons')"], ["proof (state)\nthis:\n  v \\<in> vs (ad, al)\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with vs wt"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  v \\<in> vs (ad, al)", "have v: \"P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  v \\<in> vs (ad, al)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> T", "by(blast dest: vs_confD addr_loc_type_fun)+"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with hext wt"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  P,h \\<turnstile> v :\\<le> T", "have \"P,h' \\<turnstile> ad'@al : T\" \"P,h' \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  P,h \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. P,h' \\<turnstile> ad'@al : T &&& P,h' \\<turnstile> v :\\<le> T", "by(blast intro: addr_loc_type_hext_mono conf_hext)+"], ["proof (state)\nthis:\n  P,h' \\<turnstile> ad'@al : T\n  P,h' \\<turnstile> v :\\<le> T\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,h' \\<turnstile> ad'@al : T\n  P,h' \\<turnstile> v :\\<le> T\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "using vs' obs"], ["proof (prove)\nusing this:\n  P,h' \\<turnstile> ad'@al : T\n  P,h' \\<turnstile> v :\\<le> T\n  vs_conf P h' vs\n  obs = [ReadMem ad al v, WriteMem ad' al v]\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "by(auto simp add: take_Cons' intro!: vs_confI split: if_split_asm dest: vs_confD)"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "using vs'"], ["proof (prove)\nusing this:\n  \\<not> 0 < n\n  vs_conf P h' vs\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "by simp"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_copies_non_speculative_typeable:\n  assumes \"heap_copies ad ad' als h obs h'\"\n  and \"non_speculative P vs (llist_of (map NormalAction obs))\"\n  and \"vs_conf P h vs\"\n  and \"hconf h\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad@al : T) als Ts\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad'@al : T) als Ts\"\n  shows \"heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h obs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h obs h'", "using assms"], ["proof (prove)\nusing this:\n  heap_copies ad ad' als h obs h'\n  non_speculative P vs (llist_of (map NormalAction obs))\n  vs_conf P h vs\n  hconf h\n  list_all2 (addr_loc_type P h ad) als Ts\n  list_all2 (addr_loc_type P h ad') als Ts\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h obs h'", "proof(induct arbitrary: Ts vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h Ts vs.\n       \\<lbrakk>non_speculative P vs (llist_of (map NormalAction []));\n        vs_conf P h vs; hconf h; list_all2 (addr_loc_type P h ad) [] Ts;\n        list_all2 (addr_loc_type P h ad') [] Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' [] h [] h\n 2. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "case Nil"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (map NormalAction []))\n  vs_conf P h_ vs\n  hconf h_\n  list_all2 (addr_loc_type P h_ ad) [] Ts\n  list_all2 (addr_loc_type P h_ ad') [] Ts\n\ngoal (2 subgoals):\n 1. \\<And>h Ts vs.\n       \\<lbrakk>non_speculative P vs (llist_of (map NormalAction []));\n        vs_conf P h vs; hconf h; list_all2 (addr_loc_type P h ad) [] Ts;\n        list_all2 (addr_loc_type P h ad') [] Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' [] h [] h\n 2. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_copies (heap_read_typed P) heap_write ad ad' [] h_ [] h_", "by(auto intro: heap_base.heap_copies.intros)"], ["proof (state)\nthis:\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad' [] h_ [] h_\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "case (Cons al h ob h' als obs h'')"], ["proof (state)\nthis:\n  heap_copy_loc ad ad' al h ob h'\n  heap_copies ad ad' als h' obs h''\n  \\<lbrakk>non_speculative P ?vs17 (llist_of (map NormalAction obs));\n   vs_conf P h' ?vs17; hconf h';\n   list_all2 (addr_loc_type P h' ad) als ?Ts17;\n   list_all2 (addr_loc_type P h' ad') als ?Ts17\\<rbrakk>\n  \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P) heap_write ad\n                     ad' als h' obs h''\n  non_speculative P vs (llist_of (map NormalAction (ob @ obs)))\n  vs_conf P h vs\n  hconf h\n  list_all2 (addr_loc_type P h ad) (al # als) Ts\n  list_all2 (addr_loc_type P h ad') (al # als) Ts\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "note sc = \\<open>non_speculative P vs (llist_of (map NormalAction (ob @ obs)))\\<close>\n    and vs = \\<open>vs_conf P h vs\\<close>\n    and hconf = \\<open>hconf h\\<close>\n    and wt = \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> ad@al : T) (al # als) Ts\\<close> \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> ad'@al : T) (al # als) Ts\\<close>"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (map NormalAction (ob @ obs)))\n  vs_conf P h vs\n  hconf h\n  list_all2 (addr_loc_type P h ad) (al # als) Ts\n  list_all2 (addr_loc_type P h ad') (al # als) Ts\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "have sc1: \"non_speculative P vs (llist_of (map NormalAction ob))\" \n    and sc2: \"non_speculative P (w_values P vs (map NormalAction ob)) (llist_of (map NormalAction obs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_speculative P vs (llist_of (map NormalAction ob)) &&&\n    non_speculative P (w_values P vs (map NormalAction ob))\n     (llist_of (map NormalAction obs))", "using sc"], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (map NormalAction (ob @ obs)))\n\ngoal (1 subgoal):\n 1. non_speculative P vs (llist_of (map NormalAction ob)) &&&\n    non_speculative P (w_values P vs (map NormalAction ob))\n     (llist_of (map NormalAction obs))", "by(simp_all add: non_speculative_lappend lappend_llist_of_llist_of[symmetric] del: lappend_llist_of_llist_of)"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (map NormalAction ob))\n  non_speculative P (w_values P vs (map NormalAction ob))\n   (llist_of (map NormalAction obs))\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "from wt"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h ad) (al # als) Ts\n  list_all2 (addr_loc_type P h ad') (al # als) Ts", "obtain T Ts' where Ts: \"Ts = T # Ts'\" \n    and wt1: \"P,h \\<turnstile> ad@al : T\" \"P,h \\<turnstile> ad'@al : T\"\n    and wt2: \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad@al : T) als Ts'\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h ad) (al # als) Ts\n  list_all2 (addr_loc_type P h ad') (al # als) Ts\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts'.\n        \\<lbrakk>Ts = T # Ts'; P,h \\<turnstile> ad@al : T;\n         P,h \\<turnstile> ad'@al : T;\n         list_all2 (addr_loc_type P h ad) als Ts';\n         list_all2 (addr_loc_type P h ad') als Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: list_all2_Cons1)"], ["proof (state)\nthis:\n  Ts = T # Ts'\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  list_all2 (addr_loc_type P h ad) als Ts'\n  list_all2 (addr_loc_type P h ad') als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "from \\<open>heap_copy_loc ad ad' al h ob h'\\<close> sc1 vs hconf wt1"], ["proof (chain)\npicking this:\n  heap_copy_loc ad ad' al h ob h'\n  non_speculative P vs (llist_of (map NormalAction ob))\n  vs_conf P h vs\n  hconf h\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T", "have copy: \"heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc ad ad' al h ob h'\n  non_speculative P vs (llist_of (map NormalAction ob))\n  vs_conf P h vs\n  hconf h\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'", "by(rule heap_copy_loc_non_speculative_typeable)+"], ["proof (state)\nthis:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "from heap_copy_loc_non_speculative_vs_conf[OF \\<open>heap_copy_loc ad ad' al h ob h'\\<close> _ vs hconf wt1, of \"length ob\"] sc1"], ["proof (chain)\npicking this:\n  non_speculative P vs\n   (llist_of (take (length ob) (map NormalAction ob))) \\<Longrightarrow>\n  vs_conf P h' (w_values P vs (take (length ob) (map NormalAction ob)))\n  non_speculative P vs (llist_of (map NormalAction ob))", "have vs': \"vs_conf P h' (w_values P vs (map NormalAction ob))\""], ["proof (prove)\nusing this:\n  non_speculative P vs\n   (llist_of (take (length ob) (map NormalAction ob))) \\<Longrightarrow>\n  vs_conf P h' (w_values P vs (take (length ob) (map NormalAction ob)))\n  non_speculative P vs (llist_of (map NormalAction ob))\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (map NormalAction ob))", "by simp"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (map NormalAction ob))\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "from \\<open>heap_copy_loc ad ad' al h ob h'\\<close>"], ["proof (chain)\npicking this:\n  heap_copy_loc ad ad' al h ob h'", "have \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc ad ad' al h ob h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_copy_loc)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "with wt2"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h ad) als Ts'\n  list_all2 (addr_loc_type P h ad') als Ts'\n  h \\<unlhd> h'", "have wt2': \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> ad@al : T) als Ts'\" \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> ad'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h ad) als Ts'\n  list_all2 (addr_loc_type P h ad') als Ts'\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' ad) als Ts' &&&\n    list_all2 (addr_loc_type P h' ad') als Ts'", "by -(erule List.list_all2_mono[OF _ addr_loc_type_hext_mono], assumption+)+"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' ad) als Ts'\n  list_all2 (addr_loc_type P h' ad') als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "from copy hconf wt1"], ["proof (chain)\npicking this:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\n  hconf h\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T", "have hconf': \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\n  hconf h\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule heap_conf_read.hconf_heap_copy_loc_mono[OF heap_conf_read_heap_read_typed])"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "from sc2 vs' hconf' wt2'"], ["proof (chain)\npicking this:\n  non_speculative P (w_values P vs (map NormalAction ob))\n   (llist_of (map NormalAction obs))\n  vs_conf P h' (w_values P vs (map NormalAction ob))\n  hconf h'\n  list_all2 (addr_loc_type P h' ad) als Ts'\n  list_all2 (addr_loc_type P h' ad') als Ts'", "have \"heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h' obs h''\""], ["proof (prove)\nusing this:\n  non_speculative P (w_values P vs (map NormalAction ob))\n   (llist_of (map NormalAction obs))\n  vs_conf P h' (w_values P vs (map NormalAction ob))\n  hconf h'\n  list_all2 (addr_loc_type P h' ad) als Ts'\n  list_all2 (addr_loc_type P h' ad') als Ts'\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h' obs\n     h''", "by(rule Cons)"], ["proof (state)\nthis:\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h' obs h''\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs.\n           \\<lbrakk>non_speculative P vs (llist_of (map NormalAction obs));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                              heap_write ad ad' als h' obs h'';\n        non_speculative P vs (llist_of (map NormalAction (ob @ obs)));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_copies (heap_read_typed P)\n                          heap_write ad ad' (al # als) h (ob @ obs) h''", "with copy"], ["proof (chain)\npicking this:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h' obs h''", "show ?case"], ["proof (prove)\nusing this:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad' als h' obs h''\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies (heap_read_typed P) heap_write ad ad' (al # als) h\n     (ob @ obs) h''", "by(rule heap_base.heap_copies.Cons)"], ["proof (state)\nthis:\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad' (al # als) h\n   (ob @ obs) h''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_copies_non_speculative_vs_conf:\n  assumes \"heap_copies ad ad' als h obs h'\"\n  and \"non_speculative P vs (llist_of (take n (map NormalAction obs)))\"\n  and \"vs_conf P h vs\"\n  and \"hconf h\"\n  and \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad@al : T) als Ts\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad'@al : T) als Ts\"\n  shows \"vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "using assms"], ["proof (prove)\nusing this:\n  heap_copies ad ad' als h obs h'\n  non_speculative P vs (llist_of (take n (map NormalAction obs)))\n  vs_conf P h vs\n  hconf h\n  list_all2 (addr_loc_type P h ad) als Ts\n  list_all2 (addr_loc_type P h ad') als Ts\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "proof(induction arbitrary: Ts vs n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h Ts vs n.\n       \\<lbrakk>non_speculative P vs\n                 (llist_of (take n (map NormalAction [])));\n        vs_conf P h vs; hconf h; list_all2 (addr_loc_type P h ad) [] Ts;\n        list_all2 (addr_loc_type P h ad') [] Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h\n                          (w_values P vs (take n (map NormalAction [])))\n 2. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "case Nil"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (take n (map NormalAction [])))\n  vs_conf P h_ vs\n  hconf h_\n  list_all2 (addr_loc_type P h_ ad) [] Ts\n  list_all2 (addr_loc_type P h_ ad') [] Ts\n\ngoal (2 subgoals):\n 1. \\<And>h Ts vs n.\n       \\<lbrakk>non_speculative P vs\n                 (llist_of (take n (map NormalAction [])));\n        vs_conf P h vs; hconf h; list_all2 (addr_loc_type P h ad) [] Ts;\n        list_all2 (addr_loc_type P h ad') [] Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h\n                          (w_values P vs (take n (map NormalAction [])))\n 2. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "thus ?case"], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (take n (map NormalAction [])))\n  vs_conf P h_ vs\n  hconf h_\n  list_all2 (addr_loc_type P h_ ad) [] Ts\n  list_all2 (addr_loc_type P h_ ad') [] Ts\n\ngoal (1 subgoal):\n 1. vs_conf P h_ (w_values P vs (take n (map NormalAction [])))", "by simp"], ["proof (state)\nthis:\n  vs_conf P h_ (w_values P vs (take n (map NormalAction [])))\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "case (Cons al h ob h' als obs h'')"], ["proof (state)\nthis:\n  heap_copy_loc ad ad' al h ob h'\n  heap_copies ad ad' als h' obs h''\n  \\<lbrakk>non_speculative P ?vs17\n            (llist_of (take ?n17 (map NormalAction obs)));\n   vs_conf P h' ?vs17; hconf h';\n   list_all2 (addr_loc_type P h' ad) als ?Ts17;\n   list_all2 (addr_loc_type P h' ad') als ?Ts17\\<rbrakk>\n  \\<Longrightarrow> vs_conf P h''\n                     (w_values P ?vs17 (take ?n17 (map NormalAction obs)))\n  non_speculative P vs (llist_of (take n (map NormalAction (ob @ obs))))\n  vs_conf P h vs\n  hconf h\n  list_all2 (addr_loc_type P h ad) (al # als) Ts\n  list_all2 (addr_loc_type P h ad') (al # als) Ts\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "note sc = \\<open>non_speculative P vs (llist_of (take n (map NormalAction (ob @ obs))))\\<close>\n    and hcl = \\<open>heap_copy_loc ad ad' al h ob h'\\<close>\n    and vs = \\<open>vs_conf P h vs\\<close>\n    and hconf = \\<open>hconf h\\<close>\n    and wt = \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> ad@al : T) (al # als) Ts\\<close> \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> ad'@al : T) (al # als) Ts\\<close>"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (take n (map NormalAction (ob @ obs))))\n  heap_copy_loc ad ad' al h ob h'\n  vs_conf P h vs\n  hconf h\n  list_all2 (addr_loc_type P h ad) (al # als) Ts\n  list_all2 (addr_loc_type P h ad') (al # als) Ts\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "let ?vs' = \"w_values P vs (take n (map NormalAction ob))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "from sc"], ["proof (chain)\npicking this:\n  non_speculative P vs (llist_of (take n (map NormalAction (ob @ obs))))", "have sc1: \"non_speculative P vs (llist_of (take n (map NormalAction ob)))\"\n    and sc2: \"non_speculative P ?vs' (llist_of (take (n - length ob) (map NormalAction obs)))\""], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (take n (map NormalAction (ob @ obs))))\n\ngoal (1 subgoal):\n 1. non_speculative P vs (llist_of (take n (map NormalAction ob))) &&&\n    non_speculative P (w_values P vs (take n (map NormalAction ob)))\n     (llist_of (take (n - length ob) (map NormalAction obs)))", "by(simp_all add: lappend_llist_of_llist_of[symmetric] non_speculative_lappend del: lappend_llist_of_llist_of)"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (take n (map NormalAction ob)))\n  non_speculative P (w_values P vs (take n (map NormalAction ob)))\n   (llist_of (take (n - length ob) (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "from wt"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h ad) (al # als) Ts\n  list_all2 (addr_loc_type P h ad') (al # als) Ts", "obtain T Ts' where Ts: \"Ts = T # Ts'\" \n    and wt1: \"P,h \\<turnstile> ad@al : T\" \"P,h \\<turnstile> ad'@al : T\"\n    and wt2: \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad@al : T) als Ts'\" \"list_all2 (\\<lambda>al T. P,h \\<turnstile> ad'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h ad) (al # als) Ts\n  list_all2 (addr_loc_type P h ad') (al # als) Ts\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts'.\n        \\<lbrakk>Ts = T # Ts'; P,h \\<turnstile> ad@al : T;\n         P,h \\<turnstile> ad'@al : T;\n         list_all2 (addr_loc_type P h ad) als Ts';\n         list_all2 (addr_loc_type P h ad') als Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: list_all2_Cons1)"], ["proof (state)\nthis:\n  Ts = T # Ts'\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n  list_all2 (addr_loc_type P h ad) als Ts'\n  list_all2 (addr_loc_type P h ad') als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "from hcl sc1 vs hconf wt1"], ["proof (chain)\npicking this:\n  heap_copy_loc ad ad' al h ob h'\n  non_speculative P vs (llist_of (take n (map NormalAction ob)))\n  vs_conf P h vs\n  hconf h\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T", "have vs': \"vs_conf P h' ?vs'\""], ["proof (prove)\nusing this:\n  heap_copy_loc ad ad' al h ob h'\n  non_speculative P vs (llist_of (take n (map NormalAction ob)))\n  vs_conf P h vs\n  hconf h\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction ob)))", "by(rule heap_copy_loc_non_speculative_vs_conf)"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction ob)))\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs n.\n       \\<lbrakk>heap_copy_loc ad ad' al h ob h';\n        heap_copies ad ad' als h' obs h'';\n        \\<And>Ts vs n.\n           \\<lbrakk>non_speculative P vs\n                     (llist_of (take n (map NormalAction obs)));\n            vs_conf P h' vs; hconf h';\n            list_all2 (addr_loc_type P h' ad) als Ts;\n            list_all2 (addr_loc_type P h' ad') als Ts\\<rbrakk>\n           \\<Longrightarrow> vs_conf P h''\n                              (w_values P vs\n                                (take n (map NormalAction obs)));\n        non_speculative P vs\n         (llist_of (take n (map NormalAction (ob @ obs))));\n        vs_conf P h vs; hconf h;\n        list_all2 (addr_loc_type P h ad) (al # als) Ts;\n        list_all2 (addr_loc_type P h ad') (al # als) Ts\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h''\n                          (w_values P vs\n                            (take n (map NormalAction (ob @ obs))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "proof(cases \"n < length ob\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))\n 2. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "case True"], ["proof (state)\nthis:\n  n < length ob\n\ngoal (2 subgoals):\n 1. n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))\n 2. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "from \\<open>heap_copies ad ad' als h' obs h''\\<close>"], ["proof (chain)\npicking this:\n  heap_copies ad ad' als h' obs h''", "have \"h' \\<unlhd> h''\""], ["proof (prove)\nusing this:\n  heap_copies ad ad' als h' obs h''\n\ngoal (1 subgoal):\n 1. h' \\<unlhd> h''", "by(rule hext_heap_copies)"], ["proof (state)\nthis:\n  h' \\<unlhd> h''\n\ngoal (2 subgoals):\n 1. n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))\n 2. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "with vs'"], ["proof (chain)\npicking this:\n  vs_conf P h' (w_values P vs (take n (map NormalAction ob)))\n  h' \\<unlhd> h''", "have \"vs_conf P h'' ?vs'\""], ["proof (prove)\nusing this:\n  vs_conf P h' (w_values P vs (take n (map NormalAction ob)))\n  h' \\<unlhd> h''\n\ngoal (1 subgoal):\n 1. vs_conf P h'' (w_values P vs (take n (map NormalAction ob)))", "by(rule vs_conf_hext)"], ["proof (state)\nthis:\n  vs_conf P h'' (w_values P vs (take n (map NormalAction ob)))\n\ngoal (2 subgoals):\n 1. n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))\n 2. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  vs_conf P h'' (w_values P vs (take n (map NormalAction ob)))\n\ngoal (1 subgoal):\n 1. vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "using True"], ["proof (prove)\nusing this:\n  vs_conf P h'' (w_values P vs (take n (map NormalAction ob)))\n  n < length ob\n\ngoal (1 subgoal):\n 1. vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "by simp"], ["proof (state)\nthis:\n  vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "case False"], ["proof (state)\nthis:\n  \\<not> n < length ob\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "note sc2 vs'"], ["proof (state)\nthis:\n  non_speculative P (w_values P vs (take n (map NormalAction ob)))\n   (llist_of (take (n - length ob) (map NormalAction obs)))\n  vs_conf P h' (w_values P vs (take n (map NormalAction ob)))\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "moreover"], ["proof (state)\nthis:\n  non_speculative P (w_values P vs (take n (map NormalAction ob)))\n   (llist_of (take (n - length ob) (map NormalAction obs)))\n  vs_conf P h' (w_values P vs (take n (map NormalAction ob)))\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "from False sc1"], ["proof (chain)\npicking this:\n  \\<not> n < length ob\n  non_speculative P vs (llist_of (take n (map NormalAction ob)))", "have sc1': \"non_speculative P vs (llist_of (map NormalAction ob))\""], ["proof (prove)\nusing this:\n  \\<not> n < length ob\n  non_speculative P vs (llist_of (take n (map NormalAction ob)))\n\ngoal (1 subgoal):\n 1. non_speculative P vs (llist_of (map NormalAction ob))", "by simp"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (map NormalAction ob))\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "with hcl"], ["proof (chain)\npicking this:\n  heap_copy_loc ad ad' al h ob h'\n  non_speculative P vs (llist_of (map NormalAction ob))", "have \"heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc ad ad' al h ob h'\n  non_speculative P vs (llist_of (map NormalAction ob))\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'", "using vs hconf wt1"], ["proof (prove)\nusing this:\n  heap_copy_loc ad ad' al h ob h'\n  non_speculative P vs (llist_of (map NormalAction ob))\n  vs_conf P h vs\n  hconf h\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n\ngoal (1 subgoal):\n 1. heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'", "by(rule heap_copy_loc_non_speculative_typeable)"], ["proof (state)\nthis:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "hence \"hconf h'\""], ["proof (prove)\nusing this:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\n\ngoal (1 subgoal):\n 1. hconf h'", "using hconf wt1"], ["proof (prove)\nusing this:\n  heap_base.heap_copy_loc (heap_read_typed P) heap_write ad ad' al h ob h'\n  hconf h\n  P,h \\<turnstile> ad@al : T\n  P,h \\<turnstile> ad'@al : T\n\ngoal (1 subgoal):\n 1. hconf h'", "by(rule heap_conf_read.hconf_heap_copy_loc_mono[OF heap_conf_read_heap_read_typed])"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "moreover"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "from hcl"], ["proof (chain)\npicking this:\n  heap_copy_loc ad ad' al h ob h'", "have \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc ad ad' al h ob h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_copy_loc)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "with wt2"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h ad) als Ts'\n  list_all2 (addr_loc_type P h ad') als Ts'\n  h \\<unlhd> h'", "have wt2': \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> ad@al : T) als Ts'\" \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> ad'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h ad) als Ts'\n  list_all2 (addr_loc_type P h ad') als Ts'\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' ad) als Ts' &&&\n    list_all2 (addr_loc_type P h' ad') als Ts'", "by -(erule List.list_all2_mono[OF _ addr_loc_type_hext_mono], assumption+)+"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' ad) als Ts'\n  list_all2 (addr_loc_type P h' ad') als Ts'\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "ultimately"], ["proof (chain)\npicking this:\n  non_speculative P (w_values P vs (take n (map NormalAction ob)))\n   (llist_of (take (n - length ob) (map NormalAction obs)))\n  vs_conf P h' (w_values P vs (take n (map NormalAction ob)))\n  hconf h'\n  list_all2 (addr_loc_type P h' ad) als Ts'\n  list_all2 (addr_loc_type P h' ad') als Ts'", "have \"vs_conf P h'' (w_values P ?vs' (take (n - length ob) (map NormalAction obs)))\""], ["proof (prove)\nusing this:\n  non_speculative P (w_values P vs (take n (map NormalAction ob)))\n   (llist_of (take (n - length ob) (map NormalAction obs)))\n  vs_conf P h' (w_values P vs (take n (map NormalAction ob)))\n  hconf h'\n  list_all2 (addr_loc_type P h' ad) als Ts'\n  list_all2 (addr_loc_type P h' ad') als Ts'\n\ngoal (1 subgoal):\n 1. vs_conf P h''\n     (w_values P (w_values P vs (take n (map NormalAction ob)))\n       (take (n - length ob) (map NormalAction obs)))", "by(rule Cons.IH)"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_values P (w_values P vs (take n (map NormalAction ob)))\n     (take (n - length ob) (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. \\<not> n < length ob \\<Longrightarrow>\n    vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "with False"], ["proof (chain)\npicking this:\n  \\<not> n < length ob\n  vs_conf P h''\n   (w_values P (w_values P vs (take n (map NormalAction ob)))\n     (take (n - length ob) (map NormalAction obs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n < length ob\n  vs_conf P h''\n   (w_values P (w_values P vs (take n (map NormalAction ob)))\n     (take (n - length ob) (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))", "by simp"], ["proof (state)\nthis:\n  vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vs_conf P h'' (w_values P vs (take n (map NormalAction (ob @ obs))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_clone_non_speculative_typeable_Some:\n  assumes clone: \"heap_clone P h ad h' \\<lfloor>(obs, ad')\\<rfloor>\"\n  and sc: \"non_speculative P vs (llist_of (map NormalAction obs))\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  shows \"heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write P h ad h' \\<lfloor>(obs, ad')\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write\n     P h ad h' \\<lfloor>(obs, ad')\\<rfloor>", "using clone"], ["proof (prove)\nusing this:\n  heap_clone P h ad h' \\<lfloor>(obs, ad')\\<rfloor>\n\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write\n     P h ad h' \\<lfloor>(obs, ad')\\<rfloor>", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "case (ObjClone C h'' FDTs obs')"], ["proof (state)\nthis:\n  obs = NewHeapElem ad' (Class_type C) # obs'\n  typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\n  (h'', ad') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "note FDTs = \\<open>P \\<turnstile> C has_fields FDTs\\<close>\n    and obs = \\<open>obs = NewHeapElem ad' (Class_type C) # obs'\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n  obs = NewHeapElem ad' (Class_type C) # obs'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "let ?vs = \"w_value P vs (NormalAction (NewHeapElem ad' (Class_type C) :: ('addr, 'thread_id) obs_event))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Class_type C)", "have hext: \"h \\<unlhd> h''\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h''", "by(rule hext_heap_ops)"], ["proof (state)\nthis:\n  h \\<unlhd> h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "hence type: \"typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>", "using \\<open>typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\\<close>"], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "note \\<open>heap_copies ad ad' ?als h'' obs' h'\\<close>"], ["proof (state)\nthis:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from sc"], ["proof (chain)\npicking this:\n  non_speculative P vs (llist_of (map NormalAction obs))", "have \"non_speculative P ?vs (llist_of (map NormalAction obs'))\""], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (map NormalAction obs))\n\ngoal (1 subgoal):\n 1. non_speculative P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n     (llist_of (map NormalAction obs'))", "by(simp add: obs)"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n   (llist_of (map NormalAction obs'))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n   (llist_of (map NormalAction obs'))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from \\<open>P \\<turnstile> C has_fields FDTs\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs", "have \"is_class P C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. is_class P C", "by(rule has_fields_is_class)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "hence \"is_htype P (Class_type C)\""], ["proof (prove)\nusing this:\n  is_class P C\n\ngoal (1 subgoal):\n 1. is_htype P (Class_type C)", "by simp"], ["proof (state)\nthis:\n  is_htype P (Class_type C)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "with vs \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  (h'', ad') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)", "have \"vs_conf P h'' ?vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  (h'', ad') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)\n\ngoal (1 subgoal):\n 1. vs_conf P h''\n     (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))", "by(rule vs_conf_allocate)"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close> hconf \\<open>is_htype P (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n  hconf h\n  is_htype P (Class_type C)", "have \"hconf h''\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n  hconf h\n  is_htype P (Class_type C)\n\ngoal (1 subgoal):\n 1. hconf h''", "by(rule hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from type FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> ad@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h'' \\<turnstile> ad@(case x of\n                              (x, xa) \\<Rightarrow>\n                                (case x of\n                                 (F, D) \\<Rightarrow>\n                                   \\<lambda>Tfm. CField D F)\n                                 xa) : (case x of\n  (FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close> \\<open>is_htype P (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)", "have \"typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "with FDTs"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> ad'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h'' \\<turnstile> ad'@(case x of\n                               (x, xa) \\<Rightarrow>\n                                 (case x of\n                                  (F, D) \\<Rightarrow>\n                                    \\<lambda>Tfm. CField D F)\n                                  xa) : (case x of\n   (FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n   (llist_of (map NormalAction obs'))\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n  hconf h''\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "have copy: \"heap_base.heap_copies (heap_read_typed P) heap_write ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs' h'\""], ["proof (prove)\nusing this:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n   (llist_of (map NormalAction obs'))\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n  hconf h''\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs' h'", "by(rule heap_copies_non_speculative_typeable)+"], ["proof (state)\nthis:\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from \\<open>typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\\<close> \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close> FDTs copy"], ["proof (chain)\npicking this:\n  typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\n  (h'', ad') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs' h'", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\n  (h'', ad') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs' h'\n\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write\n     P h ad h' \\<lfloor>(obs, ad')\\<rfloor>", "unfolding obs"], ["proof (prove)\nusing this:\n  typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\n  (h'', ad') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs' h'\n\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write\n     P h ad h'\n     \\<lfloor>(NewHeapElem ad' (Class_type C) # obs', ad')\\<rfloor>", "by(rule heap_base.heap_clone.intros)"], ["proof (state)\nthis:\n  heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write P\n   h ad h' \\<lfloor>(obs, ad')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "case (ArrClone T n h'' FDTs obs')"], ["proof (state)\nthis:\n  obs = NewHeapElem ad' (Array_type T n) # obs'\n  typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "note obs = \\<open>obs = NewHeapElem ad' (Array_type T n) # obs'\\<close>\n    and new = \\<open>(h'', ad') \\<in> allocate h (Array_type T n)\\<close>\n    and FDTs = \\<open>P \\<turnstile> Object has_fields FDTs\\<close>"], ["proof (state)\nthis:\n  obs = NewHeapElem ad' (Array_type T n) # obs'\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "let ?vs = \"w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n) :: ('addr, 'thread_id) obs_event))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from new"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Array_type T n)", "have hext: \"h \\<unlhd> h''\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Array_type T n)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h''", "by(rule hext_heap_ops)"], ["proof (state)\nthis:\n  h \\<unlhd> h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "hence type: \"typeof_addr h'' ad = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad = \\<lfloor>Array_type T n\\<rfloor>", "using \\<open>typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\\<close>"], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad = \\<lfloor>Array_type T n\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h'' ad = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "note \\<open>heap_copies ad ad' ?als h'' obs' h'\\<close>"], ["proof (state)\nthis:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from sc"], ["proof (chain)\npicking this:\n  non_speculative P vs (llist_of (map NormalAction obs))", "have \"non_speculative P ?vs (llist_of (map NormalAction obs'))\""], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (map NormalAction obs))\n\ngoal (1 subgoal):\n 1. non_speculative P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n     (llist_of (map NormalAction obs'))", "by(simp add: obs)"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n   (llist_of (map NormalAction obs'))\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n   (llist_of (map NormalAction obs'))\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from \\<open>typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\\<close> \\<open>hconf h\\<close>"], ["proof (chain)\npicking this:\n  typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\n  hconf h", "have \"is_htype P (Array_type T n)\""], ["proof (prove)\nusing this:\n  typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. is_htype P (Array_type T n)", "by(auto dest: typeof_addr_is_type)"], ["proof (state)\nthis:\n  is_htype P (Array_type T n)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "with vs new"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  is_htype P (Array_type T n)", "have \"vs_conf P h'' ?vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  is_htype P (Array_type T n)\n\ngoal (1 subgoal):\n 1. vs_conf P h''\n     (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))", "by(rule vs_conf_allocate)"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from new hconf \\<open>is_htype P (Array_type T n)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  hconf h\n  is_htype P (Array_type T n)", "have \"hconf h''\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  hconf h\n  is_htype P (Array_type T n)\n\ngoal (1 subgoal):\n 1. hconf h''", "by(rule hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from type FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h'' ad = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> ad@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' ad = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from new \\<open>is_htype P (Array_type T n)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  is_htype P (Array_type T n)", "have \"typeof_addr h'' ad' = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  is_htype P (Array_type T n)\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad' = \\<lfloor>Array_type T n\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h'' ad' = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "hence \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> ad'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' ad' = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "using FDTs"], ["proof (prove)\nusing this:\n  typeof_addr h'' ad' = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n   (llist_of (map NormalAction obs'))\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n  hconf h''\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)", "have copy: \"heap_base.heap_copies (heap_read_typed P) heap_write ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h'' obs' h'\""], ["proof (prove)\nusing this:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n   (llist_of (map NormalAction obs'))\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T n))))\n  hconf h''\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n     obs' h'", "by(rule heap_copies_non_speculative_typeable)+"], ["proof (state)\nthis:\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T n) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> heap_base.heap_clone allocate typeof_addr\n                          (heap_read_typed P) heap_write P h ad h'\n                          \\<lfloor>(obs, ad')\\<rfloor>", "from \\<open>typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\\<close> new FDTs copy"], ["proof (chain)\npicking this:\n  typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'", "show ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write\n     P h ad h' \\<lfloor>(obs, ad')\\<rfloor>", "unfolding obs"], ["proof (prove)\nusing this:\n  typeof_addr h ad = \\<lfloor>Array_type T n\\<rfloor>\n  (h'', ad') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_base.heap_copies (heap_read_typed P) heap_write ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write\n     P h ad h'\n     \\<lfloor>(NewHeapElem ad' (Array_type T n) # obs', ad')\\<rfloor>", "by(rule heap_base.heap_clone.ArrClone)"], ["proof (state)\nthis:\n  heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write P\n   h ad h' \\<lfloor>(obs, ad')\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_clone_non_speculative_vs_conf_Some:\n  assumes clone: \"heap_clone P h ad h' \\<lfloor>(obs, ad')\\<rfloor>\"\n  and sc: \"non_speculative P vs (llist_of (take n (map NormalAction obs)))\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  shows \"vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "using clone"], ["proof (prove)\nusing this:\n  heap_clone P h ad h' \\<lfloor>(obs, ad')\\<rfloor>\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "case (ObjClone C h'' FDTs obs')"], ["proof (state)\nthis:\n  obs = NewHeapElem ad' (Class_type C) # obs'\n  typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\n  (h'', ad') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "note FDTs = \\<open>P \\<turnstile> C has_fields FDTs\\<close>\n    and obs = \\<open>obs = NewHeapElem ad' (Class_type C) # obs'\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n  obs = NewHeapElem ad' (Class_type C) # obs'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "let ?vs = \"w_value P vs (NormalAction (NewHeapElem ad' (Class_type C) :: ('addr, 'thread_id) obs_event))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Class_type C)", "have hext: \"h \\<unlhd> h''\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h''", "by(rule hext_heap_ops)"], ["proof (state)\nthis:\n  h \\<unlhd> h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "hence type: \"typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>", "using \\<open>typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\\<close>"], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "note \\<open>heap_copies ad ad' ?als h'' obs' h'\\<close>"], ["proof (state)\nthis:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from sc"], ["proof (chain)\npicking this:\n  non_speculative P vs (llist_of (take n (map NormalAction obs)))", "have \"non_speculative P ?vs (llist_of (take (n - 1) (map NormalAction obs')))\""], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (take n (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. non_speculative P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n     (llist_of (take (n - 1) (map NormalAction obs')))", "by(simp add: obs take_Cons' split: if_split_asm)"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n   (llist_of (take (n - 1) (map NormalAction obs')))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n   (llist_of (take (n - 1) (map NormalAction obs')))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from \\<open>P \\<turnstile> C has_fields FDTs\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs", "have \"is_class P C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. is_class P C", "by(rule has_fields_is_class)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "hence \"is_htype P (Class_type C)\""], ["proof (prove)\nusing this:\n  is_class P C\n\ngoal (1 subgoal):\n 1. is_htype P (Class_type C)", "by simp"], ["proof (state)\nthis:\n  is_htype P (Class_type C)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "with vs \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  (h'', ad') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)", "have \"vs_conf P h'' ?vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  (h'', ad') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)\n\ngoal (1 subgoal):\n 1. vs_conf P h''\n     (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))", "by(rule vs_conf_allocate)"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close> hconf \\<open>is_htype P (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n  hconf h\n  is_htype P (Class_type C)", "have \"hconf h''\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n  hconf h\n  is_htype P (Class_type C)\n\ngoal (1 subgoal):\n 1. hconf h''", "by(rule hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from type FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> ad@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  typeof_addr h'' ad = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h'' \\<turnstile> ad@(case x of\n                              (x, xa) \\<Rightarrow>\n                                (case x of\n                                 (F, D) \\<Rightarrow>\n                                   \\<lambda>Tfm. CField D F)\n                                 xa) : (case x of\n  (FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from \\<open>(h'', ad') \\<in> allocate h (Class_type C)\\<close> \\<open>is_htype P (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)", "have \"typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "with FDTs"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> ad'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' ad' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h'' \\<turnstile> ad'@(case x of\n                               (x, xa) \\<Rightarrow>\n                                 (case x of\n                                  (F, D) \\<Rightarrow>\n                                    \\<lambda>Tfm. CField D F)\n                                  xa) : (case x of\n   (FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n   (llist_of (take (n - 1) (map NormalAction obs')))\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n  hconf h''\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "have vs': \"vs_conf P h' (w_values P ?vs (take (n - 1) (map NormalAction obs')))\""], ["proof (prove)\nusing this:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n   (llist_of (take (n - 1) (map NormalAction obs')))\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n  hconf h''\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (1 subgoal):\n 1. vs_conf P h'\n     (w_values P\n       (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n       (take (n - 1) (map NormalAction obs')))", "by(rule heap_copies_non_speculative_vs_conf)"], ["proof (state)\nthis:\n  vs_conf P h'\n   (w_values P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n     (take (n - 1) (map NormalAction obs')))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Class_type C) # obsa;\n        typeof_addr h ad = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs)\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))\n 2. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "proof(cases \"n > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "case True"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with obs vs'"], ["proof (chain)\npicking this:\n  obs = NewHeapElem ad' (Class_type C) # obs'\n  vs_conf P h'\n   (w_values P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n     (take (n - 1) (map NormalAction obs')))\n  0 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  obs = NewHeapElem ad' (Class_type C) # obs'\n  vs_conf P h'\n   (w_values P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Class_type C))))\n     (take (n - 1) (map NormalAction obs')))\n  0 < n\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "by(simp add: take_Cons')"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "from \\<open>heap_copies ad ad' ?als h'' obs' h'\\<close>"], ["proof (chain)\npicking this:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'", "have \"h'' \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_copies ad ad' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. h'' \\<unlhd> h'", "by(rule hext_heap_copies)"], ["proof (state)\nthis:\n  h'' \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with \\<open>h \\<unlhd> h''\\<close>"], ["proof (chain)\npicking this:\n  h \\<unlhd> h''\n  h'' \\<unlhd> h'", "have \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  h'' \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_trans)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with vs"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  h \\<unlhd> h'", "have \"vs_conf P h' vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. vs_conf P h' vs", "by(rule vs_conf_hext)"], ["proof (state)\nthis:\n  vs_conf P h' vs\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  vs_conf P h' vs\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "using False"], ["proof (prove)\nusing this:\n  vs_conf P h' vs\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "by simp"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "case (ArrClone T N h'' FDTs obs')"], ["proof (state)\nthis:\n  obs = NewHeapElem ad' (Array_type T N) # obs'\n  typeof_addr h ad = \\<lfloor>Array_type T N\\<rfloor>\n  (h'', ad') \\<in> allocate h (Array_type T N)\n  P \\<turnstile> Object has_fields FDTs\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "note obs = \\<open>obs = NewHeapElem ad' (Array_type T N) # obs'\\<close>\n    and new = \\<open>(h'', ad') \\<in> allocate h (Array_type T N)\\<close>\n    and FDTs = \\<open>P \\<turnstile> Object has_fields FDTs\\<close>"], ["proof (state)\nthis:\n  obs = NewHeapElem ad' (Array_type T N) # obs'\n  (h'', ad') \\<in> allocate h (Array_type T N)\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate N T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "let ?vs = \"w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N) :: ('addr, 'thread_id) obs_event))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from new"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Array_type T N)", "have hext: \"h \\<unlhd> h''\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Array_type T N)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h''", "by(rule hext_heap_ops)"], ["proof (state)\nthis:\n  h \\<unlhd> h''\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "hence type: \"typeof_addr h'' ad = \\<lfloor>Array_type T N\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad = \\<lfloor>Array_type T N\\<rfloor>", "using \\<open>typeof_addr h ad = \\<lfloor>Array_type T N\\<rfloor>\\<close>"], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  typeof_addr h ad = \\<lfloor>Array_type T N\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad = \\<lfloor>Array_type T N\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h'' ad = \\<lfloor>Array_type T N\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "note \\<open>heap_copies ad ad' ?als h'' obs' h'\\<close>"], ["proof (state)\nthis:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from sc"], ["proof (chain)\npicking this:\n  non_speculative P vs (llist_of (take n (map NormalAction obs)))", "have \"non_speculative P ?vs (llist_of (take (n - 1) (map NormalAction obs')))\""], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (take n (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. non_speculative P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n     (llist_of (take (n - 1) (map NormalAction obs')))", "by(simp add: obs take_Cons' split: if_split_asm)"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n   (llist_of (take (n - 1) (map NormalAction obs')))\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n   (llist_of (take (n - 1) (map NormalAction obs')))\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from \\<open>typeof_addr h ad = \\<lfloor>Array_type T N\\<rfloor>\\<close> \\<open>hconf h\\<close>"], ["proof (chain)\npicking this:\n  typeof_addr h ad = \\<lfloor>Array_type T N\\<rfloor>\n  hconf h", "have \"is_htype P (Array_type T N)\""], ["proof (prove)\nusing this:\n  typeof_addr h ad = \\<lfloor>Array_type T N\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. is_htype P (Array_type T N)", "by(auto dest: typeof_addr_is_type)"], ["proof (state)\nthis:\n  is_htype P (Array_type T N)\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "with vs new"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  (h'', ad') \\<in> allocate h (Array_type T N)\n  is_htype P (Array_type T N)", "have \"vs_conf P h'' ?vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  (h'', ad') \\<in> allocate h (Array_type T N)\n  is_htype P (Array_type T N)\n\ngoal (1 subgoal):\n 1. vs_conf P h''\n     (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))", "by(rule vs_conf_allocate)"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from new hconf \\<open>is_htype P (Array_type T N)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Array_type T N)\n  hconf h\n  is_htype P (Array_type T N)", "have \"hconf h''\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Array_type T N)\n  hconf h\n  is_htype P (Array_type T N)\n\ngoal (1 subgoal):\n 1. hconf h''", "by(rule hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from type FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h'' ad = \\<lfloor>Array_type T N\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> ad@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' ad = \\<lfloor>Array_type T N\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate N T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate N T)\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate N T)\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "from new \\<open>is_htype P (Array_type T N)\\<close>"], ["proof (chain)\npicking this:\n  (h'', ad') \\<in> allocate h (Array_type T N)\n  is_htype P (Array_type T N)", "have \"typeof_addr h'' ad' = \\<lfloor>Array_type T N\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h'', ad') \\<in> allocate h (Array_type T N)\n  is_htype P (Array_type T N)\n\ngoal (1 subgoal):\n 1. typeof_addr h'' ad' = \\<lfloor>Array_type T N\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h'' ad' = \\<lfloor>Array_type T N\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "hence \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> ad'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' ad' = \\<lfloor>Array_type T N\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate N T)", "using FDTs"], ["proof (prove)\nusing this:\n  typeof_addr h'' ad' = \\<lfloor>Array_type T N\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' ad')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate N T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate N T)\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N]) h''\n   obs' h'\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n   (llist_of (take (n - 1) (map NormalAction obs')))\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n  hconf h''\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate N T)\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate N T)", "have vs': \"vs_conf P h' (w_values P ?vs (take (n - 1) (map NormalAction obs')))\""], ["proof (prove)\nusing this:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N]) h''\n   obs' h'\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n   (llist_of (take (n - 1) (map NormalAction obs')))\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n  hconf h''\n  list_all2 (addr_loc_type P h'' ad)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate N T)\n  list_all2 (addr_loc_type P h'' ad')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate N T)\n\ngoal (1 subgoal):\n 1. vs_conf P h'\n     (w_values P\n       (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n       (take (n - 1) (map NormalAction obs')))", "by(rule heap_copies_non_speculative_vs_conf)"], ["proof (state)\nthis:\n  vs_conf P h'\n   (w_values P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n     (take (n - 1) (map NormalAction obs')))\n\ngoal (1 subgoal):\n 1. \\<And>T na h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem ad' (Array_type T na) # obsa;\n        typeof_addr h ad = \\<lfloor>Array_type T na\\<rfloor>;\n        (h'a, ad') \\<in> allocate h (Array_type T na);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies ad ad'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @\n          map ACell [0..<na])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> vs_conf P h'\n                          (w_values P vs (take n (map NormalAction obs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "proof(cases \"n > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "case True"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n 2. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with obs vs'"], ["proof (chain)\npicking this:\n  obs = NewHeapElem ad' (Array_type T N) # obs'\n  vs_conf P h'\n   (w_values P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n     (take (n - 1) (map NormalAction obs')))\n  0 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  obs = NewHeapElem ad' (Array_type T N) # obs'\n  vs_conf P h'\n   (w_values P\n     (w_value P vs (NormalAction (NewHeapElem ad' (Array_type T N))))\n     (take (n - 1) (map NormalAction obs')))\n  0 < n\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "by(simp add: take_Cons')"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "from \\<open>heap_copies ad ad' ?als h'' obs' h'\\<close>"], ["proof (chain)\npicking this:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N]) h''\n   obs' h'", "have \"h'' \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_copies ad ad'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<N]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. h'' \\<unlhd> h'", "by(rule hext_heap_copies)"], ["proof (state)\nthis:\n  h'' \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with \\<open>h \\<unlhd> h''\\<close>"], ["proof (chain)\npicking this:\n  h \\<unlhd> h''\n  h'' \\<unlhd> h'", "have \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  h'' \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_trans)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "with vs"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  h \\<unlhd> h'", "have \"vs_conf P h' vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. vs_conf P h' vs", "by(rule vs_conf_hext)"], ["proof (state)\nthis:\n  vs_conf P h' vs\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  vs_conf P h' vs\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "using False"], ["proof (prove)\nusing this:\n  vs_conf P h' vs\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (take n (map NormalAction obs)))", "by simp"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (take n (map NormalAction obs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_clone_non_speculative_typeable_None:\n  assumes \"heap_clone P h ad h' None\"\n  shows \"heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write P h ad h' None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write\n     P h ad h' None", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h ad h' None\n\ngoal (1 subgoal):\n 1. heap_base.heap_clone allocate typeof_addr (heap_read_typed P) heap_write\n     P h ad h' None", "by(cases)(blast intro: heap_base.heap_clone.intros)+"], ["", "lemma red_external_non_speculative_typeable:\n  assumes red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and sc: \"non_speculative P Vs (llist_of (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\"\n  and vs: \"vs_conf P h Vs\"\n  and hconf: \"hconf h\"\n  shows \"heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr (heap_read_typed P) heap_write P t h a M vs ta va h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups\n     empty_heap allocate typeof_addr (heap_read_typed P) heap_write P t h a\n     M vs ta va h'", "using assms"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  non_speculative P Vs\n   (llist_of (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n  vs_conf P h Vs\n  hconf h\n\ngoal (1 subgoal):\n 1. heap_base.red_external addr2thread_id thread_id2addr spurious_wakeups\n     empty_heap allocate typeof_addr (heap_read_typed P) heap_write P t h a\n     M vs ta va h'", "by(cases)(auto intro: heap_base.red_external.intros heap_clone_non_speculative_typeable_None heap_clone_non_speculative_typeable_Some dest: hext_heap_clone elim: vs_conf_hext)"], ["", "lemma red_external_non_speculative_vs_conf:\n  assumes red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  and sc: \"non_speculative P Vs (llist_of (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"\n  and vs: \"vs_conf P h Vs\"\n  and hconf: \"hconf h\"\n  shows \"vs_conf P h' (w_values P Vs (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h'\n     (w_values P Vs\n       (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))", "using assms"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n  non_speculative P Vs\n   (llist_of\n     (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n  vs_conf P h Vs\n  hconf h\n\ngoal (1 subgoal):\n 1. vs_conf P h'\n     (w_values P Vs\n       (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))", "by(cases)(auto intro: heap_base.red_external.intros heap_clone_non_speculative_vs_conf_Some dest: hext_heap_clone elim: vs_conf_hext simp add: take_Cons')"], ["", "lemma red_external_aggr_non_speculative_typeable:\n  assumes red: \"(ta, va, h') \\<in> red_external_aggr P t a M vs h\"\n  and sc: \"non_speculative P Vs (llist_of (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\"\n  and vs: \"vs_conf P h Vs\"\n  and hconf: \"hconf h\"\n  and native: \"is_native P (the (typeof_addr h a)) M\"\n  shows \"(ta, va, h') \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr spurious_wakeups empty_heap allocate typeof_addr (heap_read_typed P) heap_write P t a M vs h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ta, va, h')\n    \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr\n           spurious_wakeups empty_heap allocate typeof_addr\n           (heap_read_typed P) heap_write P t a M vs h", "using assms"], ["proof (prove)\nusing this:\n  (ta, va, h') \\<in> red_external_aggr P t a M vs h\n  non_speculative P Vs\n   (llist_of (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n  vs_conf P h Vs\n  hconf h\n  is_native P (the (typeof_addr h a)) M\n\ngoal (1 subgoal):\n 1. (ta, va, h')\n    \\<in> heap_base.red_external_aggr addr2thread_id thread_id2addr\n           spurious_wakeups empty_heap allocate typeof_addr\n           (heap_read_typed P) heap_write P t a M vs h", "by(cases \"the (typeof_addr h a)\")(auto 4 3 simp add: is_native.simps external_WT_defs.simps red_external_aggr_def heap_base.red_external_aggr_def split: if_split_asm split del: if_split del: disjCI intro: heap_clone_non_speculative_typeable_None heap_clone_non_speculative_typeable_Some dest: sees_method_decl_above)"], ["", "lemma red_external_aggr_non_speculative_vs_conf:\n  assumes red: \"(ta, va, h') \\<in> red_external_aggr P t a M vs h\"\n  and sc: \"non_speculative P Vs (llist_of (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"\n  and vs: \"vs_conf P h Vs\"\n  and hconf: \"hconf h\"\n  and native: \"is_native P (the (typeof_addr h a)) M\"\n  shows \"vs_conf P h' (w_values P Vs (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs_conf P h'\n     (w_values P Vs\n       (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))", "using assms"], ["proof (prove)\nusing this:\n  (ta, va, h') \\<in> red_external_aggr P t a M vs h\n  non_speculative P Vs\n   (llist_of\n     (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n  vs_conf P h Vs\n  hconf h\n  is_native P (the (typeof_addr h a)) M\n\ngoal (1 subgoal):\n 1. vs_conf P h'\n     (w_values P Vs\n       (take n (map NormalAction \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))", "by(cases \"the (typeof_addr h a)\")(auto 4 3 simp add: is_native.simps external_WT_defs.simps red_external_aggr_def heap_base.red_external_aggr_def take_Cons' split: if_split_asm split del: if_split del: disjCI intro: heap_clone_non_speculative_vs_conf_Some dest: hext_heap_clone elim: vs_conf_hext dest: sees_method_decl_above)"], ["", "end"], ["", "declare split_paired_Ex [simp del]"], ["", "declare eq_upto_seq_inconsist_simps [simp]"], ["", "context heap_progress begin"], ["", "lemma heap_copy_loc_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and vs: \"vs_conf P h vs\"\n  and type: \"P,h \\<turnstile> a@al : T\" \"P,h \\<turnstile> a'@al : T\"\n  and hconf: \"hconf h\"\n  and copy: \"heap_copy_loc a a' al h obs h'\"\n  and i: \"i < length obs\"\n  and read: \"obs ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\"\n  shows \"\\<exists>obs' h''. heap_copy_loc a a' al h obs' h'' \\<and> i < length obs' \\<and> take i obs' = take i obs \\<and> \n                    obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs \\<and> \n                    non_speculative P vs (llist_of (map NormalAction obs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copy_loc a a' al h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length obs \\<and>\n       non_speculative P vs (llist_of (map NormalAction obs'))", "using copy"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h obs h'\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copy_loc a a' al h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length obs \\<and>\n       non_speculative P vs (llist_of (map NormalAction obs'))", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "case (1 v'')"], ["proof (state)\nthis:\n  obs = [ReadMem a al v'', WriteMem a' al v'']\n  heap_read h a al v''\n  heap_write h a' al v'' h'\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "with read i"], ["proof (chain)\npicking this:\n  obs ! i = ReadMem a'' al'' v\n  i < length obs\n  obs = [ReadMem a al v'', WriteMem a' al v'']\n  heap_read h a al v''\n  heap_write h a' al v'' h'", "have [simp]: \"i = 0\" \"v'' = v\" \"a'' = a\" \"al'' = al\""], ["proof (prove)\nusing this:\n  obs ! i = ReadMem a'' al'' v\n  i < length obs\n  obs = [ReadMem a al v'', WriteMem a' al v'']\n  heap_read h a al v''\n  heap_write h a' al v'' h'\n\ngoal (1 subgoal):\n 1. (i = 0 &&& v'' = v) &&& a'' = a &&& al'' = al", "by(simp_all add: nth_Cons split: nat.split_asm)"], ["proof (state)\nthis:\n  i = 0\n  v'' = v\n  a'' = a\n  al'' = al\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "from v"], ["proof (chain)\npicking this:\n  v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')", "have \"v' \\<in> vs (a, al)\""], ["proof (prove)\nusing this:\n  v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\n\ngoal (1 subgoal):\n 1. v' \\<in> vs (a, al)", "by simp"], ["proof (state)\nthis:\n  v' \\<in> vs (a, al)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "with vs type"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  P,h \\<turnstile> a@al : T\n  P,h \\<turnstile> a'@al : T\n  v' \\<in> vs (a, al)", "have conf: \"P,h \\<turnstile> v' :\\<le> T\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  P,h \\<turnstile> a@al : T\n  P,h \\<turnstile> a'@al : T\n  v' \\<in> vs (a, al)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v' :\\<le> T", "by(auto dest: addr_loc_type_fun vs_confD)"], ["proof (state)\nthis:\n  P,h \\<turnstile> v' :\\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "let ?obs'' = \"[ReadMem a al v', WriteMem a' al v']\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "from hrt type(1) conf hconf"], ["proof (chain)\npicking this:\n  heap_read_typeable hconf P\n  P,h \\<turnstile> a@al : T\n  P,h \\<turnstile> v' :\\<le> T\n  hconf h", "have \"heap_read h a al v'\""], ["proof (prove)\nusing this:\n  heap_read_typeable hconf P\n  P,h \\<turnstile> a@al : T\n  P,h \\<turnstile> v' :\\<le> T\n  hconf h\n\ngoal (1 subgoal):\n 1. heap_read h a al v'", "by(rule heap_read_typeableD)"], ["proof (state)\nthis:\n  heap_read h a al v'\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "moreover"], ["proof (state)\nthis:\n  heap_read h a al v'\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "from heap_write_total[OF hconf type(2) conf]"], ["proof (chain)\npicking this:\n  \\<exists>h'. heap_write h a' al v' h'", "obtain h'' where \"heap_write h a' al v' h''\""], ["proof (prove)\nusing this:\n  \\<exists>h'. heap_write h a' al v' h'\n\ngoal (1 subgoal):\n 1. (\\<And>h''.\n        heap_write h a' al v' h'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  heap_write h a' al v' h''\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "ultimately"], ["proof (chain)\npicking this:\n  heap_read h a al v'\n  heap_write h a' al v' h''", "have \"heap_copy_loc a a' al h ?obs'' h''\""], ["proof (prove)\nusing this:\n  heap_read h a al v'\n  heap_write h a' al v' h''\n\ngoal (1 subgoal):\n 1. heap_copy_loc a a' al h [ReadMem a al v', WriteMem a' al v'] h''", ".."], ["proof (state)\nthis:\n  heap_copy_loc a a' al h [ReadMem a al v', WriteMem a' al v'] h''\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>obs = [ReadMem a al v, WriteMem a' al v];\n        heap_read h a al v; heap_write h a' al v h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copy_loc a a' al h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs \\<and>\n                            non_speculative P vs\n                             (llist_of (map NormalAction obs'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h [ReadMem a al v', WriteMem a' al v'] h''\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copy_loc a a' al h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length obs \\<and>\n       non_speculative P vs (llist_of (map NormalAction obs'))", "using 1 \\<open>v' \\<in> vs (a, al)\\<close>"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h [ReadMem a al v', WriteMem a' al v'] h''\n  obs = [ReadMem a al v'', WriteMem a' al v'']\n  heap_read h a al v''\n  heap_write h a' al v'' h'\n  v' \\<in> vs (a, al)\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copy_loc a a' al h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length obs \\<and>\n       non_speculative P vs (llist_of (map NormalAction obs'))", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>obs' h''.\n     heap_copy_loc a a' al h obs' h'' \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i obs \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length obs \\<and>\n     non_speculative P vs (llist_of (map NormalAction obs'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_copies_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and copies: \"heap_copies a a' als h obs h'\"\n  and vs: \"vs_conf P h vs\"\n  and type1: \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts\"\n  and type2: \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts\"\n  and hconf: \"hconf h\"\n  and i: \"i < length obs\"\n  and read: \"obs ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\"\n  and ns: \"non_speculative P vs (llist_of (map NormalAction (take i obs)))\"\n  shows \"\\<exists>obs' h''. heap_copies a a' als h obs' h'' \\<and> i < length obs' \\<and> take i obs' = take i obs \\<and> \n                    obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs\"\n  (is \"?concl als h obs vs i\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' als h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs", "using copies vs type1 type2 hconf i read v ns"], ["proof (prove)\nusing this:\n  heap_copies a a' als h obs h'\n  vs_conf P h vs\n  list_all2 (addr_loc_type P h a) als Ts\n  list_all2 (addr_loc_type P h a') als Ts\n  hconf h\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\n  non_speculative P vs (llist_of (map NormalAction (take i obs)))\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' als h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs", "proof(induction arbitrary: Ts vs i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h Ts vs i.\n       \\<lbrakk>vs_conf P h vs; list_all2 (addr_loc_type P h a) [] Ts;\n        list_all2 (addr_loc_type P h a') [] Ts; hconf h; i < length [];\n        [] ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i [])) (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i [])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' [] h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i [] \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length []\n 2. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "case Nil"], ["proof (state)\nthis:\n  vs_conf P h_ vs\n  list_all2 (addr_loc_type P h_ a) [] Ts\n  list_all2 (addr_loc_type P h_ a') [] Ts\n  hconf h_\n  i < length []\n  [] ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs (map NormalAction (take i [])) (a'', al'')\n  non_speculative P vs (llist_of (map NormalAction (take i [])))\n\ngoal (2 subgoals):\n 1. \\<And>h Ts vs i.\n       \\<lbrakk>vs_conf P h vs; list_all2 (addr_loc_type P h a) [] Ts;\n        list_all2 (addr_loc_type P h a') [] Ts; hconf h; i < length [];\n        [] ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i [])) (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i [])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' [] h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i [] \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length []\n 2. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "thus ?case"], ["proof (prove)\nusing this:\n  vs_conf P h_ vs\n  list_all2 (addr_loc_type P h_ a) [] Ts\n  list_all2 (addr_loc_type P h_ a') [] Ts\n  hconf h_\n  i < length []\n  [] ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs (map NormalAction (take i [])) (a'', al'')\n  non_speculative P vs (llist_of (map NormalAction (take i [])))\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' [] h_ obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i [] \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length []", "by simp"], ["proof (state)\nthis:\n  \\<exists>obs' h''.\n     heap_copies a a' [] h_ obs' h'' \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i [] \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length []\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "case (Cons al h ob h' als obs h'' Ts vs)"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h ob h'\n  heap_copies a a' als h' obs h''\n  \\<lbrakk>vs_conf P h' ?vs17; list_all2 (addr_loc_type P h' a) als ?Ts17;\n   list_all2 (addr_loc_type P h' a') als ?Ts17; hconf h'; ?i17 < length obs;\n   obs ! ?i17 = ReadMem a'' al'' v;\n   v' \\<in> w_values P ?vs17 (map NormalAction (take ?i17 obs)) (a'', al'');\n   non_speculative P ?vs17\n    (llist_of (map NormalAction (take ?i17 obs)))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>obs' h''.\n                       heap_copies a a' als h' obs' h'' \\<and>\n                       ?i17 < length obs' \\<and>\n                       take ?i17 obs' = take ?i17 obs \\<and>\n                       obs' ! ?i17 = ReadMem a'' al'' v' \\<and>\n                       length obs' \\<le> length obs\n  vs_conf P h vs\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n  list_all2 (addr_loc_type P h a') (al # als) Ts\n  hconf h\n  i < length (ob @ obs)\n  (ob @ obs) ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs))) (a'', al'')\n  non_speculative P vs (llist_of (map NormalAction (take i (ob @ obs))))\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "note copy = \\<open>heap_copy_loc a a' al h ob h'\\<close>"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h ob h'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "note vs = \\<open>vs_conf P h vs\\<close>"], ["proof (state)\nthis:\n  vs_conf P h vs\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "note type1 = \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) (al # als) Ts\\<close>\n    and type2 = \\<open>list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) (al # als) Ts\\<close>"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n  list_all2 (addr_loc_type P h a') (al # als) Ts\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "note hconf = \\<open>hconf h\\<close>"], ["proof (state)\nthis:\n  hconf h\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "note i = \\<open>i < length (ob @ obs)\\<close>"], ["proof (state)\nthis:\n  i < length (ob @ obs)\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "note read = \\<open>(ob @ obs) ! i = ReadMem a'' al'' v\\<close>"], ["proof (state)\nthis:\n  (ob @ obs) ! i = ReadMem a'' al'' v\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "note v = \\<open>v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs))) (a'', al'')\\<close>"], ["proof (state)\nthis:\n  v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs))) (a'', al'')\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "note ns = \\<open>non_speculative P vs (llist_of (map NormalAction (take i (ob @ obs))))\\<close>"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (map NormalAction (take i (ob @ obs))))\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "from type1"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) (al # als) Ts", "obtain T Ts' where Ts: \"Ts = T # Ts'\"\n    and type1': \"P,h \\<turnstile> a@al : T\"\n    and type1'': \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) (al # als) Ts\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts'.\n        \\<lbrakk>Ts = T # Ts'; P,h \\<turnstile> a@al : T;\n         list_all2 (addr_loc_type P h a) als Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: list_all2_Cons1)"], ["proof (state)\nthis:\n  Ts = T # Ts'\n  P,h \\<turnstile> a@al : T\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "from type2 Ts"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a') (al # als) Ts\n  Ts = T # Ts'", "have type2': \"P,h \\<turnstile> a'@al : T\"\n    and type2'': \"list_all2 (\\<lambda>al T. P,h \\<turnstile> a'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a') (al # als) Ts\n  Ts = T # Ts'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> a'@al : T &&& list_all2 (addr_loc_type P h a') als Ts'", "by simp_all"], ["proof (state)\nthis:\n  P,h \\<turnstile> a'@al : T\n  list_all2 (addr_loc_type P h a') als Ts'\n\ngoal (1 subgoal):\n 1. \\<And>al h ob h' als obs h'' Ts vs i.\n       \\<lbrakk>heap_copy_loc a a' al h ob h';\n        heap_copies a a' als h' obs h'';\n        \\<And>Ts vs i.\n           \\<lbrakk>vs_conf P h' vs;\n            list_all2 (addr_loc_type P h' a) als Ts;\n            list_all2 (addr_loc_type P h' a') als Ts; hconf h';\n            i < length obs; obs ! i = ReadMem a'' al'' v;\n            v' \\<in> w_values P vs (map NormalAction (take i obs))\n                      (a'', al'');\n            non_speculative P vs\n             (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>obs' h''.\n                                heap_copies a a' als h' obs' h'' \\<and>\n                                i < length obs' \\<and>\n                                take i obs' = take i obs \\<and>\n                                obs' ! i = ReadMem a'' al'' v' \\<and>\n                                length obs' \\<le> length obs;\n        vs_conf P h vs; list_all2 (addr_loc_type P h a) (al # als) Ts;\n        list_all2 (addr_loc_type P h a') (al # als) Ts; hconf h;\n        i < length (ob @ obs); (ob @ obs) ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs)))\n                  (a'', al'');\n        non_speculative P vs\n         (llist_of (map NormalAction (take i (ob @ obs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_copies a a' (al # als) h obs' h'' \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i (ob @ obs) \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length (ob @ obs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "proof(cases \"i < length ob\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "case True"], ["proof (state)\nthis:\n  i < length ob\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "with read v"], ["proof (chain)\npicking this:\n  (ob @ obs) ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs))) (a'', al'')\n  i < length ob", "have \"ob ! i = ReadMem a'' al'' v\"\n      and \"v' \\<in> w_values P vs (map NormalAction (take i ob)) (a'', al'')\""], ["proof (prove)\nusing this:\n  (ob @ obs) ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs))) (a'', al'')\n  i < length ob\n\ngoal (1 subgoal):\n 1. ob ! i = ReadMem a'' al'' v &&&\n    v' \\<in> w_values P vs (map NormalAction (take i ob)) (a'', al'')", "by(simp_all add: nth_append)"], ["proof (state)\nthis:\n  ob ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs (map NormalAction (take i ob)) (a'', al'')\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from heap_copy_loc_non_speculative_read[OF hrt vs type1' type2' hconf copy True this]"], ["proof (chain)\npicking this:\n  \\<exists>obs' h''.\n     heap_copy_loc a a' al h obs' h'' \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i ob \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length ob \\<and>\n     non_speculative P vs (llist_of (map NormalAction obs'))", "obtain ob' H'' where copy': \"heap_copy_loc a a' al h ob' H''\"\n      and i': \"i < length ob'\" and \"take i ob' = take i ob\"\n      and \"ob' ! i = ReadMem a'' al'' v'\"\n      and \"length ob' \\<le> length ob\"\n      and ns: \"non_speculative P vs (llist_of (map NormalAction ob'))\""], ["proof (prove)\nusing this:\n  \\<exists>obs' h''.\n     heap_copy_loc a a' al h obs' h'' \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i ob \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length ob \\<and>\n     non_speculative P vs (llist_of (map NormalAction obs'))\n\ngoal (1 subgoal):\n 1. (\\<And>ob' H''.\n        \\<lbrakk>heap_copy_loc a a' al h ob' H''; i < length ob';\n         take i ob' = take i ob; ob' ! i = ReadMem a'' al'' v';\n         length ob' \\<le> length ob;\n         non_speculative P vs (llist_of (map NormalAction ob'))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h ob' H''\n  i < length ob'\n  take i ob' = take i ob\n  ob' ! i = ReadMem a'' al'' v'\n  length ob' \\<le> length ob\n  non_speculative P vs (llist_of (map NormalAction ob'))\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h ob' H''\n  i < length ob'\n  take i ob' = take i ob\n  ob' ! i = ReadMem a'' al'' v'\n  length ob' \\<le> length ob\n  non_speculative P vs (llist_of (map NormalAction ob'))\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "{"], ["proof (state)\nthis:\n  heap_copy_loc a a' al h ob' H''\n  i < length ob'\n  take i ob' = take i ob\n  ob' ! i = ReadMem a'' al'' v'\n  length ob' \\<le> length ob\n  non_speculative P vs (llist_of (map NormalAction ob'))\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from copy'"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h ob' H''", "have hext: \"h \\<unlhd> H''\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob' H''\n\ngoal (1 subgoal):\n 1. h \\<unlhd> H''", "by(rule hext_heap_copy_loc)"], ["proof (state)\nthis:\n  h \\<unlhd> H''\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "have \"hconf H''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hconf H''", "by(rule heap_conf_read.hconf_heap_copy_loc_mono[OF heap_conf_read_heap_read_typed])(rule heap_copy_loc_non_speculative_typeable[OF copy' ns vs hconf type1' type2'], fact+)"], ["proof (state)\nthis:\n  hconf H''\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  hconf H''\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from type1''"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) als Ts'", "have \"list_all2 (\\<lambda>al T. P,H'' \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P H'' a) als Ts'", "by(rule List.list_all2_mono)(rule addr_loc_type_hext_mono[OF _ hext])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P H'' a) als Ts'\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P H'' a) als Ts'\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from type2''"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a') als Ts'", "have \"list_all2 (\\<lambda>al T. P,H'' \\<turnstile> a'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a') als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P H'' a') als Ts'", "by(rule List.list_all2_mono)(rule addr_loc_type_hext_mono[OF _ hext])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P H'' a') als Ts'\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P H'' a') als Ts'\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "note calculation"], ["proof (state)\nthis:\n  hconf H''\n  list_all2 (addr_loc_type P H'' a) als Ts'\n  list_all2 (addr_loc_type P H'' a') als Ts'\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "}"], ["proof (state)\nthis:\n  hconf H''\n  list_all2 (addr_loc_type P H'' a) als Ts'\n  list_all2 (addr_loc_type P H'' a') als Ts'\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from heap_copies_progress[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>vs h'.\n     heap_copies a a' als H''\n      (concat\n        (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n      h' \\<and>\n     hconf h'", "obtain obs' h''' where *: \"heap_copies a a' als H'' obs' h'''\""], ["proof (prove)\nusing this:\n  \\<exists>vs h'.\n     heap_copies a a' als H''\n      (concat\n        (map2 (\\<lambda>al v. [ReadMem a al v, WriteMem a' al v]) als vs))\n      h' \\<and>\n     hconf h'\n\ngoal (1 subgoal):\n 1. (\\<And>obs' h'''.\n        heap_copies a a' als H'' obs' h''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  heap_copies a a' als H'' obs' h'''\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  heap_copies a a' als H'' obs' h'''\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "note heap_copies_length[OF *]"], ["proof (state)\nthis:\n  length obs' = 2 * length als\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  length obs' = 2 * length als\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "note heap_copy_loc_length[OF copy']"], ["proof (state)\nthis:\n  length ob' = 2\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  length ob' = 2\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "note heap_copies_length[OF \\<open>heap_copies a a' als h' obs h''\\<close>]"], ["proof (state)\nthis:\n  length obs = 2 * length als\n\ngoal (2 subgoals):\n 1. i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)\n 2. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "ultimately"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h ob' H''\n  i < length ob'\n  take i ob' = take i ob\n  ob' ! i = ReadMem a'' al'' v'\n  length ob' \\<le> length ob\n  non_speculative P vs (llist_of (map NormalAction ob'))\n  heap_copies a a' als H'' obs' h'''\n  length obs' = 2 * length als\n  length ob' = 2\n  length obs = 2 * length als", "show ?thesis"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob' H''\n  i < length ob'\n  take i ob' = take i ob\n  ob' ! i = ReadMem a'' al'' v'\n  length ob' \\<le> length ob\n  non_speculative P vs (llist_of (map NormalAction ob'))\n  heap_copies a a' als H'' obs' h'''\n  length obs' = 2 * length als\n  length ob' = 2\n  length obs = 2 * length als\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "using True"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob' H''\n  i < length ob'\n  take i ob' = take i ob\n  ob' ! i = ReadMem a'' al'' v'\n  length ob' \\<le> length ob\n  non_speculative P vs (llist_of (map NormalAction ob'))\n  heap_copies a a' als H'' obs' h'''\n  length obs' = 2 * length als\n  length ob' = 2\n  length obs = 2 * length als\n  i < length ob\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "by(auto intro!: heap_copies.Cons exI simp add: nth_append)"], ["proof (state)\nthis:\n  \\<exists>obs' h''.\n     heap_copies a a' (al # als) h obs' h'' \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i (ob @ obs) \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length (ob @ obs)\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "case False"], ["proof (state)\nthis:\n  \\<not> i < length ob\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "let ?vs' = \"w_values P vs (map NormalAction ob)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "let ?i' = \"i - length ob\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from ns False"], ["proof (chain)\npicking this:\n  non_speculative P vs (llist_of (map NormalAction (take i (ob @ obs))))\n  \\<not> i < length ob", "obtain ns': \"non_speculative P vs (llist_of (map NormalAction ob))\"\n      and ns'': \"non_speculative P ?vs' (llist_of (map NormalAction (take ?i' obs)))\""], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (map NormalAction (take i (ob @ obs))))\n  \\<not> i < length ob\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>non_speculative P vs (llist_of (map NormalAction ob));\n      non_speculative P (w_values P vs (map NormalAction ob))\n       (llist_of (map NormalAction (take (i - length ob) obs)))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: lappend_llist_of_llist_of[symmetric] non_speculative_lappend del: lappend_llist_of_llist_of)"], ["proof (state)\nthis:\n  non_speculative P vs (llist_of (map NormalAction ob))\n  non_speculative P (w_values P vs (map NormalAction ob))\n   (llist_of (map NormalAction (take (i - length ob) obs)))\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from heap_copy_loc_non_speculative_vs_conf[OF copy _ vs hconf type1' type2', where n=\"length ob\"] ns'"], ["proof (chain)\npicking this:\n  non_speculative P vs\n   (llist_of (take (length ob) (map NormalAction ob))) \\<Longrightarrow>\n  vs_conf P h' (w_values P vs (take (length ob) (map NormalAction ob)))\n  non_speculative P vs (llist_of (map NormalAction ob))", "have \"vs_conf P h' ?vs'\""], ["proof (prove)\nusing this:\n  non_speculative P vs\n   (llist_of (take (length ob) (map NormalAction ob))) \\<Longrightarrow>\n  vs_conf P h' (w_values P vs (take (length ob) (map NormalAction ob)))\n  non_speculative P vs (llist_of (map NormalAction ob))\n\ngoal (1 subgoal):\n 1. vs_conf P h' (w_values P vs (map NormalAction ob))", "by simp"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (map NormalAction ob))\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  vs_conf P h' (w_values P vs (map NormalAction ob))\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from copy"], ["proof (chain)\npicking this:\n  heap_copy_loc a a' al h ob h'", "have hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_heap_copy_loc)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from type1''"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a) als Ts'", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a) als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a) als Ts'", "by(rule List.list_all2_mono)(rule addr_loc_type_hext_mono[OF _ hext])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a) als Ts'\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from type2''"], ["proof (chain)\npicking this:\n  list_all2 (addr_loc_type P h a') als Ts'", "have \"list_all2 (\\<lambda>al T. P,h' \\<turnstile> a'@al : T) als Ts'\""], ["proof (prove)\nusing this:\n  list_all2 (addr_loc_type P h a') als Ts'\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h' a') als Ts'", "by(rule List.list_all2_mono)(rule addr_loc_type_hext_mono[OF _ hext])"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a') als Ts'\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h' a') als Ts'\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "have \"hconf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hconf h'", "by(rule heap_conf_read.hconf_heap_copy_loc_mono[OF heap_conf_read_heap_read_typed])(rule heap_copy_loc_non_speculative_typeable[OF copy ns' vs hconf type1' type2'], fact+)"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  hconf h'\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from i False"], ["proof (chain)\npicking this:\n  i < length (ob @ obs)\n  \\<not> i < length ob", "have \"?i' < length obs\""], ["proof (prove)\nusing this:\n  i < length (ob @ obs)\n  \\<not> i < length ob\n\ngoal (1 subgoal):\n 1. i - length ob < length obs", "by simp"], ["proof (state)\nthis:\n  i - length ob < length obs\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  i - length ob < length obs\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from read False"], ["proof (chain)\npicking this:\n  (ob @ obs) ! i = ReadMem a'' al'' v\n  \\<not> i < length ob", "have \"obs ! ?i' = ReadMem a'' al'' v\""], ["proof (prove)\nusing this:\n  (ob @ obs) ! i = ReadMem a'' al'' v\n  \\<not> i < length ob\n\ngoal (1 subgoal):\n 1. obs ! (i - length ob) = ReadMem a'' al'' v", "by(simp add: nth_append)"], ["proof (state)\nthis:\n  obs ! (i - length ob) = ReadMem a'' al'' v\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "moreover"], ["proof (state)\nthis:\n  obs ! (i - length ob) = ReadMem a'' al'' v\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "from v False"], ["proof (chain)\npicking this:\n  v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs))) (a'', al'')\n  \\<not> i < length ob", "have \"v' \\<in> w_values P ?vs' (map NormalAction (take ?i' obs)) (a'', al'')\""], ["proof (prove)\nusing this:\n  v' \\<in> w_values P vs (map NormalAction (take i (ob @ obs))) (a'', al'')\n  \\<not> i < length ob\n\ngoal (1 subgoal):\n 1. v' \\<in> w_values P (w_values P vs (map NormalAction ob))\n              (map NormalAction (take (i - length ob) obs)) (a'', al'')", "by(simp)"], ["proof (state)\nthis:\n  v' \\<in> w_values P (w_values P vs (map NormalAction ob))\n            (map NormalAction (take (i - length ob) obs)) (a'', al'')\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "ultimately"], ["proof (chain)\npicking this:\n  vs_conf P h' (w_values P vs (map NormalAction ob))\n  list_all2 (addr_loc_type P h' a) als Ts'\n  list_all2 (addr_loc_type P h' a') als Ts'\n  hconf h'\n  i - length ob < length obs\n  obs ! (i - length ob) = ReadMem a'' al'' v\n  v' \\<in> w_values P (w_values P vs (map NormalAction ob))\n            (map NormalAction (take (i - length ob) obs)) (a'', al'')", "have \"?concl als h' obs ?vs' ?i'\""], ["proof (prove)\nusing this:\n  vs_conf P h' (w_values P vs (map NormalAction ob))\n  list_all2 (addr_loc_type P h' a) als Ts'\n  list_all2 (addr_loc_type P h' a') als Ts'\n  hconf h'\n  i - length ob < length obs\n  obs ! (i - length ob) = ReadMem a'' al'' v\n  v' \\<in> w_values P (w_values P vs (map NormalAction ob))\n            (map NormalAction (take (i - length ob) obs)) (a'', al'')\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' als h' obs' h'' \\<and>\n       i - length ob < length obs' \\<and>\n       take (i - length ob) obs' = take (i - length ob) obs \\<and>\n       obs' ! (i - length ob) = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length obs", "using ns''"], ["proof (prove)\nusing this:\n  vs_conf P h' (w_values P vs (map NormalAction ob))\n  list_all2 (addr_loc_type P h' a) als Ts'\n  list_all2 (addr_loc_type P h' a') als Ts'\n  hconf h'\n  i - length ob < length obs\n  obs ! (i - length ob) = ReadMem a'' al'' v\n  v' \\<in> w_values P (w_values P vs (map NormalAction ob))\n            (map NormalAction (take (i - length ob) obs)) (a'', al'')\n  non_speculative P (w_values P vs (map NormalAction ob))\n   (llist_of (map NormalAction (take (i - length ob) obs)))\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' als h' obs' h'' \\<and>\n       i - length ob < length obs' \\<and>\n       take (i - length ob) obs' = take (i - length ob) obs \\<and>\n       obs' ! (i - length ob) = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length obs", "by(rule Cons.IH)"], ["proof (state)\nthis:\n  \\<exists>obs' h''.\n     heap_copies a a' als h' obs' h'' \\<and>\n     i - length ob < length obs' \\<and>\n     take (i - length ob) obs' = take (i - length ob) obs \\<and>\n     obs' ! (i - length ob) = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length obs\n\ngoal (1 subgoal):\n 1. \\<not> i < length ob \\<Longrightarrow>\n    \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs' h''.\n     heap_copies a a' als h' obs' h'' \\<and>\n     i - length ob < length obs' \\<and>\n     take (i - length ob) obs' = take (i - length ob) obs \\<and>\n     obs' ! (i - length ob) = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length obs\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "using False copy"], ["proof (prove)\nusing this:\n  \\<exists>obs' h''.\n     heap_copies a a' als h' obs' h'' \\<and>\n     i - length ob < length obs' \\<and>\n     take (i - length ob) obs' = take (i - length ob) obs \\<and>\n     obs' ! (i - length ob) = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length obs\n  \\<not> i < length ob\n  heap_copy_loc a a' al h ob h'\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_copies a a' (al # als) h obs' h'' \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i (ob @ obs) \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and>\n       length obs' \\<le> length (ob @ obs)", "by safe(auto intro!: heap_copies.Cons exI simp add: nth_append)"], ["proof (state)\nthis:\n  \\<exists>obs' h''.\n     heap_copies a a' (al # als) h obs' h'' \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i (ob @ obs) \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length (ob @ obs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>obs' h''.\n     heap_copies a a' (al # als) h obs' h'' \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i (ob @ obs) \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and>\n     length obs' \\<le> length (ob @ obs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heap_clone_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and clone: \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and vs: \"vs_conf P h vs\"\n  and hconf: \"hconf h\"\n  and i: \"i < length obs\"\n  and read: \"obs ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\"\n  and ns: \"non_speculative P vs (llist_of (map NormalAction (take i obs)))\"\n  shows \"\\<exists>obs' h''. heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and> i < length obs' \\<and> take i obs' = take i obs \\<and> \n                    obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs", "using clone"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "case (ObjClone C h'' FDTs obs')"], ["proof (state)\nthis:\n  obs = NewHeapElem a' (Class_type C) # obs'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (h'', a') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'' obs'\n   h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "note obs = \\<open>obs = NewHeapElem a' (Class_type C) # obs'\\<close>"], ["proof (state)\nthis:\n  obs = NewHeapElem a' (Class_type C) # obs'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "note FDTs = \\<open>P \\<turnstile> C has_fields FDTs\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "let ?als = \"map (\\<lambda>((F, D), Tm). CField D F) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "let ?vs = \"w_value P vs (NormalAction (NewHeapElem a' (Class_type C)) :: ('addr, 'thread_id) obs_event action)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "let ?i = \"i - 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from i read obs"], ["proof (chain)\npicking this:\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  obs = NewHeapElem a' (Class_type C) # obs'", "have i_0: \"i > 0\""], ["proof (prove)\nusing this:\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  obs = NewHeapElem a' (Class_type C) # obs'\n\ngoal (1 subgoal):\n 1. 0 < i", "by(simp add: nth_Cons' split: if_split_asm)"], ["proof (state)\nthis:\n  0 < i\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from \\<open>P \\<turnstile> C has_fields FDTs\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs", "have \"is_class P C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. is_class P C", "by(rule has_fields_is_class)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "with \\<open>(h'', a') \\<in> allocate h (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', a') \\<in> allocate h (Class_type C)\n  is_class P C", "have type_a': \"typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>\" and hext: \"h \\<unlhd> h''\""], ["proof (prove)\nusing this:\n  (h'', a') \\<in> allocate h (Class_type C)\n  is_class P C\n\ngoal (1 subgoal):\n 1. typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor> &&& h \\<unlhd> h''", "by(auto dest: allocate_SomeD hext_allocate)"], ["proof (state)\nthis:\n  typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>\n  h \\<unlhd> h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "note \\<open>heap_copies a a' ?als h'' obs' h'\\<close>"], ["proof (state)\nthis:\n  heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) h'' obs'\n   h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) h'' obs'\n   h'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from \\<open>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close> hconf"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  hconf h", "have \"is_htype P (Class_type C)\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. is_htype P (Class_type C)", "by(rule typeof_addr_is_type)"], ["proof (state)\nthis:\n  is_htype P (Class_type C)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "with vs \\<open>(h'', a') \\<in> allocate h (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  (h'', a') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)", "have \"vs_conf P h'' ?vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  (h'', a') \\<in> allocate h (Class_type C)\n  is_htype P (Class_type C)\n\ngoal (1 subgoal):\n 1. vs_conf P h''\n     (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))", "by(rule vs_conf_allocate)"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from hext \\<open>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  h \\<unlhd> h''\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>", "have \"typeof_addr h'' a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h'' a = \\<lfloor>Class_type C\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h'' a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "hence \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a)\n     (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "using FDTs"], ["proof (prove)\nusing this:\n  typeof_addr h'' a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a)\n     (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  typeof_addr h'' a = \\<lfloor>Class_type C\\<rfloor>\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h'' \\<turnstile> a@(case x of\n                             (x, xa) \\<Rightarrow>\n                               (case x of\n                                (F, D) \\<Rightarrow>\n                                  \\<lambda>Tm. CField D F)\n                                xa) : (case x of\n (FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from FDTs type_a'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> a'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a')\n     (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)", "unfolding list_all2_map1 list_all2_map2 list_all2_refl_conv"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  typeof_addr h'' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set FDTs.\n       P,h'' \\<turnstile> a'@(case x of\n                              (x, xa) \\<Rightarrow>\n                                (case x of\n                                 (F, D) \\<Rightarrow>\n                                   \\<lambda>Tm. CField D F)\n                                 xa) : (case x of\n  (FD, T) \\<Rightarrow> fst (the (map_of FDTs FD)))", "by(fastforce intro: addr_loc_type.intros simp add: has_field_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from \\<open>(h'', a') \\<in> allocate h (Class_type C)\\<close> hconf \\<open>is_htype P (Class_type C)\\<close>"], ["proof (chain)\npicking this:\n  (h'', a') \\<in> allocate h (Class_type C)\n  hconf h\n  is_htype P (Class_type C)", "have \"hconf h''\""], ["proof (prove)\nusing this:\n  (h'', a') \\<in> allocate h (Class_type C)\n  hconf h\n  is_htype P (Class_type C)\n\ngoal (1 subgoal):\n 1. hconf h''", "by(rule hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from i read i_0 obs"], ["proof (chain)\npicking this:\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  0 < i\n  obs = NewHeapElem a' (Class_type C) # obs'", "have \"?i < length obs'\" \"obs' ! ?i = ReadMem a'' al'' v\""], ["proof (prove)\nusing this:\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  0 < i\n  obs = NewHeapElem a' (Class_type C) # obs'\n\ngoal (1 subgoal):\n 1. i - 1 < length obs' &&& obs' ! (i - 1) = ReadMem a'' al'' v", "by simp_all"], ["proof (state)\nthis:\n  i - 1 < length obs'\n  obs' ! (i - 1) = ReadMem a'' al'' v\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  i - 1 < length obs'\n  obs' ! (i - 1) = ReadMem a'' al'' v\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from v i_0 obs"], ["proof (chain)\npicking this:\n  v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\n  0 < i\n  obs = NewHeapElem a' (Class_type C) # obs'", "have \"v' \\<in> w_values P ?vs (map NormalAction (take ?i obs')) (a'', al'')\""], ["proof (prove)\nusing this:\n  v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\n  0 < i\n  obs = NewHeapElem a' (Class_type C) # obs'\n\ngoal (1 subgoal):\n 1. v' \\<in> w_values P\n              (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n              (map NormalAction (take (i - 1) obs')) (a'', al'')", "by(simp add: take_Cons')"], ["proof (state)\nthis:\n  v' \\<in> w_values P\n            (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n            (map NormalAction (take (i - 1) obs')) (a'', al'')\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  v' \\<in> w_values P\n            (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n            (map NormalAction (take (i - 1) obs')) (a'', al'')\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from ns i_0 obs"], ["proof (chain)\npicking this:\n  non_speculative P vs (llist_of (map NormalAction (take i obs)))\n  0 < i\n  obs = NewHeapElem a' (Class_type C) # obs'", "have \"non_speculative P ?vs (llist_of (map NormalAction (take ?i obs')))\""], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (map NormalAction (take i obs)))\n  0 < i\n  obs = NewHeapElem a' (Class_type C) # obs'\n\ngoal (1 subgoal):\n 1. non_speculative P\n     (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n     (llist_of (map NormalAction (take (i - 1) obs')))", "by(simp add: take_Cons')"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n   (llist_of (map NormalAction (take (i - 1) obs')))\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) h'' obs'\n   h'\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  hconf h''\n  i - 1 < length obs'\n  obs' ! (i - 1) = ReadMem a'' al'' v\n  v' \\<in> w_values P\n            (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n            (map NormalAction (take (i - 1) obs')) (a'', al'')\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n   (llist_of (map NormalAction (take (i - 1) obs')))", "have \"\\<exists>obs'' h'''. heap_copies a a' ?als h'' obs'' h''' \\<and>\n                             ?i < length obs'' \\<and> take ?i obs'' = take ?i obs' \\<and> obs'' ! ?i = ReadMem a'' al'' v' \\<and>\n                             length obs'' \\<le> length obs'\""], ["proof (prove)\nusing this:\n  heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) h'' obs'\n   h'\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tm). CField D F) FDTs)\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs)\n  hconf h''\n  i - 1 < length obs'\n  obs' ! (i - 1) = ReadMem a'' al'' v\n  v' \\<in> w_values P\n            (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n            (map NormalAction (take (i - 1) obs')) (a'', al'')\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem a' (Class_type C))))\n   (llist_of (map NormalAction (take (i - 1) obs')))\n\ngoal (1 subgoal):\n 1. \\<exists>obs'' h'''.\n       heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) h''\n        obs'' h''' \\<and>\n       i - 1 < length obs'' \\<and>\n       take (i - 1) obs'' = take (i - 1) obs' \\<and>\n       obs'' ! (i - 1) = ReadMem a'' al'' v' \\<and>\n       length obs'' \\<le> length obs'", "by(rule heap_copies_non_speculative_read[OF hrt])"], ["proof (state)\nthis:\n  \\<exists>obs'' h'''.\n     heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) h''\n      obs'' h''' \\<and>\n     i - 1 < length obs'' \\<and>\n     take (i - 1) obs'' = take (i - 1) obs' \\<and>\n     obs'' ! (i - 1) = ReadMem a'' al'' v' \\<and>\n     length obs'' \\<le> length obs'\n\ngoal (2 subgoals):\n 1. \\<And>C h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Class_type C) # obsa;\n        typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Class_type C);\n        P \\<turnstile> C has_fields FDTs;\n        heap_copies a a' (map (\\<lambda>((F, D), Tfm). CField D F) FDTs) h'a\n         obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs\n 2. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs'' h'''.\n     heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) h''\n      obs'' h''' \\<and>\n     i - 1 < length obs'' \\<and>\n     take (i - 1) obs'' = take (i - 1) obs' \\<and>\n     obs'' ! (i - 1) = ReadMem a'' al'' v' \\<and>\n     length obs'' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs", "using \\<open>typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close> \\<open>(h'', a') \\<in> allocate h (Class_type C)\\<close> FDTs obs i_0"], ["proof (prove)\nusing this:\n  \\<exists>obs'' h'''.\n     heap_copies a a' (map (\\<lambda>((F, D), Tm). CField D F) FDTs) h''\n      obs'' h''' \\<and>\n     i - 1 < length obs'' \\<and>\n     take (i - 1) obs'' = take (i - 1) obs' \\<and>\n     obs'' ! (i - 1) = ReadMem a'' al'' v' \\<and>\n     length obs'' \\<le> length obs'\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (h'', a') \\<in> allocate h (Class_type C)\n  P \\<turnstile> C has_fields FDTs\n  obs = NewHeapElem a' (Class_type C) # obs'\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs", "by(auto 4 4 intro: heap_clone.ObjClone simp add: take_Cons')"], ["proof (state)\nthis:\n  \\<exists>obs' h''.\n     heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i obs \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "case (ArrClone T n h'' FDTs obs')"], ["proof (state)\nthis:\n  obs = NewHeapElem a' (Array_type T n) # obs'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  (h'', a') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "note obs = \\<open>obs = NewHeapElem a' (Array_type T n) # obs'\\<close>"], ["proof (state)\nthis:\n  obs = NewHeapElem a' (Array_type T n) # obs'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "note FDTs = \\<open>P \\<turnstile> Object has_fields FDTs\\<close>"], ["proof (state)\nthis:\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "let ?als = \"map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "let ?Ts = \"map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "let ?vs = \"w_value P vs (NormalAction (NewHeapElem a' (Array_type T n)) :: ('addr, 'thread_id) obs_event action)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "let ?i = \"i - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from i read obs"], ["proof (chain)\npicking this:\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  obs = NewHeapElem a' (Array_type T n) # obs'", "have i_0: \"i > 0\""], ["proof (prove)\nusing this:\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  obs = NewHeapElem a' (Array_type T n) # obs'\n\ngoal (1 subgoal):\n 1. 0 < i", "by(simp add: nth_Cons' split: if_split_asm)"], ["proof (state)\nthis:\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from \\<open>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\\<close> hconf"], ["proof (chain)\npicking this:\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  hconf h", "have \"is_htype P (Array_type T n)\""], ["proof (prove)\nusing this:\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  hconf h\n\ngoal (1 subgoal):\n 1. is_htype P (Array_type T n)", "by(rule typeof_addr_is_type)"], ["proof (state)\nthis:\n  is_htype P (Array_type T n)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "with \\<open>(h'', a') \\<in> allocate h (Array_type T n)\\<close>"], ["proof (chain)\npicking this:\n  (h'', a') \\<in> allocate h (Array_type T n)\n  is_htype P (Array_type T n)", "have type_a': \"typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>\"\n    and hext: \"h \\<unlhd> h''\""], ["proof (prove)\nusing this:\n  (h'', a') \\<in> allocate h (Array_type T n)\n  is_htype P (Array_type T n)\n\ngoal (1 subgoal):\n 1. typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor> &&& h \\<unlhd> h''", "by(auto dest: allocate_SomeD hext_allocate)"], ["proof (state)\nthis:\n  typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>\n  h \\<unlhd> h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "note \\<open>heap_copies a a' ?als h'' obs' h'\\<close>"], ["proof (state)\nthis:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from vs \\<open>(h'', a') \\<in> allocate h (Array_type T n)\\<close> \\<open>is_htype P (Array_type T n)\\<close>"], ["proof (chain)\npicking this:\n  vs_conf P h vs\n  (h'', a') \\<in> allocate h (Array_type T n)\n  is_htype P (Array_type T n)", "have \"vs_conf P h'' ?vs\""], ["proof (prove)\nusing this:\n  vs_conf P h vs\n  (h'', a') \\<in> allocate h (Array_type T n)\n  is_htype P (Array_type T n)\n\ngoal (1 subgoal):\n 1. vs_conf P h''\n     (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))", "by(rule vs_conf_allocate)"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from hext \\<open>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  h \\<unlhd> h''\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>", "have type'a: \"typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h''\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>", "by(auto intro: hext_arrD)"], ["proof (state)\nthis:\n  typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from type'a FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> a@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' a = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a)\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from type_a' FDTs"], ["proof (chain)\npicking this:\n  typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs", "have \"list_all2 (\\<lambda>al T. P,h'' \\<turnstile> a'@al : T) ?als ?Ts\""], ["proof (prove)\nusing this:\n  typeof_addr h'' a' = \\<lfloor>Array_type T n\\<rfloor>\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. list_all2 (addr_loc_type P h'' a')\n     (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n     (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @\n      replicate n T)", "by(fastforce intro: list_all2_all_nthI addr_loc_type.intros simp add: has_field_def list_all2_append list_all2_map1 list_all2_map2 list_all2_refl_conv dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from \\<open>(h'', a') \\<in> allocate h (Array_type T n)\\<close> hconf \\<open>is_htype P (Array_type T n)\\<close>"], ["proof (chain)\npicking this:\n  (h'', a') \\<in> allocate h (Array_type T n)\n  hconf h\n  is_htype P (Array_type T n)", "have \"hconf h''\""], ["proof (prove)\nusing this:\n  (h'', a') \\<in> allocate h (Array_type T n)\n  hconf h\n  is_htype P (Array_type T n)\n\ngoal (1 subgoal):\n 1. hconf h''", "by(rule hconf_allocate_mono)"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  hconf h''\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from i read i_0 obs"], ["proof (chain)\npicking this:\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  0 < i\n  obs = NewHeapElem a' (Array_type T n) # obs'", "have \"?i < length obs'\" \"obs' ! ?i = ReadMem a'' al'' v\""], ["proof (prove)\nusing this:\n  i < length obs\n  obs ! i = ReadMem a'' al'' v\n  0 < i\n  obs = NewHeapElem a' (Array_type T n) # obs'\n\ngoal (1 subgoal):\n 1. i - 1 < length obs' &&& obs' ! (i - 1) = ReadMem a'' al'' v", "by simp_all"], ["proof (state)\nthis:\n  i - 1 < length obs'\n  obs' ! (i - 1) = ReadMem a'' al'' v\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  i - 1 < length obs'\n  obs' ! (i - 1) = ReadMem a'' al'' v\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from v i_0 obs"], ["proof (chain)\npicking this:\n  v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\n  0 < i\n  obs = NewHeapElem a' (Array_type T n) # obs'", "have \"v' \\<in> w_values P ?vs (map NormalAction (take ?i obs')) (a'', al'')\""], ["proof (prove)\nusing this:\n  v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'')\n  0 < i\n  obs = NewHeapElem a' (Array_type T n) # obs'\n\ngoal (1 subgoal):\n 1. v' \\<in> w_values P\n              (w_value P vs\n                (NormalAction (NewHeapElem a' (Array_type T n))))\n              (map NormalAction (take (i - 1) obs')) (a'', al'')", "by(simp add: take_Cons')"], ["proof (state)\nthis:\n  v' \\<in> w_values P\n            (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n            (map NormalAction (take (i - 1) obs')) (a'', al'')\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "moreover"], ["proof (state)\nthis:\n  v' \\<in> w_values P\n            (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n            (map NormalAction (take (i - 1) obs')) (a'', al'')\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "from ns i_0 obs"], ["proof (chain)\npicking this:\n  non_speculative P vs (llist_of (map NormalAction (take i obs)))\n  0 < i\n  obs = NewHeapElem a' (Array_type T n) # obs'", "have \"non_speculative P ?vs (llist_of (map NormalAction (take ?i obs')))\""], ["proof (prove)\nusing this:\n  non_speculative P vs (llist_of (map NormalAction (take i obs)))\n  0 < i\n  obs = NewHeapElem a' (Array_type T n) # obs'\n\ngoal (1 subgoal):\n 1. non_speculative P\n     (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n     (llist_of (map NormalAction (take (i - 1) obs')))", "by(simp add: take_Cons')"], ["proof (state)\nthis:\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n   (llist_of (map NormalAction (take (i - 1) obs')))\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "ultimately"], ["proof (chain)\npicking this:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  hconf h''\n  i - 1 < length obs'\n  obs' ! (i - 1) = ReadMem a'' al'' v\n  v' \\<in> w_values P\n            (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n            (map NormalAction (take (i - 1) obs')) (a'', al'')\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n   (llist_of (map NormalAction (take (i - 1) obs')))", "have \"\\<exists>obs'' h'''. heap_copies a a' ?als h'' obs'' h''' \\<and>\n                             ?i < length obs'' \\<and> take ?i obs'' = take ?i obs' \\<and> obs'' ! ?i = ReadMem a'' al'' v' \\<and>\n                             length obs'' \\<le> length obs'\""], ["proof (prove)\nusing this:\n  heap_copies a a'\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n]) h''\n   obs' h'\n  vs_conf P h''\n   (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n  list_all2 (addr_loc_type P h'' a)\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  list_all2 (addr_loc_type P h'' a')\n   (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n   (map (\\<lambda>(FD, T). fst (the (map_of FDTs FD))) FDTs @ replicate n T)\n  hconf h''\n  i - 1 < length obs'\n  obs' ! (i - 1) = ReadMem a'' al'' v\n  v' \\<in> w_values P\n            (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n            (map NormalAction (take (i - 1) obs')) (a'', al'')\n  non_speculative P\n   (w_value P vs (NormalAction (NewHeapElem a' (Array_type T n))))\n   (llist_of (map NormalAction (take (i - 1) obs')))\n\ngoal (1 subgoal):\n 1. \\<exists>obs'' h'''.\n       heap_copies a a'\n        (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n        h'' obs'' h''' \\<and>\n       i - 1 < length obs'' \\<and>\n       take (i - 1) obs'' = take (i - 1) obs' \\<and>\n       obs'' ! (i - 1) = ReadMem a'' al'' v' \\<and>\n       length obs'' \\<le> length obs'", "by(rule heap_copies_non_speculative_read[OF hrt])"], ["proof (state)\nthis:\n  \\<exists>obs'' h'''.\n     heap_copies a a'\n      (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n      h'' obs'' h''' \\<and>\n     i - 1 < length obs'' \\<and>\n     take (i - 1) obs'' = take (i - 1) obs' \\<and>\n     obs'' ! (i - 1) = ReadMem a'' al'' v' \\<and>\n     length obs'' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. \\<And>T n h'a FDTs obsa.\n       \\<lbrakk>obs = NewHeapElem a' (Array_type T n) # obsa;\n        typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>;\n        (h'a, a') \\<in> allocate h (Array_type T n);\n        P \\<turnstile> Object has_fields FDTs;\n        heap_copies a a'\n         (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n         h'a obsa h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obs' h''.\n                            heap_clone P h a h''\n                             \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                            i < length obs' \\<and>\n                            take i obs' = take i obs \\<and>\n                            obs' ! i = ReadMem a'' al'' v' \\<and>\n                            length obs' \\<le> length obs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>obs'' h'''.\n     heap_copies a a'\n      (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n      h'' obs'' h''' \\<and>\n     i - 1 < length obs'' \\<and>\n     take (i - 1) obs'' = take (i - 1) obs' \\<and>\n     obs'' ! (i - 1) = ReadMem a'' al'' v' \\<and>\n     length obs'' \\<le> length obs'\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs", "using \\<open>typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\\<close> \\<open>(h'', a') \\<in> allocate h (Array_type T n)\\<close> FDTs obs i_0"], ["proof (prove)\nusing this:\n  \\<exists>obs'' h'''.\n     heap_copies a a'\n      (map (\\<lambda>((F, D), Tfm). CField D F) FDTs @ map ACell [0..<n])\n      h'' obs'' h''' \\<and>\n     i - 1 < length obs'' \\<and>\n     take (i - 1) obs'' = take (i - 1) obs' \\<and>\n     obs'' ! (i - 1) = ReadMem a'' al'' v' \\<and>\n     length obs'' \\<le> length obs'\n  typeof_addr h a = \\<lfloor>Array_type T n\\<rfloor>\n  (h'', a') \\<in> allocate h (Array_type T n)\n  P \\<turnstile> Object has_fields FDTs\n  obs = NewHeapElem a' (Array_type T n) # obs'\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<exists>obs' h''.\n       heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n       i < length obs' \\<and>\n       take i obs' = take i obs \\<and>\n       obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs", "by(auto 4 4 intro: heap_clone.ArrClone simp add: take_Cons')"], ["proof (state)\nthis:\n  \\<exists>obs' h''.\n     heap_clone P h a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n     i < length obs' \\<and>\n     take i obs' = take i obs \\<and>\n     obs' ! i = ReadMem a'' al'' v' \\<and> length obs' \\<le> length obs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_external_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and vs: \"vs_conf P (shr s) vs\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'), shr s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\"\n  and aok: \"final_thread.actions_ok final s t ta\"\n  and hconf: \"hconf (shr s)\"\n  and i: \"i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and read: \"\\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (a'', al'')\"\n  and ns: \"non_speculative P vs (llist_of (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"\n  shows \"\\<exists>ta'' va'' h''. P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'), shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'', h''\\<rangle> \\<and> final_thread.actions_ok final s t ta'' \\<and>\n                         i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and> take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> = take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and> \n                         \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v' \\<and> length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta'' va'' h''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n                        shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n                       h''\\<rangle> \\<and>\n       final_thread.actions_ok final s t ta'' \\<and>\n       i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n       take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n       ReadMem a'' al'' v' \\<and>\n       length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n       \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "using red i read"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n                   shr s\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                h'\\<rangle>\n  i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\n\ngoal (1 subgoal):\n 1. \\<exists>ta'' va'' h''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n                        shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n                       h''\\<rangle> \\<and>\n       final_thread.actions_ok final s t ta'' \\<and>\n       i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n       take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n       ReadMem a'' al'' v' \\<and>\n       length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n       \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "proof cases"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = start; vs' = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = start; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = join; vs' = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = join; vs' = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = interrupt; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = interrupt; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = isInterrupted; vs' = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = isInterrupted; vs' = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 9. \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n     M = wait; vs' = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = shr s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n    shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',h''\\<rangle> \\<and>\n                         final_thread.actions_ok final s t ta'' \\<and>\n                         i < length\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                         take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                         take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                         \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                         ReadMem a'' al'' v' \\<and>\n                         length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                         \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 10. \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n      M = wait; vs' = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = shr s\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n     shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',h''\\<rangle> \\<and>\n                          final_thread.actions_ok final s t ta'' \\<and>\n                          i < length\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                          take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                          take i\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                          \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                          ReadMem a'' al'' v' \\<and>\n                          length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                          \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\nA total of 26 subgoals...", "case [simp]: (RedClone obs a')"], ["proof (state)\nthis:\n  M = clone\n  vs' = []\n  ta = (K$ [], [], [], [], [], obs)\n  va = RetVal (Addr a')\n  heap_clone P (shr s) a h' \\<lfloor>(obs, a')\\<rfloor>\n\ngoal (26 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = start; vs' = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = start; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = join; vs' = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = join; vs' = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = interrupt; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = interrupt; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = isInterrupted; vs' = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = isInterrupted; vs' = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 9. \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n     M = wait; vs' = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = shr s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n    shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',h''\\<rangle> \\<and>\n                         final_thread.actions_ok final s t ta'' \\<and>\n                         i < length\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                         take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                         take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                         \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                         ReadMem a'' al'' v' \\<and>\n                         length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                         \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 10. \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n      M = wait; vs' = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = shr s\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n     shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',h''\\<rangle> \\<and>\n                          final_thread.actions_ok final s t ta'' \\<and>\n                          i < length\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                          take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                          take i\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                          \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                          ReadMem a'' al'' v' \\<and>\n                          length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                          \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\nA total of 26 subgoals...", "from heap_clone_non_speculative_read[OF hrt \\<open>heap_clone P (shr s) a h' \\<lfloor>(obs, a')\\<rfloor>\\<close> vs hconf, of i a'' al'' v v'] i read v ns"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < length obs; obs ! i = ReadMem a'' al'' v;\n   v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n   non_speculative P vs (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>obs' h''.\n                       heap_clone P (shr s) a h''\n                        \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                       i < length obs' \\<and>\n                       take i obs' = take i obs \\<and>\n                       obs' ! i = ReadMem a'' al'' v' \\<and>\n                       length obs' \\<le> length obs\n  i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs\n            (map NormalAction\n              (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n            (a'', al'')\n  non_speculative P vs\n   (llist_of\n     (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length obs; obs ! i = ReadMem a'' al'' v;\n   v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n   non_speculative P vs (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>obs' h''.\n                       heap_clone P (shr s) a h''\n                        \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                       i < length obs' \\<and>\n                       take i obs' = take i obs \\<and>\n                       obs' ! i = ReadMem a'' al'' v' \\<and>\n                       length obs' \\<le> length obs\n  i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs\n            (map NormalAction\n              (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n            (a'', al'')\n  non_speculative P vs\n   (llist_of\n     (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n\ngoal (1 subgoal):\n 1. \\<exists>ta'' va'' h''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n                        shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n                       h''\\<rangle> \\<and>\n       final_thread.actions_ok final s t ta'' \\<and>\n       i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n       take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n       ReadMem a'' al'' v' \\<and>\n       length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n       \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "using aok"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length obs; obs ! i = ReadMem a'' al'' v;\n   v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n   non_speculative P vs (llist_of (map NormalAction (take i obs)))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>obs' h''.\n                       heap_clone P (shr s) a h''\n                        \\<lfloor>(obs', a')\\<rfloor> \\<and>\n                       i < length obs' \\<and>\n                       take i obs' = take i obs \\<and>\n                       obs' ! i = ReadMem a'' al'' v' \\<and>\n                       length obs' \\<le> length obs\n  i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs\n            (map NormalAction\n              (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n            (a'', al'')\n  non_speculative P vs\n   (llist_of\n     (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n  final_thread.actions_ok final s t ta\n\ngoal (1 subgoal):\n 1. \\<exists>ta'' va'' h''.\n       P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n                        shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n                       h''\\<rangle> \\<and>\n       final_thread.actions_ok final s t ta'' \\<and>\n       i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n       take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n       ReadMem a'' al'' v' \\<and>\n       length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n       \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "by(fastforce intro: red_external.RedClone simp add: final_thread.actions_ok_iff)"], ["proof (state)\nthis:\n  \\<exists>ta'' va'' h''.\n     P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n                      shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n                     h''\\<rangle> \\<and>\n     final_thread.actions_ok final s t ta'' \\<and>\n     i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n     take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n     take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n     \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n     ReadMem a'' al'' v' \\<and>\n     length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n     \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n\ngoal (25 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = start; vs' = [];\n        ta = \\<lbrace>NewThread (addr2thread_id a) (C, run, a) (shr s),\n        ThreadStart (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 2. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = start; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True\\<rbrace>;\n        va = RetEXC IllegalThreadState; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 3. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = join; vs' = [];\n        ta = \\<lbrace>Join (addr2thread_id a), IsInterrupted t False,\n        ThreadJoin (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 4. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = join; vs' = [];\n        ta = \\<lbrace>IsInterrupted t True, ClearInterrupt t,\n        ObsInterrupted t\\<rbrace>;\n        va = RetEXC InterruptedException; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 5. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = interrupt; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) True,\n        WakeUp (addr2thread_id a), Interrupt (addr2thread_id a),\n        ObsInterrupt (addr2thread_id a)\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 6. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = interrupt; vs' = [];\n        ta = \\<lbrace>ThreadExists (addr2thread_id a) False\\<rbrace>;\n        va = RetVal Unit; h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 7. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = isInterrupted; vs' = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) True,\n        ObsInterrupted (addr2thread_id a)\\<rbrace>;\n        va = RetVal (Bool True); h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 8. \\<And>C.\n       \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n        M = isInterrupted; vs' = [];\n        ta = \\<lbrace>IsInterrupted (addr2thread_id a) False\\<rbrace>;\n        va = RetVal (Bool False); h' = shr s;\n        typeof_addr (shr s) a = \\<lfloor>Class_type C\\<rfloor>;\n        P \\<turnstile> C \\<preceq>\\<^sup>* Thread\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                            P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n       shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',\n      h''\\<rangle> \\<and>\n                            final_thread.actions_ok final s t ta'' \\<and>\n                            i < length\n                                 \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                            take i\n                             \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                            \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                            ReadMem a'' al'' v' \\<and>\n                            length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                            \\<le> length\n                                   \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 9. \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n     M = wait; vs' = [];\n     ta = \\<lbrace>(Unlock, a), (Lock, a), IsInterrupted t True,\n     ClearInterrupt t, ObsInterrupted t\\<rbrace>;\n     va = RetEXC InterruptedException; h' = shr s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                         P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n    shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',h''\\<rangle> \\<and>\n                         final_thread.actions_ok final s t ta'' \\<and>\n                         i < length\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                         take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                         take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                         \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                         ReadMem a'' al'' v' \\<and>\n                         length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                         \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 10. \\<lbrakk>i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n      \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v;\n      M = wait; vs' = [];\n      ta = \\<lbrace>Suspend a, (Unlock, a), (Lock, a), (ReleaseAcquire, a),\n      IsInterrupted t False, SyncUnlock a\\<rbrace>;\n      va = RetStaySame; h' = shr s\\<rbrakk>\n     \\<Longrightarrow> \\<exists>ta'' va'' h''.\n                          P,t \\<turnstile> \\<langle>a\\<bullet>M(vs'),\n     shr s\\<rangle> -ta''\\<rightarrow>ext \\<langle>va'',h''\\<rangle> \\<and>\n                          final_thread.actions_ok final s t ta'' \\<and>\n                          i < length\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                          take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                          take i\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                          \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                          ReadMem a'' al'' v' \\<and>\n                          length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                          \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\nA total of 25 subgoals...", "qed(auto simp add: nth_Cons)"], ["", "lemma red_external_aggr_non_speculative_read:\n  assumes hrt: \"heap_read_typeable hconf P\"\n  and vs: \"vs_conf P (shr s) vs\"\n  and red: \"(ta, va, h') \\<in> red_external_aggr P t a M vs' (shr s)\"\n  and native: \"is_native P (the (typeof_addr (shr s) a)) M\"\n  and aok: \"final_thread.actions_ok final s t ta\"\n  and hconf: \"hconf (shr s)\"\n  and i: \"i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\"\n  and read: \"\\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\"\n  and v: \"v' \\<in> w_values P vs (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)) (a'', al'')\"\n  and ns: \"non_speculative P vs (llist_of (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\"\n  shows \"\\<exists>ta'' va'' h''. (ta'', va'', h'') \\<in> red_external_aggr P t a M vs' (shr s) \\<and> final_thread.actions_ok final s t ta'' \\<and>\n                         i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and> take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> = take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and> \n                         \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v' \\<and> length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta'' va'' h''.\n       (ta'', va'', h'') \\<in> red_external_aggr P t a M vs' (shr s) \\<and>\n       final_thread.actions_ok final s t ta'' \\<and>\n       i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n       take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n       ReadMem a'' al'' v' \\<and>\n       length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n       \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "using red native aok hconf i read v ns"], ["proof (prove)\nusing this:\n  (ta, va, h') \\<in> red_external_aggr P t a M vs' (shr s)\n  is_native P (the (typeof_addr (shr s) a)) M\n  final_thread.actions_ok final s t ta\n  hconf (shr s)\n  i < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! i = ReadMem a'' al'' v\n  v' \\<in> w_values P vs\n            (map NormalAction\n              (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>))\n            (a'', al'')\n  non_speculative P vs\n   (llist_of\n     (map NormalAction (take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)))\n\ngoal (1 subgoal):\n 1. \\<exists>ta'' va'' h''.\n       (ta'', va'', h'') \\<in> red_external_aggr P t a M vs' (shr s) \\<and>\n       final_thread.actions_ok final s t ta'' \\<and>\n       i < length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       take i \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n       take i \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n       \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n       ReadMem a'' al'' v' \\<and>\n       length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n       \\<le> length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "apply(simp add: red_external_aggr_def final_thread.actions_ok_iff ex_disj_distrib conj_disj_distribR split nth_Cons' del: if_split split: if_split_asm disj_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>obs a'.\n       \\<lbrakk>is_native P (the (typeof_addr (shr s) a)) clone;\n        hconf (shr s); i < length obs; obs ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n        non_speculative P vs (llist_of (map NormalAction (take i obs)));\n        lock_ok_las (locks s) t (K$ []);\n        final_thread.cond_action_oks final s t []; wset s t = None;\n        M = clone; ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        heap_clone P (shr s) a h' \\<lfloor>(obs, a')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (i = 0 \\<longrightarrow>\n                          (\\<exists>ta''.\n                              (\\<exists>va'' h'' obs.\n                                  ta'' = (K$ [], [], [], [], [], obs) \\<and>\n                                  (\\<exists>a'.\nva'' = RetVal (Addr a') \\<and>\nheap_clone P (shr s) a h'' \\<lfloor>(obs, a')\\<rfloor>)) \\<and>\n                              lock_ok_las (locks s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                              thread_oks (thr s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                              final_thread.cond_action_oks final s t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                              wset_actions_ok (wset s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                              interrupt_actions_ok (interrupts s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<noteq>\n                              [] \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! 0 =\n                              ReadMem a'' al'' v' \\<and>\n                              length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                              \\<le> length obs)) \\<and>\n                         (0 < i \\<longrightarrow>\n                          (\\<exists>ta''.\n                              (\\<exists>va'' h'' obs.\n                                  ta'' = (K$ [], [], [], [], [], obs) \\<and>\n                                  (\\<exists>a'.\nva'' = RetVal (Addr a') \\<and>\nheap_clone P (shr s) a h'' \\<lfloor>(obs, a')\\<rfloor>)) \\<and>\n                              lock_ok_las (locks s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                              thread_oks (thr s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                              final_thread.cond_action_oks final s t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                              wset_actions_ok (wset s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                              interrupt_actions_ok (interrupts s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                              i < length\n                                   \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                              take i\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                              take i obs \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                              ReadMem a'' al'' v' \\<and>\n                              length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                              \\<le> length obs))", "apply(drule heap_clone_non_speculative_read[OF hrt _ vs hconf, of _ _ _ _ i a'' al'' v v'])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>obs a'.\n       \\<lbrakk>is_native P (the (typeof_addr (shr s) a)) clone;\n        hconf (shr s); i < length obs; obs ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n        non_speculative P vs (llist_of (map NormalAction (take i obs)));\n        lock_ok_las (locks s) t (K$ []);\n        final_thread.cond_action_oks final s t []; wset s t = None;\n        M = clone; ta = (K$ [], [], [], [], [], obs);\n        va = RetVal (Addr a')\\<rbrakk>\n       \\<Longrightarrow> i < length obs\n 2. \\<And>obs a'.\n       \\<lbrakk>is_native P (the (typeof_addr (shr s) a)) clone;\n        hconf (shr s); i < length obs; obs ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n        non_speculative P vs (llist_of (map NormalAction (take i obs)));\n        lock_ok_las (locks s) t (K$ []);\n        final_thread.cond_action_oks final s t []; wset s t = None;\n        M = clone; ta = (K$ [], [], [], [], [], obs);\n        va = RetVal (Addr a')\\<rbrakk>\n       \\<Longrightarrow> obs ! i = ReadMem a'' al'' v\n 3. \\<And>obs a'.\n       \\<lbrakk>is_native P (the (typeof_addr (shr s) a)) clone;\n        hconf (shr s); i < length obs; obs ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n        non_speculative P vs (llist_of (map NormalAction (take i obs)));\n        lock_ok_las (locks s) t (K$ []);\n        final_thread.cond_action_oks final s t []; wset s t = None;\n        M = clone; ta = (K$ [], [], [], [], [], obs);\n        va = RetVal (Addr a')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> w_values P vs\n                                   (map NormalAction (take i obs))\n                                   (a'', al'')\n 4. \\<And>obs a'.\n       \\<lbrakk>is_native P (the (typeof_addr (shr s) a)) clone;\n        hconf (shr s); i < length obs; obs ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n        non_speculative P vs (llist_of (map NormalAction (take i obs)));\n        lock_ok_las (locks s) t (K$ []);\n        final_thread.cond_action_oks final s t []; wset s t = None;\n        M = clone; ta = (K$ [], [], [], [], [], obs);\n        va = RetVal (Addr a')\\<rbrakk>\n       \\<Longrightarrow> non_speculative P vs\n                          (llist_of (map NormalAction (take i obs)))\n 5. \\<And>obs a'.\n       \\<lbrakk>is_native P (the (typeof_addr (shr s) a)) clone;\n        hconf (shr s); i < length obs; obs ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n        non_speculative P vs (llist_of (map NormalAction (take i obs)));\n        lock_ok_las (locks s) t (K$ []);\n        final_thread.cond_action_oks final s t []; wset s t = None;\n        M = clone; ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        \\<exists>obs' h''.\n           heap_clone P (shr s) a h'' \\<lfloor>(obs', a')\\<rfloor> \\<and>\n           i < length obs' \\<and>\n           take i obs' = take i obs \\<and>\n           obs' ! i = ReadMem a'' al'' v' \\<and>\n           length obs' \\<le> length obs\\<rbrakk>\n       \\<Longrightarrow> (i = 0 \\<longrightarrow>\n                          (\\<exists>ta''.\n                              (\\<exists>va'' h'' obs.\n                                  ta'' = (K$ [], [], [], [], [], obs) \\<and>\n                                  (\\<exists>a'.\nva'' = RetVal (Addr a') \\<and>\nheap_clone P (shr s) a h'' \\<lfloor>(obs, a')\\<rfloor>)) \\<and>\n                              lock_ok_las (locks s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                              thread_oks (thr s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                              final_thread.cond_action_oks final s t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                              wset_actions_ok (wset s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                              interrupt_actions_ok (interrupts s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<noteq>\n                              [] \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! 0 =\n                              ReadMem a'' al'' v' \\<and>\n                              length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                              \\<le> length obs)) \\<and>\n                         (0 < i \\<longrightarrow>\n                          (\\<exists>ta''.\n                              (\\<exists>va'' h'' obs.\n                                  ta'' = (K$ [], [], [], [], [], obs) \\<and>\n                                  (\\<exists>a'.\nva'' = RetVal (Addr a') \\<and>\nheap_clone P (shr s) a h'' \\<lfloor>(obs, a')\\<rfloor>)) \\<and>\n                              lock_ok_las (locks s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                              thread_oks (thr s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                              final_thread.cond_action_oks final s t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                              wset_actions_ok (wset s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                              interrupt_actions_ok (interrupts s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                              i < length\n                                   \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                              take i\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                              take i obs \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                              ReadMem a'' al'' v' \\<and>\n                              length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                              \\<le> length obs))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>obs a'.\n       \\<lbrakk>is_native P (the (typeof_addr (shr s) a)) clone;\n        hconf (shr s); i < length obs; obs ! i = ReadMem a'' al'' v;\n        v' \\<in> w_values P vs (map NormalAction (take i obs)) (a'', al'');\n        non_speculative P vs (llist_of (map NormalAction (take i obs)));\n        lock_ok_las (locks s) t (K$ []);\n        final_thread.cond_action_oks final s t []; wset s t = None;\n        M = clone; ta = (K$ [], [], [], [], [], obs); va = RetVal (Addr a');\n        \\<exists>obs'.\n           (\\<exists>h''.\n               heap_clone P (shr s) a h''\n                \\<lfloor>(obs', a')\\<rfloor>) \\<and>\n           i < length obs' \\<and>\n           take i obs' = take i obs \\<and>\n           obs' ! i = ReadMem a'' al'' v' \\<and>\n           length obs' \\<le> length obs\\<rbrakk>\n       \\<Longrightarrow> (i = 0 \\<longrightarrow>\n                          (\\<exists>ta''.\n                              (\\<exists>va'' h'' obs.\n                                  ta'' = (K$ [], [], [], [], [], obs) \\<and>\n                                  (\\<exists>a'.\nva'' = RetVal (Addr a') \\<and>\nheap_clone P (shr s) a h'' \\<lfloor>(obs, a')\\<rfloor>)) \\<and>\n                              lock_ok_las (locks s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                              thread_oks (thr s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                              final_thread.cond_action_oks final s t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                              wset_actions_ok (wset s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                              interrupt_actions_ok (interrupts s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<noteq>\n                              [] \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! 0 =\n                              ReadMem a'' al'' v' \\<and>\n                              length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                              \\<le> length obs)) \\<and>\n                         (0 < i \\<longrightarrow>\n                          (\\<exists>ta''.\n                              (\\<exists>va'' h'' obs.\n                                  ta'' = (K$ [], [], [], [], [], obs) \\<and>\n                                  (\\<exists>a'.\nva'' = RetVal (Addr a') \\<and>\nheap_clone P (shr s) a h'' \\<lfloor>(obs, a')\\<rfloor>)) \\<and>\n                              lock_ok_las (locks s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n                              thread_oks (thr s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                              final_thread.cond_action_oks final s t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n                              wset_actions_ok (wset s) t\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n                              interrupt_actions_ok (interrupts s)\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>i\\<^esub> \\<and>\n                              i < length\n                                   \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> \\<and>\n                              take i\n                               \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> =\n                              take i obs \\<and>\n                              \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub> ! i =\n                              ReadMem a'' al'' v' \\<and>\n                              length \\<lbrace>ta''\\<rbrace>\\<^bsub>o\\<^esub>\n                              \\<le> length obs))", "apply(fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "declare split_paired_Ex [simp]"], ["", "declare eq_upto_seq_inconsist_simps [simp del]"], ["", "context allocated_heap begin"], ["", "lemma heap_copy_loc_allocated_same:\n  assumes \"heap_copy_loc a a' al h obs h'\"\n  shows \"allocated h' = allocated h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated h' = allocated h", "using assms"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h obs h'\n\ngoal (1 subgoal):\n 1. allocated h' = allocated h", "by cases(auto del: subsetI simp: heap_write_allocated_same)"], ["", "lemma heap_copy_loc_allocated_mono:\n  \"heap_copy_loc a a' al h obs h' \\<Longrightarrow> allocated h \\<subseteq> allocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_copy_loc a a' al h obs h' \\<Longrightarrow>\n    allocated h \\<subseteq> allocated h'", "by(simp add: heap_copy_loc_allocated_same)"], ["", "lemma heap_copies_allocated_same:\n  assumes \"heap_copies a a' al h obs h'\"\n  shows \"allocated h' = allocated h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated h' = allocated h", "using assms"], ["proof (prove)\nusing this:\n  heap_copies a a' al h obs h'\n\ngoal (1 subgoal):\n 1. allocated h' = allocated h", "by(induct)(auto simp add: heap_copy_loc_allocated_same)"], ["", "lemma heap_copies_allocated_mono:\n  \"heap_copies a a' al h obs h' \\<Longrightarrow> allocated h \\<subseteq> allocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_copies a a' al h obs h' \\<Longrightarrow>\n    allocated h \\<subseteq> allocated h'", "by(simp add: heap_copies_allocated_same)"], ["", "lemma heap_clone_allocated_mono:\n  assumes \"heap_clone P h a h' aobs\"\n  shows \"allocated h \\<subseteq> allocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated h \\<subseteq> allocated h'", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' aobs\n\ngoal (1 subgoal):\n 1. allocated h \\<subseteq> allocated h'", "by cases(blast del: subsetI intro: heap_copies_allocated_mono allocate_allocated_mono intro: subset_trans)+"], ["", "lemma red_external_allocated_mono:\n  assumes \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  shows \"allocated h \\<subseteq> allocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated h \\<subseteq> allocated h'", "using assms"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. allocated h \\<subseteq> allocated h'", "by(cases)(blast del: subsetI intro: heap_clone_allocated_mono heap_write_allocated_same)+"], ["", "lemma red_external_aggr_allocated_mono:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; is_native P (the (typeof_addr h a)) M \\<rbrakk>\n  \\<Longrightarrow> allocated h \\<subseteq> allocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     is_native P (the (typeof_addr h a)) M\\<rbrakk>\n    \\<Longrightarrow> allocated h \\<subseteq> allocated h'", "by(cases \"the (typeof_addr h a)\")(auto simp add: is_native.simps external_WT_defs.simps red_external_aggr_def split: if_split_asm dest: heap_clone_allocated_mono sees_method_decl_above)"], ["", "lemma heap_clone_allocatedD:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"NewHeapElem a'' x \\<in> set obs\"\n  shows \"a'' \\<in> allocated h' \\<and> a'' \\<notin> allocated h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a'' \\<in> allocated h' \\<and> a'' \\<notin> allocated h", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n  NewHeapElem a'' x \\<in> set obs\n\ngoal (1 subgoal):\n 1. a'' \\<in> allocated h' \\<and> a'' \\<notin> allocated h", "by cases(auto dest: allocate_allocatedD heap_copies_allocated_mono heap_copies_not_New)"], ["", "lemma red_external_allocatedD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> a' \\<in> allocated h' \\<and> a' \\<notin> allocated h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     NewHeapElem a' x\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> a' \\<in> allocated h' \\<and> a' \\<notin> allocated h", "by(erule red_external.cases)(auto dest: heap_clone_allocatedD)"], ["", "lemma red_external_aggr_allocatedD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     is_native P (the (typeof_addr h a)) M \\<rbrakk>\n  \\<Longrightarrow> a' \\<in> allocated h' \\<and> a' \\<notin> allocated h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     NewHeapElem a' x \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     is_native P (the (typeof_addr h a)) M\\<rbrakk>\n    \\<Longrightarrow> a' \\<in> allocated h' \\<and> a' \\<notin> allocated h", "by(auto simp add: is_native.simps external_WT_defs.simps red_external_aggr_def split: if_split_asm dest: heap_clone_allocatedD sees_method_decl_above)"], ["", "lemma heap_clone_NewHeapElemD:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"ad \\<in> allocated h'\"\n  and \"ad \\<notin> allocated h\"\n  shows \"\\<exists>CTn. NewHeapElem ad CTn \\<in> set obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>CTn. NewHeapElem ad CTn \\<in> set obs", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n  ad \\<in> allocated h'\n  ad \\<notin> allocated h\n\ngoal (1 subgoal):\n 1. \\<exists>CTn. NewHeapElem ad CTn \\<in> set obs", "by cases(auto dest!: allocate_allocatedD heap_copies_allocated_same)"], ["", "lemma heap_clone_fail_allocated_same:\n  assumes \"heap_clone P h a h' None\"\n  shows \"allocated h' = allocated h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allocated h' = allocated h", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' None\n\ngoal (1 subgoal):\n 1. allocated h' = allocated h", "by(cases)(auto)"], ["", "lemma red_external_NewHeapElemD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; a' \\<in> allocated h'; a' \\<notin> allocated h \\<rbrakk>\n  \\<Longrightarrow> \\<exists>CTn. NewHeapElem a' CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     a' \\<in> allocated h'; a' \\<notin> allocated h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>CTn.\n                         NewHeapElem a' CTn\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "by(erule red_external.cases)(auto dest: heap_clone_NewHeapElemD heap_clone_fail_allocated_same)"], ["", "lemma red_external_aggr_NewHeapElemD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; a' \\<in> allocated h'; a' \\<notin> allocated h;\n     is_native P (the (typeof_addr h a)) M \\<rbrakk>\n  \\<Longrightarrow> \\<exists>CTn. NewHeapElem a' CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     a' \\<in> allocated h'; a' \\<notin> allocated h;\n     is_native P (the (typeof_addr h a)) M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>CTn.\n                         NewHeapElem a' CTn\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "by(cases \"the (typeof_addr h a)\")(auto simp add: is_native.simps external_WT_defs.simps red_external_aggr_def split: if_split_asm dest: heap_clone_fail_allocated_same heap_clone_NewHeapElemD sees_method_decl_above)"], ["", "end"], ["", "context heap_base begin"], ["", "lemma binop_known_addrs:\n  assumes ok: \"start_heap_ok\"\n  shows \"binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor> \\<Longrightarrow> ka_Val v \\<subseteq> ka_Val v1 \\<union> ka_Val v2 \\<union> set start_addrs\"\n  and \"binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor> \\<Longrightarrow> a \\<in> ka_Val v1 \\<union> ka_Val v2 \\<union> set start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binop bop v1 v2 = \\<lfloor>Inl v\\<rfloor> \\<Longrightarrow>\n     ka_Val v\n     \\<subseteq> ka_Val v1 \\<union> ka_Val v2 \\<union> set start_addrs) &&&\n    (binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor> \\<Longrightarrow>\n     a \\<in> ka_Val v1 \\<union> ka_Val v2 \\<union> set start_addrs)", "apply(cases bop, auto split: if_split_asm)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. binop bop v1 v2 = \\<lfloor>Inr a\\<rfloor> \\<Longrightarrow>\n    a \\<in> ka_Val v1 \\<union> ka_Val v2 \\<union> set start_addrs", "apply(cases bop, auto split: if_split_asm simp add: addr_of_sys_xcpt_start_addr[OF ok])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heap_copy_loc_known_addrs_ReadMem:\n  assumes \"heap_copy_loc a a' al h ob h'\"\n  and \"ReadMem ad al' v \\<in> set ob\"\n  shows \"ad = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ad = a", "using assms"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n  ReadMem ad al' v \\<in> set ob\n\ngoal (1 subgoal):\n 1. ad = a", "by cases simp"], ["", "lemma heap_copies_known_addrs_ReadMem:\n  assumes \"heap_copies a a' als h obs h'\"\n  and \"ReadMem ad al v \\<in> set obs\"\n  shows \"ad = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ad = a", "using assms"], ["proof (prove)\nusing this:\n  heap_copies a a' als h obs h'\n  ReadMem ad al v \\<in> set obs\n\ngoal (1 subgoal):\n 1. ad = a", "by(induct)(auto dest: heap_copy_loc_known_addrs_ReadMem)"], ["", "lemma heap_clone_known_addrs_ReadMem:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"ReadMem ad al v \\<in> set obs\"\n  shows \"ad = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ad = a", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n  ReadMem ad al v \\<in> set obs\n\ngoal (1 subgoal):\n 1. ad = a", "by cases(auto dest: heap_copies_known_addrs_ReadMem)"], ["", "lemma red_external_known_addrs_ReadMem:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>; ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> ad \\<in> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     ReadMem ad al v\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> ad \\<in> {thread_id2addr t, a} \\<union>\n                               \\<Union> (ka_Val ` set vs) \\<union>\n                               set start_addrs", "by(erule red_external.cases)(simp_all add: heap_clone_known_addrs_ReadMem)"], ["", "lemma red_external_aggr_known_addrs_ReadMem:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; ReadMem ad al v \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> ad \\<in> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     ReadMem ad al v\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> ad \\<in> {thread_id2addr t, a} \\<union>\n                               \\<Union> (ka_Val ` set vs) \\<union>\n                               set start_addrs", "apply(auto simp add: red_external_aggr_def split: if_split_asm dest: heap_clone_known_addrs_ReadMem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heap_copy_loc_known_addrs_WriteMem:\n  assumes \"heap_copy_loc a a' al h ob h'\"\n  and \"ob ! n = WriteMem ad al' (Addr a'')\" \"n < length ob\"\n  shows \"a'' \\<in> new_obs_addrs (take n ob)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a'' \\<in> new_obs_addrs (take n ob)", "using assms"], ["proof (prove)\nusing this:\n  heap_copy_loc a a' al h ob h'\n  ob ! n = WriteMem ad al' (Addr a'')\n  n < length ob\n\ngoal (1 subgoal):\n 1. a'' \\<in> new_obs_addrs (take n ob)", "by cases(auto simp add: nth_Cons new_obs_addrs_def split: nat.split_asm)"], ["", "lemma heap_copies_known_addrs_WriteMem:\n  assumes \"heap_copies a a' als h obs h'\"\n  and \"obs ! n = WriteMem ad al (Addr a'')\" \"n < length obs\"\n  shows \"a'' \\<in> new_obs_addrs (take n obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a'' \\<in> new_obs_addrs (take n obs)", "using assms"], ["proof (prove)\nusing this:\n  heap_copies a a' als h obs h'\n  obs ! n = WriteMem ad al (Addr a'')\n  n < length obs\n\ngoal (1 subgoal):\n 1. a'' \\<in> new_obs_addrs (take n obs)", "by(induct arbitrary: n)(auto simp add: nth_append new_obs_addrs_def dest: heap_copy_loc_known_addrs_WriteMem split: if_split_asm)"], ["", "lemma heap_clone_known_addrs_WriteMem:\n  assumes \"heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\"\n  and \"obs ! n = WriteMem ad al (Addr a'')\" \"n < length obs\"\n  shows \"a'' \\<in> new_obs_addrs (take n obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a'' \\<in> new_obs_addrs (take n obs)", "using assms"], ["proof (prove)\nusing this:\n  heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>\n  obs ! n = WriteMem ad al (Addr a'')\n  n < length obs\n\ngoal (1 subgoal):\n 1. a'' \\<in> new_obs_addrs (take n obs)", "by cases(auto simp add: nth_Cons new_obs_addrs_def split: nat.split_asm dest: heap_copies_known_addrs_WriteMem)"], ["", "lemma red_external_known_addrs_WriteMem:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>; \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! n = WriteMem ad al (Addr a'); n < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> a' \\<in> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs \\<union> new_obs_addrs (take n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! n = WriteMem ad al (Addr a');\n     n < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> a' \\<in> {thread_id2addr t, a} \\<union>\n                               \\<Union> (ka_Val ` set vs) \\<union>\n                               set start_addrs \\<union>\n                               new_obs_addrs\n                                (take n\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)", "by(erule red_external.cases)(auto dest: heap_clone_known_addrs_WriteMem)"], ["", "lemma red_external_aggr_known_addrs_WriteMem:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! n = WriteMem ad al (Addr a'); n < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> a' \\<in> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs \\<union> new_obs_addrs (take n \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub> ! n = WriteMem ad al (Addr a');\n     n < length \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> a' \\<in> {thread_id2addr t, a} \\<union>\n                               \\<Union> (ka_Val ` set vs) \\<union>\n                               set start_addrs \\<union>\n                               new_obs_addrs\n                                (take n\n                                  \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>)", "apply(auto simp add: red_external_aggr_def split: if_split_asm dest: heap_clone_known_addrs_WriteMem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red_external_known_addrs_mono:\n  assumes ok: \"start_heap_ok\"\n  and red: \"P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>\"\n  shows \"(case va of RetVal v \\<Rightarrow> ka_Val v | RetExc a \\<Rightarrow> {a} | RetStaySame \\<Rightarrow> {}) \\<subseteq> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs \\<union> new_obs_addrs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case va of RetVal v \\<Rightarrow> ka_Val v | RetExc a \\<Rightarrow> {a}\n     | RetStaySame \\<Rightarrow> {})\n    \\<subseteq> {thread_id2addr t, a} \\<union>\n                \\<Union> (ka_Val ` set vs) \\<union>\n                set start_addrs \\<union>\n                new_obs_addrs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "using red"], ["proof (prove)\nusing this:\n  P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                   h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,h'\\<rangle>\n\ngoal (1 subgoal):\n 1. (case va of RetVal v \\<Rightarrow> ka_Val v | RetExc a \\<Rightarrow> {a}\n     | RetStaySame \\<Rightarrow> {})\n    \\<subseteq> {thread_id2addr t, a} \\<union>\n                \\<Union> (ka_Val ` set vs) \\<union>\n                set start_addrs \\<union>\n                new_obs_addrs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "by cases(auto simp add: addr_of_sys_xcpt_start_addr[OF ok] new_obs_addrs_def heap_clone.simps)"], ["", "lemma red_external_aggr_known_addrs_mono:\n  assumes ok: \"start_heap_ok\"\n  and red: \"(ta, va, h') \\<in> red_external_aggr P t a M vs h\" \"is_native P (the (typeof_addr h a)) M\"\n  shows \"(case va of RetVal v \\<Rightarrow> ka_Val v | RetExc a \\<Rightarrow> {a} | RetStaySame \\<Rightarrow> {}) \\<subseteq> {thread_id2addr t, a} \\<union> (\\<Union>(ka_Val ` set vs)) \\<union> set start_addrs \\<union> new_obs_addrs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case va of RetVal v \\<Rightarrow> ka_Val v | RetExc a \\<Rightarrow> {a}\n     | RetStaySame \\<Rightarrow> {})\n    \\<subseteq> {thread_id2addr t, a} \\<union>\n                \\<Union> (ka_Val ` set vs) \\<union>\n                set start_addrs \\<union>\n                new_obs_addrs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "using red"], ["proof (prove)\nusing this:\n  (ta, va, h') \\<in> red_external_aggr P t a M vs h\n  is_native P (the (typeof_addr h a)) M\n\ngoal (1 subgoal):\n 1. (case va of RetVal v \\<Rightarrow> ka_Val v | RetExc a \\<Rightarrow> {a}\n     | RetStaySame \\<Rightarrow> {})\n    \\<subseteq> {thread_id2addr t, a} \\<union>\n                \\<Union> (ka_Val ` set vs) \\<union>\n                set start_addrs \\<union>\n                new_obs_addrs \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "apply(cases \"the (typeof_addr h a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        is_native P (the (typeof_addr h a)) M;\n        the (typeof_addr h a) = Class_type x1\\<rbrakk>\n       \\<Longrightarrow> (case va of RetVal v \\<Rightarrow> ka_Val v\n                          | RetExc a \\<Rightarrow> {a}\n                          | RetStaySame \\<Rightarrow> {})\n                         \\<subseteq> {thread_id2addr t, a} \\<union>\n                                     \\<Union> (ka_Val ` set vs) \\<union>\n                                     set start_addrs \\<union>\n                                     new_obs_addrs\n\\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>\n 2. \\<And>x21 x22.\n       \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n        is_native P (the (typeof_addr h a)) M;\n        the (typeof_addr h a) = Array_type x21 x22\\<rbrakk>\n       \\<Longrightarrow> (case va of RetVal v \\<Rightarrow> ka_Val v\n                          | RetExc a \\<Rightarrow> {a}\n                          | RetStaySame \\<Rightarrow> {})\n                         \\<subseteq> {thread_id2addr t, a} \\<union>\n                                     \\<Union> (ka_Val ` set vs) \\<union>\n                                     set start_addrs \\<union>\n                                     new_obs_addrs\n\\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>", "apply(auto simp add: red_external_aggr_def addr_of_sys_xcpt_start_addr[OF ok] new_obs_addrs_def heap_clone.simps split: if_split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x.\n       \\<lbrakk>is_native P (Class_type x1) M;\n        the (typeof_addr h a) = Class_type x1; M \\<noteq> wait;\n        M \\<noteq> notify; M \\<noteq> notifyAll; M \\<noteq> clone;\n        M \\<noteq> hashcode; M \\<noteq> print; M \\<noteq> currentThread;\n        M \\<noteq> interrupted; M \\<noteq> yield;\n        P \\<turnstile> x1 \\<preceq>\\<^sup>* Thread; M \\<noteq> start;\n        M \\<noteq> join; M \\<noteq> interrupt; M \\<noteq> isInterrupted;\n        x \\<in> (case va of RetVal v \\<Rightarrow> ka_Val v\n                 | RetExc a \\<Rightarrow> {a}\n                 | RetStaySame \\<Rightarrow> {});\n        x \\<noteq> thread_id2addr t; x \\<noteq> a;\n        x \\<notin> set start_addrs; ta = \\<lbrace>\\<rbrace>;\n        (va, h') = undefined\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set vs. x \\<in> ka_Val xa\n 2. \\<And>x1 x.\n       \\<lbrakk>is_native P (Class_type x1) M;\n        the (typeof_addr h a) = Class_type x1; M \\<noteq> wait;\n        M \\<noteq> notify; M \\<noteq> notifyAll; M \\<noteq> clone;\n        M \\<noteq> hashcode; M \\<noteq> print; M \\<noteq> currentThread;\n        M \\<noteq> interrupted; M \\<noteq> yield;\n        \\<not> P \\<turnstile> x1 \\<preceq>\\<^sup>* Thread;\n        x \\<in> (case va of RetVal v \\<Rightarrow> ka_Val v\n                 | RetExc a \\<Rightarrow> {a}\n                 | RetStaySame \\<Rightarrow> {});\n        x \\<noteq> thread_id2addr t; x \\<noteq> a;\n        x \\<notin> set start_addrs; ta = \\<lbrace>\\<rbrace>;\n        (va, h') = undefined\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set vs. x \\<in> ka_Val xa\n 3. \\<And>x21 x22 x.\n       \\<lbrakk>is_native P (Array_type x21 x22) M;\n        the (typeof_addr h a) = Array_type x21 x22; M \\<noteq> wait;\n        M \\<noteq> notify; M \\<noteq> notifyAll; M \\<noteq> clone;\n        M \\<noteq> hashcode; M \\<noteq> print; M \\<noteq> currentThread;\n        M \\<noteq> interrupted; M \\<noteq> yield;\n        P \\<turnstile> x21\\<lfloor>\\<rceil> \\<le> Class Thread;\n        M \\<noteq> start; M \\<noteq> join; M \\<noteq> interrupt;\n        M \\<noteq> isInterrupted;\n        x \\<in> (case va of RetVal v \\<Rightarrow> ka_Val v\n                 | RetExc a \\<Rightarrow> {a}\n                 | RetStaySame \\<Rightarrow> {});\n        x \\<noteq> thread_id2addr t; x \\<noteq> a;\n        x \\<notin> set start_addrs; ta = \\<lbrace>\\<rbrace>;\n        (va, h') = undefined\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set vs. x \\<in> ka_Val xa\n 4. \\<And>x21 x22 x.\n       \\<lbrakk>is_native P (Array_type x21 x22) M;\n        the (typeof_addr h a) = Array_type x21 x22; M \\<noteq> wait;\n        M \\<noteq> notify; M \\<noteq> notifyAll; M \\<noteq> clone;\n        M \\<noteq> hashcode; M \\<noteq> print; M \\<noteq> currentThread;\n        M \\<noteq> interrupted; M \\<noteq> yield;\n        \\<not> P \\<turnstile> x21\\<lfloor>\\<rceil> \\<le> Class Thread;\n        x \\<in> (case va of RetVal v \\<Rightarrow> ka_Val v\n                 | RetExc a \\<Rightarrow> {a}\n                 | RetStaySame \\<Rightarrow> {});\n        x \\<noteq> thread_id2addr t; x \\<noteq> a;\n        x \\<notin> set start_addrs; ta = \\<lbrace>\\<rbrace>;\n        (va, h') = undefined\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set vs. x \\<in> ka_Val xa", "apply(auto simp add: is_native.simps elim!: external_WT_defs.cases dest: sees_method_decl_above)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red_external_NewThread_idD:\n  \"\\<lbrakk> P,t \\<turnstile> \\<langle>a\\<bullet>M(vs), h\\<rangle> -ta\\<rightarrow>ext \\<langle>va, h'\\<rangle>; NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> t' = addr2thread_id a \\<and> a' = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<langle>a\\<bullet>M(vs),\n                              h\\<rangle> -ta\\<rightarrow>ext \\<langle>va,\n                       h'\\<rangle>;\n     NewThread t' (C, M', a') h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> t' = addr2thread_id a \\<and> a' = a", "by(erule red_external.cases) simp_all"], ["", "lemma red_external_aggr_NewThread_idD:\n  \"\\<lbrakk> (ta, va, h') \\<in> red_external_aggr P t a M vs h; \n     NewThread t' (C, M', a') h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> t' = addr2thread_id a \\<and> a' = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> red_external_aggr P t a M vs h;\n     NewThread t' (C, M', a') h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> t' = addr2thread_id a \\<and> a' = a", "apply(auto simp add: red_external_aggr_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale heap'' = \n  heap'\n    addr2thread_id thread_id2addr\n    spurious_wakeups\n    empty_heap allocate typeof_addr heap_read heap_write\n    P\n  for addr2thread_id :: \"('addr :: addr) \\<Rightarrow> 'thread_id\"\n  and thread_id2addr :: \"'thread_id \\<Rightarrow> 'addr\"\n  and spurious_wakeups :: bool\n  and empty_heap :: \"'heap\"\n  and allocate :: \"'heap \\<Rightarrow> htype \\<Rightarrow> ('heap \\<times> 'addr) set\"\n  and typeof_addr :: \"'addr \\<rightharpoonup> htype\"\n  and heap_read :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> bool\"\n  and heap_write :: \"'heap \\<Rightarrow> 'addr \\<Rightarrow> addr_loc \\<Rightarrow> 'addr val \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  and P :: \"'m prog\"\n  +\n  assumes allocate_typeof_addr_SomeD: \"\\<lbrakk> (h', a) \\<in> allocate h hT; typeof_addr a \\<noteq> None \\<rbrakk> \\<Longrightarrow> typeof_addr a = \\<lfloor>hT\\<rfloor>\"\nbegin"], ["", "lemma heap_copy_loc_New_type_match:\n  \"\\<lbrakk> h.heap_copy_loc a a' al h obs h'; NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h.heap_copy_loc a a' al h obs h';\n     NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(erule h.heap_copy_loc.cases) simp"], ["", "lemma heap_copies_New_type_match:\n  \"\\<lbrakk> h.heap_copies a a' als h obs h'; NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h.heap_copies a a' als h obs h';\n     NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(induct rule: h.heap_copies.induct)(auto dest: heap_copy_loc_New_type_match)"], ["", "lemma heap_clone_New_type_match:\n  \"\\<lbrakk> h.heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>; NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h.heap_clone P h a h' \\<lfloor>(obs, a')\\<rfloor>;\n     NewHeapElem ad CTn \\<in> set obs; typeof_addr ad \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(erule h.heap_clone.cases)(auto dest: allocate_typeof_addr_SomeD heap_copies_New_type_match)"], ["", "lemma red_external_New_type_match:\n  \"\\<lbrakk> h.red_external P t a M vs h ta va h'; NewHeapElem ad CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h.red_external_syntax P t M vs h a ta va h';\n     NewHeapElem ad CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     typeof_addr ad \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(erule h.red_external.cases)(auto dest: heap_clone_New_type_match)"], ["", "lemma red_external_aggr_New_type_match:\n  \"\\<lbrakk> (ta, va, h') \\<in> h.red_external_aggr P t a M vs h; NewHeapElem ad CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>; typeof_addr ad \\<noteq> None \\<rbrakk>\n  \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, va, h') \\<in> h.red_external_aggr P t a M vs h;\n     NewHeapElem ad CTn \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>o\\<^esub>;\n     typeof_addr ad \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typeof_addr ad = \\<lfloor>CTn\\<rfloor>", "by(auto simp add: h.red_external_aggr_def split: if_split_asm dest: heap_clone_New_type_match)"], ["", "end"], ["", "end"]]}