{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWSemantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma actions_ok_iff [simp]:\n  \"actions_ok s t ta \\<longleftrightarrow>\n   lock_ok_las (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and> cond_action_oks s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and> interrupt_actions_ok (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\"", "lemma actions_ok_thread_oksD:\n  \"actions_ok s t ta \\<Longrightarrow> thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\"", "lemma actions_ok'_iff:\n  \"actions_ok' s t ta \\<longleftrightarrow>\n   lock_ok_las' (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and> cond_action_oks' s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and> interrupt_actions_ok' (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\"", "lemma actions_ok'_ta_upd_obs:\n  \"actions_ok' s t (ta_update_obs ta obs) \\<longleftrightarrow> actions_ok' s t ta\"", "lemma actions_ok'_empty: \"actions_ok' s t \\<epsilon> \\<longleftrightarrow> wset s t = None\"", "lemma actions_ok'_convert_extTA:\n  \"actions_ok' s t (convert_extTA f ta) = actions_ok' s t ta\"", "lemma actions_subset_iff:\n  \"actions_subset ta' ta \\<longleftrightarrow> \n   collect_locks' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n   collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\"", "lemma actions_subset_refl [intro]:\n  \"actions_subset ta ta\"", "lemma [iff]: \"t \\<in> final_threads s = final_thread s t\"", "lemma [pred_set_conv]: \"final_thread s = (\\<lambda>t. t \\<in> final_threads s)\"", "lemma final_threadI:\n  \"\\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; final x; wset s t = None \\<rbrakk> \\<Longrightarrow> final_thread s t\"", "lemma final_threadE:\n  assumes \"final_thread s t\"\n  obtains x where \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"final x\" \"wset s t = None\"", "lemma mfinalI:\n  \"(\\<And>t x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> final x \\<and> ln = no_wait_locks \\<and> wset s t = None) \\<Longrightarrow> mfinal s\"", "lemma mfinalD:\n  fixes ln\n  assumes \"mfinal s\" \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n  shows \"final x\" \"ln = no_wait_locks\" \"wset s t = None\"", "lemma mfinalE:\n  fixes ln\n  assumes \"mfinal s\" \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n  obtains \"final x\" \"ln = no_wait_locks\" \"wset s t = None\"", "lemma mfinal_def2: \"mfinal s \\<longleftrightarrow> dom (thr s) \\<subseteq> final_threads s\"", "lemma redT_elims [consumes 1, case_names normal acquire]:\n  assumes red: \"s -t\\<triangleright>ta\\<rightarrow> s'\"\n  and normal: \"\\<And>x x' m' ws'.\n    \\<lbrakk> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n      lock_ok_las (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n      thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n      cond_action_oks s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n      wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n      interrupt_actions_ok (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n      redT_updWs t (wset s) \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws';\n      s' = (redT_updLs (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>, (redT_updTs (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto> (x', redT_updLns (locks s) t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)), m'), ws', redT_updIs (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>) \\<rbrakk>\n    \\<Longrightarrow> thesis\"\n   and acquire: \"\\<And>x ln n.\n    \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n      ta = (K$ [], [], [], [], [], convert_RA ln);\n      \\<not> waiting (wset s t);\n      may_acquire_all (locks s) t ln; 0 < ln $ n;\n      s' = (acquire_all (locks s) t ln, (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s) \\<rbrakk>\n    \\<Longrightarrow> thesis\"\n  shows thesis", "lemma RedTI:\n  \"rtrancl3p redT s ttas s' \\<Longrightarrow> RedT s ttas s'\"", "lemma RedTE:\n  \"\\<lbrakk> RedT s ttas s'; rtrancl3p redT s ttas s' \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma RedTD:\n  \"RedT s ttas s' \\<Longrightarrow> rtrancl3p redT s ttas s'\"", "lemma RedT_induct [consumes 1, case_names refl step]:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s';\n     \\<And>s. P s [] s;\n     \\<And>s ttas s' t ta s''. \\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; P s ttas s'; s' -t\\<triangleright>ta\\<rightarrow> s'' \\<rbrakk> \\<Longrightarrow> P s (ttas @ [(t, ta)]) s''\\<rbrakk>\n  \\<Longrightarrow> P s ttas s'\"", "lemma RedT_induct' [consumes 1, case_names refl step]:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s';\n     P s [] s;\n     \\<And>ttas s' t ta s''. \\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; P s ttas s'; s' -t\\<triangleright>ta\\<rightarrow> s'' \\<rbrakk> \\<Longrightarrow> P s (ttas @ [(t, ta)]) s''\\<rbrakk>\n  \\<Longrightarrow> P s ttas s'\"", "lemma RedT_lift_preserveD:\n  assumes Red: \"s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and P: \"P s\"\n  and preserve: \"\\<And>s t tas s'. \\<lbrakk> s -t\\<triangleright>tas\\<rightarrow> s'; P s \\<rbrakk> \\<Longrightarrow> P s'\"\n  shows \"P s'\"", "lemma RedT_refl [intro, simp]:\n  \"s -\\<triangleright>[]\\<rightarrow>* s\"", "lemma redT_has_locks_inv:\n  \"\\<lbrakk> \\<langle>ls, (ts, m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts', m'), ws', is'\\<rangle>; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow>\n  has_locks (ls $ l) t' = has_locks (ls' $ l) t'\"", "lemma redT_has_lock_inv:\n  \"\\<lbrakk> \\<langle>ls, (ts, m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts', m'), ws', is'\\<rangle>; t \\<noteq> t' \\<rbrakk>\n  \\<Longrightarrow> has_lock (ls' $ l) t' = has_lock (ls $ l) t'\"", "lemma redT_ts_Some_inv:\n  \"\\<lbrakk> \\<langle>ls, (ts, m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts', m'), ws', is'\\<rangle>; t \\<noteq> t'; ts t' = \\<lfloor>x\\<rfloor> \\<rbrakk> \\<Longrightarrow> ts' t' = \\<lfloor>x\\<rfloor>\"", "lemma redT_thread_not_disappear:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; thr s' t' = None\\<rbrakk> \\<Longrightarrow> thr s t' = None\"", "lemma RedT_thread_not_disappear:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; thr s' t' = None\\<rbrakk> \\<Longrightarrow> thr s t' = None\"", "lemma redT_preserves_wset_thread_ok:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; wset_thread_ok (wset s) (thr s) \\<rbrakk> \\<Longrightarrow> wset_thread_ok (wset s') (thr s')\"", "lemma RedT_preserves_wset_thread_ok:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; wset_thread_ok (wset s) (thr s) \\<rbrakk> \\<Longrightarrow> wset_thread_ok (wset s') (thr s')\"", "lemma redT_new_thread_ts_Some:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; NewThread t' x m'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>; wset_thread_ok (wset s) (thr s) \\<rbrakk>\n  \\<Longrightarrow> thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"", "lemma RedT_new_thread_ts_not_None:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) ttas)); wset_thread_ok (wset s) (thr s) \\<rbrakk>\n   \\<Longrightarrow> thr s' t \\<noteq> None\"", "lemma redT_preserves_lock_thread_ok:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; lock_thread_ok (locks s) (thr s) \\<rbrakk> \\<Longrightarrow> lock_thread_ok (locks s') (thr s')\"", "lemma RedT_preserves_lock_thread_ok:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; lock_thread_ok (locks s) (thr s) \\<rbrakk> \\<Longrightarrow> lock_thread_ok (locks s') (thr s')\"", "lemma redT_ex_new_thread:\n  assumes \"s -t'\\<triangleright>ta\\<rightarrow> s'\" \"wset_thread_ok (wset s) (thr s)\" \"thr s' t = \\<lfloor>(x, w)\\<rfloor>\" \"thr s t = None\"\n  shows \"\\<exists>m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and> w = no_wait_locks\"", "lemma redT_ex_new_thread':\n  assumes \"s -t'\\<triangleright>ta\\<rightarrow> s'\" \"thr s' t = \\<lfloor>(x, w)\\<rfloor>\" \"thr s t = None\"\n  shows \"\\<exists>m x. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\"", "lemma determisticI:\n  \"\\<lbrakk>\\<And>s t x ta' x' m' ta'' x'' m''.\n      \\<lbrakk> s \\<in> I; thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \n        t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>; t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>; \n        actions_ok s t ta'; actions_ok s t ta'' \\<rbrakk>\n      \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m'';\n    invariant3p redT I \\<rbrakk>\n  \\<Longrightarrow> deterministic I\"", "lemma deterministicD:\n  \"\\<lbrakk> deterministic I;\n    t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>; t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n    thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta'; actions_ok s t ta''; s \\<in> I \\<rbrakk>\n  \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\"", "lemma deterministic_invariant3p:\n  \"deterministic I \\<Longrightarrow> invariant3p redT I\"", "lemma deterministic_THE:\n  \"\\<lbrakk> deterministic I; thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>; actions_ok s t ta; s \\<in> I \\<rbrakk>\n  \\<Longrightarrow> (THE (ta, x', m'). t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and> actions_ok s t ta) = (ta, x', m')\"", "lemma redT_new_thread_common:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; NewThread t' x m'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>; \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = [] \\<rbrakk> \\<Longrightarrow> m'' = shr s'\"", "lemma redT_new_thread:\n  assumes \"s -t'\\<triangleright>ta\\<rightarrow> s'\" \"thr s' t = \\<lfloor>(x, w)\\<rfloor>\" \"thr s t = None\" \"\\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = []\"\n  shows \"NewThread t x (shr s') \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and> w = no_wait_locks\"", "lemma final_no_redT: \n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<rbrakk> \\<Longrightarrow> \\<not> final x\"", "lemma mfinal_no_redT:\n  assumes redT: \"s -t\\<triangleright>ta\\<rightarrow> s'\" and mfinal: \"mfinal s\"\n  shows False"], "translations": [["", "lemma actions_ok_iff [simp]:\n  \"actions_ok s t ta \\<longleftrightarrow>\n   lock_ok_las (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and> cond_action_oks s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and> interrupt_actions_ok (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions_ok s t ta =\n    (lock_ok_las (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n     cond_action_oks s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n     interrupt_actions_ok (interrupts s)\n      \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)", "by(auto)"], ["", "lemma actions_ok_thread_oksD:\n  \"actions_ok s t ta \\<Longrightarrow> thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions_ok s t ta \\<Longrightarrow>\n    thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "by(erule actions_ok.cases)"], ["", "inductive actions_ok' :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x','m,'w,'o) thread_action \\<Rightarrow> bool\" where\n  \"\\<lbrakk> lock_ok_las' (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>; thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>; cond_action_oks' s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n     wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>; interrupt_actions_ok' (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> actions_ok' s t ta\""], ["", "declare actions_ok'.intros [intro!]"], ["", "declare actions_ok'.cases [elim!]"], ["", "lemma actions_ok'_iff:\n  \"actions_ok' s t ta \\<longleftrightarrow>\n   lock_ok_las' (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and> cond_action_oks' s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and> interrupt_actions_ok' (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions_ok' s t ta =\n    (lock_ok_las' (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n     cond_action_oks' s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n     interrupt_actions_ok' (interrupts s)\n      \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)", "by auto"], ["", "lemma actions_ok'_ta_upd_obs:\n  \"actions_ok' s t (ta_update_obs ta obs) \\<longleftrightarrow> actions_ok' s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions_ok' s t (ta_update_obs ta obs) = actions_ok' s t ta", "by(auto simp add: actions_ok'_iff lock_ok_las'_def ta_upd_simps wset_actions_ok_def)"], ["", "lemma actions_ok'_empty: \"actions_ok' s t \\<epsilon> \\<longleftrightarrow> wset s t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions_ok' s t \\<lbrace>\\<rbrace> = (wset s t = None)", "by(simp add: actions_ok'_iff lock_ok_las'_def)"], ["", "lemma actions_ok'_convert_extTA:\n  \"actions_ok' s t (convert_extTA f ta) = actions_ok' s t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions_ok' s t (convert_extTA f ta) = actions_ok' s t ta", "by(simp add: actions_ok'_iff)"], ["", "inductive actions_subset :: \"('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> ('l,'t,'x','m,'w,'o) thread_action \\<Rightarrow> bool\"\nwhere\n \"\\<lbrakk> collect_locks' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>; \n    collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n    collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> actions_subset ta' ta\""], ["", "declare actions_subset.intros [intro!]"], ["", "declare actions_subset.cases [elim!]"], ["", "lemma actions_subset_iff:\n  \"actions_subset ta' ta \\<longleftrightarrow> \n   collect_locks' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub> \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n   collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub> \\<subseteq> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub> \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions_subset ta' ta =\n    (collect_locks' \\<lbrace>ta'\\<rbrace>\\<^bsub>l\\<^esub>\n     \\<subseteq> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and>\n     collect_cond_actions \\<lbrace>ta'\\<rbrace>\\<^bsub>c\\<^esub>\n     \\<subseteq> collect_cond_actions\n                  \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n     collect_interrupts \\<lbrace>ta'\\<rbrace>\\<^bsub>i\\<^esub>\n     \\<subseteq> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)", "by auto"], ["", "lemma actions_subset_refl [intro]:\n  \"actions_subset ta ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions_subset ta ta", "by(auto intro: actions_subset.intros collect_locks'_subset_collect_locks del: subsetI)"], ["", "definition final_thread :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't \\<Rightarrow> bool\" where\n  \"\\<And>ln. final_thread s t \\<equiv> (case thr s t of None \\<Rightarrow> False | \\<lfloor>(x, ln)\\<rfloor> \\<Rightarrow> final x \\<and> ln = no_wait_locks \\<and> wset s t = None)\""], ["", "definition final_threads :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't set\" \nwhere \"final_threads s \\<equiv> {t. final_thread s t}\""], ["", "lemma [iff]: \"t \\<in> final_threads s = final_thread s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<in> final_threads s) = final_thread s t", "by (simp add: final_threads_def)"], ["", "lemma [pred_set_conv]: \"final_thread s = (\\<lambda>t. t \\<in> final_threads s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread s = (\\<lambda>t. t \\<in> final_threads s)", "by simp"], ["", "definition mfinal :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> bool\"\nwhere \"mfinal s \\<longleftrightarrow> (\\<forall>t x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<longrightarrow> final x \\<and> ln = no_wait_locks \\<and> wset s t = None)\""], ["", "lemma final_threadI:\n  \"\\<lbrakk> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; final x; wset s t = None \\<rbrakk> \\<Longrightarrow> final_thread s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; final x;\n     wset s t = None\\<rbrakk>\n    \\<Longrightarrow> final_thread s t", "by(simp add: final_thread_def)"], ["", "lemma final_threadE:\n  assumes \"final_thread s t\"\n  obtains x where \"thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \"final x\" \"wset s t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; final x;\n         wset s t = None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  final_thread s t\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; final x;\n         wset s t = None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: final_thread_def)"], ["", "lemma mfinalI:\n  \"(\\<And>t x ln. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> final x \\<and> ln = no_wait_locks \\<and> wset s t = None) \\<Longrightarrow> mfinal s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow>\n        final x \\<and>\n        ln = no_wait_locks \\<and> wset s t = None) \\<Longrightarrow>\n    mfinal s", "unfolding mfinal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t x ln.\n        thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow>\n        final x \\<and>\n        ln = no_wait_locks \\<and> wset s t = None) \\<Longrightarrow>\n    \\<forall>t x ln.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<longrightarrow>\n       final x \\<and> ln = no_wait_locks \\<and> wset s t = None", "by blast"], ["", "lemma mfinalD:\n  fixes ln\n  assumes \"mfinal s\" \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n  shows \"final x\" \"ln = no_wait_locks\" \"wset s t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final x &&& ln = no_wait_locks &&& wset s t = None", "using assms"], ["proof (prove)\nusing this:\n  mfinal s\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. final x &&& ln = no_wait_locks &&& wset s t = None", "unfolding mfinal_def"], ["proof (prove)\nusing this:\n  \\<forall>t x ln.\n     thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<longrightarrow>\n     final x \\<and> ln = no_wait_locks \\<and> wset s t = None\n  thr s t = \\<lfloor>(x, ln)\\<rfloor>\n\ngoal (1 subgoal):\n 1. final x &&& ln = no_wait_locks &&& wset s t = None", "by blast+"], ["", "lemma mfinalE:\n  fixes ln\n  assumes \"mfinal s\" \"thr s t = \\<lfloor>(x, ln)\\<rfloor>\"\n  obtains \"final x\" \"ln = no_wait_locks\" \"wset s t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>final x; ln = no_wait_locks; wset s t = None\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mfinalD[OF assms]"], ["proof (prove)\nusing this:\n  final x\n  ln = no_wait_locks\n  wset s t = None\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>final x; ln = no_wait_locks; wset s t = None\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule that)"], ["", "lemma mfinal_def2: \"mfinal s \\<longleftrightarrow> dom (thr s) \\<subseteq> final_threads s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mfinal s = (dom (thr s) \\<subseteq> final_threads s)", "by(fastforce elim: mfinalE final_threadE intro: mfinalI final_threadI)"], ["", "end"], ["", "locale multithreaded_base = final_thread +\n  constrains final :: \"'x \\<Rightarrow> bool\" \n  fixes r :: \"('l,'t,'x,'m,'w,'o) semantics\" (\"_ \\<turnstile> _ -_\\<rightarrow> _\" [50,0,0,50] 80)\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\nbegin"], ["", "abbreviation\n  r_syntax :: \"'t \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> bool\"\n              (\"_ \\<turnstile> \\<langle>_, _\\<rangle> -_\\<rightarrow> \\<langle>_, _\\<rangle>\" [50,0,0,0,0,0] 80)\nwhere\n  \"t \\<turnstile> \\<langle>x, m\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<equiv> t \\<turnstile> (x, m) -ta\\<rightarrow> (x', m')\""], ["", "inductive\n  redT :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't \\<times> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> ('l,'t,'x,'m,'w) state \\<Rightarrow> bool\" and\n  redT_syntax1 :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> ('l,'t,'x,'m,'w) state \\<Rightarrow> bool\" (\"_ -_\\<triangleright>_\\<rightarrow> _\" [50,0,0,50] 80)\nwhere\n  \"s -t\\<triangleright>ta\\<rightarrow> s' \\<equiv> redT s (t, ta) s'\"\n\n|  redT_normal:\n  \"\\<lbrakk> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n     actions_ok s t ta;\n     redT_upd s t ta x' m' s' \\<rbrakk>\n  \\<Longrightarrow> s -t\\<triangleright>ta\\<rightarrow> s'\"\n\n| redT_acquire:\n  \"\\<And>ln. \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n     may_acquire_all (locks s) t ln; ln $ n > 0;\n     s' = (acquire_all (locks s) t ln, (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s) \\<rbrakk>\n  \\<Longrightarrow> s -t\\<triangleright>((K$ []), [], [], [], [], convert_RA ln)\\<rightarrow> s'\""], ["", "abbreviation\n  redT_syntax2 :: \"('l,'t) locks \\<Rightarrow> ('l,'t,'x) thread_info \\<times> 'm \\<Rightarrow> ('w,'t) wait_sets \\<Rightarrow> 't interrupts\n                   \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action\n                   \\<Rightarrow> ('l,'t) locks \\<Rightarrow> ('l,'t,'x) thread_info \\<times> 'm \\<Rightarrow> ('w,'t) wait_sets \\<Rightarrow> 't interrupts \\<Rightarrow> bool\"\n                  (\"\\<langle>_, _, _, _\\<rangle> -_\\<triangleright>_\\<rightarrow> \\<langle>_, _, _, _\\<rangle>\" [0,0,0,0,0,0,0,0,0] 80)\nwhere\n  \"\\<langle>ls, tsm, ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', tsm', ws', is'\\<rangle> \\<equiv> (ls, tsm, ws, is) -t\\<triangleright>ta\\<rightarrow> (ls', tsm', ws', is')\""], ["", "lemma redT_elims [consumes 1, case_names normal acquire]:\n  assumes red: \"s -t\\<triangleright>ta\\<rightarrow> s'\"\n  and normal: \"\\<And>x x' m' ws'.\n    \\<lbrakk> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n      thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n      lock_ok_las (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n      thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n      cond_action_oks s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n      wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n      interrupt_actions_ok (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n      redT_updWs t (wset s) \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws';\n      s' = (redT_updLs (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>, (redT_updTs (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto> (x', redT_updLns (locks s) t no_wait_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)), m'), ws', redT_updIs (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>) \\<rbrakk>\n    \\<Longrightarrow> thesis\"\n   and acquire: \"\\<And>x ln n.\n    \\<lbrakk> thr s t = \\<lfloor>(x, ln)\\<rfloor>;\n      ta = (K$ [], [], [], [], [], convert_RA ln);\n      \\<not> waiting (wset s t);\n      may_acquire_all (locks s) t ln; 0 < ln $ n;\n      s' = (acquire_all (locks s) t ln, (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s, interrupts s) \\<rbrakk>\n    \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using red"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case redT_normal"], ["proof (state)\nthis:\n  t \\<turnstile> \\<langle>x_, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'_, m'_\\<rangle>\n  thr s t = \\<lfloor>(x_, no_wait_locks)\\<rfloor>\n  actions_ok s t ta\n  redT_upd s t ta x'_ m'_ s'\n\ngoal (2 subgoals):\n 1. \\<And>x x' m'.\n       \\<lbrakk>t \\<turnstile> \\<langle>x, shr\n      s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta;\n        redT_upd s t ta x' m' s'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x_, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'_, m'_\\<rangle>\n  thr s t = \\<lfloor>(x_, no_wait_locks)\\<rfloor>\n  actions_ok s t ta\n  redT_upd s t ta x'_ m'_ s'\n\ngoal (1 subgoal):\n 1. thesis", "using normal"], ["proof (prove)\nusing this:\n  t \\<turnstile> \\<langle>x_, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x'_, m'_\\<rangle>\n  thr s t = \\<lfloor>(x_, no_wait_locks)\\<rfloor>\n  actions_ok s t ta\n  redT_upd s t ta x'_ m'_ s'\n  \\<lbrakk>t \\<turnstile> \\<langle>?x11, shr\n    s\\<rangle> -ta\\<rightarrow> \\<langle>?x'11, ?m'11\\<rangle>;\n   thr s t = \\<lfloor>(?x11, no_wait_locks)\\<rfloor>;\n   lock_ok_las (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n   thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n   cond_action_oks s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n   wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n   interrupt_actions_ok (interrupts s)\n    \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n   redT_updWs t (wset s) \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ?ws'11;\n   s' =\n   (redT_updLs (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n    (redT_updTs (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t \\<mapsto>\n     (?x'11,\n      redT_updLns (locks s) t no_wait_locks\n       \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n     ?m'11),\n    ?ws'11,\n    redT_updIs (interrupts s)\n     \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(cases s')(auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case redT_acquire"], ["proof (state)\nthis:\n  ta = (K$ [], [], [], [], [], convert_RA ln_)\n  thr s t = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t ln_\n  0 < ln_ $ n_\n  s' =\n  (acquire_all (locks s) t ln_,\n   (thr s(t \\<mapsto> (x_, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. \\<And>x n ln.\n       \\<lbrakk>ta = (K$ [], [], [], [], [], convert_RA ln);\n        thr s t = \\<lfloor>(x, ln)\\<rfloor>; \\<not> waiting (wset s t);\n        may_acquire_all (locks s) t ln; 0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t ln,\n         (thr s(t \\<mapsto> (x, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  ta = (K$ [], [], [], [], [], convert_RA ln_)\n  thr s t = \\<lfloor>(x_, ln_)\\<rfloor>\n  \\<not> waiting (wset s t)\n  may_acquire_all (locks s) t ln_\n  0 < ln_ $ n_\n  s' =\n  (acquire_all (locks s) t ln_,\n   (thr s(t \\<mapsto> (x_, no_wait_locks)), shr s), wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. thesis", "by-(rule acquire, fastforce+)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  RedT :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> ('t \\<times> ('l,'t,'x,'m,'w,'o) thread_action) list \\<Rightarrow> ('l,'t,'x,'m,'w) state \\<Rightarrow> bool\"\n          (\"_ -\\<triangleright>_\\<rightarrow>* _\" [50,0,50] 80)\nwhere\n  \"RedT \\<equiv> rtrancl3p redT\""], ["", "lemma RedTI:\n  \"rtrancl3p redT s ttas s' \\<Longrightarrow> RedT s ttas s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtrancl3p redT s ttas s' \\<Longrightarrow>\n    s -\\<triangleright>ttas\\<rightarrow>* s'", "by(simp add: RedT_def)"], ["", "lemma RedTE:\n  \"\\<lbrakk> RedT s ttas s'; rtrancl3p redT s ttas s' \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n     rtrancl3p redT s ttas s' \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by(auto simp add: RedT_def)"], ["", "lemma RedTD:\n  \"RedT s ttas s' \\<Longrightarrow> rtrancl3p redT s ttas s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<triangleright>ttas\\<rightarrow>* s' \\<Longrightarrow>\n    rtrancl3p redT s ttas s'", "by(simp add: RedT_def)"], ["", "lemma RedT_induct [consumes 1, case_names refl step]:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s';\n     \\<And>s. P s [] s;\n     \\<And>s ttas s' t ta s''. \\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; P s ttas s'; s' -t\\<triangleright>ta\\<rightarrow> s'' \\<rbrakk> \\<Longrightarrow> P s (ttas @ [(t, ta)]) s''\\<rbrakk>\n  \\<Longrightarrow> P s ttas s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s'; \\<And>s. P s [] s;\n     \\<And>s ttas s' t ta s''.\n        \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s'; P s ttas s';\n         s' -t\\<triangleright>ta\\<rightarrow> s''\\<rbrakk>\n        \\<Longrightarrow> P s (ttas @ [(t, ta)]) s''\\<rbrakk>\n    \\<Longrightarrow> P s ttas s'", "unfolding RedT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtrancl3p redT s ttas s'; \\<And>s. P s [] s;\n     \\<And>s ttas s' t ta s''.\n        \\<lbrakk>rtrancl3p redT s ttas s'; P s ttas s';\n         s' -t\\<triangleright>ta\\<rightarrow> s''\\<rbrakk>\n        \\<Longrightarrow> P s (ttas @ [(t, ta)]) s''\\<rbrakk>\n    \\<Longrightarrow> P s ttas s'", "by(erule rtrancl3p.induct) auto"], ["", "lemma RedT_induct' [consumes 1, case_names refl step]:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s';\n     P s [] s;\n     \\<And>ttas s' t ta s''. \\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; P s ttas s'; s' -t\\<triangleright>ta\\<rightarrow> s'' \\<rbrakk> \\<Longrightarrow> P s (ttas @ [(t, ta)]) s''\\<rbrakk>\n  \\<Longrightarrow> P s ttas s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s'; P s [] s;\n     \\<And>ttas s' t ta s''.\n        \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s'; P s ttas s';\n         s' -t\\<triangleright>ta\\<rightarrow> s''\\<rbrakk>\n        \\<Longrightarrow> P s (ttas @ [(t, ta)]) s''\\<rbrakk>\n    \\<Longrightarrow> P s ttas s'", "unfolding RedT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtrancl3p redT s ttas s'; P s [] s;\n     \\<And>ttas s' t ta s''.\n        \\<lbrakk>rtrancl3p redT s ttas s'; P s ttas s';\n         s' -t\\<triangleright>ta\\<rightarrow> s''\\<rbrakk>\n        \\<Longrightarrow> P s (ttas @ [(t, ta)]) s''\\<rbrakk>\n    \\<Longrightarrow> P s ttas s'", "apply(erule rtrancl3p_induct', blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs a' b a''.\n       \\<lbrakk>P s [] s;\n        \\<And>ttas s' t ta s''.\n           \\<lbrakk>rtrancl3p redT s ttas s'; P s ttas s';\n            s' -t\\<triangleright>ta\\<rightarrow> s''\\<rbrakk>\n           \\<Longrightarrow> P s (ttas @ [(t, ta)]) s'';\n        rtrancl3p redT s bs a'; P s bs a'; redT a' b a''\\<rbrakk>\n       \\<Longrightarrow> P s (bs @ [b]) a''", "apply(case_tac b, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RedT_lift_preserveD:\n  assumes Red: \"s -\\<triangleright>ttas\\<rightarrow>* s'\"\n  and P: \"P s\"\n  and preserve: \"\\<And>s t tas s'. \\<lbrakk> s -t\\<triangleright>tas\\<rightarrow> s'; P s \\<rbrakk> \\<Longrightarrow> P s'\"\n  shows \"P s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s'", "using Red P"], ["proof (prove)\nusing this:\n  s -\\<triangleright>ttas\\<rightarrow>* s'\n  P s\n\ngoal (1 subgoal):\n 1. P s'", "by(induct rule: RedT_induct)(auto intro: preserve)"], ["", "lemma RedT_refl [intro, simp]:\n  \"s -\\<triangleright>[]\\<rightarrow>* s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\\<triangleright>[]\\<rightarrow>* s", "by(rule RedTI)(rule rtrancl3p_refl)"], ["", "lemma redT_has_locks_inv:\n  \"\\<lbrakk> \\<langle>ls, (ts, m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts', m'), ws', is'\\<rangle>; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow>\n  has_locks (ls $ l) t' = has_locks (ls' $ l) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>ls, (ts,\n                           m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts',\n                    m'), ws', is'\\<rangle>;\n     t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (ls $ l) t' = has_locks (ls' $ l) t'", "by(auto elim!: redT.cases intro: redT_updLs_has_locks[THEN sym, simplified] may_acquire_all_has_locks_acquire_locks[symmetric])"], ["", "lemma redT_has_lock_inv:\n  \"\\<lbrakk> \\<langle>ls, (ts, m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts', m'), ws', is'\\<rangle>; t \\<noteq> t' \\<rbrakk>\n  \\<Longrightarrow> has_lock (ls' $ l) t' = has_lock (ls $ l) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>ls, (ts,\n                           m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts',\n                    m'), ws', is'\\<rangle>;\n     t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_lock (ls' $ l) t' = has_lock (ls $ l) t'", "by(auto simp add: redT_has_locks_inv)"], ["", "lemma redT_ts_Some_inv:\n  \"\\<lbrakk> \\<langle>ls, (ts, m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts', m'), ws', is'\\<rangle>; t \\<noteq> t'; ts t' = \\<lfloor>x\\<rfloor> \\<rbrakk> \\<Longrightarrow> ts' t' = \\<lfloor>x\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>ls, (ts,\n                           m), ws, is\\<rangle> -t\\<triangleright>ta\\<rightarrow> \\<langle>ls', (ts',\n                    m'), ws', is'\\<rangle>;\n     t \\<noteq> t'; ts t' = \\<lfloor>x\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> ts' t' = \\<lfloor>x\\<rfloor>", "by(fastforce elim!: redT.cases simp: redT_updTs_upd[THEN sym] intro: redT_updTs_Some)"], ["", "lemma redT_thread_not_disappear:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; thr s' t' = None\\<rbrakk> \\<Longrightarrow> thr s t' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s';\n     thr s' t' = None\\<rbrakk>\n    \\<Longrightarrow> thr s t' = None", "apply(cases \"t \\<noteq> t'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s'; thr s' t' = None;\n     t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> thr s t' = None\n 2. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s'; thr s' t' = None;\n     \\<not> t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> thr s t' = None", "apply(auto elim!: redT_elims simp add: redT_updTs_upd[THEN sym] intro: redT_updTs_None)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma RedT_thread_not_disappear:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; thr s' t' = None\\<rbrakk> \\<Longrightarrow> thr s t' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n     thr s' t' = None\\<rbrakk>\n    \\<Longrightarrow> thr s t' = None", "apply(erule contrapos_pp[where Q=\"thr s' t' = None\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n     thr s t' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> thr s' t' \\<noteq> None", "apply(drule (1) RedT_lift_preserveD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa t tas s'.\n       \\<lbrakk>thr s t' \\<noteq> None;\n        sa -t\\<triangleright>tas\\<rightarrow> s';\n        thr sa t' \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> thr s' t' \\<noteq> None\n 2. \\<lbrakk>thr s t' \\<noteq> None; thr s' t' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> thr s' t' \\<noteq> None", "apply(erule_tac Q=\"thr sa t' = None\" in contrapos_nn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa t tas s'.\n       \\<lbrakk>thr s t' \\<noteq> None;\n        sa -t\\<triangleright>tas\\<rightarrow> s'; thr s' t' = None\\<rbrakk>\n       \\<Longrightarrow> thr sa t' = None\n 2. \\<lbrakk>thr s t' \\<noteq> None; thr s' t' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> thr s' t' \\<noteq> None", "apply(erule redT_thread_not_disappear)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa t tas s'.\n       \\<lbrakk>thr s t' \\<noteq> None; thr s' t' = None\\<rbrakk>\n       \\<Longrightarrow> thr s' t' = None\n 2. \\<lbrakk>thr s t' \\<noteq> None; thr s' t' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> thr s' t' \\<noteq> None", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma redT_preserves_wset_thread_ok:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; wset_thread_ok (wset s) (thr s) \\<rbrakk> \\<Longrightarrow> wset_thread_ok (wset s') (thr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s';\n     wset_thread_ok (wset s) (thr s)\\<rbrakk>\n    \\<Longrightarrow> wset_thread_ok (wset s') (thr s')", "by(fastforce elim!: redT.cases intro: wset_thread_ok_upd redT_updTs_preserves_wset_thread_ok redT_updWs_preserve_wset_thread_ok)"], ["", "lemma RedT_preserves_wset_thread_ok:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; wset_thread_ok (wset s) (thr s) \\<rbrakk> \\<Longrightarrow> wset_thread_ok (wset s') (thr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n     wset_thread_ok (wset s) (thr s)\\<rbrakk>\n    \\<Longrightarrow> wset_thread_ok (wset s') (thr s')", "by(erule (1) RedT_lift_preserveD)(erule redT_preserves_wset_thread_ok)"], ["", "lemma redT_new_thread_ts_Some:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; NewThread t' x m'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>; wset_thread_ok (wset s) (thr s) \\<rbrakk>\n  \\<Longrightarrow> thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s';\n     NewThread t' x m'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     wset_thread_ok (wset s) (thr s)\\<rbrakk>\n    \\<Longrightarrow> thr s' t' = \\<lfloor>(x, no_wait_locks)\\<rfloor>", "by(erule redT_elims)(auto dest: thread_oks_new_thread elim: redT_updTs_new_thread_ts)"], ["", "lemma RedT_new_thread_ts_not_None:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) ttas)); wset_thread_ok (wset s) (thr s) \\<rbrakk>\n   \\<Longrightarrow> thr s' t \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n     NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n     wset_thread_ok (wset s) (thr s)\\<rbrakk>\n    \\<Longrightarrow> thr s' t \\<noteq> None", "proof(induct rule: RedT_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>NewThread t x m''\n                \\<in> set (concat (map (thr_a \\<circ> snd) []));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s t \\<noteq> None\n 2. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "case refl"], ["proof (state)\nthis:\n  NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) []))\n  wset_thread_ok (wset s_) (thr s_)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>NewThread t x m''\n                \\<in> set (concat (map (thr_a \\<circ> snd) []));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s t \\<noteq> None\n 2. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "thus ?case"], ["proof (prove)\nusing this:\n  NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) []))\n  wset_thread_ok (wset s_) (thr s_)\n\ngoal (1 subgoal):\n 1. thr s_ t \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  thr s_ t \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "case (step S TTAS S' T TA S'')"], ["proof (state)\nthis:\n  S -\\<triangleright>TTAS\\<rightarrow>* S'\n  \\<lbrakk>NewThread t x m''\n           \\<in> set (concat (map (thr_a \\<circ> snd) TTAS));\n   wset_thread_ok (wset S) (thr S)\\<rbrakk>\n  \\<Longrightarrow> thr S' t \\<noteq> None\n  S' -T\\<triangleright>TA\\<rightarrow> S''\n  NewThread t x m''\n  \\<in> set (concat (map (thr_a \\<circ> snd) (TTAS @ [(T, TA)])))\n  wset_thread_ok (wset S) (thr S)\n\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "note Red = \\<open>S -\\<triangleright>TTAS\\<rightarrow>* S'\\<close>"], ["proof (state)\nthis:\n  S -\\<triangleright>TTAS\\<rightarrow>* S'\n\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "note IH = \\<open>\\<lbrakk> NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) TTAS)); wset_thread_ok (wset S) (thr S) \\<rbrakk> \\<Longrightarrow> thr S' t \\<noteq> None\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>NewThread t x m''\n           \\<in> set (concat (map (thr_a \\<circ> snd) TTAS));\n   wset_thread_ok (wset S) (thr S)\\<rbrakk>\n  \\<Longrightarrow> thr S' t \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "note red = \\<open>S' -T\\<triangleright>TA\\<rightarrow> S''\\<close>"], ["proof (state)\nthis:\n  S' -T\\<triangleright>TA\\<rightarrow> S''\n\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "note ins = \\<open>NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) (TTAS @ [(T, TA)])))\\<close>"], ["proof (state)\nthis:\n  NewThread t x m''\n  \\<in> set (concat (map (thr_a \\<circ> snd) (TTAS @ [(T, TA)])))\n\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "note wto = \\<open>wset_thread_ok (wset S) (thr S)\\<close>"], ["proof (state)\nthis:\n  wset_thread_ok (wset S) (thr S)\n\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "from Red wto"], ["proof (chain)\npicking this:\n  S -\\<triangleright>TTAS\\<rightarrow>* S'\n  wset_thread_ok (wset S) (thr S)", "have wto': \"wset_thread_ok (wset S') (thr S')\""], ["proof (prove)\nusing this:\n  S -\\<triangleright>TTAS\\<rightarrow>* S'\n  wset_thread_ok (wset S) (thr S)\n\ngoal (1 subgoal):\n 1. wset_thread_ok (wset S') (thr S')", "by(auto dest: RedT_preserves_wset_thread_ok)"], ["proof (state)\nthis:\n  wset_thread_ok (wset S') (thr S')\n\ngoal (1 subgoal):\n 1. \\<And>s ttas s' ta taa s''.\n       \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n        \\<lbrakk>NewThread t x m''\n                 \\<in> set (concat (map (thr_a \\<circ> snd) ttas));\n         wset_thread_ok (wset s) (thr s)\\<rbrakk>\n        \\<Longrightarrow> thr s' t \\<noteq> None;\n        s' -ta\\<triangleright>taa\\<rightarrow> s'';\n        NewThread t x m''\n        \\<in> set (concat (map (thr_a \\<circ> snd) (ttas @ [(ta, taa)])));\n        wset_thread_ok (wset s) (thr s)\\<rbrakk>\n       \\<Longrightarrow> thr s'' t \\<noteq> None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thr S'' t \\<noteq> None", "proof(cases \"NewThread t x m'' \\<in> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. NewThread t x m''\n    \\<in> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None\n 2. NewThread t x m''\n    \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None", "case True"], ["proof (state)\nthis:\n  NewThread t x m'' \\<in> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (2 subgoals):\n 1. NewThread t x m''\n    \\<in> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None\n 2. NewThread t x m''\n    \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None", "thus ?thesis"], ["proof (prove)\nusing this:\n  NewThread t x m'' \\<in> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. thr S'' t \\<noteq> None", "using red wto'"], ["proof (prove)\nusing this:\n  NewThread t x m'' \\<in> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>\n  S' -T\\<triangleright>TA\\<rightarrow> S''\n  wset_thread_ok (wset S') (thr S')\n\ngoal (1 subgoal):\n 1. thr S'' t \\<noteq> None", "by(auto dest!: redT_new_thread_ts_Some)"], ["proof (state)\nthis:\n  thr S'' t \\<noteq> None\n\ngoal (1 subgoal):\n 1. NewThread t x m''\n    \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. NewThread t x m''\n    \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None", "case False"], ["proof (state)\nthis:\n  NewThread t x m'' \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. NewThread t x m''\n    \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None", "hence \"NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) TTAS))\""], ["proof (prove)\nusing this:\n  NewThread t x m'' \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>\n\ngoal (1 subgoal):\n 1. NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) TTAS))", "using ins"], ["proof (prove)\nusing this:\n  NewThread t x m'' \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub>\n  NewThread t x m''\n  \\<in> set (concat (map (thr_a \\<circ> snd) (TTAS @ [(T, TA)])))\n\ngoal (1 subgoal):\n 1. NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) TTAS))", "by(auto)"], ["proof (state)\nthis:\n  NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) TTAS))\n\ngoal (1 subgoal):\n 1. NewThread t x m''\n    \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None", "hence \"thr S' t \\<noteq> None\""], ["proof (prove)\nusing this:\n  NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) TTAS))\n\ngoal (1 subgoal):\n 1. thr S' t \\<noteq> None", "using wto"], ["proof (prove)\nusing this:\n  NewThread t x m'' \\<in> set (concat (map (thr_a \\<circ> snd) TTAS))\n  wset_thread_ok (wset S) (thr S)\n\ngoal (1 subgoal):\n 1. thr S' t \\<noteq> None", "by(rule IH)"], ["proof (state)\nthis:\n  thr S' t \\<noteq> None\n\ngoal (1 subgoal):\n 1. NewThread t x m''\n    \\<notin> set \\<lbrace>TA\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n    thr S'' t \\<noteq> None", "with red"], ["proof (chain)\npicking this:\n  S' -T\\<triangleright>TA\\<rightarrow> S''\n  thr S' t \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  S' -T\\<triangleright>TA\\<rightarrow> S''\n  thr S' t \\<noteq> None\n\ngoal (1 subgoal):\n 1. thr S'' t \\<noteq> None", "by -(erule contrapos_nn, auto dest: redT_thread_not_disappear)"], ["proof (state)\nthis:\n  thr S'' t \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thr S'' t \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redT_preserves_lock_thread_ok:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; lock_thread_ok (locks s) (thr s) \\<rbrakk> \\<Longrightarrow> lock_thread_ok (locks s') (thr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s';\n     lock_thread_ok (locks s) (thr s)\\<rbrakk>\n    \\<Longrightarrow> lock_thread_ok (locks s') (thr s')", "by(auto elim!: redT_elims intro: redT_upds_preserves_lock_thread_ok acquire_all_preserves_lock_thread_ok)"], ["", "lemma RedT_preserves_lock_thread_ok:\n  \"\\<lbrakk> s -\\<triangleright>ttas\\<rightarrow>* s'; lock_thread_ok (locks s) (thr s) \\<rbrakk> \\<Longrightarrow> lock_thread_ok (locks s') (thr s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -\\<triangleright>ttas\\<rightarrow>* s';\n     lock_thread_ok (locks s) (thr s)\\<rbrakk>\n    \\<Longrightarrow> lock_thread_ok (locks s') (thr s')", "by(erule (1) RedT_lift_preserveD)(erule redT_preserves_lock_thread_ok)"], ["", "lemma redT_ex_new_thread:\n  assumes \"s -t'\\<triangleright>ta\\<rightarrow> s'\" \"wset_thread_ok (wset s) (thr s)\" \"thr s' t = \\<lfloor>(x, w)\\<rfloor>\" \"thr s t = None\"\n  shows \"\\<exists>m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and> w = no_wait_locks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       NewThread t x m\n       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n       w = no_wait_locks", "using assms"], ["proof (prove)\nusing this:\n  s -t'\\<triangleright>ta\\<rightarrow> s'\n  wset_thread_ok (wset s) (thr s)\n  thr s' t = \\<lfloor>(x, w)\\<rfloor>\n  thr s t = None\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       NewThread t x m\n       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n       w = no_wait_locks", "by cases (fastforce split: if_split_asm dest: wset_thread_okD redT_updTs_new_thread)+"], ["", "lemma redT_ex_new_thread':\n  assumes \"s -t'\\<triangleright>ta\\<rightarrow> s'\" \"thr s' t = \\<lfloor>(x, w)\\<rfloor>\" \"thr s t = None\"\n  shows \"\\<exists>m x. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m x.\n       NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "using assms"], ["proof (prove)\nusing this:\n  s -t'\\<triangleright>ta\\<rightarrow> s'\n  thr s' t = \\<lfloor>(x, w)\\<rfloor>\n  thr s t = None\n\ngoal (1 subgoal):\n 1. \\<exists>m x.\n       NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>", "by(cases)(fastforce split: if_split_asm dest!: redT_updTs_new_thread)+"], ["", "definition deterministic :: \"('l,'t,'x,'m,'w) state set \\<Rightarrow> bool\"\nwhere\n  \"deterministic I \\<longleftrightarrow> \n  (\\<forall>s t x ta' x' m' ta'' x'' m''. \n    s \\<in> I\n    \\<longrightarrow> thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n    \\<longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle> \n    \\<longrightarrow> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle> \n    \\<longrightarrow> actions_ok s t ta' \\<longrightarrow> actions_ok s t ta''\n    \\<longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m'') \\<and> invariant3p redT I\""], ["", "lemma determisticI:\n  \"\\<lbrakk>\\<And>s t x ta' x' m' ta'' x'' m''.\n      \\<lbrakk> s \\<in> I; thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; \n        t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>; t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>; \n        actions_ok s t ta'; actions_ok s t ta'' \\<rbrakk>\n      \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m'';\n    invariant3p redT I \\<rbrakk>\n  \\<Longrightarrow> deterministic I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s t x ta' x' m' ta'' x'' m''.\n                \\<lbrakk>s \\<in> I;\n                 thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n                 t \\<turnstile> \\<langle>x, shr\n       s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n                 t \\<turnstile> \\<langle>x, shr\n       s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n                 actions_ok s t ta'; actions_ok s t ta''\\<rbrakk>\n                \\<Longrightarrow> ta' = ta'' \\<and>\n                                  x' = x'' \\<and> m' = m'';\n     invariant3p redT I\\<rbrakk>\n    \\<Longrightarrow> deterministic I", "unfolding deterministic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s t x ta' x' m' ta'' x'' m''.\n                \\<lbrakk>s \\<in> I;\n                 thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n                 t \\<turnstile> \\<langle>x, shr\n       s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n                 t \\<turnstile> \\<langle>x, shr\n       s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n                 actions_ok s t ta'; actions_ok s t ta''\\<rbrakk>\n                \\<Longrightarrow> ta' = ta'' \\<and>\n                                  x' = x'' \\<and> m' = m'';\n     invariant3p redT I\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>s t x ta' x' m' ta'' x'' m''.\n                          s \\<in> I \\<longrightarrow>\n                          thr s t =\n                          \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                          t \\<turnstile> \\<langle>x, shr\n                s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle> \\<longrightarrow>\n                          t \\<turnstile> \\<langle>x, shr\n                s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<longrightarrow>\n                          actions_ok s t ta' \\<longrightarrow>\n                          actions_ok s t ta'' \\<longrightarrow>\n                          ta' = ta'' \\<and> x' = x'' \\<and> m' = m'') \\<and>\n                      invariant3p redT I", "by blast"], ["", "lemma deterministicD:\n  \"\\<lbrakk> deterministic I;\n    t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>; t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n    thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta'; actions_ok s t ta''; s \\<in> I \\<rbrakk>\n  \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic I;\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta';\n     actions_ok s t ta''; s \\<in> I\\<rbrakk>\n    \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''", "unfolding deterministic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>s t x ta' x' m' ta'' x'' m''.\n                 s \\<in> I \\<longrightarrow>\n                 thr s t =\n                 \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n                 t \\<turnstile> \\<langle>x, shr\n       s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle> \\<longrightarrow>\n                 t \\<turnstile> \\<langle>x, shr\n       s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<longrightarrow>\n                 actions_ok s t ta' \\<longrightarrow>\n                 actions_ok s t ta'' \\<longrightarrow>\n                 ta' = ta'' \\<and> x' = x'' \\<and> m' = m'') \\<and>\n             invariant3p redT I;\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle>;\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle>;\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; actions_ok s t ta';\n     actions_ok s t ta''; s \\<in> I\\<rbrakk>\n    \\<Longrightarrow> ta' = ta'' \\<and> x' = x'' \\<and> m' = m''", "by blast"], ["", "lemma deterministic_invariant3p:\n  \"deterministic I \\<Longrightarrow> invariant3p redT I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic I \\<Longrightarrow> invariant3p redT I", "unfolding deterministic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s t x ta' x' m' ta'' x'' m''.\n        s \\<in> I \\<longrightarrow>\n        thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta'\\<rightarrow> \\<langle>x', m'\\<rangle> \\<longrightarrow>\n        t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta''\\<rightarrow> \\<langle>x'', m''\\<rangle> \\<longrightarrow>\n        actions_ok s t ta' \\<longrightarrow>\n        actions_ok s t ta'' \\<longrightarrow>\n        ta' = ta'' \\<and> x' = x'' \\<and> m' = m'') \\<and>\n    invariant3p redT I \\<Longrightarrow>\n    invariant3p redT I", "by blast"], ["", "lemma deterministic_THE:\n  \"\\<lbrakk> deterministic I; thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>; t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>; actions_ok s t ta; s \\<in> I \\<rbrakk>\n  \\<Longrightarrow> (THE (ta, x', m'). t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and> actions_ok s t ta) = (ta, x', m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic I;\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n     t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n     actions_ok s t ta; s \\<in> I\\<rbrakk>\n    \\<Longrightarrow> (THE (ta, x', m').\n                          t \\<turnstile> \\<langle>x, shr\n                s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                          actions_ok s t ta) =\n                      (ta, x', m')", "by(rule the_equality)(blast dest: deterministicD)+"], ["", "end"], ["", "locale multithreaded = multithreaded_base +\n  constrains final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"('l,'t,'x,'m,'w,'o) semantics\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  assumes new_thread_memory: \"\\<lbrakk> t \\<turnstile> s -ta\\<rightarrow> s'; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> m = snd s'\"\n  and final_no_red: \"\\<lbrakk> t \\<turnstile> (x, m) -ta\\<rightarrow> (x', m'); final x \\<rbrakk> \\<Longrightarrow> False\"\nbegin"], ["", "lemma redT_new_thread_common:\n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; NewThread t' x m'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>; \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = [] \\<rbrakk> \\<Longrightarrow> m'' = shr s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s';\n     NewThread t' x m'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = []\\<rbrakk>\n    \\<Longrightarrow> m'' = shr s'", "by(auto elim!: redT_elims rtrancl3p_cases dest: new_thread_memory)"], ["", "lemma redT_new_thread:\n  assumes \"s -t'\\<triangleright>ta\\<rightarrow> s'\" \"thr s' t = \\<lfloor>(x, w)\\<rfloor>\" \"thr s t = None\" \"\\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = []\"\n  shows \"NewThread t x (shr s') \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and> w = no_wait_locks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NewThread t x (shr s')\n    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n    w = no_wait_locks", "using assms"], ["proof (prove)\nusing this:\n  s -t'\\<triangleright>ta\\<rightarrow> s'\n  thr s' t = \\<lfloor>(x, w)\\<rfloor>\n  thr s t = None\n  \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = []\n\ngoal (1 subgoal):\n 1. NewThread t x (shr s')\n    \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n    w = no_wait_locks", "apply(cases rule: redT_elims)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa x' m' ws'.\n       \\<lbrakk>thr s' t = \\<lfloor>(x, w)\\<rfloor>; thr s t = None;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = [];\n        t' \\<turnstile> \\<langle>xa, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t' = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        cond_action_oks s t' \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset_actions_ok (wset s) t' \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s)\n          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> NewThread t x (shr s')\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                         w = no_wait_locks\n 2. \\<And>xa ln n.\n       \\<lbrakk>thr s' t = \\<lfloor>(x, w)\\<rfloor>; thr s t = None;\n        \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = [];\n        thr s t' = \\<lfloor>(xa, ln)\\<rfloor>;\n        ta = (K$ [], [], [], [], [], convert_RA ln);\n        \\<not> waiting (wset s t'); may_acquire_all (locks s) t' ln;\n        0 < ln $ n;\n        s' =\n        (acquire_all (locks s) t' ln,\n         (thr s(t' \\<mapsto> (xa, no_wait_locks)), shr s), wset s,\n         interrupts s)\\<rbrakk>\n       \\<Longrightarrow> NewThread t x (shr s')\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                         w = no_wait_locks", "apply(auto split: if_split_asm del: conjI elim!: rtrancl3p_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x' m' ws'.\n       \\<lbrakk>thr s t = None; \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = [];\n        t' \\<turnstile> \\<langle>xa, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t' = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        cond_action_oks s t' \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset s t' = None;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) [] ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>);\n        t \\<noteq> t';\n        redT_updTs (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> t =\n        \\<lfloor>(x, w)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> NewThread t x m'\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                         w = no_wait_locks", "apply(drule (2) redT_updTs_new_thread)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x' m' ws'.\n       \\<lbrakk>thr s t = None; \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> = [];\n        t' \\<turnstile> \\<langle>xa, shr\ns\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle>;\n        thr s t' = \\<lfloor>(xa, no_wait_locks)\\<rfloor>;\n        lock_ok_las (locks s) t' \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>;\n        thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        cond_action_oks s t' \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub>;\n        wset s t' = None;\n        interrupt_actions_ok (interrupts s)\n         \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>;\n        redT_updWs t' (wset s) [] ws';\n        s' =\n        (redT_updLs (locks s) t' \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n         (redT_updTs (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>(t' \n          \\<mapsto>\n          (x',\n           redT_updLns (locks s) t' no_wait_locks\n            \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n          m'),\n         ws',\n         redT_updIs (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>);\n        t \\<noteq> t';\n        \\<exists>m.\n           NewThread t x m\n           \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n           w = no_wait_locks\\<rbrakk>\n       \\<Longrightarrow> NewThread t x m'\n                         \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n                         w = no_wait_locks", "apply(auto dest: new_thread_memory)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma final_no_redT: \n  \"\\<lbrakk> s -t\\<triangleright>ta\\<rightarrow> s'; thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<rbrakk> \\<Longrightarrow> \\<not> final x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s -t\\<triangleright>ta\\<rightarrow> s';\n     thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<not> final x", "by(auto elim!: redT_elims dest: final_no_red)"], ["", "lemma mfinal_no_redT:\n  assumes redT: \"s -t\\<triangleright>ta\\<rightarrow> s'\" and mfinal: \"mfinal s\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using redT mfinalD[OF mfinal, of t]"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n  thr s t = \\<lfloor>(?x, ?ln)\\<rfloor> \\<Longrightarrow> final ?x\n  thr s t = \\<lfloor>(?x, ?ln)\\<rfloor> \\<Longrightarrow>\n  ?ln = no_wait_locks\n  thr s t = \\<lfloor>(?x, ?ln)\\<rfloor> \\<Longrightarrow> wset s t = None\n\ngoal (1 subgoal):\n 1. False", "by cases (metis final_no_red, metis neq_no_wait_locks_conv)"], ["", "end"], ["", "end"]]}