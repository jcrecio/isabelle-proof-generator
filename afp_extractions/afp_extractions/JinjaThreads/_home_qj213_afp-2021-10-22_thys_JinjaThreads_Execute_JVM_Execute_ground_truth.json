{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/JVM_Execute.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma eval_sc_mexec:\n  \"(\\<lambda>t xm ta x'm'. Predicate.eval (sc_mexec P t xm) (ta, x'm')) = \n  (\\<lambda>t ((xcp, frs), h) ta ((xcp', frs'), h'). sc.execute.exec_1 (TYPE(addr jvm_method)) P P t (xcp, h, frs) ta (xcp', h', frs'))\"", "lemma sc_jvm_start_state_invar: \n  assumes \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  and \"sc_wf_start_state P C M vs\"\n  shows \"sc_state_\\<alpha> (sc_jvm_start_state_refine P C M vs) \\<in> sc_jvm_state_invar P \\<Phi>\"", "lemma JVM_rr:\n  assumes \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  shows\n  \"sc_scheduler \n     JVM_final (sc_mexec P) convert_RA\n     (JVM_rr.round_robin P n0) (pick_wakeup_via_sel (\\<lambda>s P. rm_sel s (\\<lambda>(k,v). P k v))) JVM_rr.round_robin_invar\n     (sc_jvm_state_invar P \\<Phi>)\"", "lemma JVM_rnd:\n  assumes \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  shows \n  \"sc_scheduler\n    JVM_final (sc_mexec P) convert_RA\n    (JVM_rnd.random_scheduler P) (pick_wakeup_via_sel (\\<lambda>s P. rm_sel s (\\<lambda>(k,v). P k v))) (\\<lambda>_ _. True)\n    (sc_jvm_state_invar P \\<Phi>)\""], "translations": [["", "lemma eval_sc_mexec:\n  \"(\\<lambda>t xm ta x'm'. Predicate.eval (sc_mexec P t xm) (ta, x'm')) = \n  (\\<lambda>t ((xcp, frs), h) ta ((xcp', frs'), h'). sc.execute.exec_1 (TYPE(addr jvm_method)) P P t (xcp, h, frs) ta (xcp', h', frs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t xm ta x'm'. pred.eval (sc_mexec P t xm) (ta, x'm')) =\n    (\\<lambda>t ((xcp, frs), h) ta ((xcp', frs'), h').\n        JVM_heap_base.exec_1 (\\<lambda>x. x) (\\<lambda>x. x)\n         sc_spurious_wakeups (rm.empty ()) (sc_allocate P) sc_typeof_addr\n         sc_heap_read sc_heap_write P t (xcp, h, frs) ta (xcp', h', frs'))", "by(rule ext)+(fastforce intro!: SUP1_I simp add: sc.exec_1_eq')"], ["", "lemma sc_jvm_start_state_invar: \n  assumes \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  and \"sc_wf_start_state P C M vs\"\n  shows \"sc_state_\\<alpha> (sc_jvm_start_state_refine P C M vs) \\<in> sc_jvm_state_invar P \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_refine_base.state_\\<alpha> rm.\\<alpha> rm.\\<alpha> rs.\\<alpha>\n     (heap_base.start_state_refine (\\<lambda>x. x) (rm.empty ())\n       (sc_allocate P) (rm.empty ()) rm.update (rm.empty ()) (rs.empty ())\n       JVM_local_start P C M vs)\n    \\<in> sc_jvm_state_invar P \\<Phi>", "using sc_execute.correct_jvm_state_initial[OF assms]"], ["proof (prove)\nusing this:\n  sc_start_state JVM_local_start P C M vs\n  \\<in> sc_execute.correct_jvm_state P \\<Phi>\n\ngoal (1 subgoal):\n 1. state_refine_base.state_\\<alpha> rm.\\<alpha> rm.\\<alpha> rs.\\<alpha>\n     (heap_base.start_state_refine (\\<lambda>x. x) (rm.empty ())\n       (sc_allocate P) (rm.empty ()) rm.update (rm.empty ()) (rs.empty ())\n       JVM_local_start P C M vs)\n    \\<in> sc_jvm_state_invar P \\<Phi>", "by(simp add: sc_execute.correct_jvm_state_def)"], ["", "subsection \\<open>Round-robin scheduler\\<close>"], ["", "interpretation JVM_rr: \n  sc_round_robin_base\n    JVM_final \"sc_mexec P\" convert_RA Jinja_output\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition sc_rr_JVM_start_state :: \"nat \\<Rightarrow> 'm prog \\<Rightarrow> thread_id fifo round_robin\"\nwhere \"sc_rr_JVM_start_state n0 P = JVM_rr.round_robin_start n0 (sc_start_tid P)\""], ["", "definition exec_JVM_rr ::\n  \"nat \\<Rightarrow> addr jvm_prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> \n  (thread_id \\<times> (addr, thread_id) obs_event list, \n   (addr, thread_id) locks \\<times> ((thread_id, addr jvm_thread_state \\<times> addr released_locks) rm \\<times> heap) \\<times>\n   (thread_id, addr wait_set_status) rm \\<times> thread_id rs) tllist\"\nwhere\n  \"exec_JVM_rr n0 P C M vs = JVM_rr.exec P n0 (sc_rr_JVM_start_state n0 P) (sc_jvm_start_state_refine P C M vs)\""], ["", "interpretation JVM_rr:\n  sc_round_robin \n    JVM_final \"sc_mexec P\" convert_RA Jinja_output\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_round_robin TYPE(nat) TYPE(nat) TYPE(nat)\n     TYPE(nat option \\<times> nat frame list)", "by(unfold_locales)"], ["", "lemma JVM_rr:\n  assumes \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  shows\n  \"sc_scheduler \n     JVM_final (sc_mexec P) convert_RA\n     (JVM_rr.round_robin P n0) (pick_wakeup_via_sel (\\<lambda>s P. rm_sel s (\\<lambda>(k,v). P k v))) JVM_rr.round_robin_invar\n     (sc_jvm_state_invar P \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_scheduler JVM_final (sc_mexec P) convert_RA (JVM_rr.round_robin P n0)\n     (pick_wakeup_via_sel (\\<lambda>s P. rm.sel s (\\<lambda>(k, v). P k v)))\n     JVM_rr.round_robin_invar (sc_jvm_state_invar P \\<Phi>)", "unfolding sc_scheduler_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler JVM_final (sc_mexec P) convert_RA (JVM_rr.round_robin P n0)\n     (pick_wakeup_via_sel (\\<lambda>s P. rm.sel s (\\<lambda>(x, y). P x y)))\n     JVM_rr.round_robin_invar rm.\\<alpha> rm.invar rm.lookup rm.update\n     rm.\\<alpha> rm.invar rm.lookup rm.update rm.delete rm.iteratei\n     rs.\\<alpha> rs.invar rs.memb rs.ins rs.delete\n     (sc_jvm_state_invar P \\<Phi>)", "apply(rule JVM_rr.round_robin_scheduler)"], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_rr.\\<alpha>.deterministic P (sc_jvm_state_invar P \\<Phi>)", "apply(unfold eval_sc_mexec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded_base.deterministic JVM_final\n     (\\<lambda>t ((xcp, frs), h) ta ((xcp', frs'), h').\n         JVM_heap_base.exec_1 (\\<lambda>x. x) (\\<lambda>x. x)\n          sc_spurious_wakeups (rm.empty ()) (sc_allocate P) sc_typeof_addr\n          sc_heap_read sc_heap_write P t (xcp, h, frs) ta (xcp', h', frs'))\n     convert_RA (sc_jvm_state_invar P \\<Phi>)", "apply(rule sc_execute.mexec_deterministic[OF assms sc_deterministic_heap_ops])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sc_spurious_wakeups", "apply(simp add: sc_spurious_wakeups)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Random scheduler\\<close>"], ["", "interpretation JVM_rnd: \n  sc_random_scheduler_base\n    JVM_final \"sc_mexec P\" convert_RA Jinja_output\n  for P"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition sc_rnd_JVM_start_state :: \"Random.seed \\<Rightarrow> random_scheduler\"\nwhere \"sc_rnd_JVM_start_state seed = seed\""], ["", "definition exec_JVM_rnd ::\n  \"Random.seed \\<Rightarrow> addr jvm_prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> addr val list \\<Rightarrow> \n  (thread_id \\<times> (addr, thread_id) obs_event list,\n   (addr, thread_id) locks \\<times> ((thread_id, addr jvm_thread_state \\<times> addr released_locks) rm \\<times> heap) \\<times>\n   (thread_id, addr wait_set_status) rm \\<times> thread_id rs) tllist\"\nwhere \"exec_JVM_rnd seed P C M vs = JVM_rnd.exec P (sc_rnd_JVM_start_state seed) (sc_jvm_start_state_refine P C M vs)\""], ["", "interpretation JVM_rnd:\n  sc_random_scheduler\n    JVM_final \"sc_mexec P\" convert_RA Jinja_output\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_random_scheduler TYPE(nat) TYPE(nat) TYPE(nat)\n     TYPE(nat option \\<times> nat frame list)", "by(unfold_locales)"], ["", "lemma JVM_rnd:\n  assumes \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  shows \n  \"sc_scheduler\n    JVM_final (sc_mexec P) convert_RA\n    (JVM_rnd.random_scheduler P) (pick_wakeup_via_sel (\\<lambda>s P. rm_sel s (\\<lambda>(k,v). P k v))) (\\<lambda>_ _. True)\n    (sc_jvm_state_invar P \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_scheduler JVM_final (sc_mexec P) convert_RA\n     (JVM_rnd.random_scheduler P) JVM_rnd.pick_wakeup (\\<lambda>_ _. True)\n     (sc_jvm_state_invar P \\<Phi>)", "unfolding sc_scheduler_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler JVM_final (sc_mexec P) convert_RA (JVM_rnd.random_scheduler P)\n     JVM_rnd.pick_wakeup (\\<lambda>_ _. True) rm.\\<alpha> rm.invar rm.lookup\n     rm.update rm.\\<alpha> rm.invar rm.lookup rm.update rm.delete\n     rm.iteratei rs.\\<alpha> rs.invar rs.memb rs.ins rs.delete\n     (sc_jvm_state_invar P \\<Phi>)", "apply(rule JVM_rnd.random_scheduler_scheduler)"], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_rr.\\<alpha>.deterministic P (sc_jvm_state_invar P \\<Phi>)", "apply(unfold eval_sc_mexec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded_base.deterministic JVM_final\n     (\\<lambda>t ((xcp, frs), h) ta ((xcp', frs'), h').\n         JVM_heap_base.exec_1 (\\<lambda>x. x) (\\<lambda>x. x)\n          sc_spurious_wakeups (rm.empty ()) (sc_allocate P) sc_typeof_addr\n          sc_heap_read sc_heap_write P t (xcp, h, frs) ta (xcp', h', frs'))\n     convert_RA (sc_jvm_state_invar P \\<Phi>)", "apply(rule sc_execute.mexec_deterministic[OF assms sc_deterministic_heap_ops])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sc_spurious_wakeups", "apply(simp add: sc_spurious_wakeups)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "ML_val \\<open>@{code exec_JVM_rr}\\<close>"], ["", "ML_val \\<open>@{code exec_JVM_rnd}\\<close>"], ["", "end"]]}