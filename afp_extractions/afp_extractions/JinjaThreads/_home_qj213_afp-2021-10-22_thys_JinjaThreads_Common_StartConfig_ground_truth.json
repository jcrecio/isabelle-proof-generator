{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/StartConfig.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma create_initial_object_simps:\n  \"create_initial_object (h, ads, b) C = \n   (if b \n    then let HA = allocate h (Class_type C)\n         in if HA = {} then (h, ads, False)\n            else let (h', a'') = SOME ha. ha \\<in> HA in (h', ads @ [a''], True)\n    else (h, ads, False))\"", "lemma create_initial_object_False [simp]:\n  \"create_initial_object (h, ads, False) C = (h, ads, False)\"", "lemma foldl_create_initial_object_False [simp]:\n  \"foldl create_initial_object (h, ads, False) Cs = (h, ads, False)\"", "lemma NewHeapElem_start_heap_obs_start_addrsD:\n  \"NewHeapElem a CTn \\<in> set start_heap_obs \\<Longrightarrow> a \\<in> set start_addrs\"", "lemma shr_start_state: \"shr (start_state f P C M vs) = start_heap\"", "lemma start_heap_obs_not_Read: \n  \"ReadMem ad al v \\<notin> set start_heap_obs\"", "lemma length_initialization_list_le_length_start_addrs:\n  \"length initialization_list \\<ge> length start_addrs\"", "lemma (in -) distinct_initialization_list:\n  \"distinct initialization_list\"", "lemma (in -) wf_syscls_initialization_list_is_class:\n  \"\\<lbrakk> wf_syscls P; C \\<in> set initialization_list \\<rbrakk> \\<Longrightarrow> is_class P C\"", "lemma start_addrs_NewHeapElem_start_heap_obsD:\n  \"a \\<in> set start_addrs \\<Longrightarrow> \\<exists>CTn. NewHeapElem a CTn \\<in> set start_heap_obs\"", "lemma in_set_start_addrs_conv_NewHeapElem:\n  \"a \\<in> set start_addrs \\<longleftrightarrow> (\\<exists>CTn. NewHeapElem a CTn \\<in> set start_heap_obs)\"", "lemma typeof_addr_sys_xcp: \n  \"\\<lbrakk> preallocated h; C \\<in> sys_xcpts \\<rbrakk> \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\"", "lemma typeof_sys_xcp:\n  \"\\<lbrakk> preallocated h; C \\<in> sys_xcpts \\<rbrakk> \\<Longrightarrow> typeof\\<^bsub>h\\<^esub> (Addr (addr_of_sys_xcpt C)) = \\<lfloor>Class C\\<rfloor>\"", "lemma addr_of_sys_xcpt_start_addr:\n  \"\\<lbrakk> start_heap_ok; C \\<in> sys_xcpts \\<rbrakk> \\<Longrightarrow> addr_of_sys_xcpt C \\<in> set start_addrs\"", "lemma [simp]:\n  assumes \"preallocated h\"\n  shows typeof_ClassCast: \"typeof_addr h (addr_of_sys_xcpt ClassCast) = Some(Class_type ClassCast)\"\n  and typeof_OutOfMemory: \"typeof_addr h (addr_of_sys_xcpt OutOfMemory) = Some(Class_type OutOfMemory)\" \n  and typeof_NullPointer: \"typeof_addr h (addr_of_sys_xcpt NullPointer) = Some(Class_type NullPointer)\" \n  and typeof_ArrayIndexOutOfBounds: \n  \"typeof_addr h (addr_of_sys_xcpt ArrayIndexOutOfBounds) = Some(Class_type ArrayIndexOutOfBounds)\" \n  and typeof_ArrayStore: \"typeof_addr h (addr_of_sys_xcpt ArrayStore) = Some(Class_type ArrayStore)\" \n  and typeof_NegativeArraySize: \"typeof_addr h (addr_of_sys_xcpt NegativeArraySize) = Some(Class_type NegativeArraySize)\" \n  and typeof_ArithmeticException: \"typeof_addr h (addr_of_sys_xcpt ArithmeticException) = Some(Class_type ArithmeticException)\" \n  and typeof_IllegalMonitorState: \"typeof_addr h (addr_of_sys_xcpt IllegalMonitorState) = Some(Class_type IllegalMonitorState)\"\n  and typeof_IllegalThreadState: \"typeof_addr h (addr_of_sys_xcpt IllegalThreadState) = Some(Class_type IllegalThreadState)\" \n  and typeof_InterruptedException: \"typeof_addr h (addr_of_sys_xcpt InterruptedException) = Some(Class_type InterruptedException)\"", "lemma cname_of_xcp [simp]:\n  \"\\<lbrakk> preallocated h; C \\<in> sys_xcpts \\<rbrakk> \\<Longrightarrow> cname_of h (addr_of_sys_xcpt C) = C\"", "lemma preallocated_hext:\n  \"\\<lbrakk> preallocated h; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> preallocated h'\"", "lemma preallocated_heap_ops:\n  assumes \"preallocated h\"\n  shows preallocated_allocate: \"\\<And>a. (h', a) \\<in> allocate h hT \\<Longrightarrow> preallocated h'\"\n  and preallocated_write_field: \"heap_write h a al v h' \\<Longrightarrow> preallocated h'\"", "lemma not_empty_pairE: \"\\<lbrakk> A \\<noteq> {}; \\<And>a b. (a, b) \\<in> A \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma allocate_not_emptyI: \"(h', a) \\<in> allocate h hT \\<Longrightarrow> allocate h hT \\<noteq> {}\"", "lemma allocate_Eps:\n  \"\\<lbrakk> (h'', a'') \\<in> allocate h hT; (SOME ha. ha \\<in> allocate h hT) = (h', a') \\<rbrakk> \\<Longrightarrow> (h', a') \\<in> allocate h hT\"", "lemma preallocated_start_heap:\n  \"\\<lbrakk> start_heap_ok; wf_syscls P \\<rbrakk> \\<Longrightarrow> preallocated start_heap\"", "lemma start_tid_start_addrs:\n  \"\\<lbrakk> wf_syscls P; start_heap_ok \\<rbrakk> \\<Longrightarrow> thread_id2addr start_tid \\<in> set start_addrs\"", "lemma\n  assumes \"wf_syscls P\"\n  shows dom_typeof_addr_start_heap: \"set start_addrs \\<subseteq> dom (typeof_addr start_heap)\"\n  and distinct_start_addrs: \"distinct start_addrs\"", "lemma NewHeapElem_start_heap_obsD:\n  assumes \"wf_syscls P\"\n  and \"NewHeapElem a hT \\<in> set start_heap_obs\"\n  shows \"typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\"", "lemma pick_addr_code [code]:\n  \"pick_addr (set [ha]) = ha\"", "lemma (in heap_base) start_heap_data_code:\n  \"start_heap_data = \n   (let \n     (h, ads, b) = foldl \n        (\\<lambda>(h, ads, b) C. \n           if b then\n             let HA = allocate h (Class_type C)\n             in if HA = {} then (h, ads, False)\n                else let (h', a'') = pick_addr HA in (h', a'' # ads, True)\n           else (h, ads, False)) \n        (empty_heap, [], True) \n        initialization_list \n    in (h, rev ads, b))\"", "lemmas [code] =\n  heap_base.start_heap_data_code\n  heap_base.start_heap_def\n  heap_base.start_heap_ok_def\n  heap_base.start_heap_obs_def\n  heap_base.start_addrs_def\n  heap_base.addr_of_sys_xcpt_def\n  heap_base.start_tid_def\n  heap_base.start_state_def"], "translations": [["", "lemma create_initial_object_simps:\n  \"create_initial_object (h, ads, b) C = \n   (if b \n    then let HA = allocate h (Class_type C)\n         in if HA = {} then (h, ads, False)\n            else let (h', a'') = SOME ha. ha \\<in> HA in (h', ads @ [a''], True)\n    else (h, ads, False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. create_initial_object (h, ads, b) C =\n    (if b\n     then let HA = allocate h (Class_type C)\n          in if HA = {} then (h, ads, False)\n             else let (h', a'') = SOME ha. ha \\<in> HA\n                  in (h', ads @ [a''], True)\n     else (h, ads, False))", "unfolding create_initial_object_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (h, ads, b) of\n     (h, ads, b) \\<Rightarrow>\n       \\<lambda>C.\n          if b\n          then let HA = allocate h (Class_type C)\n               in if HA = {} then (h, ads, False)\n                  else let (h', a'') = SOME ha. ha \\<in> HA\n                       in (h', ads @ [a''], True)\n          else (h, ads, False))\n     C =\n    (if b\n     then let HA = allocate h (Class_type C)\n          in if HA = {} then (h, ads, False)\n             else let (h', a'') = SOME ha. ha \\<in> HA\n                  in (h', ads @ [a''], True)\n     else (h, ads, False))", "by simp"], ["", "lemma create_initial_object_False [simp]:\n  \"create_initial_object (h, ads, False) C = (h, ads, False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. create_initial_object (h, ads, False) C = (h, ads, False)", "by(simp add: create_initial_object_simps)"], ["", "lemma foldl_create_initial_object_False [simp]:\n  \"foldl create_initial_object (h, ads, False) Cs = (h, ads, False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl create_initial_object (h, ads, False) Cs = (h, ads, False)", "by(induct Cs) simp_all"], ["", "lemma NewHeapElem_start_heap_obs_start_addrsD:\n  \"NewHeapElem a CTn \\<in> set start_heap_obs \\<Longrightarrow> a \\<in> set start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NewHeapElem a CTn \\<in> set start_heap_obs \\<Longrightarrow>\n    a \\<in> set start_addrs", "unfolding start_heap_obs_def start_addrs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. NewHeapElem a CTn\n    \\<in> set (map2 (\\<lambda>C a. NewHeapElem a (Class_type C))\n                initialization_list\n                (fst (snd start_heap_data))) \\<Longrightarrow>\n    a \\<in> set (fst (snd start_heap_data))", "by(auto dest: set_zip_rightD)"], ["", "lemma shr_start_state: \"shr (start_state f P C M vs) = start_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shr (start_state f P C M vs) = start_heap", "by(simp add: start_state_def split_beta)"], ["", "lemma start_heap_obs_not_Read: \n  \"ReadMem ad al v \\<notin> set start_heap_obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReadMem ad al v \\<notin> set start_heap_obs", "unfolding start_heap_obs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ReadMem ad al v\n    \\<notin> set (map2 (\\<lambda>C a. NewHeapElem a (Class_type C))\n                   initialization_list (fst (snd start_heap_data)))", "by auto"], ["", "lemma length_initialization_list_le_length_start_addrs:\n  \"length initialization_list \\<ge> length start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length start_addrs \\<le> length initialization_list", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length start_addrs \\<le> length initialization_list", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. length start_addrs \\<le> length initialization_list", "fix h ads xs"], ["proof (state)\ngoal (1 subgoal):\n 1. length start_addrs \\<le> length initialization_list", "have \"length (fst (snd (foldl create_initial_object (h, ads, True) xs))) \\<le> length ads + length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (snd (foldl create_initial_object (h, ads, True) xs)))\n    \\<le> length ads + length xs", "proof(induct xs arbitrary: h ads)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h ads.\n       length (fst (snd (foldl create_initial_object (h, ads, True) [])))\n       \\<le> length ads + length []\n 2. \\<And>a xs h ads.\n       (\\<And>h ads.\n           length\n            (fst (snd (foldl create_initial_object (h, ads, True) xs)))\n           \\<le> length ads + length xs) \\<Longrightarrow>\n       length\n        (fst (snd (foldl create_initial_object (h, ads, True) (a # xs))))\n       \\<le> length ads + length (a # xs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>h ads.\n       length (fst (snd (foldl create_initial_object (h, ads, True) [])))\n       \\<le> length ads + length []\n 2. \\<And>a xs h ads.\n       (\\<And>h ads.\n           length\n            (fst (snd (foldl create_initial_object (h, ads, True) xs)))\n           \\<le> length ads + length xs) \\<Longrightarrow>\n       length\n        (fst (snd (foldl create_initial_object (h, ads, True) (a # xs))))\n       \\<le> length ads + length (a # xs)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (snd (foldl create_initial_object (h, ads, True) [])))\n    \\<le> length ads + length []", "by simp"], ["proof (state)\nthis:\n  length (fst (snd (foldl create_initial_object (h, ads, True) [])))\n  \\<le> length ads + length []\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads.\n       (\\<And>h ads.\n           length\n            (fst (snd (foldl create_initial_object (h, ads, True) xs)))\n           \\<le> length ads + length xs) \\<Longrightarrow>\n       length\n        (fst (snd (foldl create_initial_object (h, ads, True) (a # xs))))\n       \\<le> length ads + length (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs h ads.\n       (\\<And>h ads.\n           length\n            (fst (snd (foldl create_initial_object (h, ads, True) xs)))\n           \\<le> length ads + length xs) \\<Longrightarrow>\n       length\n        (fst (snd (foldl create_initial_object (h, ads, True) (a # xs))))\n       \\<le> length ads + length (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  length (fst (snd (foldl create_initial_object (?h3, ?ads3, True) xs)))\n  \\<le> length ?ads3 + length xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads.\n       (\\<And>h ads.\n           length\n            (fst (snd (foldl create_initial_object (h, ads, True) xs)))\n           \\<le> length ads + length xs) \\<Longrightarrow>\n       length\n        (fst (snd (foldl create_initial_object (h, ads, True) (a # xs))))\n       \\<le> length ads + length (a # xs)", "from this[of \"fst (SOME ha. ha \\<in> allocate h (Class_type x))\" \"ads @ [snd (SOME ha. ha \\<in> allocate h (Class_type x))]\"]"], ["proof (chain)\npicking this:\n  length\n   (fst (snd (foldl create_initial_object\n               (fst (SOME haa. haa \\<in> allocate h (Class_type x)),\n                ads @ [snd (SOME haa. haa \\<in> allocate h (Class_type x))],\n                True)\n               xs)))\n  \\<le> length\n         (ads @ [snd (SOME haa. haa \\<in> allocate h (Class_type x))]) +\n        length xs", "show ?case"], ["proof (prove)\nusing this:\n  length\n   (fst (snd (foldl create_initial_object\n               (fst (SOME haa. haa \\<in> allocate h (Class_type x)),\n                ads @ [snd (SOME haa. haa \\<in> allocate h (Class_type x))],\n                True)\n               xs)))\n  \\<le> length\n         (ads @ [snd (SOME haa. haa \\<in> allocate h (Class_type x))]) +\n        length xs\n\ngoal (1 subgoal):\n 1. length (fst (snd (foldl create_initial_object (h, ads, True) (x # xs))))\n    \\<le> length ads + length (x # xs)", "by(clarsimp simp add: create_initial_object_simps split_beta)"], ["proof (state)\nthis:\n  length (fst (snd (foldl create_initial_object (h, ads, True) (x # xs))))\n  \\<le> length ads + length (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (fst (snd (foldl create_initial_object (h, ads, True) xs)))\n  \\<le> length ads + length xs\n\ngoal (1 subgoal):\n 1. length start_addrs \\<le> length initialization_list", "}"], ["proof (state)\nthis:\n  length (fst (snd (foldl create_initial_object (?h5, ?ads5, True) ?xs5)))\n  \\<le> length ?ads5 + length ?xs5\n\ngoal (1 subgoal):\n 1. length start_addrs \\<le> length initialization_list", "from this[of empty_heap \"[]\" initialization_list]"], ["proof (chain)\npicking this:\n  length\n   (fst (snd (foldl create_initial_object (empty_heap, [], True)\n               initialization_list)))\n  \\<le> length [] + length initialization_list", "show ?thesis"], ["proof (prove)\nusing this:\n  length\n   (fst (snd (foldl create_initial_object (empty_heap, [], True)\n               initialization_list)))\n  \\<le> length [] + length initialization_list\n\ngoal (1 subgoal):\n 1. length start_addrs \\<le> length initialization_list", "unfolding start_heap_def start_addrs_def start_heap_data_def"], ["proof (prove)\nusing this:\n  length\n   (fst (snd (foldl create_initial_object (empty_heap, [], True)\n               initialization_list)))\n  \\<le> length [] + length initialization_list\n\ngoal (1 subgoal):\n 1. length\n     (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                 initialization_list)))\n    \\<le> length initialization_list", "by simp"], ["proof (state)\nthis:\n  length start_addrs \\<le> length initialization_list\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in -) distinct_initialization_list:\n  \"distinct initialization_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct initialization_list", "by(simp add: initialization_list_def sys_xcpts_list_def sys_xcpts_neqs Thread_neq_sys_xcpts)"], ["", "lemma (in -) wf_syscls_initialization_list_is_class:\n  \"\\<lbrakk> wf_syscls P; C \\<in> set initialization_list \\<rbrakk> \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_syscls P; C \\<in> set initialization_list\\<rbrakk>\n    \\<Longrightarrow> is_class P C", "by(auto simp add: initialization_list_def sys_xcpts_list_def wf_syscls_is_class_xcpt)"], ["", "lemma start_addrs_NewHeapElem_start_heap_obsD:\n  \"a \\<in> set start_addrs \\<Longrightarrow> \\<exists>CTn. NewHeapElem a CTn \\<in> set start_heap_obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set start_addrs \\<Longrightarrow>\n    \\<exists>CTn. NewHeapElem a CTn \\<in> set start_heap_obs", "using length_initialization_list_le_length_start_addrs"], ["proof (prove)\nusing this:\n  length start_addrs \\<le> length initialization_list\n\ngoal (1 subgoal):\n 1. a \\<in> set start_addrs \\<Longrightarrow>\n    \\<exists>CTn. NewHeapElem a CTn \\<in> set start_heap_obs", "unfolding start_heap_obs_def start_addrs_def"], ["proof (prove)\nusing this:\n  length (fst (snd start_heap_data)) \\<le> length initialization_list\n\ngoal (1 subgoal):\n 1. a \\<in> set (fst (snd start_heap_data)) \\<Longrightarrow>\n    \\<exists>CTn.\n       NewHeapElem a CTn\n       \\<in> set (map2 (\\<lambda>C a. NewHeapElem a (Class_type C))\n                   initialization_list (fst (snd start_heap_data)))", "by(force simp add: set_zip in_set_conv_nth intro: rev_image_eqI)"], ["", "lemma in_set_start_addrs_conv_NewHeapElem:\n  \"a \\<in> set start_addrs \\<longleftrightarrow> (\\<exists>CTn. NewHeapElem a CTn \\<in> set start_heap_obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> set start_addrs) =\n    (\\<exists>CTn. NewHeapElem a CTn \\<in> set start_heap_obs)", "by(blast dest: start_addrs_NewHeapElem_start_heap_obsD intro: NewHeapElem_start_heap_obs_start_addrsD)"], ["", "subsection \\<open>@{term preallocated}\\<close>"], ["", "definition preallocated :: \"'heap \\<Rightarrow> bool\"\nwhere \"preallocated h \\<equiv> \\<forall>C \\<in> sys_xcpts. typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\""], ["", "lemma typeof_addr_sys_xcp: \n  \"\\<lbrakk> preallocated h; C \\<in> sys_xcpts \\<rbrakk> \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt C) = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk>\n    \\<Longrightarrow> typeof_addr h (addr_of_sys_xcpt C) =\n                      \\<lfloor>Class_type C\\<rfloor>", "by(simp add: preallocated_def)"], ["", "lemma typeof_sys_xcp:\n  \"\\<lbrakk> preallocated h; C \\<in> sys_xcpts \\<rbrakk> \\<Longrightarrow> typeof\\<^bsub>h\\<^esub> (Addr (addr_of_sys_xcpt C)) = \\<lfloor>Class C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h\\<^esub> (Addr (addr_of_sys_xcpt C)) =\n                      \\<lfloor>Class C\\<rfloor>", "by(simp add: typeof_addr_sys_xcp)"], ["", "lemma addr_of_sys_xcpt_start_addr:\n  \"\\<lbrakk> start_heap_ok; C \\<in> sys_xcpts \\<rbrakk> \\<Longrightarrow> addr_of_sys_xcpt C \\<in> set start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>start_heap_ok; C \\<in> sys_xcpts\\<rbrakk>\n    \\<Longrightarrow> addr_of_sys_xcpt C \\<in> set start_addrs", "unfolding start_heap_ok_def start_heap_data_def initialization_list_def sys_xcpts_list_def \n  preallocated_def start_heap_def start_addrs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (snd (foldl create_initial_object (empty_heap, [], True)\n                        [Thread, NullPointer, ClassCast, OutOfMemory,\n                         ArrayIndexOutOfBounds, ArrayStore,\n                         NegativeArraySize, ArithmeticException,\n                         IllegalMonitorState, IllegalThreadState,\n                         InterruptedException]));\n     C \\<in> sys_xcpts\\<rbrakk>\n    \\<Longrightarrow> addr_of_sys_xcpt C\n                      \\<in> set (fst (snd\n (foldl create_initial_object (empty_heap, [], True)\n   [Thread, NullPointer, ClassCast, OutOfMemory, ArrayIndexOutOfBounds,\n    ArrayStore, NegativeArraySize, ArithmeticException, IllegalMonitorState,\n    IllegalThreadState, InterruptedException])))", "apply(simp split: prod.split_asm if_split_asm add: create_initial_object_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>C \\<in> sys_xcpts;\n        allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt C = x2 \\<or>\n                         addr_of_sys_xcpt C = x2a \\<or>\n                         addr_of_sys_xcpt C = x2b \\<or>\n                         addr_of_sys_xcpt C = x2c \\<or>\n                         addr_of_sys_xcpt C = x2d \\<or>\n                         addr_of_sys_xcpt C = x2e \\<or>\n                         addr_of_sys_xcpt C = x2f \\<or>\n                         addr_of_sys_xcpt C = x2g \\<or>\n                         addr_of_sys_xcpt C = x2h \\<or>\n                         addr_of_sys_xcpt C = x2i \\<or>\n                         addr_of_sys_xcpt C = x2j", "apply(erule sys_xcpts_cases)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt NullPointer = x2 \\<or>\n                         addr_of_sys_xcpt NullPointer = x2a \\<or>\n                         addr_of_sys_xcpt NullPointer = x2b \\<or>\n                         addr_of_sys_xcpt NullPointer = x2c \\<or>\n                         addr_of_sys_xcpt NullPointer = x2d \\<or>\n                         addr_of_sys_xcpt NullPointer = x2e \\<or>\n                         addr_of_sys_xcpt NullPointer = x2f \\<or>\n                         addr_of_sys_xcpt NullPointer = x2g \\<or>\n                         addr_of_sys_xcpt NullPointer = x2h \\<or>\n                         addr_of_sys_xcpt NullPointer = x2i \\<or>\n                         addr_of_sys_xcpt NullPointer = x2j\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt OutOfMemory = x2 \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2a \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2b \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2c \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2d \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2e \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2f \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2g \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2h \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2i \\<or>\n                         addr_of_sys_xcpt OutOfMemory = x2j\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt ClassCast = x2 \\<or>\n                         addr_of_sys_xcpt ClassCast = x2a \\<or>\n                         addr_of_sys_xcpt ClassCast = x2b \\<or>\n                         addr_of_sys_xcpt ClassCast = x2c \\<or>\n                         addr_of_sys_xcpt ClassCast = x2d \\<or>\n                         addr_of_sys_xcpt ClassCast = x2e \\<or>\n                         addr_of_sys_xcpt ClassCast = x2f \\<or>\n                         addr_of_sys_xcpt ClassCast = x2g \\<or>\n                         addr_of_sys_xcpt ClassCast = x2h \\<or>\n                         addr_of_sys_xcpt ClassCast = x2i \\<or>\n                         addr_of_sys_xcpt ClassCast = x2j\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt ArrayIndexOutOfBounds = x2 \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2a \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2b \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2c \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2d \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2e \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2f \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2g \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2h \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2i \\<or>\n                         addr_of_sys_xcpt ArrayIndexOutOfBounds = x2j\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt ArrayStore = x2 \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2a \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2b \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2c \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2d \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2e \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2f \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2g \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2h \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2i \\<or>\n                         addr_of_sys_xcpt ArrayStore = x2j\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt NegativeArraySize = x2 \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2a \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2b \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2c \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2d \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2e \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2f \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2g \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2h \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2i \\<or>\n                         addr_of_sys_xcpt NegativeArraySize = x2j\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt ArithmeticException = x2 \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2a \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2b \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2c \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2d \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2e \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2f \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2g \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2h \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2i \\<or>\n                         addr_of_sys_xcpt ArithmeticException = x2j\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt IllegalMonitorState = x2 \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2a \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2b \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2c \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2d \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2e \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2f \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2g \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2h \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2i \\<or>\n                         addr_of_sys_xcpt IllegalMonitorState = x2j\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> addr_of_sys_xcpt IllegalThreadState = x2 \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2a \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2b \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2c \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2d \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2e \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2f \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2g \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2h \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2i \\<or>\n                         addr_of_sys_xcpt IllegalThreadState = x2j\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n        x2h x1i x2i x1j x2j.\n        \\<lbrakk>allocate empty_heap (Class_type Thread) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n         (x1, x2);\n         allocate x1 (Class_type NullPointer) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n         (x1a, x2a);\n         allocate x1a (Class_type ClassCast) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n         (x1b, x2b);\n         allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n         (x1c, x2c);\n         allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n         (SOME ha.\n             ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n         (x1d, x2d);\n         allocate x1d (Class_type ArrayStore) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n         (x1e, x2e);\n         allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n         (x1f, x2f);\n         allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n         (x1g, x2g);\n         allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n         (x1h, x2h);\n         allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n         (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n         (x1i, x2i);\n         allocate x1i (Class_type InterruptedException) \\<noteq> {};\n         (SOME ha.\n             ha \\<in> allocate x1i (Class_type InterruptedException)) =\n         (x1j, x2j)\\<rbrakk>\n        \\<Longrightarrow> addr_of_sys_xcpt InterruptedException = x2 \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2a \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2b \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2c \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2d \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2e \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2f \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2g \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2h \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2i \\<or>\n                          addr_of_sys_xcpt InterruptedException = x2j", "apply(simp_all add: addr_of_sys_xcpt_def start_addrs_def start_heap_data_def initialization_list_def sys_xcpts_list_def create_initial_object_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]:\n  assumes \"preallocated h\"\n  shows typeof_ClassCast: \"typeof_addr h (addr_of_sys_xcpt ClassCast) = Some(Class_type ClassCast)\"\n  and typeof_OutOfMemory: \"typeof_addr h (addr_of_sys_xcpt OutOfMemory) = Some(Class_type OutOfMemory)\" \n  and typeof_NullPointer: \"typeof_addr h (addr_of_sys_xcpt NullPointer) = Some(Class_type NullPointer)\" \n  and typeof_ArrayIndexOutOfBounds: \n  \"typeof_addr h (addr_of_sys_xcpt ArrayIndexOutOfBounds) = Some(Class_type ArrayIndexOutOfBounds)\" \n  and typeof_ArrayStore: \"typeof_addr h (addr_of_sys_xcpt ArrayStore) = Some(Class_type ArrayStore)\" \n  and typeof_NegativeArraySize: \"typeof_addr h (addr_of_sys_xcpt NegativeArraySize) = Some(Class_type NegativeArraySize)\" \n  and typeof_ArithmeticException: \"typeof_addr h (addr_of_sys_xcpt ArithmeticException) = Some(Class_type ArithmeticException)\" \n  and typeof_IllegalMonitorState: \"typeof_addr h (addr_of_sys_xcpt IllegalMonitorState) = Some(Class_type IllegalMonitorState)\"\n  and typeof_IllegalThreadState: \"typeof_addr h (addr_of_sys_xcpt IllegalThreadState) = Some(Class_type IllegalThreadState)\" \n  and typeof_InterruptedException: \"typeof_addr h (addr_of_sys_xcpt InterruptedException) = Some(Class_type InterruptedException)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((typeof_addr h (addr_of_sys_xcpt ClassCast) =\n      \\<lfloor>Class_type ClassCast\\<rfloor> &&&\n      typeof_addr h (addr_of_sys_xcpt OutOfMemory) =\n      \\<lfloor>Class_type OutOfMemory\\<rfloor>) &&&\n     typeof_addr h (addr_of_sys_xcpt NullPointer) =\n     \\<lfloor>Class_type NullPointer\\<rfloor> &&&\n     typeof_addr h (addr_of_sys_xcpt ArrayIndexOutOfBounds) =\n     \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor> &&&\n     typeof_addr h (addr_of_sys_xcpt ArrayStore) =\n     \\<lfloor>Class_type ArrayStore\\<rfloor>) &&&\n    (typeof_addr h (addr_of_sys_xcpt NegativeArraySize) =\n     \\<lfloor>Class_type NegativeArraySize\\<rfloor> &&&\n     typeof_addr h (addr_of_sys_xcpt ArithmeticException) =\n     \\<lfloor>Class_type ArithmeticException\\<rfloor>) &&&\n    typeof_addr h (addr_of_sys_xcpt IllegalMonitorState) =\n    \\<lfloor>Class_type IllegalMonitorState\\<rfloor> &&&\n    typeof_addr h (addr_of_sys_xcpt IllegalThreadState) =\n    \\<lfloor>Class_type IllegalThreadState\\<rfloor> &&&\n    typeof_addr h (addr_of_sys_xcpt InterruptedException) =\n    \\<lfloor>Class_type InterruptedException\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  preallocated h\n\ngoal (1 subgoal):\n 1. ((typeof_addr h (addr_of_sys_xcpt ClassCast) =\n      \\<lfloor>Class_type ClassCast\\<rfloor> &&&\n      typeof_addr h (addr_of_sys_xcpt OutOfMemory) =\n      \\<lfloor>Class_type OutOfMemory\\<rfloor>) &&&\n     typeof_addr h (addr_of_sys_xcpt NullPointer) =\n     \\<lfloor>Class_type NullPointer\\<rfloor> &&&\n     typeof_addr h (addr_of_sys_xcpt ArrayIndexOutOfBounds) =\n     \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor> &&&\n     typeof_addr h (addr_of_sys_xcpt ArrayStore) =\n     \\<lfloor>Class_type ArrayStore\\<rfloor>) &&&\n    (typeof_addr h (addr_of_sys_xcpt NegativeArraySize) =\n     \\<lfloor>Class_type NegativeArraySize\\<rfloor> &&&\n     typeof_addr h (addr_of_sys_xcpt ArithmeticException) =\n     \\<lfloor>Class_type ArithmeticException\\<rfloor>) &&&\n    typeof_addr h (addr_of_sys_xcpt IllegalMonitorState) =\n    \\<lfloor>Class_type IllegalMonitorState\\<rfloor> &&&\n    typeof_addr h (addr_of_sys_xcpt IllegalThreadState) =\n    \\<lfloor>Class_type IllegalThreadState\\<rfloor> &&&\n    typeof_addr h (addr_of_sys_xcpt InterruptedException) =\n    \\<lfloor>Class_type InterruptedException\\<rfloor>", "by(simp_all add: typeof_addr_sys_xcp)"], ["", "lemma cname_of_xcp [simp]:\n  \"\\<lbrakk> preallocated h; C \\<in> sys_xcpts \\<rbrakk> \\<Longrightarrow> cname_of h (addr_of_sys_xcpt C) = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk>\n    \\<Longrightarrow> cname_of h (addr_of_sys_xcpt C) = C", "by(drule (1) typeof_addr_sys_xcp)(simp add: cname_of_def)"], ["", "lemma preallocated_hext:\n  \"\\<lbrakk> preallocated h; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> preallocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "by(auto simp add: preallocated_def dest: hext_objD)"], ["", "end"], ["", "context heap begin"], ["", "lemma preallocated_heap_ops:\n  assumes \"preallocated h\"\n  shows preallocated_allocate: \"\\<And>a. (h', a) \\<in> allocate h hT \\<Longrightarrow> preallocated h'\"\n  and preallocated_write_field: \"heap_write h a al v h' \\<Longrightarrow> preallocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (h', a) \\<in> allocate h hT \\<Longrightarrow> preallocated h') &&&\n    (heap_write h a al v h' \\<Longrightarrow> preallocated h')", "using preallocated_hext[OF assms, of h']"], ["proof (prove)\nusing this:\n  h \\<unlhd> h' \\<Longrightarrow> preallocated h'\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (h', a) \\<in> allocate h hT \\<Longrightarrow> preallocated h') &&&\n    (heap_write h a al v h' \\<Longrightarrow> preallocated h')", "by(blast intro: hext_heap_ops)+"], ["", "lemma not_empty_pairE: \"\\<lbrakk> A \\<noteq> {}; \\<And>a b. (a, b) \\<in> A \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {};\n     \\<And>a b. (a, b) \\<in> A \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "lemma allocate_not_emptyI: \"(h', a) \\<in> allocate h hT \\<Longrightarrow> allocate h hT \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h', a) \\<in> allocate h hT \\<Longrightarrow> allocate h hT \\<noteq> {}", "by auto"], ["", "lemma allocate_Eps:\n  \"\\<lbrakk> (h'', a'') \\<in> allocate h hT; (SOME ha. ha \\<in> allocate h hT) = (h', a') \\<rbrakk> \\<Longrightarrow> (h', a') \\<in> allocate h hT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(h'', a'') \\<in> allocate h hT;\n     (SOME ha. ha \\<in> allocate h hT) = (h', a')\\<rbrakk>\n    \\<Longrightarrow> (h', a') \\<in> allocate h hT", "by(drule sym)(auto intro: someI)"], ["", "lemma preallocated_start_heap:\n  \"\\<lbrakk> start_heap_ok; wf_syscls P \\<rbrakk> \\<Longrightarrow> preallocated start_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>start_heap_ok; wf_syscls P\\<rbrakk>\n    \\<Longrightarrow> preallocated start_heap", "unfolding start_heap_ok_def start_heap_data_def initialization_list_def sys_xcpts_list_def \n  preallocated_def start_heap_def start_addrs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (snd (foldl create_initial_object (empty_heap, [], True)\n                        [Thread, NullPointer, ClassCast, OutOfMemory,\n                         ArrayIndexOutOfBounds, ArrayStore,\n                         NegativeArraySize, ArithmeticException,\n                         IllegalMonitorState, IllegalThreadState,\n                         InterruptedException]));\n     wf_syscls P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>sys_xcpts.\n                         typeof_addr\n                          (fst (foldl create_initial_object\n                                 (empty_heap, [], True)\n                                 [Thread, NullPointer, ClassCast,\n                                  OutOfMemory, ArrayIndexOutOfBounds,\n                                  ArrayStore, NegativeArraySize,\n                                  ArithmeticException, IllegalMonitorState,\n                                  IllegalThreadState,\n                                  InterruptedException]))\n                          (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(clarsimp split: prod.split_asm if_split_asm simp add: create_initial_object_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C.\n       \\<lbrakk>wf_syscls P;\n        allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(erule not_empty_pairE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (a, b) \\<in> allocate empty_heap (Class_type Thread);\n        (aa, ba) \\<in> allocate x1 (Class_type NullPointer);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (aa, ba) \\<in> allocate x1 (Class_type NullPointer);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d)\n        \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f)\n        \\<in> allocate x1e (Class_type NegativeArraySize)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g)\n        \\<in> allocate x1f (Class_type ArithmeticException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h)\n        \\<in> allocate x1g (Class_type IllegalMonitorState)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i)\n        \\<in> allocate x1h (Class_type IllegalThreadState)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(rotate_tac 13)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1d, x2d)\n                \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d)\n        \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1f, x2f)\n                \\<in> allocate x1e (Class_type NegativeArraySize);\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1g, x2g)\n                \\<in> allocate x1f (Class_type ArithmeticException);\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f)\n        \\<in> allocate x1e (Class_type NegativeArraySize)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1h, x2h)\n                \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g)\n        \\<in> allocate x1f (Class_type ArithmeticException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1i, x2i)\n                \\<in> allocate x1h (Class_type IllegalThreadState);\n        (x1j, x2j) \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h)\n        \\<in> allocate x1g (Class_type IllegalMonitorState)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>(x1j, x2j)\n                \\<in> allocate x1i (Class_type InterruptedException);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i)\n        \\<in> allocate x1h (Class_type IllegalThreadState)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(frule allocate_SomeD, simp add: wf_syscls_is_class_xcpt, frule hext_allocate, rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        C \\<in> sys_xcpts;\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt C) =\n                         \\<lfloor>Class_type C\\<rfloor>", "apply(erule sys_xcpts_cases)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt NullPointer) =\n                         \\<lfloor>Class_type NullPointer\\<rfloor>\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt OutOfMemory) =\n                         \\<lfloor>Class_type OutOfMemory\\<rfloor>\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt ClassCast) =\n                         \\<lfloor>Class_type ClassCast\\<rfloor>\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j\n                          (addr_of_sys_xcpt ArrayIndexOutOfBounds) =\n                         \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j (addr_of_sys_xcpt ArrayStore) =\n                         \\<lfloor>Class_type ArrayStore\\<rfloor>\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j\n                          (addr_of_sys_xcpt NegativeArraySize) =\n                         \\<lfloor>Class_type NegativeArraySize\\<rfloor>\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j\n                          (addr_of_sys_xcpt ArithmeticException) =\n                         \\<lfloor>Class_type ArithmeticException\\<rfloor>\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j\n                          (addr_of_sys_xcpt IllegalMonitorState) =\n                         \\<lfloor>Class_type IllegalMonitorState\\<rfloor>\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n       ah bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j\n                          (addr_of_sys_xcpt IllegalThreadState) =\n                         \\<lfloor>Class_type IllegalThreadState\\<rfloor>\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n        x2h x1i x2i x1j x2j C a b aa ba ab bb ac bc ad bd ae be af bf ag bg\n        ah bh ai bi aj bj.\n        \\<lbrakk>wf_syscls P;\n         (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n         (x1, x2);\n         (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n         (x1a, x2a);\n         (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n         (x1b, x2b);\n         (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n         (x1c, x2c);\n         (SOME ha.\n             ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n         (x1d, x2d);\n         (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n         (x1e, x2e);\n         (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n         (x1f, x2f);\n         (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n         (x1g, x2g);\n         (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n         (x1h, x2h);\n         (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n         (x1i, x2i);\n         (SOME ha.\n             ha \\<in> allocate x1i (Class_type InterruptedException)) =\n         (x1j, x2j);\n         typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n         empty_heap \\<unlhd> x1;\n         (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n         typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n         x1 \\<unlhd> x1a;\n         (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n         typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n         x1a \\<unlhd> x1b;\n         (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n         typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n         x1b \\<unlhd> x1c;\n         (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n         typeof_addr x1d x2d =\n         \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n         x1c \\<unlhd> x1d;\n         (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n         typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n         x1d \\<unlhd> x1e;\n         (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n         typeof_addr x1f x2f =\n         \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n         x1e \\<unlhd> x1f;\n         (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n         typeof_addr x1g x2g =\n         \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n         x1f \\<unlhd> x1g;\n         (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n         typeof_addr x1h x2h =\n         \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n         x1g \\<unlhd> x1h;\n         (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n         typeof_addr x1i x2i =\n         \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n         x1h \\<unlhd> x1i;\n         (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n         typeof_addr x1j x2j =\n         \\<lfloor>Class_type InterruptedException\\<rfloor>;\n         x1i \\<unlhd> x1j;\n         (x1j, x2j)\n         \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n        \\<Longrightarrow> typeof_addr x1j\n                           (addr_of_sys_xcpt InterruptedException) =\n                          \\<lfloor>Class_type InterruptedException\\<rfloor>", "apply(simp_all add: addr_of_sys_xcpt_def initialization_list_def sys_xcpts_list_def sys_xcpts_neqs Thread_neq_sys_xcpts start_heap_data_def start_addrs_def create_initial_object_simps allocate_not_emptyI split del: if_split)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2a =\n                         \\<lfloor>Class_type NullPointer\\<rfloor>\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2c =\n                         \\<lfloor>Class_type OutOfMemory\\<rfloor>\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2b =\n                         \\<lfloor>Class_type ClassCast\\<rfloor>\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2d =\n                         \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2e =\n                         \\<lfloor>Class_type ArrayStore\\<rfloor>\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2f =\n                         \\<lfloor>Class_type NegativeArraySize\\<rfloor>\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2g =\n                         \\<lfloor>Class_type ArithmeticException\\<rfloor>\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2h =\n                         \\<lfloor>Class_type IllegalMonitorState\\<rfloor>\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>;\n        empty_heap \\<unlhd> x1;\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        typeof_addr x1a x2a = \\<lfloor>Class_type NullPointer\\<rfloor>;\n        x1 \\<unlhd> x1a;\n        (x1a, x2a) \\<in> allocate x1 (Class_type NullPointer);\n        typeof_addr x1b x2b = \\<lfloor>Class_type ClassCast\\<rfloor>;\n        x1a \\<unlhd> x1b;\n        (x1b, x2b) \\<in> allocate x1a (Class_type ClassCast);\n        typeof_addr x1c x2c = \\<lfloor>Class_type OutOfMemory\\<rfloor>;\n        x1b \\<unlhd> x1c;\n        (x1c, x2c) \\<in> allocate x1b (Class_type OutOfMemory);\n        typeof_addr x1d x2d =\n        \\<lfloor>Class_type ArrayIndexOutOfBounds\\<rfloor>;\n        x1c \\<unlhd> x1d;\n        (x1d, x2d) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        typeof_addr x1e x2e = \\<lfloor>Class_type ArrayStore\\<rfloor>;\n        x1d \\<unlhd> x1e;\n        (x1e, x2e) \\<in> allocate x1d (Class_type ArrayStore);\n        typeof_addr x1f x2f =\n        \\<lfloor>Class_type NegativeArraySize\\<rfloor>;\n        x1e \\<unlhd> x1f;\n        (x1f, x2f) \\<in> allocate x1e (Class_type NegativeArraySize);\n        typeof_addr x1g x2g =\n        \\<lfloor>Class_type ArithmeticException\\<rfloor>;\n        x1f \\<unlhd> x1g;\n        (x1g, x2g) \\<in> allocate x1f (Class_type ArithmeticException);\n        typeof_addr x1h x2h =\n        \\<lfloor>Class_type IllegalMonitorState\\<rfloor>;\n        x1g \\<unlhd> x1h;\n        (x1h, x2h) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        typeof_addr x1i x2i =\n        \\<lfloor>Class_type IllegalThreadState\\<rfloor>;\n        x1h \\<unlhd> x1i;\n        (x1i, x2i) \\<in> allocate x1h (Class_type IllegalThreadState);\n        typeof_addr x1j x2j =\n        \\<lfloor>Class_type InterruptedException\\<rfloor>;\n        x1i \\<unlhd> x1j;\n        (x1j, x2j)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr x1j x2i =\n                         \\<lfloor>Class_type IllegalThreadState\\<rfloor>", "apply(assumption|erule typeof_addr_hext_mono)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_tid_start_addrs:\n  \"\\<lbrakk> wf_syscls P; start_heap_ok \\<rbrakk> \\<Longrightarrow> thread_id2addr start_tid \\<in> set start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_syscls P; start_heap_ok\\<rbrakk>\n    \\<Longrightarrow> thread_id2addr start_tid \\<in> set start_addrs", "unfolding start_heap_ok_def start_heap_data_def initialization_list_def sys_xcpts_list_def \n  preallocated_def start_heap_def start_addrs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_syscls P;\n     snd (snd (foldl create_initial_object (empty_heap, [], True)\n                [Thread, NullPointer, ClassCast, OutOfMemory,\n                 ArrayIndexOutOfBounds, ArrayStore, NegativeArraySize,\n                 ArithmeticException, IllegalMonitorState,\n                 IllegalThreadState, InterruptedException]))\\<rbrakk>\n    \\<Longrightarrow> thread_id2addr start_tid\n                      \\<in> set (fst (snd\n (foldl create_initial_object (empty_heap, [], True)\n   [Thread, NullPointer, ClassCast, OutOfMemory, ArrayIndexOutOfBounds,\n    ArrayStore, NegativeArraySize, ArithmeticException, IllegalMonitorState,\n    IllegalThreadState, InterruptedException])))", "apply(simp split: prod.split_asm if_split_asm add: create_initial_object_simps addr_of_sys_xcpt_def start_addrs_def start_tid_def start_heap_data_def initialization_list_def sys_xcpts_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j.\n       \\<lbrakk>wf_syscls P;\n        allocate empty_heap (Class_type Thread) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        allocate x1 (Class_type NullPointer) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        allocate x1a (Class_type ClassCast) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        allocate x1b (Class_type OutOfMemory) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        allocate x1c (Class_type ArrayIndexOutOfBounds) \\<noteq> {};\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        allocate x1d (Class_type ArrayStore) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        allocate x1e (Class_type NegativeArraySize) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        allocate x1f (Class_type ArithmeticException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        allocate x1g (Class_type IllegalMonitorState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        allocate x1h (Class_type IllegalThreadState) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        allocate x1i (Class_type InterruptedException) \\<noteq> {};\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j)\\<rbrakk>\n       \\<Longrightarrow> thread_id2addr (addr2thread_id x2) = x2 \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2a \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2b \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2c \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2d \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2e \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2f \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2g \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2h \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2i \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2j", "apply(erule not_empty_pairE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (a, b) \\<in> allocate empty_heap (Class_type Thread);\n        (aa, ba) \\<in> allocate x1 (Class_type NullPointer);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> thread_id2addr (addr2thread_id x2) = x2 \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2a \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2b \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2c \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2d \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2e \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2f \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2g \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2h \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2i \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2j", "apply(drule (1) allocate_Eps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (aa, ba) \\<in> allocate x1 (Class_type NullPointer);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        (x1, x2) \\<in> allocate empty_heap (Class_type Thread)\\<rbrakk>\n       \\<Longrightarrow> thread_id2addr (addr2thread_id x2) = x2 \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2a \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2b \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2c \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2d \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2e \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2f \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2g \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2h \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2i \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2j", "apply(rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>(x1, x2) \\<in> allocate empty_heap (Class_type Thread);\n        wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (aa, ba) \\<in> allocate x1 (Class_type NullPointer);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj)\n        \\<in> allocate x1i (Class_type InterruptedException)\\<rbrakk>\n       \\<Longrightarrow> thread_id2addr (addr2thread_id x2) = x2 \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2a \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2b \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2c \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2d \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2e \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2f \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2g \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2h \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2i \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2j", "apply(drule allocate_SomeD, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g x1h\n       x2h x1i x2i x1j x2j a b aa ba ab bb ac bc ad bd ae be af bf ag bg ah\n       bh ai bi aj bj.\n       \\<lbrakk>wf_syscls P;\n        (SOME ha. ha \\<in> allocate empty_heap (Class_type Thread)) =\n        (x1, x2);\n        (SOME ha. ha \\<in> allocate x1 (Class_type NullPointer)) =\n        (x1a, x2a);\n        (SOME ha. ha \\<in> allocate x1a (Class_type ClassCast)) =\n        (x1b, x2b);\n        (SOME ha. ha \\<in> allocate x1b (Class_type OutOfMemory)) =\n        (x1c, x2c);\n        (SOME ha.\n            ha \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds)) =\n        (x1d, x2d);\n        (SOME ha. ha \\<in> allocate x1d (Class_type ArrayStore)) =\n        (x1e, x2e);\n        (SOME ha. ha \\<in> allocate x1e (Class_type NegativeArraySize)) =\n        (x1f, x2f);\n        (SOME ha. ha \\<in> allocate x1f (Class_type ArithmeticException)) =\n        (x1g, x2g);\n        (SOME ha. ha \\<in> allocate x1g (Class_type IllegalMonitorState)) =\n        (x1h, x2h);\n        (SOME ha. ha \\<in> allocate x1h (Class_type IllegalThreadState)) =\n        (x1i, x2i);\n        (SOME ha. ha \\<in> allocate x1i (Class_type InterruptedException)) =\n        (x1j, x2j);\n        (aa, ba) \\<in> allocate x1 (Class_type NullPointer);\n        (ab, bb) \\<in> allocate x1a (Class_type ClassCast);\n        (ac, bc) \\<in> allocate x1b (Class_type OutOfMemory);\n        (ad, bd) \\<in> allocate x1c (Class_type ArrayIndexOutOfBounds);\n        (ae, be) \\<in> allocate x1d (Class_type ArrayStore);\n        (af, bf) \\<in> allocate x1e (Class_type NegativeArraySize);\n        (ag, bg) \\<in> allocate x1f (Class_type ArithmeticException);\n        (ah, bh) \\<in> allocate x1g (Class_type IllegalMonitorState);\n        (ai, bi) \\<in> allocate x1h (Class_type IllegalThreadState);\n        (aj, bj) \\<in> allocate x1i (Class_type InterruptedException);\n        typeof_addr x1 x2 = \\<lfloor>Class_type Thread\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> thread_id2addr (addr2thread_id x2) = x2 \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2a \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2b \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2c \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2d \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2e \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2f \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2g \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2h \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2i \\<or>\n                         thread_id2addr (addr2thread_id x2) = x2j", "apply(auto intro: addr2thread_id_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  assumes \"wf_syscls P\"\n  shows dom_typeof_addr_start_heap: \"set start_addrs \\<subseteq> dom (typeof_addr start_heap)\"\n  and distinct_start_addrs: \"distinct start_addrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set start_addrs \\<subseteq> dom (typeof_addr start_heap) &&&\n    distinct start_addrs", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set start_addrs \\<subseteq> dom (typeof_addr start_heap)\n 2. distinct start_addrs", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. set start_addrs \\<subseteq> dom (typeof_addr start_heap)\n 2. distinct start_addrs", "fix h ads b and Cs xs :: \"cname list\""], ["proof (state)\ngoal (2 subgoals):\n 1. set start_addrs \\<subseteq> dom (typeof_addr start_heap)\n 2. distinct start_addrs", "assume \"set ads \\<subseteq> dom (typeof_addr h)\" and \"distinct (Cs @ xs)\" and \"length Cs = length ads\"\n      and \"\\<And>C a. (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\"\n      and \"\\<And>C. C \\<in> set xs \\<Longrightarrow> is_class P C\""], ["proof (state)\nthis:\n  set ads \\<subseteq> dom (typeof_addr h)\n  distinct (Cs @ xs)\n  length Cs = length ads\n  (?C3, ?a3) \\<in> set (zip Cs ads) \\<Longrightarrow>\n  typeof_addr h ?a3 = \\<lfloor>Class_type ?C3\\<rfloor>\n  ?C3 \\<in> set xs \\<Longrightarrow> is_class P ?C3\n\ngoal (2 subgoals):\n 1. set start_addrs \\<subseteq> dom (typeof_addr start_heap)\n 2. distinct start_addrs", "hence \"set (fst (snd (foldl create_initial_object (h, ads, b) xs))) \\<subseteq>\n             dom (typeof_addr (fst (foldl create_initial_object (h, ads, b) xs))) \\<and> \n           (distinct ads \\<longrightarrow> distinct (fst (snd (foldl create_initial_object (h, ads, b) xs))))\"\n      (is \"?concl xs h ads b Cs\")"], ["proof (prove)\nusing this:\n  set ads \\<subseteq> dom (typeof_addr h)\n  distinct (Cs @ xs)\n  length Cs = length ads\n  (?C3, ?a3) \\<in> set (zip Cs ads) \\<Longrightarrow>\n  typeof_addr h ?a3 = \\<lfloor>Class_type ?C3\\<rfloor>\n  ?C3 \\<in> set xs \\<Longrightarrow> is_class P ?C3\n\ngoal (1 subgoal):\n 1. set (fst (snd (foldl create_initial_object (h, ads, b) xs)))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             xs))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct (fst (snd (foldl create_initial_object (h, ads, b) xs))))", "proof(induct xs arbitrary: h ads b Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h ads b Cs.\n       \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ []);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C. C \\<in> set [] \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) [])))\n                         \\<subseteq> dom\n(typeof_addr (fst (foldl create_initial_object (h, ads, b) []))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) []))))\n 2. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "case Nil"], ["proof (state)\nthis:\n  set ads \\<subseteq> dom (typeof_addr h)\n  distinct (Cs @ [])\n  length Cs = length ads\n  (?C3, ?a3) \\<in> set (zip Cs ads) \\<Longrightarrow>\n  typeof_addr h ?a3 = \\<lfloor>Class_type ?C3\\<rfloor>\n  ?C3 \\<in> set [] \\<Longrightarrow> is_class P ?C3\n\ngoal (2 subgoals):\n 1. \\<And>h ads b Cs.\n       \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ []);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C. C \\<in> set [] \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) [])))\n                         \\<subseteq> dom\n(typeof_addr (fst (foldl create_initial_object (h, ads, b) []))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) []))))\n 2. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "thus ?case"], ["proof (prove)\nusing this:\n  set ads \\<subseteq> dom (typeof_addr h)\n  distinct (Cs @ [])\n  length Cs = length ads\n  (?C3, ?a3) \\<in> set (zip Cs ads) \\<Longrightarrow>\n  typeof_addr h ?a3 = \\<lfloor>Class_type ?C3\\<rfloor>\n  ?C3 \\<in> set [] \\<Longrightarrow> is_class P ?C3\n\ngoal (1 subgoal):\n 1. set (fst (snd (foldl create_initial_object (h, ads, b) [])))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             []))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct (fst (snd (foldl create_initial_object (h, ads, b) []))))", "by auto"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h, ads, b) [])))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h, ads, b)\n                           []))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) []))))\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>set ?ads3 \\<subseteq> dom (typeof_addr ?h3);\n   distinct (?Cs3 @ xs); length ?Cs3 = length ?ads3;\n   \\<And>C a.\n      (C, a) \\<in> set (zip ?Cs3 ?ads3) \\<Longrightarrow>\n      typeof_addr ?h3 a = \\<lfloor>Class_type C\\<rfloor>;\n   \\<And>C. C \\<in> set xs \\<Longrightarrow> is_class P C\\<rbrakk>\n  \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n                                    (?h3, ?ads3, ?b3) xs)))\n                    \\<subseteq> dom (typeof_addr\n(fst (foldl create_initial_object (?h3, ?ads3, ?b3) xs))) \\<and>\n                    (distinct ?ads3 \\<longrightarrow>\n                     distinct\n                      (fst (snd (foldl create_initial_object\n                                  (?h3, ?ads3, ?b3) xs))))\n  set ads \\<subseteq> dom (typeof_addr h)\n  distinct (Cs @ x # xs)\n  length Cs = length ads\n  (?C3, ?a3) \\<in> set (zip Cs ads) \\<Longrightarrow>\n  typeof_addr h ?a3 = \\<lfloor>Class_type ?C3\\<rfloor>\n  ?C3 \\<in> set (x # xs) \\<Longrightarrow> is_class P ?C3\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "note ads = \\<open>set ads \\<subseteq> dom (typeof_addr h)\\<close>"], ["proof (state)\nthis:\n  set ads \\<subseteq> dom (typeof_addr h)\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "note dist = \\<open>distinct (Cs @ x # xs)\\<close>"], ["proof (state)\nthis:\n  distinct (Cs @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "note len = \\<open>length Cs = length ads\\<close>"], ["proof (state)\nthis:\n  length Cs = length ads\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "note type = \\<open>\\<And>C a. (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close>"], ["proof (state)\nthis:\n  (?C, ?a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n  typeof_addr h ?a = \\<lfloor>Class_type ?C\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "note is_class = \\<open>\\<And>C. C \\<in> set (x # xs) \\<Longrightarrow> is_class P C\\<close>"], ["proof (state)\nthis:\n  ?C \\<in> set (x # xs) \\<Longrightarrow> is_class P ?C\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>set ads \\<subseteq> dom (typeof_addr h);\n                    distinct (Cs @ xs); length Cs = length ads;\n                    \\<And>C a.\n                       (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    \\<And>C.\n                       C \\<in> set xs \\<Longrightarrow>\n                       is_class P C\\<rbrakk>\n                   \\<Longrightarrow> set\n(fst (snd (foldl create_initial_object (h, ads, b) xs)))\n                                     \\<subseteq> dom\n            (typeof_addr\n              (fst (foldl create_initial_object (h, ads, b) xs))) \\<and>\n                                     (distinct ads \\<longrightarrow>\ndistinct (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n        set ads \\<subseteq> dom (typeof_addr h); distinct (Cs @ a # xs);\n        length Cs = length ads;\n        \\<And>C a.\n           (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        \\<And>C.\n           C \\<in> set (a # xs) \\<Longrightarrow> is_class P C\\<rbrakk>\n       \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n   (h, ads, b) (a # xs))))\n                         \\<subseteq> dom\n(typeof_addr\n  (fst (foldl create_initial_object (h, ads, b) (a # xs)))) \\<and>\n                         (distinct ads \\<longrightarrow>\n                          distinct\n                           (fst (snd (foldl create_initial_object\n (h, ads, b) (a # xs)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "proof(cases \"b \\<and> allocate h (Class_type x) \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n 2. \\<not> (b \\<and>\n            allocate h (Class_type x) \\<noteq> {}) \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "case False"], ["proof (state)\nthis:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n\ngoal (2 subgoals):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n 2. \\<not> (b \\<and>\n            allocate h (Class_type x) \\<noteq> {}) \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n\ngoal (1 subgoal):\n 1. set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "using ads len"], ["proof (prove)\nusing this:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n  set ads \\<subseteq> dom (typeof_addr h)\n  length Cs = length ads\n\ngoal (1 subgoal):\n 1. set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "by(auto simp add: create_initial_object_simps zip_append1)"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h, ads, b)\n                           (x # xs)))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "case [simp]: True"], ["proof (state)\nthis:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "obtain h' a' where h'a': \"(SOME ha. ha \\<in> allocate h (Class_type x)) = (h', a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h' a'.\n        (SOME haa. haa \\<in> allocate h (Class_type x)) =\n        (h', a') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"SOME ha. ha \\<in> allocate h (Class_type x)\")"], ["proof (state)\nthis:\n  (SOME haa. haa \\<in> allocate h (Class_type x)) = (h', a')\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "with True"], ["proof (chain)\npicking this:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}\n  (SOME haa. haa \\<in> allocate h (Class_type x)) = (h', a')", "have new_obj: \"(h', a') \\<in> allocate h (Class_type x)\""], ["proof (prove)\nusing this:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}\n  (SOME haa. haa \\<in> allocate h (Class_type x)) = (h', a')\n\ngoal (1 subgoal):\n 1. (h', a') \\<in> allocate h (Class_type x)", "by(auto simp del: True intro: allocate_Eps)"], ["proof (state)\nthis:\n  (h', a') \\<in> allocate h (Class_type x)\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "hence hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h (Class_type x)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_allocate)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "with ads new_obj"], ["proof (chain)\npicking this:\n  set ads \\<subseteq> dom (typeof_addr h)\n  (h', a') \\<in> allocate h (Class_type x)\n  h \\<unlhd> h'", "have ads': \"set ads \\<subseteq> dom (typeof_addr h')\""], ["proof (prove)\nusing this:\n  set ads \\<subseteq> dom (typeof_addr h)\n  (h', a') \\<in> allocate h (Class_type x)\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. set ads \\<subseteq> dom (typeof_addr h')", "by(auto dest: typeof_addr_hext_mono[OF hext_allocate])"], ["proof (state)\nthis:\n  set ads \\<subseteq> dom (typeof_addr h')\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "moreover"], ["proof (state)\nthis:\n  set ads \\<subseteq> dom (typeof_addr h')\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "{"], ["proof (state)\nthis:\n  set ads \\<subseteq> dom (typeof_addr h')\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "from new_obj ads' is_class[of x]"], ["proof (chain)\npicking this:\n  (h', a') \\<in> allocate h (Class_type x)\n  set ads \\<subseteq> dom (typeof_addr h')\n  x \\<in> set (x # xs) \\<Longrightarrow> is_class P x", "have \"set (ads @ [a']) \\<subseteq> dom (typeof_addr h')\""], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h (Class_type x)\n  set ads \\<subseteq> dom (typeof_addr h')\n  x \\<in> set (x # xs) \\<Longrightarrow> is_class P x\n\ngoal (1 subgoal):\n 1. set (ads @ [a']) \\<subseteq> dom (typeof_addr h')", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  set (ads @ [a']) \\<subseteq> dom (typeof_addr h')\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "moreover"], ["proof (state)\nthis:\n  set (ads @ [a']) \\<subseteq> dom (typeof_addr h')\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "from dist"], ["proof (chain)\npicking this:\n  distinct (Cs @ x # xs)", "have \"distinct ((Cs @ [x]) @ xs)\""], ["proof (prove)\nusing this:\n  distinct (Cs @ x # xs)\n\ngoal (1 subgoal):\n 1. distinct ((Cs @ [x]) @ xs)", "by simp"], ["proof (state)\nthis:\n  distinct ((Cs @ [x]) @ xs)\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "moreover"], ["proof (state)\nthis:\n  distinct ((Cs @ [x]) @ xs)\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "have \"length (Cs @ [x]) = length (ads @ [a'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Cs @ [x]) = length (ads @ [a'])", "using len"], ["proof (prove)\nusing this:\n  length Cs = length ads\n\ngoal (1 subgoal):\n 1. length (Cs @ [x]) = length (ads @ [a'])", "by simp"], ["proof (state)\nthis:\n  length (Cs @ [x]) = length (ads @ [a'])\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "moreover"], ["proof (state)\nthis:\n  length (Cs @ [x]) = length (ads @ [a'])\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "{"], ["proof (state)\nthis:\n  length (Cs @ [x]) = length (ads @ [a'])\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "fix C a"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "assume \"(C, a) \\<in> set (zip (Cs @ [x]) (ads @ [a']))\""], ["proof (state)\nthis:\n  (C, a) \\<in> set (zip (Cs @ [x]) (ads @ [a']))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "hence \"typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (C, a) \\<in> set (zip (Cs @ [x]) (ads @ [a']))\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>", "using hext new_obj type[of C a] len is_class"], ["proof (prove)\nusing this:\n  (C, a) \\<in> set (zip (Cs @ [x]) (ads @ [a']))\n  h \\<unlhd> h'\n  (h', a') \\<in> allocate h (Class_type x)\n  (C, a) \\<in> set (zip Cs ads) \\<Longrightarrow>\n  typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  length Cs = length ads\n  ?C \\<in> set (x # xs) \\<Longrightarrow> is_class P ?C\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>", "by(auto dest: allocate_SomeD hext_objD)"], ["proof (state)\nthis:\n  typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "}"], ["proof (state)\nthis:\n  (?C5, ?a5) \\<in> set (zip (Cs @ [x]) (ads @ [a'])) \\<Longrightarrow>\n  typeof_addr h' ?a5 = \\<lfloor>Class_type ?C5\\<rfloor>\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "note type' = this"], ["proof (state)\nthis:\n  (?C5, ?a5) \\<in> set (zip (Cs @ [x]) (ads @ [a'])) \\<Longrightarrow>\n  typeof_addr h' ?a5 = \\<lfloor>Class_type ?C5\\<rfloor>\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "moreover"], ["proof (state)\nthis:\n  (?C5, ?a5) \\<in> set (zip (Cs @ [x]) (ads @ [a'])) \\<Longrightarrow>\n  typeof_addr h' ?a5 = \\<lfloor>Class_type ?C5\\<rfloor>\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "have is_class': \"\\<And>C. C \\<in> set xs \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C. C \\<in> set xs \\<Longrightarrow> is_class P C", "using is_class"], ["proof (prove)\nusing this:\n  ?C \\<in> set (x # xs) \\<Longrightarrow> is_class P ?C\n\ngoal (1 subgoal):\n 1. \\<And>C. C \\<in> set xs \\<Longrightarrow> is_class P C", "by simp"], ["proof (state)\nthis:\n  ?C3 \\<in> set xs \\<Longrightarrow> is_class P ?C3\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "ultimately"], ["proof (chain)\npicking this:\n  set (ads @ [a']) \\<subseteq> dom (typeof_addr h')\n  distinct ((Cs @ [x]) @ xs)\n  length (Cs @ [x]) = length (ads @ [a'])\n  (?C5, ?a5) \\<in> set (zip (Cs @ [x]) (ads @ [a'])) \\<Longrightarrow>\n  typeof_addr h' ?a5 = \\<lfloor>Class_type ?C5\\<rfloor>\n  ?C3 \\<in> set xs \\<Longrightarrow> is_class P ?C3", "have \"?concl xs h' (ads @ [a']) True (Cs @ [x])\""], ["proof (prove)\nusing this:\n  set (ads @ [a']) \\<subseteq> dom (typeof_addr h')\n  distinct ((Cs @ [x]) @ xs)\n  length (Cs @ [x]) = length (ads @ [a'])\n  (?C5, ?a5) \\<in> set (zip (Cs @ [x]) (ads @ [a'])) \\<Longrightarrow>\n  typeof_addr h' ?a5 = \\<lfloor>Class_type ?C5\\<rfloor>\n  ?C3 \\<in> set xs \\<Longrightarrow> is_class P ?C3\n\ngoal (1 subgoal):\n 1. set (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs)))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object\n                             (h', ads @ [a'], True) xs))) \\<and>\n    (distinct (ads @ [a']) \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))", "by(rule Cons)"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs)))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h', ads @ [a'], True)\n                           xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "moreover"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs)))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h', ads @ [a'], True)\n                           xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "have \"a' \\<notin> set ads\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<notin> set ads", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a' \\<in> set ads \\<Longrightarrow> False", "assume a': \"a' \\<in> set ads\""], ["proof (state)\nthis:\n  a' \\<in> set ads\n\ngoal (1 subgoal):\n 1. a' \\<in> set ads \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a' \\<in> set ads", "obtain C where \"(C, a') \\<in> set (zip Cs ads)\" \"C \\<in> set Cs\""], ["proof (prove)\nusing this:\n  a' \\<in> set ads\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>(C, a') \\<in> set (zip Cs ads); C \\<in> set Cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using len"], ["proof (prove)\nusing this:\n  a' \\<in> set ads\n  length Cs = length ads\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>(C, a') \\<in> set (zip Cs ads); C \\<in> set Cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_zip in_set_conv_nth"], ["proof (prove)\nusing this:\n  \\<exists>i<length ads. ads ! i = a'\n  length Cs = length ads\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>(C, a')\n                 \\<in> {(Cs ! i, ads ! i) |i.\n                        i < min (length Cs) (length ads)};\n         \\<exists>i<length Cs. Cs ! i = C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (C, a') \\<in> set (zip Cs ads)\n  C \\<in> set Cs\n\ngoal (1 subgoal):\n 1. a' \\<in> set ads \\<Longrightarrow> False", "hence \"typeof_addr h a' = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (C, a') \\<in> set (zip Cs ads)\n  C \\<in> set Cs\n\ngoal (1 subgoal):\n 1. typeof_addr h a' = \\<lfloor>Class_type C\\<rfloor>", "by-(rule type)"], ["proof (state)\nthis:\n  typeof_addr h a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. a' \\<in> set ads \\<Longrightarrow> False", "with hext"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  typeof_addr h a' = \\<lfloor>Class_type C\\<rfloor>", "have \"typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof_addr h a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>", "by(rule typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. a' \\<in> set ads \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. a' \\<in> set ads \\<Longrightarrow> False", "from new_obj is_class"], ["proof (chain)\npicking this:\n  (h', a') \\<in> allocate h (Class_type x)\n  ?C \\<in> set (x # xs) \\<Longrightarrow> is_class P ?C", "have \"typeof_addr h' a' = \\<lfloor>Class_type x\\<rfloor>\""], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h (Class_type x)\n  ?C \\<in> set (x # xs) \\<Longrightarrow> is_class P ?C\n\ngoal (1 subgoal):\n 1. typeof_addr h' a' = \\<lfloor>Class_type x\\<rfloor>", "by(auto dest: allocate_SomeD)"], ["proof (state)\nthis:\n  typeof_addr h' a' = \\<lfloor>Class_type x\\<rfloor>\n\ngoal (1 subgoal):\n 1. a' \\<in> set ads \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\n  typeof_addr h' a' = \\<lfloor>Class_type x\\<rfloor>", "have \"C = x\""], ["proof (prove)\nusing this:\n  typeof_addr h' a' = \\<lfloor>Class_type C\\<rfloor>\n  typeof_addr h' a' = \\<lfloor>Class_type x\\<rfloor>\n\ngoal (1 subgoal):\n 1. C = x", "by simp"], ["proof (state)\nthis:\n  C = x\n\ngoal (1 subgoal):\n 1. a' \\<in> set ads \\<Longrightarrow> False", "with dist \\<open>C \\<in> set Cs\\<close>"], ["proof (chain)\npicking this:\n  distinct (Cs @ x # xs)\n  C \\<in> set Cs\n  C = x", "show False"], ["proof (prove)\nusing this:\n  distinct (Cs @ x # xs)\n  C \\<in> set Cs\n  C = x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a' \\<notin> set ads\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "moreover"], ["proof (state)\nthis:\n  a' \\<notin> set ads\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "note calculation"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs)))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h', ads @ [a'], True)\n                           xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n  a' \\<notin> set ads\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "}"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs)))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h', ads @ [a'], True)\n                           xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n  a' \\<notin> set ads\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "ultimately"], ["proof (chain)\npicking this:\n  set ads \\<subseteq> dom (typeof_addr h')\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs)))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h', ads @ [a'], True)\n                           xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n  a' \\<notin> set ads", "show ?thesis"], ["proof (prove)\nusing this:\n  set ads \\<subseteq> dom (typeof_addr h')\n  set (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs)))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h', ads @ [a'], True)\n                           xs))) \\<and>\n  (distinct (ads @ [a']) \\<longrightarrow>\n   distinct\n    (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\n  a' \\<notin> set ads\n\ngoal (1 subgoal):\n 1. set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object (h, ads, b)\n                             (x # xs)))) \\<and>\n    (distinct ads \\<longrightarrow>\n     distinct\n      (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))", "by(simp add: create_initial_object_simps new_obj h'a')"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h, ads, b)\n                           (x # xs)))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h, ads, b) (x # xs))))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h, ads, b)\n                           (x # xs)))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (fst (snd (foldl create_initial_object (h, ads, b) xs)))\n  \\<subseteq> dom (typeof_addr\n                    (fst (foldl create_initial_object (h, ads, b)\n                           xs))) \\<and>\n  (distinct ads \\<longrightarrow>\n   distinct (fst (snd (foldl create_initial_object (h, ads, b) xs))))\n\ngoal (2 subgoals):\n 1. set start_addrs \\<subseteq> dom (typeof_addr start_heap)\n 2. distinct start_addrs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set ?ads5 \\<subseteq> dom (typeof_addr ?h5);\n   distinct (?Cs5 @ ?xs5); length ?Cs5 = length ?ads5;\n   \\<And>C a.\n      (C, a) \\<in> set (zip ?Cs5 ?ads5) \\<Longrightarrow>\n      typeof_addr ?h5 a = \\<lfloor>Class_type C\\<rfloor>;\n   \\<And>C. C \\<in> set ?xs5 \\<Longrightarrow> is_class P C\\<rbrakk>\n  \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n                                    (?h5, ?ads5, ?b5) ?xs5)))\n                    \\<subseteq> dom (typeof_addr\n(fst (foldl create_initial_object (?h5, ?ads5, ?b5) ?xs5))) \\<and>\n                    (distinct ?ads5 \\<longrightarrow>\n                     distinct\n                      (fst (snd (foldl create_initial_object\n                                  (?h5, ?ads5, ?b5) ?xs5))))\n\ngoal (2 subgoals):\n 1. set start_addrs \\<subseteq> dom (typeof_addr start_heap)\n 2. distinct start_addrs", "from this[of \"[]\" empty_heap \"[]\" initialization_list True]\n    distinct_initialization_list wf_syscls_initialization_list_is_class[OF assms]"], ["proof (chain)\npicking this:\n  \\<lbrakk>set [] \\<subseteq> dom (typeof_addr empty_heap);\n   distinct ([] @ initialization_list); length [] = length [];\n   \\<And>C a.\n      (C, a) \\<in> set (zip [] []) \\<Longrightarrow>\n      typeof_addr empty_heap a = \\<lfloor>Class_type C\\<rfloor>;\n   \\<And>C.\n      C \\<in> set initialization_list \\<Longrightarrow>\n      is_class P C\\<rbrakk>\n  \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n                                    (empty_heap, [], True)\n                                    initialization_list)))\n                    \\<subseteq> dom (typeof_addr\n(fst (foldl create_initial_object (empty_heap, [], True)\n       initialization_list))) \\<and>\n                    (distinct [] \\<longrightarrow>\n                     distinct\n                      (fst (snd (foldl create_initial_object\n                                  (empty_heap, [], True)\n                                  initialization_list))))\n  distinct initialization_list\n  ?C \\<in> set initialization_list \\<Longrightarrow> is_class P ?C", "show \"set start_addrs \\<subseteq> dom (typeof_addr start_heap)\"\n    and \"distinct start_addrs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set [] \\<subseteq> dom (typeof_addr empty_heap);\n   distinct ([] @ initialization_list); length [] = length [];\n   \\<And>C a.\n      (C, a) \\<in> set (zip [] []) \\<Longrightarrow>\n      typeof_addr empty_heap a = \\<lfloor>Class_type C\\<rfloor>;\n   \\<And>C.\n      C \\<in> set initialization_list \\<Longrightarrow>\n      is_class P C\\<rbrakk>\n  \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n                                    (empty_heap, [], True)\n                                    initialization_list)))\n                    \\<subseteq> dom (typeof_addr\n(fst (foldl create_initial_object (empty_heap, [], True)\n       initialization_list))) \\<and>\n                    (distinct [] \\<longrightarrow>\n                     distinct\n                      (fst (snd (foldl create_initial_object\n                                  (empty_heap, [], True)\n                                  initialization_list))))\n  distinct initialization_list\n  ?C \\<in> set initialization_list \\<Longrightarrow> is_class P ?C\n\ngoal (1 subgoal):\n 1. set start_addrs \\<subseteq> dom (typeof_addr start_heap) &&&\n    distinct start_addrs", "unfolding start_heap_def start_addrs_def start_heap_data_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set [] \\<subseteq> dom (typeof_addr empty_heap);\n   distinct ([] @ initialization_list); length [] = length [];\n   \\<And>C a.\n      (C, a) \\<in> set (zip [] []) \\<Longrightarrow>\n      typeof_addr empty_heap a = \\<lfloor>Class_type C\\<rfloor>;\n   \\<And>C.\n      C \\<in> set initialization_list \\<Longrightarrow>\n      is_class P C\\<rbrakk>\n  \\<Longrightarrow> set (fst (snd (foldl create_initial_object\n                                    (empty_heap, [], True)\n                                    initialization_list)))\n                    \\<subseteq> dom (typeof_addr\n(fst (foldl create_initial_object (empty_heap, [], True)\n       initialization_list))) \\<and>\n                    (distinct [] \\<longrightarrow>\n                     distinct\n                      (fst (snd (foldl create_initial_object\n                                  (empty_heap, [], True)\n                                  initialization_list))))\n  distinct initialization_list\n  ?C \\<in> set initialization_list \\<Longrightarrow> is_class P ?C\n\ngoal (1 subgoal):\n 1. set (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                    initialization_list)))\n    \\<subseteq> dom (typeof_addr\n                      (fst (foldl create_initial_object\n                             (empty_heap, [], True)\n                             initialization_list))) &&&\n    distinct\n     (fst (snd (foldl create_initial_object (empty_heap, [], True)\n                 initialization_list)))", "by auto"], ["proof (state)\nthis:\n  set start_addrs \\<subseteq> dom (typeof_addr start_heap)\n  distinct start_addrs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NewHeapElem_start_heap_obsD:\n  assumes \"wf_syscls P\"\n  and \"NewHeapElem a hT \\<in> set start_heap_obs\"\n  shows \"typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "proof(cases hT)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "case (Class_type C)"], ["proof (state)\nthis:\n  hT = Class_type C\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "{"], ["proof (state)\nthis:\n  hT = Class_type C\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "fix h ads b xs Cs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "assume \"(C, a) \\<in> set (zip (Cs @ xs) (fst (snd (foldl create_initial_object (h, ads, b) xs))))\"\n        and \"\\<forall>(C, a) \\<in> set (zip Cs ads). typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\"\n        and \"length Cs = length ads\"\n        and \"\\<forall>C \\<in> set xs. is_class P C\""], ["proof (state)\nthis:\n  (C, a)\n  \\<in> set (zip (Cs @ xs)\n              (fst (snd (foldl create_initial_object (h, ads, b) xs))))\n  \\<forall>(C, a)\\<in>set (zip Cs ads).\n     typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  length Cs = length ads\n  \\<forall>C\\<in>set xs. is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "hence \"typeof_addr (fst (foldl create_initial_object (h, ads, b) xs)) a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (C, a)\n  \\<in> set (zip (Cs @ xs)\n              (fst (snd (foldl create_initial_object (h, ads, b) xs))))\n  \\<forall>(C, a)\\<in>set (zip Cs ads).\n     typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  length Cs = length ads\n  \\<forall>C\\<in>set xs. is_class P C\n\ngoal (1 subgoal):\n 1. typeof_addr (fst (foldl create_initial_object (h, ads, b) xs)) a =\n    \\<lfloor>Class_type C\\<rfloor>", "proof(induct xs arbitrary: h ads b Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h ads b Cs.\n       \\<lbrakk>(C, a)\n                \\<in> set (zip (Cs @ [])\n                            (fst (snd (foldl create_initial_object\n  (h, ads, b) []))));\n        \\<forall>(C, a)\\<in>set (zip Cs ads).\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        length Cs = length ads; Ball (set []) (is_class P)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr\n                          (fst (foldl create_initial_object (h, ads, b) []))\n                          a =\n                         \\<lfloor>Class_type C\\<rfloor>\n 2. \\<And>aa xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>(C, a)\n                            \\<in> set (zip (Cs @ xs)\n  (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n                    \\<forall>(C, a)\\<in>set (zip Cs ads).\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    length Cs = length ads;\n                    Ball (set xs) (is_class P)\\<rbrakk>\n                   \\<Longrightarrow> typeof_addr\n(fst (foldl create_initial_object (h, ads, b) xs)) a =\n                                     \\<lfloor>Class_type C\\<rfloor>;\n        (C, a)\n        \\<in> set (zip (Cs @ aa # xs)\n                    (fst (snd (foldl create_initial_object (h, ads, b)\n                                (aa # xs)))));\n        \\<forall>(C, a)\\<in>set (zip Cs ads).\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        length Cs = length ads; Ball (set (aa # xs)) (is_class P)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (aa # xs)))\n                          a =\n                         \\<lfloor>Class_type C\\<rfloor>", "case Nil"], ["proof (state)\nthis:\n  (C, a)\n  \\<in> set (zip (Cs @ [])\n              (fst (snd (foldl create_initial_object (h, ads, b) []))))\n  \\<forall>a\\<in>set (zip Cs ads).\n     case a of\n     (C, a) \\<Rightarrow> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  length Cs = length ads\n  \\<forall>a\\<in>set []. is_class P a\n\ngoal (2 subgoals):\n 1. \\<And>h ads b Cs.\n       \\<lbrakk>(C, a)\n                \\<in> set (zip (Cs @ [])\n                            (fst (snd (foldl create_initial_object\n  (h, ads, b) []))));\n        \\<forall>(C, a)\\<in>set (zip Cs ads).\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        length Cs = length ads; Ball (set []) (is_class P)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr\n                          (fst (foldl create_initial_object (h, ads, b) []))\n                          a =\n                         \\<lfloor>Class_type C\\<rfloor>\n 2. \\<And>aa xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>(C, a)\n                            \\<in> set (zip (Cs @ xs)\n  (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n                    \\<forall>(C, a)\\<in>set (zip Cs ads).\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    length Cs = length ads;\n                    Ball (set xs) (is_class P)\\<rbrakk>\n                   \\<Longrightarrow> typeof_addr\n(fst (foldl create_initial_object (h, ads, b) xs)) a =\n                                     \\<lfloor>Class_type C\\<rfloor>;\n        (C, a)\n        \\<in> set (zip (Cs @ aa # xs)\n                    (fst (snd (foldl create_initial_object (h, ads, b)\n                                (aa # xs)))));\n        \\<forall>(C, a)\\<in>set (zip Cs ads).\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        length Cs = length ads; Ball (set (aa # xs)) (is_class P)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (aa # xs)))\n                          a =\n                         \\<lfloor>Class_type C\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  (C, a)\n  \\<in> set (zip (Cs @ [])\n              (fst (snd (foldl create_initial_object (h, ads, b) []))))\n  \\<forall>a\\<in>set (zip Cs ads).\n     case a of\n     (C, a) \\<Rightarrow> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  length Cs = length ads\n  \\<forall>a\\<in>set []. is_class P a\n\ngoal (1 subgoal):\n 1. typeof_addr (fst (foldl create_initial_object (h, ads, b) [])) a =\n    \\<lfloor>Class_type C\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  typeof_addr (fst (foldl create_initial_object (h, ads, b) [])) a =\n  \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>aa xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>(C, a)\n                            \\<in> set (zip (Cs @ xs)\n  (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n                    \\<forall>(C, a)\\<in>set (zip Cs ads).\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    length Cs = length ads;\n                    Ball (set xs) (is_class P)\\<rbrakk>\n                   \\<Longrightarrow> typeof_addr\n(fst (foldl create_initial_object (h, ads, b) xs)) a =\n                                     \\<lfloor>Class_type C\\<rfloor>;\n        (C, a)\n        \\<in> set (zip (Cs @ aa # xs)\n                    (fst (snd (foldl create_initial_object (h, ads, b)\n                                (aa # xs)))));\n        \\<forall>(C, a)\\<in>set (zip Cs ads).\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        length Cs = length ads; Ball (set (aa # xs)) (is_class P)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (aa # xs)))\n                          a =\n                         \\<lfloor>Class_type C\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>(C, a)\n                            \\<in> set (zip (Cs @ xs)\n  (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n                    \\<forall>(C, a)\\<in>set (zip Cs ads).\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    length Cs = length ads;\n                    Ball (set xs) (is_class P)\\<rbrakk>\n                   \\<Longrightarrow> typeof_addr\n(fst (foldl create_initial_object (h, ads, b) xs)) a =\n                                     \\<lfloor>Class_type C\\<rfloor>;\n        (C, a)\n        \\<in> set (zip (Cs @ aa # xs)\n                    (fst (snd (foldl create_initial_object (h, ads, b)\n                                (aa # xs)))));\n        \\<forall>(C, a)\\<in>set (zip Cs ads).\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        length Cs = length ads; Ball (set (aa # xs)) (is_class P)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (aa # xs)))\n                          a =\n                         \\<lfloor>Class_type C\\<rfloor>", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(C, a)\n           \\<in> set (zip (?Cs3 @ xs)\n                       (fst (snd (foldl create_initial_object\n                                   (?h3, ?ads3, ?b3) xs))));\n   \\<forall>a\\<in>set (zip ?Cs3 ?ads3).\n      case a of\n      (C, a) \\<Rightarrow>\n        typeof_addr ?h3 a = \\<lfloor>Class_type C\\<rfloor>;\n   length ?Cs3 = length ?ads3; \\<forall>a\\<in>set xs. is_class P a\\<rbrakk>\n  \\<Longrightarrow> typeof_addr\n                     (fst (foldl create_initial_object (?h3, ?ads3, ?b3)\n                            xs))\n                     a =\n                    \\<lfloor>Class_type C\\<rfloor>\n  (C, a)\n  \\<in> set (zip (Cs @ x # xs)\n              (fst (snd (foldl create_initial_object (h, ads, b)\n                          (x # xs)))))\n  \\<forall>a\\<in>set (zip Cs ads).\n     case a of\n     (C, a) \\<Rightarrow> typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  length Cs = length ads\n  \\<forall>a\\<in>set (x # xs). is_class P a\n\ngoal (1 subgoal):\n 1. \\<And>aa xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>(C, a)\n                            \\<in> set (zip (Cs @ xs)\n  (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n                    \\<forall>(C, a)\\<in>set (zip Cs ads).\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    length Cs = length ads;\n                    Ball (set xs) (is_class P)\\<rbrakk>\n                   \\<Longrightarrow> typeof_addr\n(fst (foldl create_initial_object (h, ads, b) xs)) a =\n                                     \\<lfloor>Class_type C\\<rfloor>;\n        (C, a)\n        \\<in> set (zip (Cs @ aa # xs)\n                    (fst (snd (foldl create_initial_object (h, ads, b)\n                                (aa # xs)))));\n        \\<forall>(C, a)\\<in>set (zip Cs ads).\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        length Cs = length ads; Ball (set (aa # xs)) (is_class P)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (aa # xs)))\n                          a =\n                         \\<lfloor>Class_type C\\<rfloor>", "note inv = \\<open>\\<forall>(C, a) \\<in> set (zip Cs ads). typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\\<close>\n          and Ca = \\<open>(C, a) \\<in> set (zip (Cs @ x # xs) (fst (snd (foldl create_initial_object (h, ads, b) (x # xs)))))\\<close>\n          and len = \\<open>length Cs = length ads\\<close>\n          and is_class = \\<open>\\<forall>C \\<in> set (x # xs). is_class P C\\<close>"], ["proof (state)\nthis:\n  \\<forall>(C, a)\\<in>set (zip Cs ads).\n     typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (C, a)\n  \\<in> set (zip (Cs @ x # xs)\n              (fst (snd (foldl create_initial_object (h, ads, b)\n                          (x # xs)))))\n  length Cs = length ads\n  \\<forall>C\\<in>set (x # xs). is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>aa xs h ads b Cs.\n       \\<lbrakk>\\<And>h ads b Cs.\n                   \\<lbrakk>(C, a)\n                            \\<in> set (zip (Cs @ xs)\n  (fst (snd (foldl create_initial_object (h, ads, b) xs))));\n                    \\<forall>(C, a)\\<in>set (zip Cs ads).\n                       typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n                    length Cs = length ads;\n                    Ball (set xs) (is_class P)\\<rbrakk>\n                   \\<Longrightarrow> typeof_addr\n(fst (foldl create_initial_object (h, ads, b) xs)) a =\n                                     \\<lfloor>Class_type C\\<rfloor>;\n        (C, a)\n        \\<in> set (zip (Cs @ aa # xs)\n                    (fst (snd (foldl create_initial_object (h, ads, b)\n                                (aa # xs)))));\n        \\<forall>(C, a)\\<in>set (zip Cs ads).\n           typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>;\n        length Cs = length ads; Ball (set (aa # xs)) (is_class P)\\<rbrakk>\n       \\<Longrightarrow> typeof_addr\n                          (fst (foldl create_initial_object (h, ads, b)\n                                 (aa # xs)))\n                          a =\n                         \\<lfloor>Class_type C\\<rfloor>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "proof(cases \"b \\<and> allocate h (Class_type x) \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>\n 2. \\<not> (b \\<and>\n            allocate h (Class_type x) \\<noteq> {}) \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "case False"], ["proof (state)\nthis:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n\ngoal (2 subgoals):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>\n 2. \\<not> (b \\<and>\n            allocate h (Class_type x) \\<noteq> {}) \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n\ngoal (1 subgoal):\n 1. typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "using inv Ca len"], ["proof (prove)\nusing this:\n  \\<not> (b \\<and> allocate h (Class_type x) \\<noteq> {})\n  \\<forall>(C, a)\\<in>set (zip Cs ads).\n     typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  (C, a)\n  \\<in> set (zip (Cs @ x # xs)\n              (fst (snd (foldl create_initial_object (h, ads, b)\n                          (x # xs)))))\n  length Cs = length ads\n\ngoal (1 subgoal):\n 1. typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "by(auto simp add: create_initial_object_simps zip_append1 split: if_split_asm)"], ["proof (state)\nthis:\n  typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n  \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "case [simp]: True"], ["proof (state)\nthis:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "obtain h' a' where h'a': \"(SOME ha. ha \\<in> allocate h (Class_type x)) = (h', a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h' a'.\n        (SOME haa. haa \\<in> allocate h (Class_type x)) =\n        (h', a') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"SOME ha. ha \\<in> allocate h (Class_type x)\")"], ["proof (state)\nthis:\n  (SOME haa. haa \\<in> allocate h (Class_type x)) = (h', a')\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "with True"], ["proof (chain)\npicking this:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}\n  (SOME haa. haa \\<in> allocate h (Class_type x)) = (h', a')", "have new_obj: \"(h', a') \\<in> allocate h (Class_type x)\""], ["proof (prove)\nusing this:\n  b \\<and> allocate h (Class_type x) \\<noteq> {}\n  (SOME haa. haa \\<in> allocate h (Class_type x)) = (h', a')\n\ngoal (1 subgoal):\n 1. (h', a') \\<in> allocate h (Class_type x)", "by(auto simp del: True intro: allocate_Eps)"], ["proof (state)\nthis:\n  (h', a') \\<in> allocate h (Class_type x)\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "hence hext: \"h \\<unlhd> h'\""], ["proof (prove)\nusing this:\n  (h', a') \\<in> allocate h (Class_type x)\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h'", "by(rule hext_allocate)"], ["proof (state)\nthis:\n  h \\<unlhd> h'\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "have \"(C, a) \\<in> set (zip ((Cs @ [x]) @ xs) (fst (snd (foldl create_initial_object (h', ads @ [a'], True) xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C, a)\n    \\<in> set (zip ((Cs @ [x]) @ xs)\n                (fst (snd (foldl create_initial_object\n                            (h', ads @ [a'], True) xs))))", "using Ca new_obj"], ["proof (prove)\nusing this:\n  (C, a)\n  \\<in> set (zip (Cs @ x # xs)\n              (fst (snd (foldl create_initial_object (h, ads, b)\n                          (x # xs)))))\n  (h', a') \\<in> allocate h (Class_type x)\n\ngoal (1 subgoal):\n 1. (C, a)\n    \\<in> set (zip ((Cs @ [x]) @ xs)\n                (fst (snd (foldl create_initial_object\n                            (h', ads @ [a'], True) xs))))", "by(simp add: create_initial_object_simps h'a')"], ["proof (state)\nthis:\n  (C, a)\n  \\<in> set (zip ((Cs @ [x]) @ xs)\n              (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                          xs))))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  (C, a)\n  \\<in> set (zip ((Cs @ [x]) @ xs)\n              (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                          xs))))\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "have \"\\<forall>(C, a)\\<in>set (zip (Cs @ [x]) (ads @ [a'])).  typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(C, a)\\<in>set (zip (Cs @ [x]) (ads @ [a'])).\n       typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (zip (Cs @ [x]) (ads @ [a'])) \\<Longrightarrow>\n       typeof_addr h' b = \\<lfloor>Class_type a\\<rfloor>", "fix C a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (zip (Cs @ [x]) (ads @ [a'])) \\<Longrightarrow>\n       typeof_addr h' b = \\<lfloor>Class_type a\\<rfloor>", "assume \"(C, a) \\<in> set (zip (Cs @ [x]) (ads @ [a']))\""], ["proof (state)\nthis:\n  (C, a) \\<in> set (zip (Cs @ [x]) (ads @ [a']))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (zip (Cs @ [x]) (ads @ [a'])) \\<Longrightarrow>\n       typeof_addr h' b = \\<lfloor>Class_type a\\<rfloor>", "thus \"typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (C, a) \\<in> set (zip (Cs @ [x]) (ads @ [a']))\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>", "using inv len hext new_obj is_class"], ["proof (prove)\nusing this:\n  (C, a) \\<in> set (zip (Cs @ [x]) (ads @ [a']))\n  \\<forall>(C, a)\\<in>set (zip Cs ads).\n     typeof_addr h a = \\<lfloor>Class_type C\\<rfloor>\n  length Cs = length ads\n  h \\<unlhd> h'\n  (h', a') \\<in> allocate h (Class_type x)\n  \\<forall>C\\<in>set (x # xs). is_class P C\n\ngoal (1 subgoal):\n 1. typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>", "by(auto dest: allocate_SomeD typeof_addr_hext_mono)"], ["proof (state)\nthis:\n  typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(C, a)\\<in>set (zip (Cs @ [x]) (ads @ [a'])).\n     typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  \\<forall>(C, a)\\<in>set (zip (Cs @ [x]) (ads @ [a'])).\n     typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "have \"length (Cs @ [x]) = length (ads @ [a'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Cs @ [x]) = length (ads @ [a'])", "using len"], ["proof (prove)\nusing this:\n  length Cs = length ads\n\ngoal (1 subgoal):\n 1. length (Cs @ [x]) = length (ads @ [a'])", "by simp"], ["proof (state)\nthis:\n  length (Cs @ [x]) = length (ads @ [a'])\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  length (Cs @ [x]) = length (ads @ [a'])\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "have \"\\<forall>C \\<in> set xs. is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>set xs. is_class P C", "using is_class"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>set (x # xs). is_class P C\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>set xs. is_class P C", "by simp"], ["proof (state)\nthis:\n  \\<forall>C\\<in>set xs. is_class P C\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  (C, a)\n  \\<in> set (zip ((Cs @ [x]) @ xs)\n              (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                          xs))))\n  \\<forall>(C, a)\\<in>set (zip (Cs @ [x]) (ads @ [a'])).\n     typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\n  length (Cs @ [x]) = length (ads @ [a'])\n  \\<forall>C\\<in>set xs. is_class P C", "have \"typeof_addr (fst (foldl create_initial_object (h', ads @ [a'], True) xs)) a = \\<lfloor>Class_type C\\<rfloor>\""], ["proof (prove)\nusing this:\n  (C, a)\n  \\<in> set (zip ((Cs @ [x]) @ xs)\n              (fst (snd (foldl create_initial_object (h', ads @ [a'], True)\n                          xs))))\n  \\<forall>(C, a)\\<in>set (zip (Cs @ [x]) (ads @ [a'])).\n     typeof_addr h' a = \\<lfloor>Class_type C\\<rfloor>\n  length (Cs @ [x]) = length (ads @ [a'])\n  \\<forall>C\\<in>set xs. is_class P C\n\ngoal (1 subgoal):\n 1. typeof_addr\n     (fst (foldl create_initial_object (h', ads @ [a'], True) xs)) a =\n    \\<lfloor>Class_type C\\<rfloor>", "by(rule Cons)"], ["proof (state)\nthis:\n  typeof_addr (fst (foldl create_initial_object (h', ads @ [a'], True) xs))\n   a =\n  \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. b \\<and> allocate h (Class_type x) \\<noteq> {} \\<Longrightarrow>\n    typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  typeof_addr (fst (foldl create_initial_object (h', ads @ [a'], True) xs))\n   a =\n  \\<lfloor>Class_type C\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "using new_obj"], ["proof (prove)\nusing this:\n  typeof_addr (fst (foldl create_initial_object (h', ads @ [a'], True) xs))\n   a =\n  \\<lfloor>Class_type C\\<rfloor>\n  (h', a') \\<in> allocate h (Class_type x)\n\ngoal (1 subgoal):\n 1. typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n    \\<lfloor>Class_type C\\<rfloor>", "by(simp add: create_initial_object_simps h'a')"], ["proof (state)\nthis:\n  typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n  \\<lfloor>Class_type C\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  typeof_addr (fst (foldl create_initial_object (h, ads, b) (x # xs))) a =\n  \\<lfloor>Class_type C\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  typeof_addr (fst (foldl create_initial_object (h, ads, b) xs)) a =\n  \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(C, a)\n           \\<in> set (zip (?Cs5 @ ?xs5)\n                       (fst (snd (foldl create_initial_object\n                                   (?h5, ?ads5, ?b5) ?xs5))));\n   \\<forall>(C, a)\\<in>set (zip ?Cs5 ?ads5).\n      typeof_addr ?h5 a = \\<lfloor>Class_type C\\<rfloor>;\n   length ?Cs5 = length ?ads5;\n   \\<forall>C\\<in>set ?xs5. is_class P C\\<rbrakk>\n  \\<Longrightarrow> typeof_addr\n                     (fst (foldl create_initial_object (?h5, ?ads5, ?b5)\n                            ?xs5))\n                     a =\n                    \\<lfloor>Class_type C\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hT = Class_type x1 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n 2. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "from this[of \"[]\" initialization_list empty_heap \"[]\" True] assms wf_syscls_initialization_list_is_class[of P]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(C, a)\n           \\<in> set (zip ([] @ initialization_list)\n                       (fst (snd (foldl create_initial_object\n                                   (empty_heap, [], True)\n                                   initialization_list))));\n   \\<forall>(C, a)\\<in>set (zip [] []).\n      typeof_addr empty_heap a = \\<lfloor>Class_type C\\<rfloor>;\n   length [] = length [];\n   \\<forall>C\\<in>set initialization_list. is_class P C\\<rbrakk>\n  \\<Longrightarrow> typeof_addr\n                     (fst (foldl create_initial_object\n                            (empty_heap, [], True) initialization_list))\n                     a =\n                    \\<lfloor>Class_type C\\<rfloor>\n  wf_syscls P\n  NewHeapElem a hT \\<in> set start_heap_obs\n  \\<lbrakk>wf_syscls P; ?C \\<in> set initialization_list\\<rbrakk>\n  \\<Longrightarrow> is_class P ?C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(C, a)\n           \\<in> set (zip ([] @ initialization_list)\n                       (fst (snd (foldl create_initial_object\n                                   (empty_heap, [], True)\n                                   initialization_list))));\n   \\<forall>(C, a)\\<in>set (zip [] []).\n      typeof_addr empty_heap a = \\<lfloor>Class_type C\\<rfloor>;\n   length [] = length [];\n   \\<forall>C\\<in>set initialization_list. is_class P C\\<rbrakk>\n  \\<Longrightarrow> typeof_addr\n                     (fst (foldl create_initial_object\n                            (empty_heap, [], True) initialization_list))\n                     a =\n                    \\<lfloor>Class_type C\\<rfloor>\n  wf_syscls P\n  NewHeapElem a hT \\<in> set start_heap_obs\n  \\<lbrakk>wf_syscls P; ?C \\<in> set initialization_list\\<rbrakk>\n  \\<Longrightarrow> is_class P ?C\n\ngoal (1 subgoal):\n 1. typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "by(auto simp add: start_heap_obs_def start_heap_data_def start_heap_def Class_type)"], ["proof (state)\nthis:\n  typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "case Array_type"], ["proof (state)\nthis:\n  hT = Array_type x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       hT = Array_type x21 x22 \\<Longrightarrow>\n       typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  hT = Array_type x21_ x22_\n\ngoal (1 subgoal):\n 1. typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "using assms"], ["proof (prove)\nusing this:\n  hT = Array_type x21_ x22_\n  wf_syscls P\n  NewHeapElem a hT \\<in> set start_heap_obs\n\ngoal (1 subgoal):\n 1. typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>", "by(auto simp add: start_heap_obs_def start_heap_data_def start_heap_def)"], ["proof (state)\nthis:\n  typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  typeof_addr start_heap a = \\<lfloor>hT\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Code generation\\<close>"], ["", "definition pick_addr :: \"('heap \\<times> 'addr) set \\<Rightarrow> 'heap \\<times> 'addr\"\nwhere \"pick_addr HA = (SOME ha. ha \\<in> HA)\""], ["", "lemma pick_addr_code [code]:\n  \"pick_addr (set [ha]) = ha\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_addr (set [ha]) = ha", "by(simp add: pick_addr_def)"], ["", "lemma (in heap_base) start_heap_data_code:\n  \"start_heap_data = \n   (let \n     (h, ads, b) = foldl \n        (\\<lambda>(h, ads, b) C. \n           if b then\n             let HA = allocate h (Class_type C)\n             in if HA = {} then (h, ads, False)\n                else let (h', a'') = pick_addr HA in (h', a'' # ads, True)\n           else (h, ads, False)) \n        (empty_heap, [], True) \n        initialization_list \n    in (h, rev ads, b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_heap_data =\n    (let (h, ads, b) =\n           foldl\n            (\\<lambda>(h, ads, b) C.\n                if b\n                then let HA = allocate h (Class_type C)\n                     in if HA = {} then (h, ads, False)\n                        else let (h', a'') = pick_addr HA\n                             in (h', a'' # ads, True)\n                else (h, ads, False))\n            (empty_heap, [], True) initialization_list\n     in (h, rev ads, b))", "unfolding start_heap_data_def create_initial_object_def pick_addr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\n     (\\<lambda>(h, ads, b) C.\n         if b\n         then let HA = allocate h (Class_type C)\n              in if HA = {} then (h, ads, False)\n                 else let (h', a'') = SOME ha. ha \\<in> HA\n                      in (h', ads @ [a''], True)\n         else (h, ads, False))\n     (empty_heap, [], True) initialization_list =\n    (let (h, ads, b) =\n           foldl\n            (\\<lambda>(h, ads, b) C.\n                if b\n                then let HA = allocate h (Class_type C)\n                     in if HA = {} then (h, ads, False)\n                        else let (h', a'') = SOME ha. ha \\<in> HA\n                             in (h', a'' # ads, True)\n                else (h, ads, False))\n            (empty_heap, [], True) initialization_list\n     in (h, rev ads, b))", "by(rule rev_induct)(simp_all add: split_beta)"], ["", "lemmas [code] =\n  heap_base.start_heap_data_code\n  heap_base.start_heap_def\n  heap_base.start_heap_ok_def\n  heap_base.start_heap_obs_def\n  heap_base.start_addrs_def\n  heap_base.addr_of_sys_xcpt_def\n  heap_base.start_tid_def\n  heap_base.start_state_def"], ["", "end"]]}