{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/Random_Scheduler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma next_thread_eq_None_iff:\n  assumes \"thr'_invar active\" \"random_scheduler_invar seed T\"\n  shows \"next_thread seed active = None \\<longleftrightarrow> thr'_\\<alpha> active = {}\"", "lemma next_thread_eq_SomeD:\n  assumes \"next_thread seed active = Some (t, seed')\"\n  and \"thr'_invar active\" \"random_scheduler_invar seed T\"\n  shows \"t \\<in> thr'_\\<alpha> active\"", "lemma random_scheduler_spec:\n  assumes det: \"\\<alpha>.deterministic I\"\n  shows \"scheduler_spec final r random_scheduler random_scheduler_invar thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I\"", "lemma random_scheduler_scheduler:\n  assumes det: \"\\<alpha>.deterministic I\"\n  shows \n  \"scheduler\n     final r convert_RA\n     random_scheduler (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))) random_scheduler_invar\n     thr_\\<alpha> thr_invar thr_lookup thr_update \n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete\n     I\"", "lemmas [code] =\n  random_scheduler_base.next_thread_def\n  random_scheduler_base.random_scheduler_def"], "translations": [["", "lemma next_thread_eq_None_iff:\n  assumes \"thr'_invar active\" \"random_scheduler_invar seed T\"\n  shows \"next_thread seed active = None \\<longleftrightarrow> thr'_\\<alpha> active = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (next_thread seed active = None) = (thr'_\\<alpha> active = {})", "using thr'.to_list_correct[OF assms(1)]"], ["proof (prove)\nusing this:\n  set (thr'_to_list active) = thr'_\\<alpha> active\n  distinct (thr'_to_list active)\n\ngoal (1 subgoal):\n 1. (next_thread seed active = None) = (thr'_\\<alpha> active = {})", "by(auto simp add: next_thread_def neq_Nil_conv)"], ["", "lemma next_thread_eq_SomeD:\n  assumes \"next_thread seed active = Some (t, seed')\"\n  and \"thr'_invar active\" \"random_scheduler_invar seed T\"\n  shows \"t \\<in> thr'_\\<alpha> active\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> thr'_\\<alpha> active", "using assms"], ["proof (prove)\nusing this:\n  next_thread seed active = \\<lfloor>(t, seed')\\<rfloor>\n  thr'_invar active\n  True\n\ngoal (1 subgoal):\n 1. t \\<in> thr'_\\<alpha> active", "by(auto simp add: next_thread_def thr'.to_list_correct split: if_split_asm dest: select[of _ seed])"], ["", "lemma random_scheduler_spec:\n  assumes det: \"\\<alpha>.deterministic I\"\n  shows \"scheduler_spec final r random_scheduler random_scheduler_invar thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler_spec final r local.random_scheduler (\\<lambda>_ _. True)\n     thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.random_scheduler \\<sigma> s = None; state_invar s;\n        True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "fix \\<sigma> s"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.random_scheduler \\<sigma> s = None; state_invar s;\n        True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "assume rr: \"random_scheduler \\<sigma> s = None\"\n    and invar: \"random_scheduler_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\""], ["proof (state)\nthis:\n  local.random_scheduler \\<sigma> s = None\n  True\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.random_scheduler \\<sigma> s = None; state_invar s;\n        True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "from invar(2)"], ["proof (chain)\npicking this:\n  state_invar s", "have \"thr'_invar (active_threads s)\""], ["proof (prove)\nusing this:\n  state_invar s\n\ngoal (1 subgoal):\n 1. thr'_invar (active_threads s)", "by(rule active_threads_correct)"], ["proof (state)\nthis:\n  thr'_invar (active_threads s)\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>local.random_scheduler \\<sigma> s = None; state_invar s;\n        True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 4. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 5. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "thus \"\\<alpha>.active_threads (state_\\<alpha> s) = {}\""], ["proof (prove)\nusing this:\n  thr'_invar (active_threads s)\n\ngoal (1 subgoal):\n 1. \\<alpha>.active_threads (state_\\<alpha> s) = {}", "using rr invar"], ["proof (prove)\nusing this:\n  thr'_invar (active_threads s)\n  local.random_scheduler \\<sigma> s = None\n  True\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<alpha>.active_threads (state_\\<alpha> s) = {}", "by(auto simp add: random_scheduler_def Option_bind_eq_None_conv next_thread_eq_None_iff step_thread_eq_None_conv[OF det] dest: next_thread_eq_SomeD)"], ["proof (state)\nthis:\n  \\<alpha>.active_threads (state_\\<alpha> s) = {}\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "fix \\<sigma> s t \\<sigma>'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "assume rr: \"random_scheduler \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n    and invar: \"random_scheduler_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\""], ["proof (state)\nthis:\n  local.random_scheduler \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  True\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x ln n.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                            0 < ln $ n \\<and>\n                            \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n                            may_acquire_all (locks s) t ln\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 3. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "thus \"\\<exists>x ln n. thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and> 0 < ln $ n \\<and> \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and> may_acquire_all (locks s) t ln\""], ["proof (prove)\nusing this:\n  local.random_scheduler \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  True\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n       may_acquire_all (locks s) t ln", "by(fastforce simp add: random_scheduler_def Option_bind_eq_Some_conv dest: step_thread_Some_NoneD[OF det])"], ["proof (state)\nthis:\n  \\<exists>x ln n.\n     thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n     may_acquire_all (locks s) t ln\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "fix \\<sigma> s t ta x' m' \\<sigma>'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "assume rr: \"random_scheduler \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n    and invar: \"random_scheduler_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\""], ["proof (state)\nthis:\n  local.random_scheduler \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  True\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            thr_\\<alpha> (thr s) t =\n                            \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                            \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n                            \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n 2. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "thus \"\\<exists>x. thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> Predicate.eval (r t (x, shr s)) (ta, x', m') \\<and> \\<alpha>.actions_ok (state_\\<alpha> s) t ta\""], ["proof (prove)\nusing this:\n  local.random_scheduler \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  True\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n       \\<alpha>.actions_ok (state_\\<alpha> s) t ta", "by(auto simp add: random_scheduler_def Option_bind_eq_Some_conv dest: step_thread_Some_SomeD[OF det])"], ["proof (state)\nthis:\n  \\<exists>x.\n     thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n     \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> s t \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, None, \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>\\<sigma> s t ta x' m' \\<sigma>'.\n       \\<lbrakk>local.random_scheduler \\<sigma> s =\n                \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                          \\<sigma>')\\<rfloor>;\n        state_invar s; True; state_\\<alpha> s \\<in> I\\<rbrakk>\n       \\<Longrightarrow> True", "qed simp_all"], ["", "end"], ["", "sublocale random_scheduler_base <\n  scheduler_base\n    final r convert_RA\n    \"random_scheduler\" \"output\" \"pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))\" random_scheduler_invar\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  for n0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale random_scheduler <\n  pick_wakeup_spec\n    final r convert_RA\n    \"pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))\" random_scheduler_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar\n    is_\\<alpha> is_invar"], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_wakeup_spec pick_wakeup (\\<lambda>_ _. True) ws_\\<alpha> ws_invar", "by(rule pick_wakeup_spec_via_sel)(unfold_locales)"], ["", "context random_scheduler begin"], ["", "lemma random_scheduler_scheduler:\n  assumes det: \"\\<alpha>.deterministic I\"\n  shows \n  \"scheduler\n     final r convert_RA\n     random_scheduler (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))) random_scheduler_invar\n     thr_\\<alpha> thr_invar thr_lookup thr_update \n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete\n     I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA local.random_scheduler pick_wakeup\n     (\\<lambda>_ _. True) thr_\\<alpha> thr_invar thr_lookup thr_update\n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA local.random_scheduler pick_wakeup\n     (\\<lambda>_ _. True) thr_\\<alpha> thr_invar thr_lookup thr_update\n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete I", "interpret scheduler_spec\n      final r convert_RA\n      random_scheduler random_scheduler_invar\n      thr_\\<alpha> thr_invar\n      ws_\\<alpha> ws_invar\n      is_\\<alpha> is_invar\n      I"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler_spec final r local.random_scheduler (\\<lambda>_ _. True)\n     thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I", "using det"], ["proof (prove)\nusing this:\n  \\<alpha>.deterministic I\n\ngoal (1 subgoal):\n 1. scheduler_spec final r local.random_scheduler (\\<lambda>_ _. True)\n     thr_\\<alpha> thr_invar ws_\\<alpha> ws_invar is_\\<alpha> is_invar I", "by(rule random_scheduler_spec)"], ["proof (state)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA local.random_scheduler pick_wakeup\n     (\\<lambda>_ _. True) thr_\\<alpha> thr_invar thr_lookup thr_update\n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete I", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA local.random_scheduler pick_wakeup\n     (\\<lambda>_ _. True) thr_\\<alpha> thr_invar thr_lookup thr_update\n     ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n     is_\\<alpha> is_invar is_memb is_ins is_delete I", "by(unfold_locales)(rule \\<alpha>.deterministic_invariant3p[OF det])"], ["proof (state)\nthis:\n  scheduler final r convert_RA local.random_scheduler pick_wakeup\n   (\\<lambda>_ _. True) thr_\\<alpha> thr_invar thr_lookup thr_update\n   ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate is_\\<alpha>\n   is_invar is_memb is_ins is_delete I\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Code generator setup\\<close>"], ["", "lemmas [code] =\n  random_scheduler_base.next_thread_def\n  random_scheduler_base.random_scheduler_def"], ["", "end"]]}