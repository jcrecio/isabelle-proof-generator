{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Common/Type.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemmas identifier_name_defs [code_unfold] =\n  this_def run_def start_def wait_def notify_def notifyAll_def join_def interrupt_def isInterrupted_def\n  hashcode_def clone_def print_def currentThread_def interrupted_def yield_def", "lemma Object_Thread_Throwable_neq [simp]:\n  \"Thread \\<noteq> Object\" \"Object \\<noteq> Thread\"\n  \"Object \\<noteq> Throwable\" \"Throwable \\<noteq> Object\"\n  \"Thread \\<noteq> Throwable\" \"Throwable \\<noteq> Thread\"", "lemma synth_method_names_neq_aux:\n  \"start \\<noteq> wait\" \"start \\<noteq> notify\" \"start \\<noteq> notifyAll\" \"start \\<noteq> join\" \"start \\<noteq> interrupt\" \"start \\<noteq> isInterrupted\"\n  \"start \\<noteq> hashcode\" \"start \\<noteq> clone\" \"start \\<noteq> print\" \"start \\<noteq> currentThread\"\n  \"start \\<noteq> interrupted\" \"start \\<noteq> yield\" \"start \\<noteq> run\"\n  \"wait \\<noteq> notify\" \"wait \\<noteq> notifyAll\" \"wait \\<noteq> join\"  \"wait \\<noteq> interrupt\" \"wait \\<noteq> isInterrupted\"\n  \"wait \\<noteq> hashcode\" \"wait \\<noteq> clone\" \"wait \\<noteq> print\" \"wait \\<noteq> currentThread\" \n  \"wait \\<noteq> interrupted\" \"wait \\<noteq> yield\"  \"wait \\<noteq> run\"\n  \"notify \\<noteq> notifyAll\" \"notify \\<noteq> join\" \"notify \\<noteq> interrupt\" \"notify \\<noteq> isInterrupted\"\n  \"notify \\<noteq> hashcode\" \"notify \\<noteq> clone\" \"notify \\<noteq> print\" \"notify \\<noteq> currentThread\"\n  \"notify \\<noteq> interrupted\" \"notify \\<noteq> yield\" \"notify \\<noteq> run\"\n  \"notifyAll \\<noteq> join\" \"notifyAll \\<noteq> interrupt\" \"notifyAll \\<noteq> isInterrupted\"\n  \"notifyAll \\<noteq> hashcode\" \"notifyAll \\<noteq> clone\" \"notifyAll \\<noteq> print\" \"notifyAll \\<noteq> currentThread\"\n  \"notifyAll \\<noteq> interrupted\" \"notifyAll \\<noteq> yield\" \"notifyAll \\<noteq> run\"\n  \"join \\<noteq> interrupt\" \"join \\<noteq> isInterrupted\"\n  \"join \\<noteq> hashcode\" \"join \\<noteq> clone\" \"join \\<noteq> print\" \"join \\<noteq> currentThread\" \n  \"join \\<noteq> interrupted\" \"join \\<noteq> yield\" \"join \\<noteq> run\"\n  \"interrupt \\<noteq> isInterrupted\"\n  \"interrupt \\<noteq> hashcode\" \"interrupt \\<noteq> clone\" \"interrupt \\<noteq> print\" \"interrupt \\<noteq> currentThread\" \n  \"interrupt \\<noteq> interrupted\" \"interrupt \\<noteq> yield\" \"interrupt \\<noteq> run\"\n  \"isInterrupted \\<noteq> hashcode\" \"isInterrupted \\<noteq> clone\" \"isInterrupted \\<noteq> print\" \"isInterrupted \\<noteq> currentThread\" \n  \"isInterrupted \\<noteq> interrupted\" \"isInterrupted \\<noteq> yield\" \"isInterrupted \\<noteq> run\"\n  \"hashcode \\<noteq> clone\" \"hashcode \\<noteq> print\" \"hashcode \\<noteq> currentThread\" \n  \"hashcode \\<noteq> interrupted\" \"hashcode \\<noteq> yield\" \"hashcode \\<noteq> run\"\n  \"clone \\<noteq> print\" \"clone \\<noteq> currentThread\" \n  \"clone \\<noteq> interrupted\" \"clone \\<noteq> yield\" \"clone \\<noteq> run\"\n  \"print \\<noteq> currentThread\" \n  \"print \\<noteq> interrupted\" \"print \\<noteq> yield\" \"print \\<noteq> run\"\n  \"currentThread \\<noteq> interrupted\" \"currentThread \\<noteq> yield\" \"currentThread \\<noteq> run\"\n  \"interrupted \\<noteq> yield\" \"interrupted \\<noteq> run\"\n  \"yield \\<noteq> run\"", "lemmas synth_method_names_neq [simp] = synth_method_names_neq_aux synth_method_names_neq_aux[symmetric]\n\n\\<comment> \\<open>types\\<close>", "lemmas refTE [consumes 1, case_names NT Class Array] = is_refT.cases", "lemma not_refTE [consumes 1, case_names Void Boolean Integer]:\n  \"\\<lbrakk> \\<not>is_refT T; T = Void \\<Longrightarrow> P; T = Boolean \\<Longrightarrow> P; T = Integer \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma rec_htype_is_case [simp]: \"rec_htype = case_htype\"", "lemma ty_of_htype_eq_convs [simp]:\n  shows ty_of_htype_eq_Boolean: \"ty_of_htype hT \\<noteq> Boolean\"\n  and ty_of_htype_eq_Void: \"ty_of_htype hT \\<noteq> Void\"\n  and ty_of_htype_eq_Integer: \"ty_of_htype hT \\<noteq> Integer\"\n  and ty_of_htype_eq_NT: \"ty_of_htype hT \\<noteq> NT\"\n  and ty_of_htype_eq_Class: \"ty_of_htype hT = Class C \\<longleftrightarrow> hT = Class_type C\"\n  and ty_of_htype_eq_Array: \"ty_of_htype hT = Array T \\<longleftrightarrow> (\\<exists>n. hT = Array_type T n)\"", "lemma class_type_of_eq:\n  \"class_type_of hT = \n  (case hT of Class_type C \\<Rightarrow> C | Array_type T n \\<Rightarrow> Object)\"", "lemma class_type_of'_ty_of_htype [simp]:\n  \"class_type_of' (ty_of_htype hT) = \\<lfloor>class_type_of hT\\<rfloor>\"", "lemma is_Array_conv [simp]: \"is_Array T \\<longleftrightarrow> (\\<exists>U. T = Array U)\"", "lemma is_Class_conv [simp]: \"is_Class T \\<longleftrightarrow> (\\<exists>C. T = Class C)\""], "translations": [["", "lemmas identifier_name_defs [code_unfold] =\n  this_def run_def start_def wait_def notify_def notifyAll_def join_def interrupt_def isInterrupted_def\n  hashcode_def clone_def print_def currentThread_def interrupted_def yield_def"], ["", "lemma Object_Thread_Throwable_neq [simp]:\n  \"Thread \\<noteq> Object\" \"Object \\<noteq> Thread\"\n  \"Object \\<noteq> Throwable\" \"Throwable \\<noteq> Object\"\n  \"Thread \\<noteq> Throwable\" \"Throwable \\<noteq> Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Thread \\<noteq> Object &&&\n     Object \\<noteq> Thread &&& Object \\<noteq> Throwable) &&&\n    Throwable \\<noteq> Object &&&\n    Thread \\<noteq> Throwable &&& Throwable \\<noteq> Thread", "by(auto simp add: Thread_def Object_def Throwable_def)"], ["", "lemma synth_method_names_neq_aux:\n  \"start \\<noteq> wait\" \"start \\<noteq> notify\" \"start \\<noteq> notifyAll\" \"start \\<noteq> join\" \"start \\<noteq> interrupt\" \"start \\<noteq> isInterrupted\"\n  \"start \\<noteq> hashcode\" \"start \\<noteq> clone\" \"start \\<noteq> print\" \"start \\<noteq> currentThread\"\n  \"start \\<noteq> interrupted\" \"start \\<noteq> yield\" \"start \\<noteq> run\"\n  \"wait \\<noteq> notify\" \"wait \\<noteq> notifyAll\" \"wait \\<noteq> join\"  \"wait \\<noteq> interrupt\" \"wait \\<noteq> isInterrupted\"\n  \"wait \\<noteq> hashcode\" \"wait \\<noteq> clone\" \"wait \\<noteq> print\" \"wait \\<noteq> currentThread\" \n  \"wait \\<noteq> interrupted\" \"wait \\<noteq> yield\"  \"wait \\<noteq> run\"\n  \"notify \\<noteq> notifyAll\" \"notify \\<noteq> join\" \"notify \\<noteq> interrupt\" \"notify \\<noteq> isInterrupted\"\n  \"notify \\<noteq> hashcode\" \"notify \\<noteq> clone\" \"notify \\<noteq> print\" \"notify \\<noteq> currentThread\"\n  \"notify \\<noteq> interrupted\" \"notify \\<noteq> yield\" \"notify \\<noteq> run\"\n  \"notifyAll \\<noteq> join\" \"notifyAll \\<noteq> interrupt\" \"notifyAll \\<noteq> isInterrupted\"\n  \"notifyAll \\<noteq> hashcode\" \"notifyAll \\<noteq> clone\" \"notifyAll \\<noteq> print\" \"notifyAll \\<noteq> currentThread\"\n  \"notifyAll \\<noteq> interrupted\" \"notifyAll \\<noteq> yield\" \"notifyAll \\<noteq> run\"\n  \"join \\<noteq> interrupt\" \"join \\<noteq> isInterrupted\"\n  \"join \\<noteq> hashcode\" \"join \\<noteq> clone\" \"join \\<noteq> print\" \"join \\<noteq> currentThread\" \n  \"join \\<noteq> interrupted\" \"join \\<noteq> yield\" \"join \\<noteq> run\"\n  \"interrupt \\<noteq> isInterrupted\"\n  \"interrupt \\<noteq> hashcode\" \"interrupt \\<noteq> clone\" \"interrupt \\<noteq> print\" \"interrupt \\<noteq> currentThread\" \n  \"interrupt \\<noteq> interrupted\" \"interrupt \\<noteq> yield\" \"interrupt \\<noteq> run\"\n  \"isInterrupted \\<noteq> hashcode\" \"isInterrupted \\<noteq> clone\" \"isInterrupted \\<noteq> print\" \"isInterrupted \\<noteq> currentThread\" \n  \"isInterrupted \\<noteq> interrupted\" \"isInterrupted \\<noteq> yield\" \"isInterrupted \\<noteq> run\"\n  \"hashcode \\<noteq> clone\" \"hashcode \\<noteq> print\" \"hashcode \\<noteq> currentThread\" \n  \"hashcode \\<noteq> interrupted\" \"hashcode \\<noteq> yield\" \"hashcode \\<noteq> run\"\n  \"clone \\<noteq> print\" \"clone \\<noteq> currentThread\" \n  \"clone \\<noteq> interrupted\" \"clone \\<noteq> yield\" \"clone \\<noteq> run\"\n  \"print \\<noteq> currentThread\" \n  \"print \\<noteq> interrupted\" \"print \\<noteq> yield\" \"print \\<noteq> run\"\n  \"currentThread \\<noteq> interrupted\" \"currentThread \\<noteq> yield\" \"currentThread \\<noteq> run\"\n  \"interrupted \\<noteq> yield\" \"interrupted \\<noteq> run\"\n  \"yield \\<noteq> run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((((start \\<noteq> wait &&& start \\<noteq> notify) &&&\n        start \\<noteq> notifyAll &&&\n        start \\<noteq> join &&& start \\<noteq> interrupt) &&&\n       (start \\<noteq> isInterrupted &&&\n        start \\<noteq> hashcode &&& start \\<noteq> clone) &&&\n       start \\<noteq> print &&&\n       start \\<noteq> currentThread &&& start \\<noteq> interrupted) &&&\n      ((start \\<noteq> yield &&& start \\<noteq> run) &&&\n       wait \\<noteq> notify &&&\n       wait \\<noteq> notifyAll &&& wait \\<noteq> join) &&&\n      (wait \\<noteq> interrupt &&&\n       wait \\<noteq> isInterrupted &&& wait \\<noteq> hashcode) &&&\n      wait \\<noteq> clone &&&\n      wait \\<noteq> print &&& wait \\<noteq> currentThread) &&&\n     (((wait \\<noteq> interrupted &&& wait \\<noteq> yield) &&&\n       wait \\<noteq> run &&&\n       notify \\<noteq> notifyAll &&& notify \\<noteq> join) &&&\n      (notify \\<noteq> interrupt &&&\n       notify \\<noteq> isInterrupted &&& notify \\<noteq> hashcode) &&&\n      notify \\<noteq> clone &&&\n      notify \\<noteq> print &&& notify \\<noteq> currentThread) &&&\n     ((notify \\<noteq> interrupted &&&\n       notify \\<noteq> yield &&& notify \\<noteq> run) &&&\n      notifyAll \\<noteq> join &&&\n      notifyAll \\<noteq> interrupt &&& notifyAll \\<noteq> isInterrupted) &&&\n     (notifyAll \\<noteq> hashcode &&&\n      notifyAll \\<noteq> clone &&& notifyAll \\<noteq> print) &&&\n     notifyAll \\<noteq> currentThread &&&\n     notifyAll \\<noteq> interrupted &&& notifyAll \\<noteq> yield) &&&\n    ((((notifyAll \\<noteq> run &&& join \\<noteq> interrupt) &&&\n       join \\<noteq> isInterrupted &&&\n       join \\<noteq> hashcode &&& join \\<noteq> clone) &&&\n      (join \\<noteq> print &&&\n       join \\<noteq> currentThread &&& join \\<noteq> interrupted) &&&\n      join \\<noteq> yield &&&\n      join \\<noteq> run &&& interrupt \\<noteq> isInterrupted) &&&\n     ((interrupt \\<noteq> hashcode &&&\n       interrupt \\<noteq> clone &&& interrupt \\<noteq> print) &&&\n      interrupt \\<noteq> currentThread &&&\n      interrupt \\<noteq> interrupted &&& interrupt \\<noteq> yield) &&&\n     (interrupt \\<noteq> run &&&\n      isInterrupted \\<noteq> hashcode &&& isInterrupted \\<noteq> clone) &&&\n     isInterrupted \\<noteq> print &&&\n     isInterrupted \\<noteq> currentThread &&&\n     isInterrupted \\<noteq> interrupted) &&&\n    (((isInterrupted \\<noteq> yield &&& isInterrupted \\<noteq> run) &&&\n      hashcode \\<noteq> clone &&&\n      hashcode \\<noteq> print &&& hashcode \\<noteq> currentThread) &&&\n     (hashcode \\<noteq> interrupted &&&\n      hashcode \\<noteq> yield &&& hashcode \\<noteq> run) &&&\n     clone \\<noteq> print &&&\n     clone \\<noteq> currentThread &&& clone \\<noteq> interrupted) &&&\n    ((clone \\<noteq> yield &&&\n      clone \\<noteq> run &&& print \\<noteq> currentThread) &&&\n     print \\<noteq> interrupted &&&\n     print \\<noteq> yield &&& print \\<noteq> run) &&&\n    (currentThread \\<noteq> interrupted &&&\n     currentThread \\<noteq> yield &&& currentThread \\<noteq> run) &&&\n    interrupted \\<noteq> yield &&&\n    interrupted \\<noteq> run &&& yield \\<noteq> run", "by(simp_all add: identifier_name_defs)"], ["", "lemmas synth_method_names_neq [simp] = synth_method_names_neq_aux synth_method_names_neq_aux[symmetric]\n\n\\<comment> \\<open>types\\<close>"], ["", "datatype ty\n  = Void          \\<comment> \\<open>type of statements\\<close>\n  | Boolean\n  | Integer\n  | NT            \\<comment> \\<open>null type\\<close>\n  | Class cname   \\<comment> \\<open>class type\\<close>\n  | Array ty      (\"_\\<lfloor>\\<rceil>\" 95) \\<comment> \\<open>array type\\<close>"], ["", "context\n  notes [[inductive_internals]]\nbegin"], ["", "inductive is_refT :: \"ty \\<Rightarrow> bool\" where\n  \"is_refT NT\"\n| \"is_refT (Class C)\"\n| \"is_refT (A\\<lfloor>\\<rceil>)\""], ["", "declare is_refT.intros[iff]"], ["", "end"], ["", "lemmas refTE [consumes 1, case_names NT Class Array] = is_refT.cases"], ["", "lemma not_refTE [consumes 1, case_names Void Boolean Integer]:\n  \"\\<lbrakk> \\<not>is_refT T; T = Void \\<Longrightarrow> P; T = Boolean \\<Longrightarrow> P; T = Integer \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_refT T; T = Void \\<Longrightarrow> P;\n     T = Boolean \\<Longrightarrow> P;\n     T = Integer \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases T, auto)"], ["", "fun ground_type :: \"ty \\<Rightarrow> ty\" where\n  \"ground_type (Array T) = ground_type T\"\n| \"ground_type T = T\""], ["", "abbreviation is_NT_Array :: \"ty \\<Rightarrow> bool\" where\n  \"is_NT_Array T \\<equiv> ground_type T = NT\""], ["", "primrec the_Class :: \"ty \\<Rightarrow> cname\"\nwhere\n  \"the_Class (Class C) = C\""], ["", "primrec the_Array :: \"ty \\<Rightarrow> ty\"\nwhere\n  \"the_Array (T\\<lfloor>\\<rceil>) = T\""], ["", "datatype htype =\n  Class_type \"cname\"\n| Array_type \"ty\" \"nat\""], ["", "primrec ty_of_htype :: \"htype \\<Rightarrow> ty\"\nwhere\n  \"ty_of_htype (Class_type C) = Class C\"\n| \"ty_of_htype (Array_type T n) = Array T\""], ["", "primrec alen_of_htype :: \"htype \\<Rightarrow> nat\"\nwhere\n  \"alen_of_htype (Array_type T n) = n\""], ["", "primrec class_type_of :: \"htype \\<Rightarrow> cname\"\nwhere \n  \"class_type_of (Class_type C) = C\"\n| \"class_type_of (Array_type T n) = Object\""], ["", "fun class_type_of' :: \"ty \\<Rightarrow> cname option\"\nwhere \n  \"class_type_of' (Class C) = \\<lfloor>C\\<rfloor>\"\n| \"class_type_of' (Array T) = \\<lfloor>Object\\<rfloor>\"\n| \"class_type_of' _ = None\""], ["", "lemma rec_htype_is_case [simp]: \"rec_htype = case_htype\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_htype = case_htype", "by(auto simp add: fun_eq_iff split: htype.split)"], ["", "lemma ty_of_htype_eq_convs [simp]:\n  shows ty_of_htype_eq_Boolean: \"ty_of_htype hT \\<noteq> Boolean\"\n  and ty_of_htype_eq_Void: \"ty_of_htype hT \\<noteq> Void\"\n  and ty_of_htype_eq_Integer: \"ty_of_htype hT \\<noteq> Integer\"\n  and ty_of_htype_eq_NT: \"ty_of_htype hT \\<noteq> NT\"\n  and ty_of_htype_eq_Class: \"ty_of_htype hT = Class C \\<longleftrightarrow> hT = Class_type C\"\n  and ty_of_htype_eq_Array: \"ty_of_htype hT = Array T \\<longleftrightarrow> (\\<exists>n. hT = Array_type T n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ty_of_htype hT \\<noteq> Boolean &&&\n     ty_of_htype hT \\<noteq> Void &&& ty_of_htype hT \\<noteq> Integer) &&&\n    ty_of_htype hT \\<noteq> NT &&&\n    (ty_of_htype hT = Class C) = (hT = Class_type C) &&&\n    (ty_of_htype hT = T\\<lfloor>\\<rceil>) =\n    (\\<exists>n. hT = Array_type T n)", "by(case_tac [!] hT) simp_all"], ["", "lemma class_type_of_eq:\n  \"class_type_of hT = \n  (case hT of Class_type C \\<Rightarrow> C | Array_type T n \\<Rightarrow> Object)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_type_of hT =\n    (case hT of Class_type C \\<Rightarrow> C\n     | Array_type T n \\<Rightarrow> Object)", "by(simp split: htype.split)"], ["", "lemma class_type_of'_ty_of_htype [simp]:\n  \"class_type_of' (ty_of_htype hT) = \\<lfloor>class_type_of hT\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_type_of' (ty_of_htype hT) = \\<lfloor>class_type_of hT\\<rfloor>", "by(cases hT) simp_all"], ["", "fun is_Array :: \"ty \\<Rightarrow> bool\"\nwhere\n  \"is_Array (Array T) = True\"\n| \"is_Array _ = False\""], ["", "lemma is_Array_conv [simp]: \"is_Array T \\<longleftrightarrow> (\\<exists>U. T = Array U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Array T = (\\<exists>U. T = U\\<lfloor>\\<rceil>)", "by(cases T) simp_all"], ["", "fun is_Class :: \"ty \\<Rightarrow> bool\"\nwhere\n  \"is_Class (Class C) = True\"\n| \"is_Class _ = False\""], ["", "lemma is_Class_conv [simp]: \"is_Class T \\<longleftrightarrow> (\\<exists>C. T = Class C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Class T = (\\<exists>C. T = Class C)", "by(cases T) simp_all"], ["", "subsection \\<open>Code generator setup\\<close>"], ["", "code_pred is_refT"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"]]}