{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Compiler/J0.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma extNTA2J0_iff [simp]:\n  \"extNTA2J0 P (C, M, a) = \n   ({this:Class (fst (method P C M))=\\<lfloor>Addr a\\<rfloor>; snd (the (snd (snd (snd (method P C M)))))}, [])\"", "lemma obs_a_extTA2J_eq_obs_a_extTA2J0 [simp]: \"\\<lbrace>extTA2J P ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>extTA2J0 P ta\\<rbrace>\\<^bsub>o\\<^esub>\"", "lemma extTA2J0_\\<epsilon>: \"extTA2J0 P \\<epsilon> = \\<epsilon>\"", "lemma assumes wf: \"wwf_J_prog P\"\n  shows red_fv_subset: \"extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> fv e' \\<subseteq> fv e\"\n  and reds_fvs_subset: \"extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> fvs es' \\<subseteq> fvs es\"", "lemma assumes wwf: \"wwf_J_prog P\"\n  shows red_fv_ok: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; fv e \\<subseteq> dom (lcl s) \\<rbrakk> \\<Longrightarrow> fv e' \\<subseteq> dom (lcl s')\"\n  and reds_fvs_ok: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; fvs es \\<subseteq> dom (lcl s) \\<rbrakk> \\<Longrightarrow> fvs es' \\<subseteq> dom (lcl s')\"", "lemma is_call_red_state_unchanged: \n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; call e = \\<lfloor>aMvs\\<rfloor>; \\<not> synthesized_call P (hp s) aMvs \\<rbrakk> \\<Longrightarrow> s' = s \\<and> ta = \\<epsilon>\"\n\n  and is_calls_reds_state_unchanged:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; calls es = \\<lfloor>aMvs\\<rfloor>; \\<not> synthesized_call P (hp s) aMvs \\<rbrakk> \\<Longrightarrow> s' = s \\<and> ta = \\<epsilon>\"", "lemma called_methodD:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; call e = \\<lfloor>(a, M, vs)\\<rfloor>; \\<not> synthesized_call P (hp s) (a, M, vs) \\<rbrakk> \n  \\<Longrightarrow> \\<exists>hT D Us U pns body. hp s' = hp s \\<and> typeof_addr (hp s) a = \\<lfloor>hT\\<rfloor> \\<and>\n                           P \\<turnstile> class_type_of hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns, body)\\<rfloor> in D \\<and> \n                           length vs = length pns \\<and> length Us = length pns\"\n\n  and called_methodsD:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; calls es = \\<lfloor>(a, M, vs)\\<rfloor>; \\<not> synthesized_call P (hp s) (a, M, vs) \\<rbrakk> \n  \\<Longrightarrow> \\<exists>hT D Us U pns body. hp s' = hp s \\<and> typeof_addr (hp s) a = \\<lfloor>hT\\<rfloor> \\<and>\n                           P \\<turnstile> class_type_of hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns, body)\\<rfloor> in D \\<and>\n                           length vs = length pns \\<and> length Us = length pns\"", "lemma \\<tau>move0_\\<tau>moves0_intros:\n  fixes e e1 e2 e' :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move0NewArray: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (newA T\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move0Cast: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Cast U e)\"\n  and \\<tau>move0CastRed: \"\\<tau>move0 P h (Cast U (Val v))\"\n  and \\<tau>move0InstanceOf: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e instanceof T)\"\n  and \\<tau>move0InstanceOfRed: \"\\<tau>move0 P h ((Val v) instanceof T)\"\n  and \\<tau>move0BinOp1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<guillemotleft>bop\\<guillemotright>e')\"\n  and \\<tau>move0BinOp2: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<guillemotleft>bop\\<guillemotright>e)\"\n  and \\<tau>move0BinOp: \"\\<tau>move0 P h (Val v\\<guillemotleft>bop\\<guillemotright>Val v')\"\n  and \\<tau>move0Var: \"\\<tau>move0 P h (Var V)\"\n  and \\<tau>move0LAss: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (V := e)\"\n  and \\<tau>move0LAssRed: \"\\<tau>move0 P h (V := Val v)\"\n  and \\<tau>move0AAcc1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<lfloor>e'\\<rceil>)\"\n  and \\<tau>move0AAcc2: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move0AAss1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<lfloor>e1\\<rceil> := e2)\"\n  and \\<tau>move0AAss2: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<lfloor>e\\<rceil> := e')\"\n  and \\<tau>move0AAss3: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<lfloor>Val v'\\<rceil> := e)\"\n  and \\<tau>move0ALength: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<bullet>length)\"\n  and \\<tau>move0FAcc: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<bullet>F{D})\"\n  and \\<tau>move0FAss1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (FAss e F D e')\"\n  and \\<tau>move0FAss2: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>F{D} := e)\"\n  and \\<tau>move0CAS1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\"\n  and \\<tau>move0CAS2: \"\\<tau>move0 P h e' \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\"\n  and \\<tau>move0CAS3: \"\\<tau>move0 P h e'' \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e''))\"\n  and \\<tau>move0CallObj: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<bullet>M(es))\"\n  and \\<tau>move0CallParams: \"\\<tau>moves0 P h es \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>M(es))\"\n  and \\<tau>move0Call: \"(\\<And>T C Ts Tr D. \\<lbrakk> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>; class_type_of' T = \\<lfloor>C\\<rfloor>; P \\<turnstile> C sees M:Ts\\<rightarrow>Tr = Native in D \\<rbrakk> \\<Longrightarrow> \\<tau>external_defs D M) \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>M(map Val vs))\"\n  and \\<tau>move0Block: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h {V:T=vo; e}\"\n  and \\<tau>move0BlockRed: \"\\<tau>move0 P h {V:T=vo; Val v}\"\n  and \\<tau>move0Sync: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (sync\\<^bsub>V'\\<^esub> (e) e')\"\n  and \\<tau>move0InSync: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (insync\\<^bsub>V'\\<^esub> (a) e)\"\n  and \\<tau>move0Seq: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e;;e')\"\n  and \\<tau>move0SeqRed: \"\\<tau>move0 P h (Val v;; e')\"\n  and \\<tau>move0Cond: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (if (e) e1 else e2)\"\n  and \\<tau>move0CondRed: \"\\<tau>move0 P h (if (Val v) e1 else e2)\"\n  and \\<tau>move0WhileRed: \"\\<tau>move0 P h (while (e) e')\"\n  and \\<tau>move0Throw: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (throw e)\"\n  and \\<tau>move0ThrowNull: \"\\<tau>move0 P h (throw null)\"\n  and \\<tau>move0Try: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (try e catch(C V) e')\"\n  and \\<tau>move0TryRed: \"\\<tau>move0 P h (try Val v catch(C V) e)\"\n  and \\<tau>move0TryThrow: \"\\<tau>move0 P h (try Throw a catch(C V) e)\"\n  and \\<tau>move0NewArrayThrow: \"\\<tau>move0 P h (newA T\\<lfloor>Throw a\\<rceil>)\"\n  and \\<tau>move0CastThrow: \"\\<tau>move0 P h (Cast T (Throw a))\"\n  and \\<tau>move0CInstanceOfThrow: \"\\<tau>move0 P h ((Throw a) instanceof T)\"\n  and \\<tau>move0BinOpThrow1: \"\\<tau>move0 P h (Throw a \\<guillemotleft>bop\\<guillemotright> e')\"\n  and \\<tau>move0BinOpThrow2: \"\\<tau>move0 P h (Val v \\<guillemotleft>bop\\<guillemotright> Throw a)\"\n  and \\<tau>move0LAssThrow: \"\\<tau>move0 P h (V:=(Throw a))\"\n  and \\<tau>move0AAccThrow1: \"\\<tau>move0 P h (Throw a\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move0AAccThrow2: \"\\<tau>move0 P h (Val v\\<lfloor>Throw a\\<rceil>)\"\n  and \\<tau>move0AAssThrow1: \"\\<tau>move0 P h (AAss (Throw a) e e')\"\n  and \\<tau>move0AAssThrow2: \"\\<tau>move0 P h (AAss (Val v) (Throw a) e')\"\n  and \\<tau>move0AAssThrow3: \"\\<tau>move0 P h (AAss (Val v) (Val v') (Throw a))\"\n  and \\<tau>move0ALengthThrow: \"\\<tau>move0 P h (Throw a\\<bullet>length)\"\n  and \\<tau>move0FAccThrow: \"\\<tau>move0 P h (Throw a\\<bullet>F{D})\"\n  and \\<tau>move0FAssThrow1: \"\\<tau>move0 P h (Throw a\\<bullet>F{D} := e)\"\n  and \\<tau>move0FAssThrow2: \"\\<tau>move0 P h (FAss (Val v) F D (Throw a))\"\n  and \\<tau>move0CallThrowObj: \"\\<tau>move0 P h (Throw a\\<bullet>M(es))\"\n  and \\<tau>move0CallThrowParams: \"\\<tau>move0 P h (Val v\\<bullet>M(map Val vs @ Throw a # es))\"\n  and \\<tau>move0BlockThrow: \"\\<tau>move0 P h {V:T=vo; Throw a}\"\n  and \\<tau>move0SyncThrow: \"\\<tau>move0 P h (sync\\<^bsub>V'\\<^esub> (Throw a) e)\"\n  and \\<tau>move0SeqThrow: \"\\<tau>move0 P h (Throw a;;e)\"\n  and \\<tau>move0CondThrow: \"\\<tau>move0 P h (if (Throw a) e1 else e2)\"\n  and \\<tau>move0ThrowThrow: \"\\<tau>move0 P h (throw (Throw a))\"\n\n  and \\<tau>moves0Hd: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>moves0 P h (e # es)\"\n  and \\<tau>moves0Tl: \"\\<tau>moves0 P h es \\<Longrightarrow> \\<tau>moves0 P h (Val v # es)\"", "lemma \\<tau>moves0_map_Val [iff]:\n  \"\\<not> \\<tau>moves0 P h (map Val vs)\"", "lemma \\<tau>moves0_map_Val_append [simp]:\n  \"\\<tau>moves0 P h (map Val vs @ es) = \\<tau>moves0 P h es\"", "lemma no_reds_map_Val_Throw [simp]:\n  \"extTA,P,t \\<turnstile> \\<langle>map Val vs @ Throw a # es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> = False\"", "lemma assumes [simp]: \"extTA \\<epsilon> = \\<epsilon>\"\n  shows red_\\<tau>_taD: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move0 P (hp s) e \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"\n  and reds_\\<tau>_taD: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves0 P (hp s) es \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"", "lemma \\<tau>move0_heap_unchanged: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move0 P (hp s) e \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"\n  and \\<tau>moves0_heap_unchanged: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves0 P (hp s) es \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"", "lemma \\<tau>Move0_iff:\n  \"\\<tau>Move0 P h ees \\<longleftrightarrow> (let (e, _) = ees in \\<tau>move0 P h e \\<or> final e)\"", "lemma no_call_simps [simp]:\n  \"no_call P h (new C) = True\"\n  \"no_call P h (newA T\\<lfloor>e\\<rceil>) = no_call P h e\"\n  \"no_call P h (Cast T e) = no_call P h e\"\n  \"no_call P h (e instanceof T) = no_call P h e\"\n  \"no_call P h (Val v) = True\"\n  \"no_call P h (Var V) = True\"\n  \"no_call P h (V := e) = no_call P h e\"\n  \"no_call P h (e \\<guillemotleft>bop\\<guillemotright> e') = (if is_val e then no_call P h e' else no_call P h e)\"\n  \"no_call P h (a\\<lfloor>i\\<rceil>) = (if is_val a then no_call P h i else no_call P h a)\"\n  \"no_call P h (AAss a i e) = (if is_val a then (if is_val i then no_call P h e else no_call P h i) else no_call P h a)\"\n  \"no_call P h (a\\<bullet>length) = no_call P h a\"\n  \"no_call P h (e\\<bullet>F{D}) = no_call P h e\"\n  \"no_call P h (FAss e F D e') = (if is_val e then no_call P h e' else no_call P h e)\"\n  \"no_call P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) = (if is_val e then (if is_val e' then no_call P h e'' else no_call P h e') else no_call P h e)\"\n  \"no_call P h (e\\<bullet>M(es)) = (if is_val e then (if is_vals es \\<and> is_addr e then synthesized_call P h (THE a. e = addr a, M, THE vs. es = map Val vs) else no_calls P h es) else no_call P h e)\"\n  \"no_call P h ({V:T=vo; e}) = no_call P h e\"\n  \"no_call P h (sync\\<^bsub>V'\\<^esub> (e) e') = no_call P h e\"\n  \"no_call P h (insync\\<^bsub>V'\\<^esub> (ad) e) = no_call P h e\"\n  \"no_call P h (e;;e') = no_call P h e\"\n  \"no_call P h (if (e) e1 else e2) = no_call P h e\"\n  \"no_call P h (while(e) e') = True\"\n  \"no_call P h (throw e) = no_call P h e\"\n  \"no_call P h (try e catch(C V) e') = no_call P h e\"", "lemma no_calls_simps [simp]:\n  \"no_calls P h [] = True\"\n  \"no_calls P h (e # es) = (if is_val e then no_calls P h es else no_call P h e)\"", "lemma no_calls_map_Val [simp]:\n  \"no_calls P h (map Val vs)\"", "lemma assumes nfin: \"\\<not> final e'\"\n shows inline_call_\\<tau>move0_inv: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<tau>move0 P h (inline_call e' e) = \\<tau>move0 P h e'\"\n  and inline_calls_\\<tau>moves0_inv: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<tau>moves0 P h (inline_calls e' es) = \\<tau>move0 P h e'\"", "lemma \\<tau>red0_iff [iff]:\n  \"\\<tau>red0 extTA P t h (e, xs) (e', xs') = (extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle> \\<and> \\<tau>move0 P h e \\<and> no_call P h e)\"", "lemma \\<tau>reds0_iff [iff]:\n  \"\\<tau>reds0 extTA P t h (es, xs) (es', xs') =\n  (extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle> \\<and> \\<tau>moves0 P h es \\<and> no_calls P h es)\"", "lemma \\<tau>red0t_1step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e', xs')\"", "lemma \\<tau>red0t_2step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e;\n     extTA,P,t \\<turnstile> \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move0 P h e'; no_call P h e' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e'', xs'')\"", "lemma \\<tau>red1t_3step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e; \n     extTA,P,t \\<turnstile> \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move0 P h e'; no_call P h e';\n     extTA,P,t \\<turnstile> \\<langle>e'', (h, xs'')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e''', (h, xs''')\\<rangle>; \\<tau>move0 P h e''; no_call P h e'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e''', xs''')\"", "lemma \\<tau>reds0t_1step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es', xs')\"", "lemma \\<tau>reds0t_2step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es; \n     extTA,P,t \\<turnstile> \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves0 P h es'; no_calls P h es' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es'', xs'')\"", "lemma \\<tau>reds0t_3step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es; \n     extTA,P,t \\<turnstile> \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves0 P h es'; no_calls P h es';\n     extTA,P,t \\<turnstile> \\<langle>es'', (h, xs'')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es''', (h, xs''')\\<rangle>; \\<tau>moves0 P h es''; no_calls P h es'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es''', xs''')\"", "lemma \\<tau>red0r_1step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e', xs')\"", "lemma \\<tau>red0r_2step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e;\n     extTA,P,t \\<turnstile> \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move0 P h e'; no_call P h e' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e'', xs'')\"", "lemma \\<tau>red0r_3step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e; \n     extTA,P,t \\<turnstile> \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move0 P h e'; no_call P h e';\n     extTA,P,t \\<turnstile> \\<langle>e'', (h, xs'')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e''', (h, xs''')\\<rangle>; \\<tau>move0 P h e''; no_call P h e'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e''', xs''')\"", "lemma \\<tau>reds0r_1step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es', xs')\"", "lemma \\<tau>reds0r_2step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es; \n     extTA,P,t \\<turnstile> \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves0 P h es'; no_calls P h es' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es'', xs'')\"", "lemma \\<tau>reds0r_3step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es; \n     extTA,P,t \\<turnstile> \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves0 P h es'; no_calls P h es';\n     extTA,P,t \\<turnstile> \\<langle>es'', (h, xs'')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es''', (h, xs''')\\<rangle>; \\<tau>moves0 P h es''; no_calls P h es'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es''', xs''')\"", "lemma \\<tau>red0t_inj_\\<tau>reds0t:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs')\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (e # es, xs) (e' # es, xs')\"", "lemma \\<tau>reds0t_cons_\\<tau>reds0t:\n  \"\\<tau>reds0t extTA P t h (es, xs) (es', xs')\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (Val v # es, xs) (Val v # es', xs')\"", "lemma \\<tau>red0r_inj_\\<tau>reds0r:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs')\n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (e # es, xs) (e' # es, xs')\"", "lemma \\<tau>reds0r_cons_\\<tau>reds0r:\n  \"\\<tau>reds0r extTA P t h (es, xs) (es', xs') \n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (Val v # es, xs) (Val v # es', xs')\"", "lemma NewArray_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs')\n  \\<Longrightarrow> \\<tau>red0t extTA P t h (newA T\\<lfloor>e\\<rceil>, xs) (newA T\\<lfloor>e'\\<rceil>, xs')\"", "lemma Cast_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Cast T e, xs) (Cast T e', xs')\"", "lemma InstanceOf_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e instanceof T, xs) (e' instanceof T, xs')\"", "lemma BinOp_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (e1, xs) (e1', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs) (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')\"", "lemma BinOp_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (e2, xs) (e2', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs) (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')\"", "lemma LAss_\\<tau>red0t:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (V := e, xs) (V := e', xs')\"", "lemma AAcc_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (a\\<lfloor>i\\<rceil>, xs) (a'\\<lfloor>i\\<rceil>, xs')\"", "lemma AAcc_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val a\\<lfloor>i\\<rceil>, xs) (Val a\\<lfloor>i'\\<rceil>, xs')\"", "lemma AAss_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (a\\<lfloor>i\\<rceil> := e, xs) (a'\\<lfloor>i\\<rceil> := e, xs')\"", "lemma AAss_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val a\\<lfloor>i\\<rceil> := e, xs) (Val a\\<lfloor>i'\\<rceil> := e, xs')\"", "lemma AAss_\\<tau>red0t_xt3:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs) (Val a\\<lfloor>Val i\\<rceil> := e', xs')\"", "lemma ALength_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')\"", "lemma FAcc_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')\"", "lemma FAss_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e\\<bullet>F{D} := e2, xs) (e'\\<bullet>F{D} := e2, xs')\"", "lemma FAss_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v\\<bullet>F{D} := e, xs) (Val v\\<bullet>F{D} := e', xs')\"", "lemma CAS_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs) (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')\"", "lemma CAS_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')\"", "lemma CAS_\\<tau>red0t_xt3:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')\"", "lemma Call_\\<tau>red0t_obj:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')\"", "lemma Call_\\<tau>red0t_param:\n  \"\\<tau>reds0t extTA P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v\\<bullet>M(es), xs) (Val v\\<bullet>M(es'), xs')\"", "lemma Block_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs(V := vo)) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs) ({V:T=xs' V; e'}, xs'(V := xs V))\"", "lemma Sync_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs) (sync\\<^bsub>V\\<^esub> (e') e2, xs')\"", "lemma InSync_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (insync\\<^bsub>V\\<^esub> (a) e, xs) (insync\\<^bsub>V\\<^esub> (a) e', xs')\"", "lemma Seq_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e;;e2, xs) (e';;e2, xs')\"", "lemma Cond_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')\"", "lemma Throw_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (throw e, xs) (throw e', xs')\"", "lemma Try_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (try e catch(C V) e2, xs) (try e' catch(C V) e2, xs')\"", "lemma NewArray_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (newA T\\<lfloor>e\\<rceil>, xs) (newA T\\<lfloor>e'\\<rceil>, xs')\"", "lemma Cast_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Cast T e, xs) (Cast T e', xs')\"", "lemma InstanceOf_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e instanceof T, xs) (e' instanceof T, xs')\"", "lemma BinOp_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (e1, xs) (e1', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs) (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')\"", "lemma BinOp_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (e2, xs) (e2', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs) (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')\"", "lemma LAss_\\<tau>red0r:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (V := e, xs) (V := e', xs')\"", "lemma AAcc_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (a\\<lfloor>i\\<rceil>, xs) (a'\\<lfloor>i\\<rceil>, xs')\"", "lemma AAcc_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val a\\<lfloor>i\\<rceil>, xs) (Val a\\<lfloor>i'\\<rceil>, xs')\"", "lemma AAss_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (a\\<lfloor>i\\<rceil> := e, xs) (a'\\<lfloor>i\\<rceil> := e, xs')\"", "lemma AAss_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val a\\<lfloor>i\\<rceil> := e, xs) (Val a\\<lfloor>i'\\<rceil> := e, xs')\"", "lemma AAss_\\<tau>red0r_xt3:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs) (Val a\\<lfloor>Val i\\<rceil> := e', xs')\"", "lemma ALength_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')\"", "lemma FAcc_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')\"", "lemma FAss_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e\\<bullet>F{D} := e2, xs) (e'\\<bullet>F{D} := e2, xs')\"", "lemma FAss_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v\\<bullet>F{D} := e, xs) (Val v\\<bullet>F{D} := e', xs')\"", "lemma CAS_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs) (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')\"", "lemma CAS_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')\"", "lemma CAS_\\<tau>red0r_xt3:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')\"", "lemma Call_\\<tau>red0r_obj:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')\"", "lemma Call_\\<tau>red0r_param:\n  \"\\<tau>reds0r extTA P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v\\<bullet>M(es), xs) (Val v\\<bullet>M(es'), xs')\"", "lemma Block_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs(V := vo)) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs) ({V:T=xs' V; e'}, xs'(V := xs V))\"", "lemma Sync_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs) (sync\\<^bsub>V\\<^esub> (e') e2, xs')\"", "lemma InSync_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (insync\\<^bsub>V\\<^esub> (a) e, xs) (insync\\<^bsub>V\\<^esub> (a) e', xs')\"", "lemma Seq_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e;;e2, xs) (e';;e2, xs')\"", "lemma Cond_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')\"", "lemma Throw_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (throw e, xs) (throw e', xs')\"", "lemma Try_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (try e catch(C V) e2, xs) (try e' catch(C V) e2, xs')\"", "lemma \\<tau>Red0_conv [iff]:\n  \"\\<tau>Red0 P t h (e, es) (e', es') = (P,t \\<turnstile>0 \\<langle>e/es, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'/es', h\\<rangle> \\<and> \\<tau>Move0 P h (e, es))\"", "lemma \\<tau>red0r_lcl_incr:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> dom xs \\<subseteq> dom xs'\"", "lemma \\<tau>red0t_lcl_incr:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> dom xs \\<subseteq> dom xs'\"", "lemma \\<tau>red0r_dom_lcl:\n  assumes wwf: \"wwf_J_prog P\"\n  shows \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> dom xs' \\<subseteq> dom xs \\<union> fv e\"", "lemma \\<tau>red0t_dom_lcl:\n  assumes wwf: \"wwf_J_prog P\"\n  shows \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> dom xs' \\<subseteq> dom xs \\<union> fv e\"", "lemma \\<tau>red0r_fv_subset:\n  assumes wwf: \"wwf_J_prog P\"\n  shows \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> fv e' \\<subseteq> fv e\"", "lemma \\<tau>red0t_fv_subset:\n  assumes wwf: \"wwf_J_prog P\"\n  shows \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> fv e' \\<subseteq> fv e\"", "lemma fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move0_callD: \"call e = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow> \\<tau>move0 P h e \\<longleftrightarrow> (synthesized_call P h (a, M, vs) \\<longrightarrow> \\<tau>external' P h a M)\"\n  and \\<tau>moves0_callsD: \"calls es = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow> \\<tau>moves0 P h es \\<longleftrightarrow> (synthesized_call P h (a, M, vs) \\<longrightarrow> \\<tau>external' P h a M)\"", "lemma fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move0_not_call: \"\\<lbrakk> \\<tau>move0 P h e; call e = \\<lfloor>(a, M, vs)\\<rfloor>; synthesized_call P h (a, M, vs) \\<rbrakk> \\<Longrightarrow> \\<tau>external' P h a M\"\n  and \\<tau>moves0_not_calls: \"\\<lbrakk> \\<tau>moves0 P h es; calls es = \\<lfloor>(a, M, vs)\\<rfloor>; synthesized_call P h (a, M, vs) \\<rbrakk> \\<Longrightarrow> \\<tau>external' P h a M\"", "lemma \\<tau>red0_into_\\<tau>Red0:\n  assumes red: \"\\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\"\n  shows \"\\<tau>Red0 P t h (e, es) (e', es)\"", "lemma \\<tau>red0r_into_\\<tau>Red0r:\n  assumes wwf: \"wwf_J_prog P\"\n  shows\n  \"\\<lbrakk> \\<tau>red0r (extTA2J0 P) P t h (e, Map.empty) (e'', Map.empty); fv e = {} \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Red0r P t h (e, es) (e'', es)\"", "lemma \\<tau>red0t_into_\\<tau>Red0t:\n  assumes wwf: \"wwf_J_prog P\"\n  shows\n  \"\\<lbrakk> \\<tau>red0t (extTA2J0 P) P t h (e, Map.empty) (e'', Map.empty); fv e = {} \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Red0t P t h (e, es) (e'', es)\"", "lemma \\<tau>red0r_Val:\n  \"\\<tau>red0r extTA P t h (Val v, xs) s' \\<longleftrightarrow> s' = (Val v, xs)\"", "lemma \\<tau>red0t_Val:\n  \"\\<tau>red0t extTA P t h (Val v, xs) s' \\<longleftrightarrow> False\"", "lemma \\<tau>reds0r_map_Val:\n  \"\\<tau>reds0r extTA P t h (map Val vs, xs) s' \\<longleftrightarrow> s' = (map Val vs, xs)\"", "lemma \\<tau>reds0t_map_Val:\n  \"\\<tau>reds0t extTA P t h (map Val vs, xs) s' \\<longleftrightarrow> False\"", "lemma Red_Suspend_is_call:\n  \"\\<lbrakk> P,t \\<turnstile>0 \\<langle>e/exs, h\\<rangle> -ta\\<rightarrow> \\<langle>e'/exs', h'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> is_call e'\"", "lemma red0_mthr: \"multithreaded final_expr0 (mred0 P)\"", "lemma red0_\\<tau>mthr_wf: \"\\<tau>multithreaded_wf final_expr0 (mred0 P) (\\<tau>MOVE0 P)\"", "lemma red_\\<tau>mthr_wf: \"\\<tau>multithreaded_wf final_expr (mred P) (\\<tau>MOVE P)\"", "lemma \\<tau>Red0r_into_red0_\\<tau>mthr_silent_moves:\n  \"\\<tau>Red0r P t h (e, es) (e'', es'') \\<Longrightarrow> red0_mthr.silent_moves P t ((e, es), h) ((e'', es''), h)\"", "lemma \\<tau>Red0t_into_red0_\\<tau>mthr_silent_movet:\n  \"\\<tau>Red0t P t h (e, es) (e'', es'') \\<Longrightarrow> red0_mthr.silent_movet P t ((e, es), h) ((e'', es''), h)\""], "translations": [["", "lemma extNTA2J0_iff [simp]:\n  \"extNTA2J0 P (C, M, a) = \n   ({this:Class (fst (method P C M))=\\<lfloor>Addr a\\<rfloor>; snd (the (snd (snd (snd (method P C M)))))}, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extNTA2J0 P (C, M, a) =\n    ({this:Class\n            (fst (method P C\n                   M))=\\<lfloor>Addr\n                                 a\\<rfloor>; snd\n        (the (snd (snd (snd (method P C M)))))},\n     [])", "by(simp add: extNTA2J0_def split_def)"], ["", "abbreviation extTA2J0 :: \n  \"'addr J_prog \\<Rightarrow> ('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'heap) J0_thread_action\"\nwhere \"extTA2J0 P \\<equiv> convert_extTA (extNTA2J0 P)\""], ["", "lemma obs_a_extTA2J_eq_obs_a_extTA2J0 [simp]: \"\\<lbrace>extTA2J P ta\\<rbrace>\\<^bsub>o\\<^esub> = \\<lbrace>extTA2J0 P ta\\<rbrace>\\<^bsub>o\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>extTA2J P ta\\<rbrace>\\<^bsub>o\\<^esub> =\n    \\<lbrace>extTA2J0 P ta\\<rbrace>\\<^bsub>o\\<^esub>", "by(cases ta)(simp add: ta_upd_simps)"], ["", "lemma extTA2J0_\\<epsilon>: \"extTA2J0 P \\<epsilon> = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extTA2J0 P \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>", "by(simp)"], ["", "context J_heap_base begin"], ["", "definition no_call :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> ('a, 'b, 'addr) exp \\<Rightarrow> bool\"\nwhere \"no_call P h e = (\\<forall>aMvs. call e = \\<lfloor>aMvs\\<rfloor> \\<longrightarrow> synthesized_call P h aMvs)\""], ["", "definition no_calls :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> ('a, 'b, 'addr) exp list \\<Rightarrow> bool\"\nwhere \"no_calls P h es = (\\<forall>aMvs. calls es = \\<lfloor>aMvs\\<rfloor> \\<longrightarrow> synthesized_call P h aMvs)\""], ["", "inductive red0 :: \n  \"'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr expr \\<Rightarrow> 'addr expr list \\<Rightarrow> 'heap\n  \\<Rightarrow> ('addr, 'thread_id, 'heap) J0_thread_action \\<Rightarrow> 'addr expr \\<Rightarrow> 'addr expr list \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile>0 ((1\\<langle>_'/_,/_\\<rangle>) -_\\<rightarrow>/ (1\\<langle>_'/_,/_\\<rangle>))\" [51,0,0,0,0,0,0,0,0] 81)\nfor P :: \"'addr J_prog\" and t :: 'thread_id\nwhere\n\n  red0Red:\n  \"\\<lbrakk> extTA2J0 P,P,t \\<turnstile> \\<langle>e, (h, Map.empty)\\<rangle> -ta\\<rightarrow> \\<langle>e', (h', xs')\\<rangle>;\n     \\<forall>aMvs. call e = \\<lfloor>aMvs\\<rfloor> \\<longrightarrow> synthesized_call P h aMvs \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile>0 \\<langle>e/es, h\\<rangle> -ta\\<rightarrow> \\<langle>e'/es, h'\\<rangle>\"\n\n| red0Call:\n  \"\\<lbrakk> call e = \\<lfloor>(a, M, vs)\\<rfloor>; typeof_addr h a = \\<lfloor>U\\<rfloor>; \n     P \\<turnstile> class_type_of U sees M:Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D; \n     size vs = size pns; size Ts = size pns \\<rbrakk>\n  \\<Longrightarrow> P,t \\<turnstile>0 \\<langle>e/es, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>blocks (this # pns) (Class D # Ts) (Addr a # vs) body/e#es, h\\<rangle>\"\n\n| red0Return:\n  \"final e' \\<Longrightarrow> P,t \\<turnstile>0 \\<langle>e'/e#es, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>inline_call e' e/es, h\\<rangle>\""], ["", "abbreviation J0_start_state :: \"'addr J_prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> 'addr val list \\<Rightarrow> ('addr, 'thread_id, 'heap) J0_state\"\nwhere\n  \"J0_start_state \\<equiv> \n   start_state (\\<lambda>C M Ts T (pns, body) vs. (blocks (this # pns) (Class C # Ts) (Null # vs) body, []))\""], ["", "abbreviation mred0 ::\n  \"'addr J_prog \\<Rightarrow> ('addr,'thread_id,'addr expr \\<times> 'addr expr list,'heap,'addr,('addr, 'thread_id) obs_event) semantics\"\nwhere \"mred0 P \\<equiv> (\\<lambda>t ((e, es), h) ta ((e', es'), h'). red0 P t e es h ta e' es' h')\""], ["", "end"], ["", "declare domIff[iff, simp del]"], ["", "context J_heap_base begin"], ["", "lemma assumes wf: \"wwf_J_prog P\"\n  shows red_fv_subset: \"extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle> \\<Longrightarrow> fv e' \\<subseteq> fv e\"\n  and reds_fvs_subset: \"extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> \\<Longrightarrow> fvs es' \\<subseteq> fvs es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                            \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     fv e' \\<subseteq> fv e) &&&\n    (extTA,P,t \\<turnstile> \\<langle>es,s\\<rangle> [-ta\\<rightarrow>]\n                            \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     fvs es' \\<subseteq> fvs es)", "proof(induct rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       fv (addr a) \\<subseteq> fv (new C)\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt OutOfMemory)) \\<subseteq> fv (new C)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> fv (newA T\\<lfloor>e\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a)\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n       \\<subseteq> fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> fv (Cast C e)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> fv (Cast T (Val v))\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> fv (Cast T (Val v))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e' \\<subseteq> fv e\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T)\n                          \\<subseteq> fv (e instanceof T)\nA total of 98 subgoals...", "case (RedCall s a U M Ts T pns body D vs)"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       fv (addr a) \\<subseteq> fv (new C)\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt OutOfMemory)) \\<subseteq> fv (new C)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> fv (newA T\\<lfloor>e\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a)\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n       \\<subseteq> fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> fv (Cast C e)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> fv (Cast T (Val v))\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> fv (Cast T (Val v))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e' \\<subseteq> fv e\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T)\n                          \\<subseteq> fv (e instanceof T)\nA total of 98 subgoals...", "hence \"fv body \\<subseteq> {this} \\<union> set pns\""], ["proof (prove)\nusing this:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n\ngoal (1 subgoal):\n 1. fv body \\<subseteq> {this} \\<union> set pns", "using wf"], ["proof (prove)\nusing this:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n  wwf_J_prog P\n\ngoal (1 subgoal):\n 1. fv body \\<subseteq> {this} \\<union> set pns", "by(fastforce dest!:sees_wf_mdecl simp:wf_mdecl_def)"], ["proof (state)\nthis:\n  fv body \\<subseteq> {this} \\<union> set pns\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       fv (addr a) \\<subseteq> fv (new C)\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt OutOfMemory)) \\<subseteq> fv (new C)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> fv (newA T\\<lfloor>e\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a)\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n       \\<subseteq> fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> fv (Cast C e)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> fv (Cast T (Val v))\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> fv (Cast T (Val v))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e' \\<subseteq> fv e\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T)\n                          \\<subseteq> fv (e instanceof T)\nA total of 98 subgoals...", "with RedCall"], ["proof (chain)\npicking this:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n  fv body \\<subseteq> {this} \\<union> set pns", "show ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n  fv body \\<subseteq> {this} \\<union> set pns\n\ngoal (1 subgoal):\n 1. fv (blocks (this # pns) (Class D # Ts) (Addr a # vs) body)\n    \\<subseteq> fv (addr a\\<bullet>M(map Val vs))", "by fastforce"], ["proof (state)\nthis:\n  fv (blocks (this # pns) (Class D # Ts) (Addr a # vs) body)\n  \\<subseteq> fv (addr a\\<bullet>M(map Val vs))\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       fv (addr a) \\<subseteq> fv (new C)\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt OutOfMemory)) \\<subseteq> fv (new C)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> fv (newA T\\<lfloor>e\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a)\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n       \\<subseteq> fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> fv (Cast C e)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> fv (Cast T (Val v))\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> fv (Cast T (Val v))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e' \\<subseteq> fv e\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T)\n                          \\<subseteq> fv (e instanceof T)\nA total of 97 subgoals...", "next"], ["proof (state)\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       fv (addr a) \\<subseteq> fv (new C)\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt OutOfMemory)) \\<subseteq> fv (new C)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> fv (newA T\\<lfloor>e\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a)\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n       \\<subseteq> fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> fv (Cast C e)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> fv (Cast T (Val v))\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> fv (Cast T (Val v))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e' \\<subseteq> fv e\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T)\n                          \\<subseteq> fv (e instanceof T)\nA total of 97 subgoals...", "case RedCallExternal"], ["proof (state)\nthis:\n  typeof_addr (hp s_) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  ta'_ = extTA ta_\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       fv (addr a) \\<subseteq> fv (new C)\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt OutOfMemory)) \\<subseteq> fv (new C)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> fv (newA T\\<lfloor>e\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a)\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n       \\<subseteq> fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> fv (Cast C e)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> fv (Cast T (Val v))\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> fv (Cast T (Val v))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e' \\<subseteq> fv e\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T)\n                          \\<subseteq> fv (e instanceof T)\nA total of 97 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s_) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  ta'_ = extTA ta_\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n\ngoal (1 subgoal):\n 1. fv e'_ \\<subseteq> fv (addr a_\\<bullet>M_(map Val vs_))", "by(auto simp add: extRet2J_def split: extCallRet.split_asm)"], ["proof (state)\nthis:\n  fv e'_ \\<subseteq> fv (addr a_\\<bullet>M_(map Val vs_))\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       (h', a) \\<in> allocate h (Class_type C) \\<Longrightarrow>\n       fv (addr a) \\<subseteq> fv (new C)\n 2. \\<And>h C l.\n       allocate h (Class_type C) = {} \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt OutOfMemory)) \\<subseteq> fv (new C)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> fv (newA T\\<lfloor>e\\<rceil>)\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a)\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 5. \\<And>i T s.\n       i <s 0 \\<Longrightarrow>\n       fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n       \\<subseteq> fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i;\n        allocate h (Array_type T (nat (sint i))) = {}\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> fv\n(newA T\\<lfloor>Val (Intg i)\\<rceil>)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e' \\<subseteq> fv e\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> fv (Cast C e)\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> fv (Cast T (Val v))\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> fv (Cast T (Val v))\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e' \\<subseteq> fv e\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T)\n                          \\<subseteq> fv (e instanceof T)\nA total of 96 subgoals...", "qed(fastforce)+"], ["", "end"], ["", "declare domIff[iff del]"], ["", "context J_heap_base begin"], ["", "lemma assumes wwf: \"wwf_J_prog P\"\n  shows red_fv_ok: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; fv e \\<subseteq> dom (lcl s) \\<rbrakk> \\<Longrightarrow> fv e' \\<subseteq> dom (lcl s')\"\n  and reds_fvs_ok: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; fvs es \\<subseteq> dom (lcl s) \\<rbrakk> \\<Longrightarrow> fvs es' \\<subseteq> dom (lcl s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n      fv e \\<subseteq> dom (lcl s)\\<rbrakk>\n     \\<Longrightarrow> fv e' \\<subseteq> dom (lcl s')) &&&\n    (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n      fvs es \\<subseteq> dom (lcl s)\\<rbrakk>\n     \\<Longrightarrow> fvs es' \\<subseteq> dom (lcl s'))", "proof(induct rule: red_reds.inducts)"], ["proof (state)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 98 subgoals...", "case (RedCall s a U M Ts T pns body D vs)"], ["proof (state)\nthis:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n  fv (addr a\\<bullet>M(map Val vs)) \\<subseteq> dom (lcl s)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 98 subgoals...", "from \\<open>P \\<turnstile> class_type_of U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns, body)\\<rfloor> in D\\<close>"], ["proof (chain)\npicking this:\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D", "have \"wwf_J_mdecl P D (M,Ts,T,pns,body)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n\ngoal (1 subgoal):\n 1. wwf_J_mdecl P D (M, Ts, T, pns, body)", "by(auto dest!: sees_wf_mdecl[OF wwf] simp add: wf_mdecl_def)"], ["proof (state)\nthis:\n  wwf_J_mdecl P D (M, Ts, T, pns, body)\n\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 98 subgoals...", "with RedCall"], ["proof (chain)\npicking this:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n  fv (addr a\\<bullet>M(map Val vs)) \\<subseteq> dom (lcl s)\n  wwf_J_mdecl P D (M, Ts, T, pns, body)", "show ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s) a = \\<lfloor>U\\<rfloor>\n  P \\<turnstile> class_type_of\n                  U sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                   body)\\<rfloor> in D\n  length vs = length pns\n  length Ts = length pns\n  fv (addr a\\<bullet>M(map Val vs)) \\<subseteq> dom (lcl s)\n  wwf_J_mdecl P D (M, Ts, T, pns, body)\n\ngoal (1 subgoal):\n 1. fv (blocks (this # pns) (Class D # Ts) (Addr a # vs) body)\n    \\<subseteq> dom (lcl s)", "by(auto)"], ["proof (state)\nthis:\n  fv (blocks (this # pns) (Class D # Ts) (Addr a # vs) body)\n  \\<subseteq> dom (lcl s)\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 97 subgoals...", "next"], ["proof (state)\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 97 subgoals...", "case RedCallExternal"], ["proof (state)\nthis:\n  typeof_addr (hp s_) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  ta'_ = extTA ta_\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n  fv (addr a_\\<bullet>M_(map Val vs_)) \\<subseteq> dom (lcl s_)\n\ngoal (97 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 97 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof_addr (hp s_) a_ = \\<lfloor>hU_\\<rfloor>\n  P \\<turnstile> class_type_of\n                  hU_ sees M_: Ts_\\<rightarrow>T_ = Native in D_\n  P,t \\<turnstile> \\<langle>a_\\<bullet>M_(vs_),\n                   hp s_\\<rangle> -ta_\\<rightarrow>ext \\<langle>va_,\n                 h'_\\<rangle>\n  ta'_ = extTA ta_\n  e'_ = extRet2J (addr a_\\<bullet>M_(map Val vs_)) va_\n  s'_ = (h'_, lcl s_)\n  fv (addr a_\\<bullet>M_(map Val vs_)) \\<subseteq> dom (lcl s_)\n\ngoal (1 subgoal):\n 1. fv e'_ \\<subseteq> dom (lcl s'_)", "by(auto simp add: extRet2J_def split: extCallRet.split_asm)"], ["proof (state)\nthis:\n  fv e'_ \\<subseteq> dom (lcl s'_)\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "next"], ["proof (state)\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "case (BlockRed e h x V vo ta e' h' x' T)"], ["proof (state)\nthis:\n  extTA,P,t \\<turnstile> \\<langle>e,\n                          (h, x(V := vo))\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',(h', x')\\<rangle>\n  fv e \\<subseteq> dom (lcl (h, x(V := vo))) \\<Longrightarrow>\n  fv e' \\<subseteq> dom (lcl (h', x'))\n  fv {V:T=vo; e} \\<subseteq> dom (lcl (h, x))\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "note red = \\<open>extTA,P,t \\<turnstile> \\<langle>e,(h, x(V := vo))\\<rangle> -ta\\<rightarrow> \\<langle>e',(h', x')\\<rangle>\\<close>"], ["proof (state)\nthis:\n  extTA,P,t \\<turnstile> \\<langle>e,\n                          (h, x(V := vo))\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',(h', x')\\<rangle>\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "hence \"fv e' \\<subseteq> fv e\""], ["proof (prove)\nusing this:\n  extTA,P,t \\<turnstile> \\<langle>e,\n                          (h, x(V := vo))\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',(h', x')\\<rangle>\n\ngoal (1 subgoal):\n 1. fv e' \\<subseteq> fv e", "by(auto dest: red_fv_subset[OF wwf] del: subsetI)"], ["proof (state)\nthis:\n  fv e' \\<subseteq> fv e\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "moreover"], ["proof (state)\nthis:\n  fv e' \\<subseteq> fv e\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "from \\<open> fv {V:T=vo; e} \\<subseteq> dom (lcl (h, x))\\<close>"], ["proof (chain)\npicking this:\n  fv {V:T=vo; e} \\<subseteq> dom (lcl (h, x))", "have \"fv e - {V} \\<subseteq> dom x\""], ["proof (prove)\nusing this:\n  fv {V:T=vo; e} \\<subseteq> dom (lcl (h, x))\n\ngoal (1 subgoal):\n 1. fv e - {V} \\<subseteq> dom x", "by(simp)"], ["proof (state)\nthis:\n  fv e - {V} \\<subseteq> dom x\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  fv e' \\<subseteq> fv e\n  fv e - {V} \\<subseteq> dom x", "have \"fv e' - {V} \\<subseteq> dom x - {V}\""], ["proof (prove)\nusing this:\n  fv e' \\<subseteq> fv e\n  fv e - {V} \\<subseteq> dom x\n\ngoal (1 subgoal):\n 1. fv e' - {V} \\<subseteq> dom x - {V}", "by(auto)"], ["proof (state)\nthis:\n  fv e' - {V} \\<subseteq> dom x - {V}\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "moreover"], ["proof (state)\nthis:\n  fv e' - {V} \\<subseteq> dom x - {V}\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "from red"], ["proof (chain)\npicking this:\n  extTA,P,t \\<turnstile> \\<langle>e,\n                          (h, x(V := vo))\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',(h', x')\\<rangle>", "have \"dom (x(V := vo)) \\<subseteq> dom x'\""], ["proof (prove)\nusing this:\n  extTA,P,t \\<turnstile> \\<langle>e,\n                          (h, x(V := vo))\\<rangle> -ta\\<rightarrow>\n                         \\<langle>e',(h', x')\\<rangle>\n\ngoal (1 subgoal):\n 1. dom (x(V := vo)) \\<subseteq> dom x'", "by(auto dest: red_lcl_incr del: subsetI)"], ["proof (state)\nthis:\n  dom (x(V := vo)) \\<subseteq> dom x'\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  fv e' - {V} \\<subseteq> dom x - {V}\n  dom (x(V := vo)) \\<subseteq> dom x'", "have \"fv e' - {V} \\<subseteq> dom x' - {V}\""], ["proof (prove)\nusing this:\n  fv e' - {V} \\<subseteq> dom x - {V}\n  dom (x(V := vo)) \\<subseteq> dom x'\n\ngoal (1 subgoal):\n 1. fv e' - {V} \\<subseteq> dom x' - {V}", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  fv e' - {V} \\<subseteq> dom x' - {V}\n\ngoal (96 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 96 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  fv e' - {V} \\<subseteq> dom x' - {V}\n\ngoal (1 subgoal):\n 1. fv {V:T=x' V; e'} \\<subseteq> dom (lcl (h', x'(V := x V)))", "by(auto simp del: fun_upd_apply)"], ["proof (state)\nthis:\n  fv {V:T=x' V; e'} \\<subseteq> dom (lcl (h', x'(V := x V)))\n\ngoal (95 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        fv (new C) \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (newA T\\<lfloor>e\\<rceil>) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (newA T\\<lfloor>e'\\<rceil>)\n                         \\<subseteq> dom (lcl s')\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (addr a) \\<subseteq> dom (lcl (h', l))\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt NegativeArraySize))\n                         \\<subseteq> dom (lcl s)\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        fv (newA T\\<lfloor>Val (Intg i)\\<rceil>)\n        \\<subseteq> dom (lcl (h, l))\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt OutOfMemory))\n                         \\<subseteq> dom (lcl (h, l))\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n        fv e' \\<subseteq> dom (lcl s');\n        fv (Cast C e) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Cast C e') \\<subseteq> dom (lcl s')\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Val v) \\<subseteq> dom (lcl s)\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        fv (Cast T (Val v)) \\<subseteq> dom (lcl s)\\<rbrakk>\n       \\<Longrightarrow> fv (Throw (addr_of_sys_xcpt ClassCast))\n                         \\<subseteq> dom (lcl s)\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         fv e \\<subseteq> dom (lcl s) \\<Longrightarrow>\n         fv e' \\<subseteq> dom (lcl s');\n         fv (e instanceof T) \\<subseteq> dom (lcl s)\\<rbrakk>\n        \\<Longrightarrow> fv (e' instanceof T) \\<subseteq> dom (lcl s')\nA total of 95 subgoals...", "qed(fastforce dest: red_lcl_incr del: subsetI)+"], ["", "lemma is_call_red_state_unchanged: \n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; call e = \\<lfloor>aMvs\\<rfloor>; \\<not> synthesized_call P (hp s) aMvs \\<rbrakk> \\<Longrightarrow> s' = s \\<and> ta = \\<epsilon>\"\n\n  and is_calls_reds_state_unchanged:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; calls es = \\<lfloor>aMvs\\<rfloor>; \\<not> synthesized_call P (hp s) aMvs \\<rbrakk> \\<Longrightarrow> s' = s \\<and> ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n      call e = \\<lfloor>aMvs\\<rfloor>;\n      \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n     \\<Longrightarrow> s' = s \\<and> ta = \\<lbrace>\\<rbrace>) &&&\n    (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n      calls es = \\<lfloor>aMvs\\<rfloor>;\n      \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n     \\<Longrightarrow> s' = s \\<and> ta = \\<lbrace>\\<rbrace>)", "apply(induct rule: red_reds.inducts)"], ["proof (prove)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp (h, l)) aMvs\\<rbrakk>\n       \\<Longrightarrow> (h', l) = (h, l) \\<and>\n                         \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace> =\n                         \\<lbrace>\\<rbrace>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        call (new C) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp (h, l)) aMvs\\<rbrakk>\n       \\<Longrightarrow> (h, l) = (h, l) \\<and>\n                         \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n        \\<Longrightarrow> s' = s \\<and> ta = \\<lbrace>\\<rbrace>;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n       \\<Longrightarrow> s' = s \\<and> ta = \\<lbrace>\\<rbrace>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        call (newA T\\<lfloor>Val (Intg i)\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp (h, l)) aMvs\\<rbrakk>\n       \\<Longrightarrow> (h', l) = (h, l) \\<and>\n                         \\<lbrace>NewHeapElem a\n                                   (Array_type T (nat (sint i)))\\<rbrace> =\n                         \\<lbrace>\\<rbrace>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        call (newA T\\<lfloor>Val (Intg i)\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n       \\<Longrightarrow> s = s \\<and>\n                         \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        call (newA T\\<lfloor>Val (Intg i)\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp (h, l)) aMvs\\<rbrakk>\n       \\<Longrightarrow> (h, l) = (h, l) \\<and>\n                         \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n         \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n        \\<Longrightarrow> s' = s \\<and> ta = \\<lbrace>\\<rbrace>;\n        call (Cast C e) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n       \\<Longrightarrow> s' = s \\<and> ta = \\<lbrace>\\<rbrace>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        call (Cast T (Val v)) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n       \\<Longrightarrow> s = s \\<and>\n                         \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        call (Cast T (Val v)) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n       \\<Longrightarrow> s = s \\<and>\n                         \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>call e = \\<lfloor>aMvs\\<rfloor>;\n          \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n         \\<Longrightarrow> s' = s \\<and> ta = \\<lbrace>\\<rbrace>;\n         call (e instanceof T) = \\<lfloor>aMvs\\<rfloor>;\n         \\<not> synthesized_call P (hp s) aMvs\\<rbrakk>\n        \\<Longrightarrow> s' = s \\<and> ta = \\<lbrace>\\<rbrace>\nA total of 98 subgoals...", "apply(fastforce split: if_split_asm simp add: synthesized_call_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma called_methodD:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; call e = \\<lfloor>(a, M, vs)\\<rfloor>; \\<not> synthesized_call P (hp s) (a, M, vs) \\<rbrakk> \n  \\<Longrightarrow> \\<exists>hT D Us U pns body. hp s' = hp s \\<and> typeof_addr (hp s) a = \\<lfloor>hT\\<rfloor> \\<and>\n                           P \\<turnstile> class_type_of hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns, body)\\<rfloor> in D \\<and> \n                           length vs = length pns \\<and> length Us = length pns\"\n\n  and called_methodsD:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; calls es = \\<lfloor>(a, M, vs)\\<rfloor>; \\<not> synthesized_call P (hp s) (a, M, vs) \\<rbrakk> \n  \\<Longrightarrow> \\<exists>hT D Us U pns body. hp s' = hp s \\<and> typeof_addr (hp s) a = \\<lfloor>hT\\<rfloor> \\<and>\n                           P \\<turnstile> class_type_of hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns, body)\\<rfloor> in D \\<and>\n                           length vs = length pns \\<and> length Us = length pns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n      call e = \\<lfloor>(a, M, vs)\\<rfloor>;\n      \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                          hp s' = hp s \\<and>\n                          typeof_addr (hp s) a = \\<lfloor>hT\\<rfloor> \\<and>\n                          P \\<turnstile> class_type_of\n    hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns, body)\\<rfloor> in D \\<and>\n                          length vs = length pns \\<and>\n                          length Us = length pns) &&&\n    (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n      calls es = \\<lfloor>(a, M, vs)\\<rfloor>;\n      \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                          hp s' = hp s \\<and>\n                          typeof_addr (hp s) a = \\<lfloor>hT\\<rfloor> \\<and>\n                          P \\<turnstile> class_type_of\n    hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns, body)\\<rfloor> in D \\<and>\n                          length vs = length pns \\<and>\n                          length Us = length pns)", "apply(induct rule: red_reds.inducts)"], ["proof (prove)\ngoal (98 subgoals):\n 1. \\<And>h' aa h C l.\n       \\<lbrakk>(h', aa) \\<in> allocate h (Class_type C);\n        call (new C) = \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp (h, l)) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp (h', l) = hp (h, l) \\<and>\n                            typeof_addr (hp (h, l)) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        call (new C) = \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp (h, l)) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp (h, l) = hp (h, l) \\<and>\n                            typeof_addr (hp (h, l)) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>call e = \\<lfloor>(a, M, vs)\\<rfloor>;\n         \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                             hp s' = hp s \\<and>\n                             typeof_addr (hp s) a =\n                             \\<lfloor>hT\\<rfloor> \\<and>\n                             P \\<turnstile> class_type_of\n       hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n         body)\\<rfloor> in D \\<and>\n                             length vs = length pns \\<and>\n                             length Us = length pns;\n        call (newA T\\<lfloor>e\\<rceil>) = \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp s' = hp s \\<and>\n                            typeof_addr (hp s) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 4. \\<And>i h' aa h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', aa) \\<in> allocate h (Array_type T (nat (sint i)));\n        call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n        \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp (h, l)) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp (h', l) = hp (h, l) \\<and>\n                            typeof_addr (hp (h, l)) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n        \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp s = hp s \\<and>\n                            typeof_addr (hp s) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        call (newA T\\<lfloor>Val (Intg i)\\<rceil>) =\n        \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp (h, l)) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp (h, l) = hp (h, l) \\<and>\n                            typeof_addr (hp (h, l)) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<lbrakk>call e = \\<lfloor>(a, M, vs)\\<rfloor>;\n         \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                             hp s' = hp s \\<and>\n                             typeof_addr (hp s) a =\n                             \\<lfloor>hT\\<rfloor> \\<and>\n                             P \\<turnstile> class_type_of\n       hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n         body)\\<rfloor> in D \\<and>\n                             length vs = length pns \\<and>\n                             length Us = length pns;\n        call (Cast C e) = \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp s' = hp s \\<and>\n                            typeof_addr (hp s) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        call (Cast T (Val v)) = \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp s = hp s \\<and>\n                            typeof_addr (hp s) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        call (Cast T (Val v)) = \\<lfloor>(a, M, vs)\\<rfloor>;\n        \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                            hp s = hp s \\<and>\n                            typeof_addr (hp s) a =\n                            \\<lfloor>hT\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n        body)\\<rfloor> in D \\<and>\n                            length vs = length pns \\<and>\n                            length Us = length pns\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<lbrakk>call e = \\<lfloor>(a, M, vs)\\<rfloor>;\n          \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n         \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                              hp s' = hp s \\<and>\n                              typeof_addr (hp s) a =\n                              \\<lfloor>hT\\<rfloor> \\<and>\n                              P \\<turnstile> class_type_of\n        hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n          body)\\<rfloor> in D \\<and>\n                              length vs = length pns \\<and>\n                              length Us = length pns;\n         call (e instanceof T) = \\<lfloor>(a, M, vs)\\<rfloor>;\n         \\<not> synthesized_call P (hp s) (a, M, vs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>hT D Us U pns body.\n                             hp s' = hp s \\<and>\n                             typeof_addr (hp s) a =\n                             \\<lfloor>hT\\<rfloor> \\<and>\n                             P \\<turnstile> class_type_of\n       hT sees M: Us\\<rightarrow>U = \\<lfloor>(pns,\n         body)\\<rfloor> in D \\<and>\n                             length vs = length pns \\<and>\n                             length Us = length pns\nA total of 98 subgoals...", "apply(auto split: if_split_asm simp add: synthesized_call_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa hU Ts T pns body D.\n       \\<lbrakk>typeof_addr aa a = \\<lfloor>hU\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        hU sees M: Ts\\<rightarrow>T = \\<lfloor>(pns,\n                          body)\\<rfloor> in D;\n        length vs = length pns; length Ts = length pns;\n        \\<forall>Ts Tr x.\n           \\<not> P \\<turnstile> class_type_of\n                                  hU sees M: Ts\\<rightarrow>Tr = Native in x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D Us U pnsa.\n                            (\\<exists>body.\n                                P \\<turnstile> class_type_of\n          hU sees M: Us\\<rightarrow>U = \\<lfloor>(pnsa,\n            body)\\<rfloor> in D) \\<and>\n                            length pns = length pnsa \\<and>\n                            length Us = length pnsa", "apply(fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Silent moves\\<close>"], ["", "primrec  \\<tau>move0 :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> ('a, 'b, 'addr) exp \\<Rightarrow> bool\"\n  and \\<tau>moves0 :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> ('a, 'b, 'addr) exp list \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>move0 P h (new C) \\<longleftrightarrow> False\"\n| \"\\<tau>move0 P h (newA T\\<lfloor>e\\<rceil>) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a)\"\n| \"\\<tau>move0 P h (Cast U e) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v)\"\n| \"\\<tau>move0 P h (e instanceof T) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v)\"\n| \"\\<tau>move0 P h (e \\<guillemotleft>bop\\<guillemotright> e') \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v \\<and>\n   (\\<tau>move0 P h e' \\<or> (\\<exists>a. e' = Throw a) \\<or> (\\<exists>v. e' = Val v)))\"\n| \"\\<tau>move0 P h (Val v) \\<longleftrightarrow> False\"\n| \"\\<tau>move0 P h (Var V) \\<longleftrightarrow> True\"\n| \"\\<tau>move0 P h (V := e) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v)\"\n| \"\\<tau>move0 P h (a\\<lfloor>i\\<rceil>) \\<longleftrightarrow> \\<tau>move0 P h a \\<or> (\\<exists>ad. a = Throw ad) \\<or> (\\<exists>v. a = Val v \\<and> (\\<tau>move0 P h i \\<or> (\\<exists>a. i = Throw a)))\"\n| \"\\<tau>move0 P h (AAss a i e) \\<longleftrightarrow> \\<tau>move0 P h a \\<or> (\\<exists>ad. a = Throw ad) \\<or> (\\<exists>v. a = Val v \\<and> \n   (\\<tau>move0 P h i \\<or> (\\<exists>a. i = Throw a) \\<or> (\\<exists>v. i = Val v \\<and> (\\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a)))))\"\n| \"\\<tau>move0 P h (a\\<bullet>length) \\<longleftrightarrow> \\<tau>move0 P h a \\<or> (\\<exists>ad. a = Throw ad)\"\n| \"\\<tau>move0 P h (e\\<bullet>F{D}) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a)\"\n| \"\\<tau>move0 P h (FAss e F D e') \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v \\<and> (\\<tau>move0 P h e' \\<or> (\\<exists>a. e' = Throw a)))\"\n| \"\\<tau>move0 P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v \\<and>\n   (\\<tau>move0 P h e' \\<or> (\\<exists>a. e' = Throw a) \\<or> (\\<exists>v. e' = Val v \\<and> (\\<tau>move0 P h e'' \\<or> (\\<exists>a. e'' = Throw a)))))\"\n| \"\\<tau>move0 P h (e\\<bullet>M(es)) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v \\<and>\n   ((\\<tau>moves0 P h es \\<or> (\\<exists>vs a es'. es = map Val vs @ Throw a # es')) \\<or> \n    (\\<exists>vs. es = map Val vs \\<and> (v = Null \\<or> (\\<forall>T C Ts Tr D. typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor> \\<longrightarrow> class_type_of' T = \\<lfloor>C\\<rfloor> \\<longrightarrow> P \\<turnstile> C sees M:Ts\\<rightarrow>Tr = Native in D \\<longrightarrow> \\<tau>external_defs D M)))))\"\n| \"\\<tau>move0 P h ({V:T=vo; e}) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> ((\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v))\"\n| \"\\<tau>move0 P h (sync\\<^bsub>V'\\<^esub>(e) e') \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a)\"\n| \"\\<tau>move0 P h (insync\\<^bsub>V'\\<^esub>(ad) e) \\<longleftrightarrow> \\<tau>move0 P h e\"\n| \"\\<tau>move0 P h (e;;e') \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v)\"\n| \"\\<tau>move0 P h (if (e) e' else e'') \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v)\"\n| \"\\<tau>move0 P h (while (e) e') = True\"\n| \\<comment> \\<open>@{term \"Throw a\"} is no @{text \"\\<tau>move0\"} because there is no reduction for it.\n  If it were, most defining equations would be simpler. However, @{term \"insync\\<^bsub>V'\\<^esub>(ad) (Throw ad)\"}\n  must not be a @{text \"\\<tau>move0\"}, but would be if @{term \"Throw a\"} was.\\<close>\n  \"\\<tau>move0 P h (throw e) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> e = null\"\n| \"\\<tau>move0 P h (try e catch(C V) e') \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>a. e = Throw a) \\<or> (\\<exists>v. e = Val v)\"\n\n| \"\\<tau>moves0 P h [] \\<longleftrightarrow> False\"\n| \"\\<tau>moves0 P h (e # es) \\<longleftrightarrow> \\<tau>move0 P h e \\<or> (\\<exists>v. e = Val v \\<and> \\<tau>moves0 P h es)\""], ["", "abbreviation \\<tau>MOVE :: \"'m prog \\<Rightarrow> (('addr expr \\<times> 'addr locals) \\<times> 'heap, ('addr, 'thread_id, 'heap) J_thread_action) trsys\"\nwhere \"\\<tau>MOVE \\<equiv> \\<lambda>P ((e, x), h) ta s'. \\<tau>move0 P h e \\<and> ta = \\<epsilon>\""], ["", "primrec \\<tau>Move0 :: \"'m prog \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr \\<times> 'addr expr list) \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>Move0 P h (e, exs) = (\\<tau>move0 P h e \\<or> final e)\""], ["", "abbreviation \\<tau>MOVE0 :: \"'m prog \\<Rightarrow> (('addr expr \\<times> 'addr expr list) \\<times> 'heap, ('addr, 'thread_id, 'heap) J0_thread_action) trsys\"\nwhere \"\\<tau>MOVE0 \\<equiv> \\<lambda>P (es, h) ta s. \\<tau>Move0 P h es \\<and> ta = \\<epsilon>\""], ["", "definition \\<tau>red0 ::\n  \"(('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'x,'heap) Jinja_thread_action)\n  \\<Rightarrow> 'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr \\<times> 'addr locals) \\<Rightarrow> ('addr expr \\<times> 'addr locals) \\<Rightarrow> bool\"\nwhere\n  \"\\<tau>red0 extTA P t h exs e'xs' =\n   (extTA,P,t \\<turnstile> \\<langle>fst exs, (h, snd exs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>fst e'xs', (h, snd e'xs')\\<rangle> \\<and> \\<tau>move0 P h (fst exs) \\<and> no_call P h (fst exs))\""], ["", "definition \\<tau>reds0 :: \n  \"(('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'x,'heap) Jinja_thread_action) \n  \\<Rightarrow> 'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr list \\<times> 'addr locals) \\<Rightarrow> ('addr expr list \\<times> 'addr locals) \\<Rightarrow> bool\"\nwhere \n  \"\\<tau>reds0 extTA P t h esxs es'xs' = \n   (extTA,P,t \\<turnstile> \\<langle>fst esxs, (h, snd esxs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>fst es'xs', (h, snd es'xs')\\<rangle> \\<and> \\<tau>moves0 P h (fst esxs) \\<and>\n    no_calls P h (fst esxs))\""], ["", "abbreviation \\<tau>red0t ::\n  \"(('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'x,'heap) Jinja_thread_action) \n  \\<Rightarrow> 'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr \\<times> 'addr locals) \\<Rightarrow> ('addr expr \\<times> 'addr locals) \\<Rightarrow> bool\"\nwhere \"\\<tau>red0t extTA P t h \\<equiv> (\\<tau>red0 extTA P t h)^++\""], ["", "abbreviation \\<tau>reds0t ::\n  \"(('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'x,'heap) Jinja_thread_action) \n  \\<Rightarrow> 'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr list \\<times> 'addr locals) \\<Rightarrow> ('addr expr list \\<times> 'addr locals) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds0t extTA P t h \\<equiv> (\\<tau>reds0 extTA P t h)^++\""], ["", "abbreviation \\<tau>red0r :: \n  \"(('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'x,'heap) Jinja_thread_action) \n  \\<Rightarrow> 'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr \\<times> 'addr locals) \\<Rightarrow> ('addr expr \\<times> 'addr locals) \\<Rightarrow> bool\"\nwhere \"\\<tau>red0r extTA P t h \\<equiv> (\\<tau>red0 extTA P t h)^**\""], ["", "abbreviation \\<tau>reds0r :: \n  \"(('addr, 'thread_id, 'heap) external_thread_action \\<Rightarrow> ('addr, 'thread_id, 'x,'heap) Jinja_thread_action)\n  \\<Rightarrow> 'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr list \\<times> 'addr locals) \\<Rightarrow> ('addr expr list \\<times> 'addr locals) \\<Rightarrow> bool\"\nwhere \"\\<tau>reds0r extTA P t h \\<equiv> (\\<tau>reds0 extTA P t h)^**\""], ["", "definition \\<tau>Red0 :: \n  \"'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr \\<times> 'addr expr list) \\<Rightarrow> ('addr expr \\<times> 'addr expr list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red0 P t h ees e'es' = (P,t \\<turnstile>0 \\<langle>fst ees/snd ees, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>fst e'es'/snd e'es', h\\<rangle> \\<and> \\<tau>Move0 P h ees)\""], ["", "abbreviation \\<tau>Red0r ::\n  \"'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr \\<times> 'addr expr list) \\<Rightarrow> ('addr expr \\<times> 'addr expr list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red0r P t h \\<equiv> (\\<tau>Red0 P t h)^**\""], ["", "abbreviation \\<tau>Red0t ::\n  \"'addr J_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'heap \\<Rightarrow> ('addr expr \\<times> 'addr expr list) \\<Rightarrow> ('addr expr \\<times> 'addr expr list) \\<Rightarrow> bool\"\nwhere \"\\<tau>Red0t P t h \\<equiv> (\\<tau>Red0 P t h)^++\""], ["", "lemma \\<tau>move0_\\<tau>moves0_intros:\n  fixes e e1 e2 e' :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move0NewArray: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (newA T\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move0Cast: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Cast U e)\"\n  and \\<tau>move0CastRed: \"\\<tau>move0 P h (Cast U (Val v))\"\n  and \\<tau>move0InstanceOf: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e instanceof T)\"\n  and \\<tau>move0InstanceOfRed: \"\\<tau>move0 P h ((Val v) instanceof T)\"\n  and \\<tau>move0BinOp1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<guillemotleft>bop\\<guillemotright>e')\"\n  and \\<tau>move0BinOp2: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<guillemotleft>bop\\<guillemotright>e)\"\n  and \\<tau>move0BinOp: \"\\<tau>move0 P h (Val v\\<guillemotleft>bop\\<guillemotright>Val v')\"\n  and \\<tau>move0Var: \"\\<tau>move0 P h (Var V)\"\n  and \\<tau>move0LAss: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (V := e)\"\n  and \\<tau>move0LAssRed: \"\\<tau>move0 P h (V := Val v)\"\n  and \\<tau>move0AAcc1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<lfloor>e'\\<rceil>)\"\n  and \\<tau>move0AAcc2: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move0AAss1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<lfloor>e1\\<rceil> := e2)\"\n  and \\<tau>move0AAss2: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<lfloor>e\\<rceil> := e')\"\n  and \\<tau>move0AAss3: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<lfloor>Val v'\\<rceil> := e)\"\n  and \\<tau>move0ALength: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<bullet>length)\"\n  and \\<tau>move0FAcc: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<bullet>F{D})\"\n  and \\<tau>move0FAss1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (FAss e F D e')\"\n  and \\<tau>move0FAss2: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>F{D} := e)\"\n  and \\<tau>move0CAS1: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\"\n  and \\<tau>move0CAS2: \"\\<tau>move0 P h e' \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))\"\n  and \\<tau>move0CAS3: \"\\<tau>move0 P h e'' \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e''))\"\n  and \\<tau>move0CallObj: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e\\<bullet>M(es))\"\n  and \\<tau>move0CallParams: \"\\<tau>moves0 P h es \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>M(es))\"\n  and \\<tau>move0Call: \"(\\<And>T C Ts Tr D. \\<lbrakk> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>; class_type_of' T = \\<lfloor>C\\<rfloor>; P \\<turnstile> C sees M:Ts\\<rightarrow>Tr = Native in D \\<rbrakk> \\<Longrightarrow> \\<tau>external_defs D M) \\<Longrightarrow> \\<tau>move0 P h (Val v\\<bullet>M(map Val vs))\"\n  and \\<tau>move0Block: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h {V:T=vo; e}\"\n  and \\<tau>move0BlockRed: \"\\<tau>move0 P h {V:T=vo; Val v}\"\n  and \\<tau>move0Sync: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (sync\\<^bsub>V'\\<^esub> (e) e')\"\n  and \\<tau>move0InSync: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (insync\\<^bsub>V'\\<^esub> (a) e)\"\n  and \\<tau>move0Seq: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e;;e')\"\n  and \\<tau>move0SeqRed: \"\\<tau>move0 P h (Val v;; e')\"\n  and \\<tau>move0Cond: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (if (e) e1 else e2)\"\n  and \\<tau>move0CondRed: \"\\<tau>move0 P h (if (Val v) e1 else e2)\"\n  and \\<tau>move0WhileRed: \"\\<tau>move0 P h (while (e) e')\"\n  and \\<tau>move0Throw: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (throw e)\"\n  and \\<tau>move0ThrowNull: \"\\<tau>move0 P h (throw null)\"\n  and \\<tau>move0Try: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (try e catch(C V) e')\"\n  and \\<tau>move0TryRed: \"\\<tau>move0 P h (try Val v catch(C V) e)\"\n  and \\<tau>move0TryThrow: \"\\<tau>move0 P h (try Throw a catch(C V) e)\"\n  and \\<tau>move0NewArrayThrow: \"\\<tau>move0 P h (newA T\\<lfloor>Throw a\\<rceil>)\"\n  and \\<tau>move0CastThrow: \"\\<tau>move0 P h (Cast T (Throw a))\"\n  and \\<tau>move0CInstanceOfThrow: \"\\<tau>move0 P h ((Throw a) instanceof T)\"\n  and \\<tau>move0BinOpThrow1: \"\\<tau>move0 P h (Throw a \\<guillemotleft>bop\\<guillemotright> e')\"\n  and \\<tau>move0BinOpThrow2: \"\\<tau>move0 P h (Val v \\<guillemotleft>bop\\<guillemotright> Throw a)\"\n  and \\<tau>move0LAssThrow: \"\\<tau>move0 P h (V:=(Throw a))\"\n  and \\<tau>move0AAccThrow1: \"\\<tau>move0 P h (Throw a\\<lfloor>e\\<rceil>)\"\n  and \\<tau>move0AAccThrow2: \"\\<tau>move0 P h (Val v\\<lfloor>Throw a\\<rceil>)\"\n  and \\<tau>move0AAssThrow1: \"\\<tau>move0 P h (AAss (Throw a) e e')\"\n  and \\<tau>move0AAssThrow2: \"\\<tau>move0 P h (AAss (Val v) (Throw a) e')\"\n  and \\<tau>move0AAssThrow3: \"\\<tau>move0 P h (AAss (Val v) (Val v') (Throw a))\"\n  and \\<tau>move0ALengthThrow: \"\\<tau>move0 P h (Throw a\\<bullet>length)\"\n  and \\<tau>move0FAccThrow: \"\\<tau>move0 P h (Throw a\\<bullet>F{D})\"\n  and \\<tau>move0FAssThrow1: \"\\<tau>move0 P h (Throw a\\<bullet>F{D} := e)\"\n  and \\<tau>move0FAssThrow2: \"\\<tau>move0 P h (FAss (Val v) F D (Throw a))\"\n  and \\<tau>move0CallThrowObj: \"\\<tau>move0 P h (Throw a\\<bullet>M(es))\"\n  and \\<tau>move0CallThrowParams: \"\\<tau>move0 P h (Val v\\<bullet>M(map Val vs @ Throw a # es))\"\n  and \\<tau>move0BlockThrow: \"\\<tau>move0 P h {V:T=vo; Throw a}\"\n  and \\<tau>move0SyncThrow: \"\\<tau>move0 P h (sync\\<^bsub>V'\\<^esub> (Throw a) e)\"\n  and \\<tau>move0SeqThrow: \"\\<tau>move0 P h (Throw a;;e)\"\n  and \\<tau>move0CondThrow: \"\\<tau>move0 P h (if (Throw a) e1 else e2)\"\n  and \\<tau>move0ThrowThrow: \"\\<tau>move0 P h (throw (Throw a))\"\n\n  and \\<tau>moves0Hd: \"\\<tau>move0 P h e \\<Longrightarrow> \\<tau>moves0 P h (e # es)\"\n  and \\<tau>moves0Tl: \"\\<tau>moves0 P h es \\<Longrightarrow> \\<tau>moves0 P h (Val v # es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((((\\<tau>move0 P h e \\<Longrightarrow>\n          \\<tau>move0 P h (newA T\\<lfloor>e\\<rceil>)) &&&\n         (\\<tau>move0 P h e \\<Longrightarrow>\n          \\<tau>move0 P h (Cast U e))) &&&\n        \\<tau>move0 P h (Cast U (Val v)) &&&\n        (\\<tau>move0 P h e \\<Longrightarrow>\n         \\<tau>move0 P h (e instanceof T))) &&&\n       (\\<tau>move0 P h (Val v instanceof T) &&&\n        (\\<tau>move0 P h e \\<Longrightarrow>\n         \\<tau>move0 P h (e \\<guillemotleft>bop\\<guillemotright> e'))) &&&\n       (\\<tau>move0 P h e \\<Longrightarrow>\n        \\<tau>move0 P h (Val v \\<guillemotleft>bop\\<guillemotright> e)) &&&\n       \\<tau>move0 P h\n        (Val v \\<guillemotleft>bop\\<guillemotright> Val v')) &&&\n      ((\\<tau>move0 P h (Var V) &&&\n        (\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (V:=e))) &&&\n       \\<tau>move0 P h (V:=Val v) &&&\n       (\\<tau>move0 P h e \\<Longrightarrow>\n        \\<tau>move0 P h (e\\<lfloor>e'\\<rceil>))) &&&\n      ((\\<tau>move0 P h e \\<Longrightarrow>\n        \\<tau>move0 P h (Val v\\<lfloor>e\\<rceil>)) &&&\n       (\\<tau>move0 P h e \\<Longrightarrow>\n        \\<tau>move0 P h (e\\<lfloor>e1\\<rceil> := e2))) &&&\n      (\\<tau>move0 P h e \\<Longrightarrow>\n       \\<tau>move0 P h (Val v\\<lfloor>e\\<rceil> := e')) &&&\n      (\\<tau>move0 P h e \\<Longrightarrow>\n       \\<tau>move0 P h (Val v\\<lfloor>Val v'\\<rceil> := e))) &&&\n     ((((\\<tau>move0 P h e \\<Longrightarrow>\n         \\<tau>move0 P h (e\\<bullet>length)) &&&\n        (\\<tau>move0 P h e \\<Longrightarrow>\n         \\<tau>move0 P h (e\\<bullet>F{D}))) &&&\n       (\\<tau>move0 P h e \\<Longrightarrow>\n        \\<tau>move0 P h (e\\<bullet>F{D} := e')) &&&\n       (\\<tau>move0 P h e \\<Longrightarrow>\n        \\<tau>move0 P h (Val v\\<bullet>F{D} := e))) &&&\n      ((\\<tau>move0 P h e \\<Longrightarrow>\n        \\<tau>move0 P h\n         (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e''))) &&&\n       (\\<tau>move0 P h e' \\<Longrightarrow>\n        \\<tau>move0 P h\n         (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')))) &&&\n      (\\<tau>move0 P h e'' \\<Longrightarrow>\n       \\<tau>move0 P h\n        (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e''))) &&&\n      (\\<tau>move0 P h e \\<Longrightarrow>\n       \\<tau>move0 P h (e\\<bullet>M(es)))) &&&\n     (((\\<tau>moves0 P h es \\<Longrightarrow>\n        \\<tau>move0 P h (Val v\\<bullet>M(es))) &&&\n       ((\\<And>T C Ts Tr D.\n            \\<lbrakk>typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n             class_type_of' T = \\<lfloor>C\\<rfloor>;\n             P \\<turnstile> C sees M: Ts\\<rightarrow>Tr = Native in D\\<rbrakk>\n            \\<Longrightarrow> \\<tau>external_defs D M) \\<Longrightarrow>\n        \\<tau>move0 P h (Val v\\<bullet>M(map Val vs)))) &&&\n      (\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h {V:T=vo; e}) &&&\n      \\<tau>move0 P h {V:T=vo; Val v}) &&&\n     ((\\<tau>move0 P h e \\<Longrightarrow>\n       \\<tau>move0 P h (sync\\<^bsub>V'\\<^esub> (e) e')) &&&\n      (\\<tau>move0 P h e \\<Longrightarrow>\n       \\<tau>move0 P h (insync\\<^bsub>V'\\<^esub> (a) e))) &&&\n     (\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (e;; e')) &&&\n     \\<tau>move0 P h (Val v;; e')) &&&\n    (((((\\<tau>move0 P h e \\<Longrightarrow>\n         \\<tau>move0 P h (if (e) e1 else e2)) &&&\n        \\<tau>move0 P h (if (Val v) e1 else e2)) &&&\n       \\<tau>move0 P h (while (e) e') &&&\n       (\\<tau>move0 P h e \\<Longrightarrow> \\<tau>move0 P h (throw e))) &&&\n      (\\<tau>move0 P h (throw null) &&&\n       (\\<tau>move0 P h e \\<Longrightarrow>\n        \\<tau>move0 P h (try e catch(C V) e'))) &&&\n      \\<tau>move0 P h (try Val v catch(C V) e) &&&\n      \\<tau>move0 P h (try Throw a catch(C V) e)) &&&\n     ((\\<tau>move0 P h (newA T\\<lfloor>Throw a\\<rceil>) &&&\n       \\<tau>move0 P h (Cast T (Throw a))) &&&\n      \\<tau>move0 P h (Throw a instanceof T) &&&\n      \\<tau>move0 P h (Throw a \\<guillemotleft>bop\\<guillemotright> e')) &&&\n     (\\<tau>move0 P h\n       (Val v \\<guillemotleft>bop\\<guillemotright> Throw a) &&&\n      \\<tau>move0 P h (V:=Throw a)) &&&\n     \\<tau>move0 P h (Throw a\\<lfloor>e\\<rceil>) &&&\n     \\<tau>move0 P h (Val v\\<lfloor>Throw a\\<rceil>)) &&&\n    (((\\<tau>move0 P h (Throw a\\<lfloor>e\\<rceil> := e') &&&\n       \\<tau>move0 P h (Val v\\<lfloor>Throw a\\<rceil> := e')) &&&\n      \\<tau>move0 P h (Val v\\<lfloor>Val v'\\<rceil> := Throw a) &&&\n      \\<tau>move0 P h (Throw a\\<bullet>length)) &&&\n     (\\<tau>move0 P h (Throw a\\<bullet>F{D}) &&&\n      \\<tau>move0 P h (Throw a\\<bullet>F{D} := e)) &&&\n     \\<tau>move0 P h (Val v\\<bullet>F{D} := Throw a) &&&\n     \\<tau>move0 P h (Throw a\\<bullet>M(es))) &&&\n    ((\\<tau>move0 P h (Val v\\<bullet>M(map Val vs @ Throw a # es)) &&&\n      \\<tau>move0 P h {V:T=vo; Throw a}) &&&\n     \\<tau>move0 P h (sync\\<^bsub>V'\\<^esub> (Throw a) e) &&&\n     \\<tau>move0 P h (Throw a;; e)) &&&\n    (\\<tau>move0 P h (if (Throw a) e1 else e2) &&&\n     \\<tau>move0 P h (throw (Throw a))) &&&\n    (\\<tau>move0 P h e \\<Longrightarrow> \\<tau>moves0 P h (e # es)) &&&\n    (\\<tau>moves0 P h es \\<Longrightarrow> \\<tau>moves0 P h (Val v # es))", "by auto"], ["", "lemma \\<tau>moves0_map_Val [iff]:\n  \"\\<not> \\<tau>moves0 P h (map Val vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<tau>moves0 P h (map Val vs)", "by(induct vs) auto"], ["", "lemma \\<tau>moves0_map_Val_append [simp]:\n  \"\\<tau>moves0 P h (map Val vs @ es) = \\<tau>moves0 P h es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>moves0 P h (map Val vs @ es) = \\<tau>moves0 P h es", "by(induct vs)(auto)"], ["", "lemma no_reds_map_Val_Throw [simp]:\n  \"extTA,P,t \\<turnstile> \\<langle>map Val vs @ Throw a # es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle> = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extTA,P,t \\<turnstile> \\<langle>map Val vs @ Throw a # es,\n                            s\\<rangle> [-ta\\<rightarrow>]\n                           \\<langle>es',s'\\<rangle> =\n    False", "by(induct vs arbitrary: es')(auto elim: reds.cases)"], ["", "lemma assumes [simp]: \"extTA \\<epsilon> = \\<epsilon>\"\n  shows red_\\<tau>_taD: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move0 P (hp s) e \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\"\n  and reds_\\<tau>_taD: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves0 P (hp s) es \\<rbrakk> \\<Longrightarrow> ta = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n      \\<tau>move0 P (hp s) e\\<rbrakk>\n     \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>) &&&\n    (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n      \\<tau>moves0 P (hp s) es\\<rbrakk>\n     \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>)", "apply(induct rule: red_reds.inducts)"], ["proof (prove)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<tau>move0 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a (Class_type C)\\<rbrace> =\n                         \\<lbrace>\\<rbrace>\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<tau>move0 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<tau>move0 P (hp s) e \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>;\n        \\<tau>move0 P (hp s) (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<tau>move0 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>NewHeapElem a\n                                   (Array_type T (nat (sint i)))\\<rbrace> =\n                         \\<lbrace>\\<rbrace>\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<tau>move0 P (hp s) (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<tau>move0 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<tau>move0 P (hp s) e \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>;\n        \\<tau>move0 P (hp s) (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<tau>move0 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<tau>move0 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> \\<lbrace>\\<rbrace> = \\<lbrace>\\<rbrace>\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<tau>move0 P (hp s) e \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>;\n         \\<tau>move0 P (hp s) (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> ta = \\<lbrace>\\<rbrace>\nA total of 98 subgoals...", "apply(fastforce simp add: map_eq_append_conv \\<tau>external'_def \\<tau>external_def dest: \\<tau>external'_red_external_TA_empty)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>move0_heap_unchanged: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, s\\<rangle> -ta\\<rightarrow> \\<langle>e', s'\\<rangle>; \\<tau>move0 P (hp s) e \\<rbrakk> \\<Longrightarrow> hp s' = hp s\"\n  and \\<tau>moves0_heap_unchanged: \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, s\\<rangle> [-ta\\<rightarrow>] \\<langle>es', s'\\<rangle>; \\<tau>moves0 P (hp s) es \\<rbrakk> \\<Longrightarrow> hp s' = hp s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,s\\<rangle> -ta\\<rightarrow>\n                                     \\<langle>e',s'\\<rangle>;\n      \\<tau>move0 P (hp s) e\\<rbrakk>\n     \\<Longrightarrow> hp s' = hp s) &&&\n    (\\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\ns\\<rangle> [-ta\\<rightarrow>]\n                                     \\<langle>es',s'\\<rangle>;\n      \\<tau>moves0 P (hp s) es\\<rbrakk>\n     \\<Longrightarrow> hp s' = hp s)", "apply(induct rule: red_reds.inducts)"], ["proof (prove)\ngoal (98 subgoals):\n 1. \\<And>h' a h C l.\n       \\<lbrakk>(h', a) \\<in> allocate h (Class_type C);\n        \\<tau>move0 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> hp (h', l) = hp (h, l)\n 2. \\<And>h C l.\n       \\<lbrakk>allocate h (Class_type C) = {};\n        \\<tau>move0 P (hp (h, l)) (new C)\\<rbrakk>\n       \\<Longrightarrow> hp (h, l) = hp (h, l)\n 3. \\<And>e s ta e' s' T.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<tau>move0 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n        \\<tau>move0 P (hp s) (newA T\\<lfloor>e\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp s' = hp s\n 4. \\<And>i h' a h T l.\n       \\<lbrakk>0 \\<le>s i;\n        (h', a) \\<in> allocate h (Array_type T (nat (sint i)));\n        \\<tau>move0 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp (h', l) = hp (h, l)\n 5. \\<And>i T s.\n       \\<lbrakk>i <s 0;\n        \\<tau>move0 P (hp s) (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 6. \\<And>i h T l.\n       \\<lbrakk>0 \\<le>s i; allocate h (Array_type T (nat (sint i))) = {};\n        \\<tau>move0 P (hp (h, l))\n         (newA T\\<lfloor>Val (Intg i)\\<rceil>)\\<rbrakk>\n       \\<Longrightarrow> hp (h, l) = hp (h, l)\n 7. \\<And>e s ta e' s' C.\n       \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n  s\\<rangle> -ta\\<rightarrow>\n \\<langle>e',s'\\<rangle>;\n        \\<tau>move0 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n        \\<tau>move0 P (hp s) (Cast C e)\\<rbrakk>\n       \\<Longrightarrow> hp s' = hp s\n 8. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        P \\<turnstile> U \\<le> T;\n        \\<tau>move0 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 9. \\<And>s v U T.\n       \\<lbrakk>typeof\\<^bsub>hp s\\<^esub> v = \\<lfloor>U\\<rfloor>;\n        \\<not> P \\<turnstile> U \\<le> T;\n        \\<tau>move0 P (hp s) (Cast T (Val v))\\<rbrakk>\n       \\<Longrightarrow> hp s = hp s\n 10. \\<And>e s ta e' s' T.\n        \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n   s\\<rangle> -ta\\<rightarrow>\n  \\<langle>e',s'\\<rangle>;\n         \\<tau>move0 P (hp s) e \\<Longrightarrow> hp s' = hp s;\n         \\<tau>move0 P (hp s) (e instanceof T)\\<rbrakk>\n        \\<Longrightarrow> hp s' = hp s\nA total of 98 subgoals...", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa hU M Ts T D vs ab ac ad ae af ba va h' ag ah ai aj ak bb vsa\n       am es'.\n       \\<lbrakk>typeof_addr a aa = \\<lfloor>hU\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        hU sees M: Ts\\<rightarrow>T = Native in D;\n        P,t \\<turnstile> \\<langle>aa\\<bullet>M(vs),\n                         a\\<rangle> -(ab, ac, ad, ae, af,\nba)\\<rightarrow>ext \\<langle>va,h'\\<rangle>;\n        (ag, ah, ai, aj, ak, bb) = extTA (ab, ac, ad, ae, af, ba);\n        map Val vs = map Val vsa @ Throw am # es'\\<rbrakk>\n       \\<Longrightarrow> h' = a\n 2. \\<And>a aa hU M Ts T D vs ab ac ad ae af ba va h' ag ah ai aj ak bb.\n       \\<lbrakk>typeof_addr a aa = \\<lfloor>hU\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        hU sees M: Ts\\<rightarrow>T = Native in D;\n        P,t \\<turnstile> \\<langle>aa\\<bullet>M(vs),\n                         a\\<rangle> -(ab, ac, ad, ae, af,\nba)\\<rightarrow>ext \\<langle>va,h'\\<rangle>;\n        (ag, ah, ai, aj, ak, bb) = extTA (ab, ac, ad, ae, af, ba);\n        \\<forall>Ts Tr D.\n           P \\<turnstile> class_type_of\n                           hU sees M: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n           \\<tau>external_defs D M\\<rbrakk>\n       \\<Longrightarrow> h' = a", "apply(fastforce simp add: map_eq_append_conv \\<tau>external'_def \\<tau>external_def dest: \\<tau>external'_red_external_heap_unchanged)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Move0_iff:\n  \"\\<tau>Move0 P h ees \\<longleftrightarrow> (let (e, _) = ees in \\<tau>move0 P h e \\<or> final e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Move0 P h ees =\n    (let (e, uu_) = ees in \\<tau>move0 P h e \\<or> final e)", "by(cases ees)(simp)"], ["", "lemma no_call_simps [simp]:\n  \"no_call P h (new C) = True\"\n  \"no_call P h (newA T\\<lfloor>e\\<rceil>) = no_call P h e\"\n  \"no_call P h (Cast T e) = no_call P h e\"\n  \"no_call P h (e instanceof T) = no_call P h e\"\n  \"no_call P h (Val v) = True\"\n  \"no_call P h (Var V) = True\"\n  \"no_call P h (V := e) = no_call P h e\"\n  \"no_call P h (e \\<guillemotleft>bop\\<guillemotright> e') = (if is_val e then no_call P h e' else no_call P h e)\"\n  \"no_call P h (a\\<lfloor>i\\<rceil>) = (if is_val a then no_call P h i else no_call P h a)\"\n  \"no_call P h (AAss a i e) = (if is_val a then (if is_val i then no_call P h e else no_call P h i) else no_call P h a)\"\n  \"no_call P h (a\\<bullet>length) = no_call P h a\"\n  \"no_call P h (e\\<bullet>F{D}) = no_call P h e\"\n  \"no_call P h (FAss e F D e') = (if is_val e then no_call P h e' else no_call P h e)\"\n  \"no_call P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) = (if is_val e then (if is_val e' then no_call P h e'' else no_call P h e') else no_call P h e)\"\n  \"no_call P h (e\\<bullet>M(es)) = (if is_val e then (if is_vals es \\<and> is_addr e then synthesized_call P h (THE a. e = addr a, M, THE vs. es = map Val vs) else no_calls P h es) else no_call P h e)\"\n  \"no_call P h ({V:T=vo; e}) = no_call P h e\"\n  \"no_call P h (sync\\<^bsub>V'\\<^esub> (e) e') = no_call P h e\"\n  \"no_call P h (insync\\<^bsub>V'\\<^esub> (ad) e) = no_call P h e\"\n  \"no_call P h (e;;e') = no_call P h e\"\n  \"no_call P h (if (e) e1 else e2) = no_call P h e\"\n  \"no_call P h (while(e) e') = True\"\n  \"no_call P h (throw e) = no_call P h e\"\n  \"no_call P h (try e catch(C V) e') = no_call P h e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((no_call P h (new C) = True &&&\n       no_call P h (newA T\\<lfloor>e\\<rceil>) = no_call P h e) &&&\n      no_call P h (Cast T e) = no_call P h e &&&\n      no_call P h (e instanceof T) = no_call P h e &&&\n      no_call P h (Val v) = True) &&&\n     (no_call P h (Var V) = True &&&\n      no_call P h (V:=e) = no_call P h e &&&\n      no_call P h (e \\<guillemotleft>bop\\<guillemotright> e') =\n      (if is_val e then no_call P h e' else no_call P h e)) &&&\n     no_call P h (a\\<lfloor>i\\<rceil>) =\n     (if is_val a then no_call P h i else no_call P h a) &&&\n     no_call P h (a\\<lfloor>i\\<rceil> := e) =\n     (if is_val a then if is_val i then no_call P h e else no_call P h i\n      else no_call P h a) &&&\n     no_call P h (a\\<bullet>length) = no_call P h a) &&&\n    ((no_call P h (e\\<bullet>F{D}) = no_call P h e &&&\n      no_call P h (e\\<bullet>F{D} := e') =\n      (if is_val e then no_call P h e' else no_call P h e) &&&\n      no_call P h (e\\<bullet>compareAndSwap(D\\<bullet>F, e', e'')) =\n      (if is_val e\n       then if is_val e' then no_call P h e'' else no_call P h e'\n       else no_call P h e)) &&&\n     no_call P h (e\\<bullet>M(es)) =\n     (if is_val e\n      then if is_vals es \\<and> is_addr e\n           then synthesized_call P h\n                 (THE a. e = addr a, M, THE vs. es = map Val vs)\n           else no_calls P h es\n      else no_call P h e) &&&\n     no_call P h {V:T=vo; e} = no_call P h e &&&\n     no_call P h (sync\\<^bsub>V'\\<^esub> (e) e') = no_call P h e) &&&\n    (no_call P h (insync\\<^bsub>V'\\<^esub> (ad) e) = no_call P h e &&&\n     no_call P h (e;; e') = no_call P h e &&&\n     no_call P h (if (e) e1 else e2) = no_call P h e) &&&\n    no_call P h (while (e) e') = True &&&\n    no_call P h (throw e) = no_call P h e &&&\n    no_call P h (try e catch(C V) e') = no_call P h e", "by(auto simp add: no_call_def no_calls_def)"], ["", "lemma no_calls_simps [simp]:\n  \"no_calls P h [] = True\"\n  \"no_calls P h (e # es) = (if is_val e then no_calls P h es else no_call P h e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_calls P h [] = True &&&\n    no_calls P h (e # es) =\n    (if is_val e then no_calls P h es else no_call P h e)", "by(simp_all add: no_call_def no_calls_def)"], ["", "lemma no_calls_map_Val [simp]:\n  \"no_calls P h (map Val vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_calls P h (map Val vs)", "by(induct vs) simp_all"], ["", "lemma assumes nfin: \"\\<not> final e'\"\n shows inline_call_\\<tau>move0_inv: \"call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<tau>move0 P h (inline_call e' e) = \\<tau>move0 P h e'\"\n  and inline_calls_\\<tau>moves0_inv: \"calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow> \\<tau>moves0 P h (inline_calls e' es) = \\<tau>move0 P h e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (call e = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     \\<tau>move0 P h (inline_call e' e) = \\<tau>move0 P h e') &&&\n    (calls es = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n     \\<tau>moves0 P h (inline_calls e' es) = \\<tau>move0 P h e')", "apply(induct e and es rule: \\<tau>move0.induct \\<tau>moves0.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<tau>move0 P h (inline_call e' (new x)) = \\<tau>move0 P h e'\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (inline_call e' (newA x1\\<lfloor>x2\\<rceil>)) =\n                         \\<tau>move0 P h e'\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (inline_call e' (Cast x1 x2)) =\n                         \\<tau>move0 P h e'\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (inline_call e' (x1 instanceof x2)) =\n                         \\<tau>move0 P h e'\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<tau>move0 P h (inline_call e' (Val x)) = \\<tau>move0 P h e'\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h (inline_call e' x3) = \\<tau>move0 P h e';\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3)) =\n                         \\<tau>move0 P h e'\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n       \\<tau>move0 P h (inline_call e' (Var x)) = \\<tau>move0 P h e'\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (inline_call e' (x1:=x2)) =\n                         \\<tau>move0 P h e'\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (inline_call e' (x1\\<lfloor>x2\\<rceil>)) =\n                         \\<tau>move0 P h e'\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<tau>move0 P h (inline_call e' x3) = \\<tau>move0 P h e';\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>aMvs\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move0 P h\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) =\n                          \\<tau>move0 P h e'\nA total of 25 subgoals...", "apply(insert nfin)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>call (new x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (inline_call e' (new x)) =\n                         \\<tau>move0 P h e'\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call (newA x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (inline_call e' (newA x1\\<lfloor>x2\\<rceil>)) =\n                         \\<tau>move0 P h e'\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call (Cast x1 x2) = \\<lfloor>aMvs\\<rfloor>; \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (inline_call e' (Cast x1 x2)) =\n                         \\<tau>move0 P h e'\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call (x1 instanceof x2) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (inline_call e' (x1 instanceof x2)) =\n                         \\<tau>move0 P h e'\n 5. \\<And>x.\n       \\<lbrakk>call (Val x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (inline_call e' (Val x)) =\n                         \\<tau>move0 P h e'\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h (inline_call e' x3) = \\<tau>move0 P h e';\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (inline_call e'\n                            (x1 \\<guillemotleft>x2\\<guillemotright> x3)) =\n                         \\<tau>move0 P h e'\n 7. \\<And>x.\n       \\<lbrakk>call (Var x) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (inline_call e' (Var x)) =\n                         \\<tau>move0 P h e'\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call (x1:=x2) = \\<lfloor>aMvs\\<rfloor>; \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (inline_call e' (x1:=x2)) =\n                         \\<tau>move0 P h e'\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (inline_call e' (x1\\<lfloor>x2\\<rceil>)) =\n                         \\<tau>move0 P h e'\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n         call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n         call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<tau>move0 P h (inline_call e' x3) = \\<tau>move0 P h e';\n         call (x1\\<lfloor>x2\\<rceil> := x3) = \\<lfloor>aMvs\\<rfloor>;\n         \\<not> final e'\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move0 P h\n                           (inline_call e' (x1\\<lfloor>x2\\<rceil> := x3)) =\n                          \\<tau>move0 P h e'\nA total of 25 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call x2 = \\<lfloor>aMvs\\<rfloor>; \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>move0 P h e' \\<or>\n                          (\\<exists>a. inline_call e' x2 = Throw a)) =\n                         \\<tau>move0 P h e'\n 2. \\<And>x2.\n       \\<lbrakk>\\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call x2 = \\<lfloor>aMvs\\<rfloor>; \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>move0 P h e' \\<or>\n                          (\\<exists>a. inline_call e' x2 = Throw a) \\<or>\n                          (\\<exists>v. inline_call e' x2 = Val v)) =\n                         \\<tau>move0 P h e'\n 3. \\<And>x1.\n       \\<lbrakk>\\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x1 = \\<lfloor>aMvs\\<rfloor>; \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>move0 P h e' \\<or>\n                          (\\<exists>a. inline_call e' x1 = Throw a) \\<or>\n                          (\\<exists>v. inline_call e' x1 = Val v)) =\n                         \\<tau>move0 P h e'\n 4. \\<And>x1 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h (inline_call e' x3) = \\<tau>move0 P h e';\n        (if is_val x1 then call x3 else call x1) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (is_val x1 \\<longrightarrow>\n                          (\\<tau>move0 P h x1 \\<or>\n                           (\\<exists>a. x1 = Throw a) \\<or>\n                           (\\<exists>v. x1 = Val v) \\<and>\n                           (\\<tau>move0 P h (inline_call e' x3) \\<or>\n                            (\\<exists>a. inline_call e' x3 = Throw a) \\<or>\n                            (\\<exists>v. inline_call e' x3 = Val v))) =\n                          \\<tau>move0 P h e') \\<and>\n                         (\\<not> is_val x1 \\<longrightarrow>\n                          (\\<tau>move0 P h (inline_call e' x1) \\<or>\n                           (\\<exists>a. inline_call e' x1 = Throw a) \\<or>\n                           (\\<exists>v. inline_call e' x1 = Val v) \\<and>\n                           (\\<tau>move0 P h x3 \\<or>\n                            (\\<exists>a. x3 = Throw a) \\<or>\n                            (\\<exists>v. x3 = Val v))) =\n                          \\<tau>move0 P h e')\n 5. \\<And>x2.\n       \\<lbrakk>\\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call x2 = \\<lfloor>aMvs\\<rfloor>; \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>move0 P h e' \\<or>\n                          (\\<exists>a. inline_call e' x2 = Throw a) \\<or>\n                          (\\<exists>v. inline_call e' x2 = Val v)) =\n                         \\<tau>move0 P h e'\n 6. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        (if is_val x1 then call x2 else call x1) = \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (is_val x1 \\<longrightarrow>\n                          (\\<tau>move0 P h x1 \\<or>\n                           (\\<exists>ad. x1 = Throw ad) \\<or>\n                           (\\<exists>v. x1 = Val v) \\<and>\n                           (\\<tau>move0 P h (inline_call e' x2) \\<or>\n                            (\\<exists>a. inline_call e' x2 = Throw a))) =\n                          \\<tau>move0 P h e') \\<and>\n                         (\\<not> is_val x1 \\<longrightarrow>\n                          (\\<tau>move0 P h (inline_call e' x1) \\<or>\n                           (\\<exists>ad. inline_call e' x1 = Throw ad) \\<or>\n                           (\\<exists>v. inline_call e' x1 = Val v) \\<and>\n                           (\\<tau>move0 P h x2 \\<or>\n                            (\\<exists>a. x2 = Throw a))) =\n                          \\<tau>move0 P h e')\n 7. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x2 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h (inline_call e' x2) = \\<tau>move0 P h e';\n        call x3 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h (inline_call e' x3) = \\<tau>move0 P h e';\n        (if is_val x1 then if is_val x2 then call x3 else call x2\n         else call x1) =\n        \\<lfloor>aMvs\\<rfloor>;\n        \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (is_val x2 \\<longrightarrow>\n                          (is_val x1 \\<longrightarrow>\n                           (\\<tau>move0 P h x1 \\<or>\n                            (\\<exists>ad. x1 = Throw ad) \\<or>\n                            (\\<exists>v. x1 = Val v) \\<and>\n                            (\\<tau>move0 P h x2 \\<or>\n                             (\\<exists>a. x2 = Throw a) \\<or>\n                             (\\<exists>v. x2 = Val v) \\<and>\n                             (\\<tau>move0 P h (inline_call e' x3) \\<or>\n                              (\\<exists>a. inline_call e' x3 = Throw a)))) =\n                           \\<tau>move0 P h e') \\<and>\n                          (\\<not> is_val x1 \\<longrightarrow>\n                           (\\<tau>move0 P h (inline_call e' x1) \\<or>\n                            (\\<exists>ad.\n                                inline_call e' x1 = Throw ad) \\<or>\n                            (\\<exists>v. inline_call e' x1 = Val v) \\<and>\n                            (\\<tau>move0 P h x2 \\<or>\n                             (\\<exists>a. x2 = Throw a) \\<or>\n                             (\\<exists>v. x2 = Val v) \\<and>\n                             (\\<tau>move0 P h x3 \\<or>\n                              (\\<exists>a. x3 = Throw a)))) =\n                           \\<tau>move0 P h e')) \\<and>\n                         (\\<not> is_val x2 \\<longrightarrow>\n                          (is_val x1 \\<longrightarrow>\n                           (\\<tau>move0 P h x1 \\<or>\n                            (\\<exists>ad. x1 = Throw ad) \\<or>\n                            (\\<exists>v. x1 = Val v) \\<and>\n                            (\\<tau>move0 P h (inline_call e' x2) \\<or>\n                             (\\<exists>a. inline_call e' x2 = Throw a) \\<or>\n                             (\\<exists>v. inline_call e' x2 = Val v) \\<and>\n                             (\\<tau>move0 P h x3 \\<or>\n                              (\\<exists>a. x3 = Throw a)))) =\n                           \\<tau>move0 P h e') \\<and>\n                          (\\<not> is_val x1 \\<longrightarrow>\n                           (\\<tau>move0 P h (inline_call e' x1) \\<or>\n                            (\\<exists>ad.\n                                inline_call e' x1 = Throw ad) \\<or>\n                            (\\<exists>v. inline_call e' x1 = Val v) \\<and>\n                            (\\<tau>move0 P h x2 \\<or>\n                             (\\<exists>a. x2 = Throw a) \\<or>\n                             (\\<exists>v. x2 = Val v) \\<and>\n                             (\\<tau>move0 P h x3 \\<or>\n                              (\\<exists>a. x3 = Throw a)))) =\n                           \\<tau>move0 P h e'))\n 8. \\<And>x.\n       \\<lbrakk>\\<tau>move0 P h (inline_call e' x) = \\<tau>move0 P h e';\n        call x = \\<lfloor>aMvs\\<rfloor>; \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>move0 P h e' \\<or>\n                          (\\<exists>ad. inline_call e' x = Throw ad)) =\n                         \\<tau>move0 P h e'\n 9. \\<And>x1.\n       \\<lbrakk>\\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n        call x1 = \\<lfloor>aMvs\\<rfloor>; \\<not> final e'\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>move0 P h e' \\<or>\n                          (\\<exists>a. inline_call e' x1 = Throw a)) =\n                         \\<tau>move0 P h e'\n 10. \\<And>x1 x4.\n        \\<lbrakk>call x1 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n                 \\<tau>move0 P h (inline_call e' x1) = \\<tau>move0 P h e';\n         call x4 = \\<lfloor>aMvs\\<rfloor> \\<Longrightarrow>\n         \\<tau>move0 P h (inline_call e' x4) = \\<tau>move0 P h e';\n         (if is_val x1 then call x4 else call x1) = \\<lfloor>aMvs\\<rfloor>;\n         \\<not> final e'\\<rbrakk>\n        \\<Longrightarrow> (is_val x1 \\<longrightarrow>\n                           (\\<tau>move0 P h x1 \\<or>\n                            (\\<exists>a. x1 = Throw a) \\<or>\n                            (\\<exists>v. x1 = Val v) \\<and>\n                            (\\<tau>move0 P h (inline_call e' x4) \\<or>\n                             (\\<exists>a. inline_call e' x4 = Throw a))) =\n                           \\<tau>move0 P h e') \\<and>\n                          (\\<not> is_val x1 \\<longrightarrow>\n                           (\\<tau>move0 P h (inline_call e' x1) \\<or>\n                            (\\<exists>a. inline_call e' x1 = Throw a) \\<or>\n                            (\\<exists>v. inline_call e' x1 = Val v) \\<and>\n                            (\\<tau>move0 P h x4 \\<or>\n                             (\\<exists>a. x4 = Throw a))) =\n                           \\<tau>move0 P h e')\nA total of 19 subgoals...", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>red0_iff [iff]:\n  \"\\<tau>red0 extTA P t h (e, xs) (e', xs') = (extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle> \\<and> \\<tau>move0 P h e \\<and> no_call P h e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0 extTA P t h (e, xs) (e', xs') =\n    (extTA,P,t \\<turnstile> \\<langle>e,\n                             (h, xs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                            \\<langle>e',(h, xs')\\<rangle> \\<and>\n     \\<tau>move0 P h e \\<and> no_call P h e)", "by(simp add: \\<tau>red0_def)"], ["", "lemma \\<tau>reds0_iff [iff]:\n  \"\\<tau>reds0 extTA P t h (es, xs) (es', xs') =\n  (extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle> \\<and> \\<tau>moves0 P h es \\<and> no_calls P h es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds0 extTA P t h (es, xs) (es', xs') =\n    (extTA,P,t \\<turnstile> \\<langle>es,\n                             (h, xs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                            \\<langle>es',(h, xs')\\<rangle> \\<and>\n     \\<tau>moves0 P h es \\<and> no_calls P h es)", "by(simp add: \\<tau>reds0_def)"], ["", "lemma \\<tau>red0t_1step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n                                     (h,\nxs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                    \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move0 P h e; no_call P h e\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e', xs')", "by(blast intro: tranclp.r_into_trancl)"], ["", "lemma \\<tau>red0t_2step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e;\n     extTA,P,t \\<turnstile> \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move0 P h e'; no_call P h e' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n                                     (h,\nxs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                    \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move0 P h e; no_call P h e;\n     extTA,P,t \\<turnstile> \\<langle>e',\n                             (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                            \\<langle>e'',(h, xs'')\\<rangle>;\n     \\<tau>move0 P h e'; no_call P h e'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e'', xs'')", "by(blast intro: tranclp.trancl_into_trancl[OF \\<tau>red0t_1step])"], ["", "lemma \\<tau>red1t_3step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e; \n     extTA,P,t \\<turnstile> \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move0 P h e'; no_call P h e';\n     extTA,P,t \\<turnstile> \\<langle>e'', (h, xs'')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e''', (h, xs''')\\<rangle>; \\<tau>move0 P h e''; no_call P h e'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e''', xs''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n                                     (h,\nxs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                    \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move0 P h e; no_call P h e;\n     extTA,P,t \\<turnstile> \\<langle>e',\n                             (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                            \\<langle>e'',(h, xs'')\\<rangle>;\n     \\<tau>move0 P h e'; no_call P h e';\n     extTA,P,t \\<turnstile> \\<langle>e'',\n                             (h, xs'')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                            \\<langle>e''',(h, xs''')\\<rangle>;\n     \\<tau>move0 P h e''; no_call P h e''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red0t extTA P t h (e, xs) (e''', xs''')", "by(blast intro: tranclp.trancl_into_trancl[OF \\<tau>red0t_2step])"], ["", "lemma \\<tau>reds0t_1step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\n                                     (h,\nxs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                    \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves0 P h es; no_calls P h es\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es', xs')", "by(blast intro: tranclp.r_into_trancl)"], ["", "lemma \\<tau>reds0t_2step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es; \n     extTA,P,t \\<turnstile> \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves0 P h es'; no_calls P h es' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\n                                     (h,\nxs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                    \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves0 P h es; no_calls P h es;\n     extTA,P,t \\<turnstile> \\<langle>es',\n                             (h, xs')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                            \\<langle>es'',(h, xs'')\\<rangle>;\n     \\<tau>moves0 P h es'; no_calls P h es'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es'', xs'')", "by(blast intro: tranclp.trancl_into_trancl[OF \\<tau>reds0t_1step])"], ["", "lemma \\<tau>reds0t_3step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es; \n     extTA,P,t \\<turnstile> \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves0 P h es'; no_calls P h es';\n     extTA,P,t \\<turnstile> \\<langle>es'', (h, xs'')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es''', (h, xs''')\\<rangle>; \\<tau>moves0 P h es''; no_calls P h es'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es''', xs''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\n                                     (h,\nxs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                    \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves0 P h es; no_calls P h es;\n     extTA,P,t \\<turnstile> \\<langle>es',\n                             (h, xs')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                            \\<langle>es'',(h, xs'')\\<rangle>;\n     \\<tau>moves0 P h es'; no_calls P h es';\n     extTA,P,t \\<turnstile> \\<langle>es'',\n                             (h, xs'')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                            \\<langle>es''',(h, xs''')\\<rangle>;\n     \\<tau>moves0 P h es''; no_calls P h es''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds0t extTA P t h (es, xs) (es''', xs''')", "by(blast intro: tranclp.trancl_into_trancl[OF \\<tau>reds0t_2step])"], ["", "lemma \\<tau>red0r_1step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n                                     (h,\nxs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                    \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move0 P h e; no_call P h e\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e', xs')", "by(blast intro: r_into_rtranclp)"], ["", "lemma \\<tau>red0r_2step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e;\n     extTA,P,t \\<turnstile> \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move0 P h e'; no_call P h e' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n                                     (h,\nxs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                    \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move0 P h e; no_call P h e;\n     extTA,P,t \\<turnstile> \\<langle>e',\n                             (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                            \\<langle>e'',(h, xs'')\\<rangle>;\n     \\<tau>move0 P h e'; no_call P h e'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e'', xs'')", "by(blast intro: rtranclp.rtrancl_into_rtrancl[OF \\<tau>red0r_1step])"], ["", "lemma \\<tau>red0r_3step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>e, (h, xs)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>; \\<tau>move0 P h e; no_call P h e; \n     extTA,P,t \\<turnstile> \\<langle>e', (h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'', (h, xs'')\\<rangle>; \\<tau>move0 P h e'; no_call P h e';\n     extTA,P,t \\<turnstile> \\<langle>e'', (h, xs'')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e''', (h, xs''')\\<rangle>; \\<tau>move0 P h e''; no_call P h e'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e''', xs''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>e,\n                                     (h,\nxs)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                                    \\<langle>e',(h, xs')\\<rangle>;\n     \\<tau>move0 P h e; no_call P h e;\n     extTA,P,t \\<turnstile> \\<langle>e',\n                             (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                            \\<langle>e'',(h, xs'')\\<rangle>;\n     \\<tau>move0 P h e'; no_call P h e';\n     extTA,P,t \\<turnstile> \\<langle>e'',\n                             (h, xs'')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                            \\<langle>e''',(h, xs''')\\<rangle>;\n     \\<tau>move0 P h e''; no_call P h e''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>red0r extTA P t h (e, xs) (e''', xs''')", "by(blast intro: rtranclp.rtrancl_into_rtrancl[OF \\<tau>red0r_2step])"], ["", "lemma \\<tau>reds0r_1step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\n                                     (h,\nxs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                    \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves0 P h es; no_calls P h es\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es', xs')", "by(blast intro: r_into_rtranclp)"], ["", "lemma \\<tau>reds0r_2step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es; \n     extTA,P,t \\<turnstile> \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves0 P h es'; no_calls P h es' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es'', xs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\n                                     (h,\nxs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                    \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves0 P h es; no_calls P h es;\n     extTA,P,t \\<turnstile> \\<langle>es',\n                             (h, xs')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                            \\<langle>es'',(h, xs'')\\<rangle>;\n     \\<tau>moves0 P h es'; no_calls P h es'\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es'', xs'')", "by(blast intro: rtranclp.rtrancl_into_rtrancl[OF \\<tau>reds0r_1step])"], ["", "lemma \\<tau>reds0r_3step:\n  \"\\<lbrakk> extTA,P,t \\<turnstile> \\<langle>es, (h, xs)\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es', (h, xs')\\<rangle>; \\<tau>moves0 P h es; no_calls P h es; \n     extTA,P,t \\<turnstile> \\<langle>es', (h, xs')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es'', (h, xs'')\\<rangle>; \\<tau>moves0 P h es'; no_calls P h es';\n     extTA,P,t \\<turnstile> \\<langle>es'', (h, xs'')\\<rangle> [-\\<epsilon>\\<rightarrow>] \\<langle>es''', (h, xs''')\\<rangle>; \\<tau>moves0 P h es''; no_calls P h es'' \\<rbrakk>\n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es''', xs''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extTA,P,t \\<turnstile> \\<langle>es,\n                                     (h,\nxs)\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                                    \\<langle>es',(h, xs')\\<rangle>;\n     \\<tau>moves0 P h es; no_calls P h es;\n     extTA,P,t \\<turnstile> \\<langle>es',\n                             (h, xs')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                            \\<langle>es'',(h, xs'')\\<rangle>;\n     \\<tau>moves0 P h es'; no_calls P h es';\n     extTA,P,t \\<turnstile> \\<langle>es'',\n                             (h, xs'')\\<rangle> [-\\<lbrace>\\<rbrace>\\<rightarrow>]\n                            \\<langle>es''',(h, xs''')\\<rangle>;\n     \\<tau>moves0 P h es''; no_calls P h es''\\<rbrakk>\n    \\<Longrightarrow> \\<tau>reds0r extTA P t h (es, xs) (es''', xs''')", "by(blast intro: rtranclp.rtrancl_into_rtrancl[OF \\<tau>reds0r_2step])"], ["", "lemma \\<tau>red0t_inj_\\<tau>reds0t:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs')\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (e # es, xs) (e' # es, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>reds0t extTA P t h (e # es, xs) (e' # es, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl ListRed1)"], ["", "lemma \\<tau>reds0t_cons_\\<tau>reds0t:\n  \"\\<tau>reds0t extTA P t h (es, xs) (es', xs')\n  \\<Longrightarrow> \\<tau>reds0t extTA P t h (Val v # es, xs) (Val v # es', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds0t extTA P t h (es, xs) (es', xs') \\<Longrightarrow>\n    \\<tau>reds0t extTA P t h (Val v # es, xs) (Val v # es', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl ListRed2)"], ["", "lemma \\<tau>red0r_inj_\\<tau>reds0r:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs')\n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (e # es, xs) (e' # es, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>reds0r extTA P t h (e # es, xs) (e' # es, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl ListRed1)"], ["", "lemma \\<tau>reds0r_cons_\\<tau>reds0r:\n  \"\\<tau>reds0r extTA P t h (es, xs) (es', xs') \n  \\<Longrightarrow> \\<tau>reds0r extTA P t h (Val v # es, xs) (Val v # es', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds0r extTA P t h (es, xs) (es', xs') \\<Longrightarrow>\n    \\<tau>reds0r extTA P t h (Val v # es, xs) (Val v # es', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl ListRed2)"], ["", "lemma NewArray_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs')\n  \\<Longrightarrow> \\<tau>red0t extTA P t h (newA T\\<lfloor>e\\<rceil>, xs) (newA T\\<lfloor>e'\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (newA T\\<lfloor>e\\<rceil>, xs)\n     (newA T\\<lfloor>e'\\<rceil>, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl NewArrayRed)"], ["", "lemma Cast_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Cast T e, xs) (Cast T e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (Cast T e, xs) (Cast T e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CastRed)"], ["", "lemma InstanceOf_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e instanceof T, xs) (e' instanceof T, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (e instanceof T, xs) (e' instanceof T, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl InstanceOfRed)"], ["", "lemma BinOp_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (e1, xs) (e1', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs) (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e1, xs) (e1', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs)\n     (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl BinOpRed1)"], ["", "lemma BinOp_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (e2, xs) (e2', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs) (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e2, xs) (e2', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h\n     (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs)\n     (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl BinOpRed2)"], ["", "lemma LAss_\\<tau>red0t:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (V := e, xs) (V := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (V:=e, xs) (V:=e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl LAssRed)"], ["", "lemma AAcc_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (a\\<lfloor>i\\<rceil>, xs) (a'\\<lfloor>i\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (a\\<lfloor>i\\<rceil>, xs)\n     (a'\\<lfloor>i\\<rceil>, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAccRed1)"], ["", "lemma AAcc_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val a\\<lfloor>i\\<rceil>, xs) (Val a\\<lfloor>i'\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (i, xs) (i', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (Val a\\<lfloor>i\\<rceil>, xs)\n     (Val a\\<lfloor>i'\\<rceil>, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAccRed2)"], ["", "lemma AAss_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (a\\<lfloor>i\\<rceil> := e, xs) (a'\\<lfloor>i\\<rceil> := e, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (a\\<lfloor>i\\<rceil> := e, xs)\n     (a'\\<lfloor>i\\<rceil> := e, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAssRed1)"], ["", "lemma AAss_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val a\\<lfloor>i\\<rceil> := e, xs) (Val a\\<lfloor>i'\\<rceil> := e, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (i, xs) (i', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (Val a\\<lfloor>i\\<rceil> := e, xs)\n     (Val a\\<lfloor>i'\\<rceil> := e, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAssRed2)"], ["", "lemma AAss_\\<tau>red0t_xt3:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs) (Val a\\<lfloor>Val i\\<rceil> := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs)\n     (Val a\\<lfloor>Val i\\<rceil> := e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl AAssRed3)"], ["", "lemma ALength_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl ALengthRed)"], ["", "lemma FAcc_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl FAccRed)"], ["", "lemma FAss_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e\\<bullet>F{D} := e2, xs) (e'\\<bullet>F{D} := e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (e\\<bullet>F{D} := e2, xs)\n     (e'\\<bullet>F{D} := e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl FAssRed1)"], ["", "lemma FAss_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v\\<bullet>F{D} := e, xs) (Val v\\<bullet>F{D} := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (Val v\\<bullet>F{D} := e, xs)\n     (Val v\\<bullet>F{D} := e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl FAssRed2)"], ["", "lemma CAS_\\<tau>red0t_xt1:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs) (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h\n     (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs)\n     (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CASRed1)"], ["", "lemma CAS_\\<tau>red0t_xt2:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs)\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CASRed2)"], ["", "lemma CAS_\\<tau>red0t_xt3:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs)\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CASRed3)"], ["", "lemma Call_\\<tau>red0t_obj:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CallObj)"], ["", "lemma Call_\\<tau>red0t_param:\n  \"\\<tau>reds0t extTA P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v\\<bullet>M(es), xs) (Val v\\<bullet>M(es'), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds0t extTA P t h (es, xs) (es', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (Val v\\<bullet>M(es), xs)\n     (Val v\\<bullet>M(es'), xs')", "by(induct rule: tranclp_induct2)(fastforce intro: tranclp.trancl_into_trancl CallParams)+"], ["", "lemma Block_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs(V := vo)) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs) ({V:T=xs' V; e'}, xs'(V := xs V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs(V := vo)) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n     ({V:T=xs' V; e'}, xs'(V := xs V))", "proof(induct rule: tranclp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<tau>red0 extTA P t h (e, xs(V := vo)) (a, b) \\<Longrightarrow>\n       \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n        ({V:T=b V; a}, b(V := xs V))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0t extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "case base"], ["proof (state)\nthis:\n  \\<tau>red0 extTA P t h (e, xs(V := vo)) (a_, b_)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<tau>red0 extTA P t h (e, xs(V := vo)) (a, b) \\<Longrightarrow>\n       \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n        ({V:T=b V; a}, b(V := xs V))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0t extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<tau>red0 extTA P t h (e, xs(V := vo)) (a_, b_)\n\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n     ({V:T=b_ V; a_}, b_(V := xs V))", "by(auto intro: BlockRed simp del: fun_upd_apply)"], ["proof (state)\nthis:\n  \\<tau>red0t extTA P t h ({V:T=vo; e}, xs) ({V:T=b_ V; a_}, b_(V := xs V))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0t extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0t extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "case (step e' xs' e'' xs'')"], ["proof (state)\nthis:\n  \\<tau>red0t extTA P t h (e, xs(V := vo)) (e', xs')\n  \\<tau>red0 extTA P t h (e', xs') (e'', xs'')\n  \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=xs' V; e'}, xs'(V := xs V))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0t extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "from \\<open>\\<tau>red0 extTA P t h (e', xs') (e'', xs'')\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>red0 extTA P t h (e', xs') (e'', xs'')", "have \"extTA,P,t \\<turnstile> \\<langle>e',(h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'',(h, xs'')\\<rangle>\" \"\\<tau>move0 P h e'\" \"no_call P h e'\""], ["proof (prove)\nusing this:\n  \\<tau>red0 extTA P t h (e', xs') (e'', xs'')\n\ngoal (1 subgoal):\n 1. extTA,P,t \\<turnstile> \\<langle>e',\n                            (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                           \\<langle>e'',(h, xs'')\\<rangle> &&&\n    \\<tau>move0 P h e' &&& no_call P h e'", "by auto"], ["proof (state)\nthis:\n  extTA,P,t \\<turnstile> \\<langle>e',\n                          (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>e'',(h, xs'')\\<rangle>\n  \\<tau>move0 P h e'\n  no_call P h e'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0t extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "hence \"extTA,P,t \\<turnstile> \\<langle>e',(h, xs'(V := xs V, V := xs' V))\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'',(h, xs'')\\<rangle>\""], ["proof (prove)\nusing this:\n  extTA,P,t \\<turnstile> \\<langle>e',\n                          (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>e'',(h, xs'')\\<rangle>\n  \\<tau>move0 P h e'\n  no_call P h e'\n\ngoal (1 subgoal):\n 1. extTA,P,t \\<turnstile> \\<langle>e',\n                            (h, xs'\n                             (V := xs V,\n                              V := xs' V))\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                           \\<langle>e'',(h, xs'')\\<rangle>", "by simp"], ["proof (state)\nthis:\n  extTA,P,t \\<turnstile> \\<langle>e',\n                          (h, xs'\n                           (V := xs V,\n                            V := xs' V))\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>e'',(h, xs'')\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0t extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "from BlockRed[OF this, of T] \\<open>\\<tau>move0 P h e'\\<close> \\<open>no_call P h e'\\<close>"], ["proof (chain)\npicking this:\n  extTA,P,t \\<turnstile> \\<langle>{V:T=xs' V; e'},\n                          (h, xs'\n                           (V := xs V))\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>{V:T=xs'' V; e''},\n                          (h, xs''(V := (xs'(V := xs V)) V))\\<rangle>\n  \\<tau>move0 P h e'\n  no_call P h e'", "have \"\\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V)) ({V:T=xs'' V; e''}, xs''(V := xs V))\""], ["proof (prove)\nusing this:\n  extTA,P,t \\<turnstile> \\<langle>{V:T=xs' V; e'},\n                          (h, xs'\n                           (V := xs V))\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>{V:T=xs'' V; e''},\n                          (h, xs''(V := (xs'(V := xs V)) V))\\<rangle>\n  \\<tau>move0 P h e'\n  no_call P h e'\n\ngoal (1 subgoal):\n 1. \\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V))\n     ({V:T=xs'' V; e''}, xs''(V := xs V))", "by(auto)"], ["proof (state)\nthis:\n  \\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V))\n   ({V:T=xs'' V; e''}, xs''(V := xs V))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0t extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "with \\<open>\\<tau>red0t extTA P t h ({V:T=vo; e}, xs) ({V:T=xs' V; e'}, xs'(V := xs V))\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=xs' V; e'}, xs'(V := xs V))\n  \\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V))\n   ({V:T=xs'' V; e''}, xs''(V := xs V))", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=xs' V; e'}, xs'(V := xs V))\n  \\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V))\n   ({V:T=xs'' V; e''}, xs''(V := xs V))\n\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n     ({V:T=xs'' V; e''}, xs''(V := xs V))", ".."], ["proof (state)\nthis:\n  \\<tau>red0t extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=xs'' V; e''}, xs''(V := xs V))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sync_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs) (sync\\<^bsub>V\\<^esub> (e') e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs)\n     (sync\\<^bsub>V\\<^esub> (e') e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl SynchronizedRed1)"], ["", "lemma InSync_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (insync\\<^bsub>V\\<^esub> (a) e, xs) (insync\\<^bsub>V\\<^esub> (a) e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (insync\\<^bsub>V\\<^esub> (a) e, xs)\n     (insync\\<^bsub>V\\<^esub> (a) e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl SynchronizedRed2)"], ["", "lemma Seq_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (e;;e2, xs) (e';;e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (e;; e2, xs) (e';; e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl SeqRed)"], ["", "lemma Cond_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (if (e) e1 else e2, xs)\n     (if (e') e1 else e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl CondRed)"], ["", "lemma Throw_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (throw e, xs) (throw e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (throw e, xs) (throw e', xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl ThrowRed)"], ["", "lemma Try_\\<tau>red0t_xt:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0t extTA P t h (try e catch(C V) e2, xs) (try e' catch(C V) e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0t extTA P t h (try e catch(C V) e2, xs)\n     (try e' catch(C V) e2, xs')", "by(induct rule: tranclp_induct2)(auto intro: tranclp.trancl_into_trancl TryRed)"], ["", "lemma NewArray_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (newA T\\<lfloor>e\\<rceil>, xs) (newA T\\<lfloor>e'\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (newA T\\<lfloor>e\\<rceil>, xs)\n     (newA T\\<lfloor>e'\\<rceil>, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl NewArrayRed)"], ["", "lemma Cast_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Cast T e, xs) (Cast T e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Cast T e, xs) (Cast T e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CastRed)"], ["", "lemma InstanceOf_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e instanceof T, xs) (e' instanceof T, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (e instanceof T, xs) (e' instanceof T, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl InstanceOfRed)"], ["", "lemma BinOp_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (e1, xs) (e1', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs) (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e1, xs) (e1', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (e1 \\<guillemotleft>bop\\<guillemotright> e2, xs)\n     (e1' \\<guillemotleft>bop\\<guillemotright> e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl BinOpRed1)"], ["", "lemma BinOp_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (e2, xs) (e2', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs) (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e2, xs) (e2', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h\n     (Val v \\<guillemotleft>bop\\<guillemotright> e2, xs)\n     (Val v \\<guillemotleft>bop\\<guillemotright> e2', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl BinOpRed2)"], ["", "lemma LAss_\\<tau>red0r:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (V := e, xs) (V := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (V:=e, xs) (V:=e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl LAssRed)"], ["", "lemma AAcc_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (a\\<lfloor>i\\<rceil>, xs) (a'\\<lfloor>i\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (a\\<lfloor>i\\<rceil>, xs)\n     (a'\\<lfloor>i\\<rceil>, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAccRed1)"], ["", "lemma AAcc_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val a\\<lfloor>i\\<rceil>, xs) (Val a\\<lfloor>i'\\<rceil>, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (i, xs) (i', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Val a\\<lfloor>i\\<rceil>, xs)\n     (Val a\\<lfloor>i'\\<rceil>, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAccRed2)"], ["", "lemma AAss_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (a\\<lfloor>i\\<rceil> := e, xs) (a'\\<lfloor>i\\<rceil> := e, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (a\\<lfloor>i\\<rceil> := e, xs)\n     (a'\\<lfloor>i\\<rceil> := e, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAssRed1)"], ["", "lemma AAss_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (i, xs) (i', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val a\\<lfloor>i\\<rceil> := e, xs) (Val a\\<lfloor>i'\\<rceil> := e, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (i, xs) (i', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Val a\\<lfloor>i\\<rceil> := e, xs)\n     (Val a\\<lfloor>i'\\<rceil> := e, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAssRed2)"], ["", "lemma AAss_\\<tau>red0r_xt3:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs) (Val a\\<lfloor>Val i\\<rceil> := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Val a\\<lfloor>Val i\\<rceil> := e, xs)\n     (Val a\\<lfloor>Val i\\<rceil> := e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl AAssRed3)"], ["", "lemma ALength_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (a, xs) (a', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (a\\<bullet>length, xs) (a'\\<bullet>length, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl ALengthRed)"], ["", "lemma FAcc_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (e\\<bullet>F{D}, xs) (e'\\<bullet>F{D}, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl FAccRed)"], ["", "lemma FAss_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e\\<bullet>F{D} := e2, xs) (e'\\<bullet>F{D} := e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (e\\<bullet>F{D} := e2, xs)\n     (e'\\<bullet>F{D} := e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl FAssRed1)"], ["", "lemma FAss_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v\\<bullet>F{D} := e, xs) (Val v\\<bullet>F{D} := e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Val v\\<bullet>F{D} := e, xs)\n     (Val v\\<bullet>F{D} := e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl FAssRed2)"], ["", "lemma CAS_\\<tau>red0r_xt1:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs) (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h\n     (e\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs)\n     (e'\\<bullet>compareAndSwap(D\\<bullet>F, e2, e3), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CASRed1)"], ["", "lemma CAS_\\<tau>red0r_xt2:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e, e3), xs)\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, e', e3), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CASRed2)"], ["", "lemma CAS_\\<tau>red0r_xt3:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs) (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e), xs)\n     (Val v\\<bullet>compareAndSwap(D\\<bullet>F, Val v', e'), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CASRed3)"], ["", "lemma Call_\\<tau>red0r_obj:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (e\\<bullet>M(ps), xs) (e'\\<bullet>M(ps), xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CallObj)"], ["", "lemma Call_\\<tau>red0r_param:\n  \"\\<tau>reds0r extTA P t h (es, xs) (es', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (Val v\\<bullet>M(es), xs) (Val v\\<bullet>M(es'), xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds0r extTA P t h (es, xs) (es', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Val v\\<bullet>M(es), xs)\n     (Val v\\<bullet>M(es'), xs')", "by(induct rule: rtranclp_induct2)(fastforce intro: rtranclp.rtrancl_into_rtrancl CallParams)+"], ["", "lemma Block_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs(V := vo)) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs) ({V:T=xs' V; e'}, xs'(V := xs V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs(V := vo)) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n     ({V:T=xs' V; e'}, xs'(V := xs V))", "proof(induct rule: rtranclp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n     ({V:T=(xs(V := vo)) V; e}, xs(V := vo, V := xs V))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n     ({V:T=(xs(V := vo)) V; e}, xs(V := vo, V := xs V))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n     ({V:T=(xs(V := vo)) V; e}, xs(V := vo, V := xs V))", "by(simp del: fun_upd_apply)(auto simp add: fun_upd_apply)"], ["proof (state)\nthis:\n  \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=(xs(V := vo)) V; e}, xs(V := vo, V := xs V))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "case (step e' xs' e'' xs'')"], ["proof (state)\nthis:\n  \\<tau>red0r extTA P t h (e, xs(V := vo)) (e', xs')\n  \\<tau>red0 extTA P t h (e', xs') (e'', xs'')\n  \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=xs' V; e'}, xs'(V := xs V))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "from \\<open>\\<tau>red0 extTA P t h (e', xs') (e'', xs'')\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>red0 extTA P t h (e', xs') (e'', xs'')", "have \"extTA,P,t \\<turnstile> \\<langle>e',(h, xs')\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'',(h, xs'')\\<rangle>\" \"\\<tau>move0 P h e'\" \"no_call P h e'\""], ["proof (prove)\nusing this:\n  \\<tau>red0 extTA P t h (e', xs') (e'', xs'')\n\ngoal (1 subgoal):\n 1. extTA,P,t \\<turnstile> \\<langle>e',\n                            (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                           \\<langle>e'',(h, xs'')\\<rangle> &&&\n    \\<tau>move0 P h e' &&& no_call P h e'", "by auto"], ["proof (state)\nthis:\n  extTA,P,t \\<turnstile> \\<langle>e',\n                          (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>e'',(h, xs'')\\<rangle>\n  \\<tau>move0 P h e'\n  no_call P h e'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "hence \"extTA,P,t \\<turnstile> \\<langle>e',(h, xs'(V := xs V, V := xs' V))\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'',(h, xs'')\\<rangle>\""], ["proof (prove)\nusing this:\n  extTA,P,t \\<turnstile> \\<langle>e',\n                          (h, xs')\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>e'',(h, xs'')\\<rangle>\n  \\<tau>move0 P h e'\n  no_call P h e'\n\ngoal (1 subgoal):\n 1. extTA,P,t \\<turnstile> \\<langle>e',\n                            (h, xs'\n                             (V := xs V,\n                              V := xs' V))\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                           \\<langle>e'',(h, xs'')\\<rangle>", "by simp"], ["proof (state)\nthis:\n  extTA,P,t \\<turnstile> \\<langle>e',\n                          (h, xs'\n                           (V := xs V,\n                            V := xs' V))\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>e'',(h, xs'')\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "from BlockRed[OF this, of T] \\<open>\\<tau>move0 P h e'\\<close> \\<open>no_call P h e'\\<close>"], ["proof (chain)\npicking this:\n  extTA,P,t \\<turnstile> \\<langle>{V:T=xs' V; e'},\n                          (h, xs'\n                           (V := xs V))\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>{V:T=xs'' V; e''},\n                          (h, xs''(V := (xs'(V := xs V)) V))\\<rangle>\n  \\<tau>move0 P h e'\n  no_call P h e'", "have \"\\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V)) ({V:T=xs'' V; e''}, xs''(V := xs V))\""], ["proof (prove)\nusing this:\n  extTA,P,t \\<turnstile> \\<langle>{V:T=xs' V; e'},\n                          (h, xs'\n                           (V := xs V))\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                         \\<langle>{V:T=xs'' V; e''},\n                          (h, xs''(V := (xs'(V := xs V)) V))\\<rangle>\n  \\<tau>move0 P h e'\n  no_call P h e'\n\ngoal (1 subgoal):\n 1. \\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V))\n     ({V:T=xs'' V; e''}, xs''(V := xs V))", "by auto"], ["proof (state)\nthis:\n  \\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V))\n   ({V:T=xs'' V; e''}, xs''(V := xs V))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (e, xs(V := vo)) (a, b);\n        \\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n         ({V:T=b V; a}, b(V := xs V))\\<rbrakk>\n       \\<Longrightarrow> \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n                          ({V:T=ba V; aa}, ba(V := xs V))", "with \\<open>\\<tau>red0r extTA P t h ({V:T=vo; e}, xs) ({V:T=xs' V; e'}, xs'(V := xs V))\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=xs' V; e'}, xs'(V := xs V))\n  \\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V))\n   ({V:T=xs'' V; e''}, xs''(V := xs V))", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=xs' V; e'}, xs'(V := xs V))\n  \\<tau>red0 extTA P t h ({V:T=xs' V; e'}, xs'(V := xs V))\n   ({V:T=xs'' V; e''}, xs''(V := xs V))\n\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n     ({V:T=xs'' V; e''}, xs''(V := xs V))", ".."], ["proof (state)\nthis:\n  \\<tau>red0r extTA P t h ({V:T=vo; e}, xs)\n   ({V:T=xs'' V; e''}, xs''(V := xs V))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sync_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs) (sync\\<^bsub>V\\<^esub> (e') e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (sync\\<^bsub>V\\<^esub> (e) e2, xs)\n     (sync\\<^bsub>V\\<^esub> (e') e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl SynchronizedRed1)"], ["", "lemma InSync_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (insync\\<^bsub>V\\<^esub> (a) e, xs) (insync\\<^bsub>V\\<^esub> (a) e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (insync\\<^bsub>V\\<^esub> (a) e, xs)\n     (insync\\<^bsub>V\\<^esub> (a) e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl SynchronizedRed2)"], ["", "lemma Seq_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (e;;e2, xs) (e';;e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (e;; e2, xs) (e';; e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl SeqRed)"], ["", "lemma Cond_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (if (e) e1 else e2, xs) (if (e') e1 else e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (if (e) e1 else e2, xs)\n     (if (e') e1 else e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl CondRed)"], ["", "lemma Throw_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (throw e, xs) (throw e', xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (throw e, xs) (throw e', xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl ThrowRed)"], ["", "lemma Try_\\<tau>red0r_xt:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> \\<tau>red0r extTA P t h (try e catch(C V) e2, xs) (try e' catch(C V) e2, xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (try e catch(C V) e2, xs)\n     (try e' catch(C V) e2, xs')", "by(induct rule: rtranclp_induct2)(auto intro: rtranclp.rtrancl_into_rtrancl TryRed)"], ["", "lemma \\<tau>Red0_conv [iff]:\n  \"\\<tau>Red0 P t h (e, es) (e', es') = (P,t \\<turnstile>0 \\<langle>e/es, h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'/es', h\\<rangle> \\<and> \\<tau>Move0 P h (e, es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es') =\n    (P,t \\<turnstile>0 \\<langle>e/es,\n                        h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                       \\<langle>e'/es',h\\<rangle> \\<and>\n     \\<tau>Move0 P h (e, es))", "by(simp add: \\<tau>Red0_def)"], ["", "lemma \\<tau>red0r_lcl_incr:\n  \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> dom xs \\<subseteq> dom xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    dom xs \\<subseteq> dom xs'", "by(induct rule: rtranclp_induct2)(auto dest: red_lcl_incr del: subsetI)"], ["", "lemma \\<tau>red0t_lcl_incr:\n  \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> dom xs \\<subseteq> dom xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    dom xs \\<subseteq> dom xs'", "by(rule \\<tau>red0r_lcl_incr)(rule tranclp_into_rtranclp)"], ["", "lemma \\<tau>red0r_dom_lcl:\n  assumes wwf: \"wwf_J_prog P\"\n  shows \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> dom xs' \\<subseteq> dom xs \\<union> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    dom xs' \\<subseteq> dom xs \\<union> fv e", "apply(induct rule: converse_rtranclp_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dom xs' \\<subseteq> dom xs' \\<union> fv e'\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h (aa, ba) (e', xs');\n        dom xs' \\<subseteq> dom ba \\<union> fv aa\\<rbrakk>\n       \\<Longrightarrow> dom xs' \\<subseteq> dom b \\<union> fv a", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0 extTA P t h (a, b) (aa, ba);\n        \\<tau>red0r extTA P t h (aa, ba) (e', xs');\n        dom xs' \\<subseteq> dom ba \\<union> fv aa\\<rbrakk>\n       \\<Longrightarrow> dom xs' \\<subseteq> dom b \\<union> fv a", "apply(clarsimp del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (aa, ba) (e', xs');\n        dom xs' \\<subseteq> dom ba \\<union> fv aa;\n        extTA,P,t \\<turnstile> \\<langle>a,\n                                (h, b)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                               \\<langle>aa,(h, ba)\\<rangle>;\n        \\<tau>move0 P h a; no_call P h a\\<rbrakk>\n       \\<Longrightarrow> dom xs' \\<subseteq> dom b \\<union> fv a", "apply(frule red_dom_lcl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (aa, ba) (e', xs');\n        dom xs' \\<subseteq> dom ba \\<union> fv aa;\n        extTA,P,t \\<turnstile> \\<langle>a,\n                                (h, b)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                               \\<langle>aa,(h, ba)\\<rangle>;\n        \\<tau>move0 P h a; no_call P h a;\n        dom (lcl (h, ba))\n        \\<subseteq> dom (lcl (h, b)) \\<union> fv a\\<rbrakk>\n       \\<Longrightarrow> dom xs' \\<subseteq> dom b \\<union> fv a", "apply(drule red_fv_subset[OF wwf])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>red0r extTA P t h (aa, ba) (e', xs');\n        dom xs' \\<subseteq> dom ba \\<union> fv aa; \\<tau>move0 P h a;\n        no_call P h a;\n        dom (lcl (h, ba)) \\<subseteq> dom (lcl (h, b)) \\<union> fv a;\n        fv aa \\<subseteq> fv a\\<rbrakk>\n       \\<Longrightarrow> dom xs' \\<subseteq> dom b \\<union> fv a", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>red0t_dom_lcl:\n  assumes wwf: \"wwf_J_prog P\"\n  shows \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> dom xs' \\<subseteq> dom xs \\<union> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    dom xs' \\<subseteq> dom xs \\<union> fv e", "by(rule \\<tau>red0r_dom_lcl[OF wwf])(rule tranclp_into_rtranclp)"], ["", "lemma \\<tau>red0r_fv_subset:\n  assumes wwf: \"wwf_J_prog P\"\n  shows \"\\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow> fv e' \\<subseteq> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    fv e' \\<subseteq> fv e", "by(induct rule: converse_rtranclp_induct2)(auto dest: red_fv_subset[OF wwf])"], ["", "lemma \\<tau>red0t_fv_subset:\n  assumes wwf: \"wwf_J_prog P\"\n  shows \"\\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow> fv e' \\<subseteq> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (e, xs) (e', xs') \\<Longrightarrow>\n    fv e' \\<subseteq> fv e", "by(rule \\<tau>red0r_fv_subset[OF wwf])(rule tranclp_into_rtranclp)"], ["", "lemma fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move0_callD: \"call e = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow> \\<tau>move0 P h e \\<longleftrightarrow> (synthesized_call P h (a, M, vs) \\<longrightarrow> \\<tau>external' P h a M)\"\n  and \\<tau>moves0_callsD: \"calls es = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow> \\<tau>moves0 P h es \\<longleftrightarrow> (synthesized_call P h (a, M, vs) \\<longrightarrow> \\<tau>external' P h a M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (call e = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n     \\<tau>move0 P h e =\n     (synthesized_call P h (a, M, vs) \\<longrightarrow>\n      \\<tau>external' P h a M)) &&&\n    (calls es = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n     \\<tau>moves0 P h es =\n     (synthesized_call P h (a, M, vs) \\<longrightarrow>\n      \\<tau>external' P h a M))", "apply(induct e and es rule: call.induct calls.induct)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       call (new x) = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n       \\<tau>move0 P h (new x) =\n       (synthesized_call P h (a, M, vs) \\<longrightarrow>\n        \\<tau>external' P h a M)\n 2. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h x2 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call (newA x1\\<lfloor>x2\\<rceil>) =\n        \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (newA x1\\<lfloor>x2\\<rceil>) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 3. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h x2 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call (Cast x1 x2) = \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (Cast x1 x2) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 4. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h x1 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call (x1 instanceof x2) = \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (x1 instanceof x2) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 5. \\<And>x.\n       call (Val x) = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n       \\<tau>move0 P h (Val x) =\n       (synthesized_call P h (a, M, vs) \\<longrightarrow>\n        \\<tau>external' P h a M)\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>call x1 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h x1 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call x3 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h x3 =\n        (synthesized_call P h (a, M, vs) \\<longrightarrow>\n         \\<tau>external' P h a M);\n        call (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n        \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 7. \\<And>x.\n       call (Var x) = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n       \\<tau>move0 P h (Var x) =\n       (synthesized_call P h (a, M, vs) \\<longrightarrow>\n        \\<tau>external' P h a M)\n 8. \\<And>x1 x2.\n       \\<lbrakk>call x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h x2 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call (x1:=x2) = \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (x1:=x2) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 9. \\<And>x1 x2.\n       \\<lbrakk>call x1 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                \\<tau>move0 P h x1 =\n                (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                 \\<tau>external' P h a M);\n        call x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n        \\<tau>move0 P h x2 =\n        (synthesized_call P h (a, M, vs) \\<longrightarrow>\n         \\<tau>external' P h a M);\n        call (x1\\<lfloor>x2\\<rceil>) = \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>move0 P h (x1\\<lfloor>x2\\<rceil>) =\n                         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                          \\<tau>external' P h a M)\n 10. \\<And>x1 x2 x3.\n        \\<lbrakk>call x1 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n                 \\<tau>move0 P h x1 =\n                 (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                  \\<tau>external' P h a M);\n         call x2 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n         \\<tau>move0 P h x2 =\n         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n          \\<tau>external' P h a M);\n         call x3 = \\<lfloor>(a, M, vs)\\<rfloor> \\<Longrightarrow>\n         \\<tau>move0 P h x3 =\n         (synthesized_call P h (a, M, vs) \\<longrightarrow>\n          \\<tau>external' P h a M);\n         call (x1\\<lfloor>x2\\<rceil> := x3) =\n         \\<lfloor>(a, M, vs)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<tau>move0 P h (x1\\<lfloor>x2\\<rceil> := x3) =\n                          (synthesized_call P h (a, M, vs) \\<longrightarrow>\n                           \\<tau>external' P h a M)\nA total of 25 subgoals...", "apply(auto split: if_split_asm simp add: is_vals_conv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>vsa aa es'.\n       \\<lbrakk>synthesized_call P h (a, M, vs);\n        map Val vs = map Val vsa @ Throw aa # es'\\<rbrakk>\n       \\<Longrightarrow> \\<tau>external' P h a M\n 2. \\<lbrakk>synthesized_call P h (a, M, vs);\n     \\<forall>T.\n        (\\<exists>z.\n            typeof_addr h a = \\<lfloor>z\\<rfloor> \\<and>\n            ty_of_htype z = T) \\<longrightarrow>\n        (\\<forall>C.\n            class_type_of' T = \\<lfloor>C\\<rfloor> \\<longrightarrow>\n            (\\<forall>Ts Tr D.\n                P \\<turnstile> C sees M: Ts\\<rightarrow>Tr = Native in D \\<longrightarrow>\n                \\<tau>external_defs D M))\\<rbrakk>\n    \\<Longrightarrow> \\<tau>external' P h a M\n 3. \\<And>z Ts Tr D.\n       \\<lbrakk>\\<forall>vsa a es'.\n                   map Val vs \\<noteq> map Val vsa @ Throw a # es';\n        typeof_addr h a = \\<lfloor>z\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        z sees M: Ts\\<rightarrow>Tr = Native in D;\n        \\<not> synthesized_call P h (a, M, vs)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>external_defs D M\n 4. \\<And>z Ts Tr D.\n       \\<lbrakk>\\<forall>vsa a es'.\n                   map Val vs \\<noteq> map Val vsa @ Throw a # es';\n        typeof_addr h a = \\<lfloor>z\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        z sees M: Ts\\<rightarrow>Tr = Native in D;\n        \\<tau>external' P h a M\\<rbrakk>\n       \\<Longrightarrow> \\<tau>external_defs D M", "apply(fastforce simp add: synthesized_call_def map_eq_append_conv \\<tau>external'_def \\<tau>external_def dest: sees_method_fun)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fixes e :: \"('a, 'b, 'addr) exp\" and es :: \"('a, 'b, 'addr) exp list\"\n  shows \\<tau>move0_not_call: \"\\<lbrakk> \\<tau>move0 P h e; call e = \\<lfloor>(a, M, vs)\\<rfloor>; synthesized_call P h (a, M, vs) \\<rbrakk> \\<Longrightarrow> \\<tau>external' P h a M\"\n  and \\<tau>moves0_not_calls: \"\\<lbrakk> \\<tau>moves0 P h es; calls es = \\<lfloor>(a, M, vs)\\<rfloor>; synthesized_call P h (a, M, vs) \\<rbrakk> \\<Longrightarrow> \\<tau>external' P h a M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<tau>move0 P h e; call e = \\<lfloor>(a, M, vs)\\<rfloor>;\n      synthesized_call P h (a, M, vs)\\<rbrakk>\n     \\<Longrightarrow> \\<tau>external' P h a M) &&&\n    (\\<lbrakk>\\<tau>moves0 P h es; calls es = \\<lfloor>(a, M, vs)\\<rfloor>;\n      synthesized_call P h (a, M, vs)\\<rbrakk>\n     \\<Longrightarrow> \\<tau>external' P h a M)", "apply(drule \\<tau>move0_callD[where P=P and h=h], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>moves0 P h es; calls es = \\<lfloor>(a, M, vs)\\<rfloor>;\n     synthesized_call P h (a, M, vs)\\<rbrakk>\n    \\<Longrightarrow> \\<tau>external' P h a M", "apply(drule \\<tau>moves0_callsD[where P=P and h=h], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>red0_into_\\<tau>Red0:\n  assumes red: \"\\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\"\n  shows \"\\<tau>Red0 P t h (e, es) (e', es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es)", "from red"], ["proof (chain)\npicking this:\n  \\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')", "have red: \"extTA2J0 P,P,t \\<turnstile> \\<langle>e, (h, Map.empty)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>\"\n    and \"\\<tau>move0 P h e\" and \"no_call P h e\""], ["proof (prove)\nusing this:\n  \\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\n\ngoal (1 subgoal):\n 1. extTA2J0\n     P,P,t \\<turnstile> \\<langle>e,\n                         (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                        \\<langle>e',(h, xs')\\<rangle> &&&\n    \\<tau>move0 P h e &&& no_call P h e", "by auto"], ["proof (state)\nthis:\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n  \\<tau>move0 P h e\n  no_call P h e\n\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es)", "hence \"P,t \\<turnstile>0 \\<langle>e/es,h\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e'/es,h\\<rangle>\""], ["proof (prove)\nusing this:\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n  \\<tau>move0 P h e\n  no_call P h e\n\ngoal (1 subgoal):\n 1. P,t \\<turnstile>0 \\<langle>e/es,\n                       h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e'/es,h\\<rangle>", "by-(erule red0Red,auto simp add: no_call_def)"], ["proof (state)\nthis:\n  P,t \\<turnstile>0 \\<langle>e/es,\n                     h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                    \\<langle>e'/es,h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,t \\<turnstile>0 \\<langle>e/es,\n                     h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                    \\<langle>e'/es,h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es)", "using \\<open>\\<tau>move0 P h e\\<close>"], ["proof (prove)\nusing this:\n  P,t \\<turnstile>0 \\<langle>e/es,\n                     h\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                    \\<langle>e'/es,h\\<rangle>\n  \\<tau>move0 P h e\n\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es)", "by(auto)"], ["proof (state)\nthis:\n  \\<tau>Red0 P t h (e, es) (e', es)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>red0r_into_\\<tau>Red0r:\n  assumes wwf: \"wwf_J_prog P\"\n  shows\n  \"\\<lbrakk> \\<tau>red0r (extTA2J0 P) P t h (e, Map.empty) (e'', Map.empty); fv e = {} \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Red0r P t h (e, es) (e'', es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>red0r (extTA2J0 P) P t h (e, Map.empty) (e'', Map.empty);\n     fv e = {}\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Red0r P t h (e, es) (e'', es)", "proof(induct e xs\\<equiv>\"Map.empty :: 'addr locals\" rule: converse_rtranclp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. fv e'' = {} \\<Longrightarrow> \\<tau>Red0r P t h (e'', es) (e'', es)\n 2. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "case refl"], ["proof (state)\nthis:\n  fv e'' = {}\n\ngoal (2 subgoals):\n 1. fv e'' = {} \\<Longrightarrow> \\<tau>Red0r P t h (e'', es) (e'', es)\n 2. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red0r P t h (e'', es) (e'', es)", "by blast"], ["proof (state)\nthis:\n  \\<tau>Red0r P t h (e'', es) (e'', es)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "case (step e e' xs')"], ["proof (state)\nthis:\n  \\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\n  \\<tau>red0r (extTA2J0 P) P t h (e', xs') (e'', Map.empty)\n  \\<lbrakk>xs' = Map.empty; fv e' = {}\\<rbrakk>\n  \\<Longrightarrow> \\<tau>Red0r P t h (e', es) (e'', es)\n  fv e = {}\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "from \\<open>\\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')", "have red: \"extTA2J0 P,P,t \\<turnstile> \\<langle>e, (h, Map.empty)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>\"\n    and \"\\<tau>move0 P h e\"  and \"no_call P h e\""], ["proof (prove)\nusing this:\n  \\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\n\ngoal (1 subgoal):\n 1. extTA2J0\n     P,P,t \\<turnstile> \\<langle>e,\n                         (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                        \\<langle>e',(h, xs')\\<rangle> &&&\n    \\<tau>move0 P h e &&& no_call P h e", "by auto"], ["proof (state)\nthis:\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n  \\<tau>move0 P h e\n  no_call P h e\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "from red_dom_lcl[OF red] \\<open>fv e = {}\\<close>"], ["proof (chain)\npicking this:\n  dom (lcl (h, xs')) \\<subseteq> dom (lcl (h, Map.empty)) \\<union> fv e\n  fv e = {}", "have \"dom xs' = {}\""], ["proof (prove)\nusing this:\n  dom (lcl (h, xs')) \\<subseteq> dom (lcl (h, Map.empty)) \\<union> fv e\n  fv e = {}\n\ngoal (1 subgoal):\n 1. dom xs' = {}", "by(auto split:if_split_asm)"], ["proof (state)\nthis:\n  dom xs' = {}\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "hence \"xs' = Map.empty\""], ["proof (prove)\nusing this:\n  dom xs' = {}\n\ngoal (1 subgoal):\n 1. xs' = Map.empty", "by(auto)"], ["proof (state)\nthis:\n  xs' = Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "moreover"], ["proof (state)\nthis:\n  xs' = Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "from wwf red"], ["proof (chain)\npicking this:\n  wwf_J_prog P\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>", "have \"fv e' \\<subseteq> fv e\""], ["proof (prove)\nusing this:\n  wwf_J_prog P\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n\ngoal (1 subgoal):\n 1. fv e' \\<subseteq> fv e", "by(rule red_fv_subset)"], ["proof (state)\nthis:\n  fv e' \\<subseteq> fv e\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "with \\<open>fv e = {}\\<close>"], ["proof (chain)\npicking this:\n  fv e = {}\n  fv e' \\<subseteq> fv e", "have \"fv e' = {}\""], ["proof (prove)\nusing this:\n  fv e = {}\n  fv e' \\<subseteq> fv e\n\ngoal (1 subgoal):\n 1. fv e' = {}", "by blast"], ["proof (state)\nthis:\n  fv e' = {}\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "ultimately"], ["proof (chain)\npicking this:\n  xs' = Map.empty\n  fv e' = {}", "have \"\\<tau>Red0r P t h (e', es) (e'', es)\""], ["proof (prove)\nusing this:\n  xs' = Map.empty\n  fv e' = {}\n\ngoal (1 subgoal):\n 1. \\<tau>Red0r P t h (e', es) (e'', es)", "by(rule step)"], ["proof (state)\nthis:\n  \\<tau>Red0r P t h (e', es) (e'', es)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "moreover"], ["proof (state)\nthis:\n  \\<tau>Red0r P t h (e', es) (e'', es)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "from red \\<open>\\<tau>move0 P h e\\<close> \\<open>xs' = Map.empty\\<close> \\<open>no_call P h e\\<close>"], ["proof (chain)\npicking this:\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n  \\<tau>move0 P h e\n  xs' = Map.empty\n  no_call P h e", "have \"\\<tau>Red0 P t h (e, es) (e', es)\""], ["proof (prove)\nusing this:\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n  \\<tau>move0 P h e\n  xs' = Map.empty\n  no_call P h e\n\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es)", "by(auto simp add: no_call_def intro!: red0Red)"], ["proof (state)\nthis:\n  \\<tau>Red0 P t h (e, es) (e', es)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0r (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0r P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0r P t h (a, es) (e'', es)", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau>Red0r P t h (e', es) (e'', es)\n  \\<tau>Red0 P t h (e, es) (e', es)", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau>Red0r P t h (e', es) (e'', es)\n  \\<tau>Red0 P t h (e, es) (e', es)\n\ngoal (1 subgoal):\n 1. \\<tau>Red0r P t h (e, es) (e'', es)", "by(blast intro: converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  \\<tau>Red0r P t h (e, es) (e'', es)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>red0t_into_\\<tau>Red0t:\n  assumes wwf: \"wwf_J_prog P\"\n  shows\n  \"\\<lbrakk> \\<tau>red0t (extTA2J0 P) P t h (e, Map.empty) (e'', Map.empty); fv e = {} \\<rbrakk>\n  \\<Longrightarrow> \\<tau>Red0t P t h (e, es) (e'', es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau>red0t (extTA2J0 P) P t h (e, Map.empty) (e'', Map.empty);\n     fv e = {}\\<rbrakk>\n    \\<Longrightarrow> \\<tau>Red0t P t h (e, es) (e'', es)", "proof(induct e xs\\<equiv>\"Map.empty :: 'addr locals\" rule: converse_tranclp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty)\n                 (e'', Map.empty);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)\n 2. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "case base"], ["proof (state)\nthis:\n  \\<tau>red0 (extTA2J0 P) P t h (a_, Map.empty) (e'', Map.empty)\n  fv a_ = {}\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty)\n                 (e'', Map.empty);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)\n 2. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<tau>red0 (extTA2J0 P) P t h (a_, Map.empty) (e'', Map.empty)\n  fv a_ = {}\n\ngoal (1 subgoal):\n 1. \\<tau>Red0t P t h (a_, es) (e'', es)", "by(blast intro!: tranclp.r_into_trancl \\<tau>red0_into_\\<tau>Red0)"], ["proof (state)\nthis:\n  \\<tau>Red0t P t h (a_, es) (e'', es)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "case (step e e' xs')"], ["proof (state)\nthis:\n  \\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\n  \\<tau>red0t (extTA2J0 P) P t h (e', xs') (e'', Map.empty)\n  \\<lbrakk>xs' = Map.empty; fv e' = {}\\<rbrakk>\n  \\<Longrightarrow> \\<tau>Red0t P t h (e', es) (e'', es)\n  fv e = {}\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "from \\<open>\\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\\<close>"], ["proof (chain)\npicking this:\n  \\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')", "have red: \"extTA2J0 P,P,t \\<turnstile> \\<langle>e, (h, Map.empty)\\<rangle> -\\<epsilon>\\<rightarrow> \\<langle>e', (h, xs')\\<rangle>\" and \"\\<tau>move0 P h e\" and \"no_call P h e\""], ["proof (prove)\nusing this:\n  \\<tau>red0 (extTA2J0 P) P t h (e, Map.empty) (e', xs')\n\ngoal (1 subgoal):\n 1. extTA2J0\n     P,P,t \\<turnstile> \\<langle>e,\n                         (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                        \\<langle>e',(h, xs')\\<rangle> &&&\n    \\<tau>move0 P h e &&& no_call P h e", "by auto"], ["proof (state)\nthis:\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n  \\<tau>move0 P h e\n  no_call P h e\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "from red_dom_lcl[OF red] \\<open>fv e = {}\\<close>"], ["proof (chain)\npicking this:\n  dom (lcl (h, xs')) \\<subseteq> dom (lcl (h, Map.empty)) \\<union> fv e\n  fv e = {}", "have \"dom xs' = {}\""], ["proof (prove)\nusing this:\n  dom (lcl (h, xs')) \\<subseteq> dom (lcl (h, Map.empty)) \\<union> fv e\n  fv e = {}\n\ngoal (1 subgoal):\n 1. dom xs' = {}", "by(auto split:if_split_asm)"], ["proof (state)\nthis:\n  dom xs' = {}\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "hence \"xs' = Map.empty\""], ["proof (prove)\nusing this:\n  dom xs' = {}\n\ngoal (1 subgoal):\n 1. xs' = Map.empty", "by auto"], ["proof (state)\nthis:\n  xs' = Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "moreover"], ["proof (state)\nthis:\n  xs' = Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "from wwf red"], ["proof (chain)\npicking this:\n  wwf_J_prog P\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>", "have \"fv e' \\<subseteq> fv e\""], ["proof (prove)\nusing this:\n  wwf_J_prog P\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n\ngoal (1 subgoal):\n 1. fv e' \\<subseteq> fv e", "by(rule red_fv_subset)"], ["proof (state)\nthis:\n  fv e' \\<subseteq> fv e\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "with \\<open>fv e = {}\\<close>"], ["proof (chain)\npicking this:\n  fv e = {}\n  fv e' \\<subseteq> fv e", "have \"fv e' = {}\""], ["proof (prove)\nusing this:\n  fv e = {}\n  fv e' \\<subseteq> fv e\n\ngoal (1 subgoal):\n 1. fv e' = {}", "by blast"], ["proof (state)\nthis:\n  fv e' = {}\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "ultimately"], ["proof (chain)\npicking this:\n  xs' = Map.empty\n  fv e' = {}", "have \"\\<tau>Red0t P t h (e', es) (e'', es)\""], ["proof (prove)\nusing this:\n  xs' = Map.empty\n  fv e' = {}\n\ngoal (1 subgoal):\n 1. \\<tau>Red0t P t h (e', es) (e'', es)", "by(rule step)"], ["proof (state)\nthis:\n  \\<tau>Red0t P t h (e', es) (e'', es)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "moreover"], ["proof (state)\nthis:\n  \\<tau>Red0t P t h (e', es) (e'', es)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "from red \\<open>\\<tau>move0 P h e\\<close> \\<open>xs' = Map.empty\\<close> \\<open>no_call P h e\\<close>"], ["proof (chain)\npicking this:\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n  \\<tau>move0 P h e\n  xs' = Map.empty\n  no_call P h e", "have \"\\<tau>Red0 P t h (e, es) (e', es)\""], ["proof (prove)\nusing this:\n  extTA2J0\n   P,P,t \\<turnstile> \\<langle>e,\n                       (h, Map.empty)\\<rangle> -\\<lbrace>\\<rbrace>\\<rightarrow>\n                      \\<langle>e',(h, xs')\\<rangle>\n  \\<tau>move0 P h e\n  xs' = Map.empty\n  no_call P h e\n\ngoal (1 subgoal):\n 1. \\<tau>Red0 P t h (e, es) (e', es)", "by(auto simp add: no_call_def intro!: red0Red)"], ["proof (state)\nthis:\n  \\<tau>Red0 P t h (e, es) (e', es)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>\\<tau>red0 (extTA2J0 P) P t h (a, Map.empty) (aa, ba);\n        \\<tau>red0t (extTA2J0 P) P t h (aa, ba) (e'', Map.empty);\n        \\<lbrakk>ba = Map.empty; fv aa = {}\\<rbrakk>\n        \\<Longrightarrow> \\<tau>Red0t P t h (aa, es) (e'', es);\n        fv a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>Red0t P t h (a, es) (e'', es)", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau>Red0t P t h (e', es) (e'', es)\n  \\<tau>Red0 P t h (e, es) (e', es)", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau>Red0t P t h (e', es) (e'', es)\n  \\<tau>Red0 P t h (e, es) (e', es)\n\ngoal (1 subgoal):\n 1. \\<tau>Red0t P t h (e, es) (e'', es)", "by(blast intro: tranclp_into_tranclp2)"], ["proof (state)\nthis:\n  \\<tau>Red0t P t h (e, es) (e'', es)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>red0r_Val:\n  \"\\<tau>red0r extTA P t h (Val v, xs) s' \\<longleftrightarrow> s' = (Val v, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0r extTA P t h (Val v, xs) s' = (s' = (Val v, xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>red0r extTA P t h (Val v, xs) s' \\<Longrightarrow>\n    s' = (Val v, xs)\n 2. s' = (Val v, xs) \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Val v, xs) s'", "assume \"\\<tau>red0r extTA P t h (Val v, xs) s'\""], ["proof (state)\nthis:\n  \\<tau>red0r extTA P t h (Val v, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>red0r extTA P t h (Val v, xs) s' \\<Longrightarrow>\n    s' = (Val v, xs)\n 2. s' = (Val v, xs) \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Val v, xs) s'", "thus \"s' = (Val v, xs)\""], ["proof (prove)\nusing this:\n  \\<tau>red0r extTA P t h (Val v, xs) s'\n\ngoal (1 subgoal):\n 1. s' = (Val v, xs)", "by induct(auto)"], ["proof (state)\nthis:\n  s' = (Val v, xs)\n\ngoal (1 subgoal):\n 1. s' = (Val v, xs) \\<Longrightarrow>\n    \\<tau>red0r extTA P t h (Val v, xs) s'", "qed auto"], ["", "lemma \\<tau>red0t_Val:\n  \"\\<tau>red0t extTA P t h (Val v, xs) s' \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>red0t extTA P t h (Val v, xs) s' = False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>red0t extTA P t h (Val v, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v, xs) s'", "assume \"\\<tau>red0t extTA P t h (Val v, xs) s'\""], ["proof (state)\nthis:\n  \\<tau>red0t extTA P t h (Val v, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>red0t extTA P t h (Val v, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v, xs) s'", "thus False"], ["proof (prove)\nusing this:\n  \\<tau>red0t extTA P t h (Val v, xs) s'\n\ngoal (1 subgoal):\n 1. False", "by induct auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False \\<Longrightarrow> \\<tau>red0t extTA P t h (Val v, xs) s'", "qed auto"], ["", "lemma \\<tau>reds0r_map_Val:\n  \"\\<tau>reds0r extTA P t h (map Val vs, xs) s' \\<longleftrightarrow> s' = (map Val vs, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds0r extTA P t h (map Val vs, xs) s' = (s' = (map Val vs, xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>reds0r extTA P t h (map Val vs, xs) s' \\<Longrightarrow>\n    s' = (map Val vs, xs)\n 2. s' = (map Val vs, xs) \\<Longrightarrow>\n    \\<tau>reds0r extTA P t h (map Val vs, xs) s'", "assume \"\\<tau>reds0r extTA P t h (map Val vs, xs) s'\""], ["proof (state)\nthis:\n  \\<tau>reds0r extTA P t h (map Val vs, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>reds0r extTA P t h (map Val vs, xs) s' \\<Longrightarrow>\n    s' = (map Val vs, xs)\n 2. s' = (map Val vs, xs) \\<Longrightarrow>\n    \\<tau>reds0r extTA P t h (map Val vs, xs) s'", "thus \"s' = (map Val vs, xs)\""], ["proof (prove)\nusing this:\n  \\<tau>reds0r extTA P t h (map Val vs, xs) s'\n\ngoal (1 subgoal):\n 1. s' = (map Val vs, xs)", "by induct auto"], ["proof (state)\nthis:\n  s' = (map Val vs, xs)\n\ngoal (1 subgoal):\n 1. s' = (map Val vs, xs) \\<Longrightarrow>\n    \\<tau>reds0r extTA P t h (map Val vs, xs) s'", "qed auto"], ["", "lemma \\<tau>reds0t_map_Val:\n  \"\\<tau>reds0t extTA P t h (map Val vs, xs) s' \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>reds0t extTA P t h (map Val vs, xs) s' = False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>reds0t extTA P t h (map Val vs, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>reds0t extTA P t h (map Val vs, xs) s'", "assume \"\\<tau>reds0t extTA P t h (map Val vs, xs) s'\""], ["proof (state)\nthis:\n  \\<tau>reds0t extTA P t h (map Val vs, xs) s'\n\ngoal (2 subgoals):\n 1. \\<tau>reds0t extTA P t h (map Val vs, xs) s' \\<Longrightarrow> False\n 2. False \\<Longrightarrow> \\<tau>reds0t extTA P t h (map Val vs, xs) s'", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<tau>reds0t extTA P t h (map Val vs, xs) s'\n\ngoal (1 subgoal):\n 1. False", "by induct auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False \\<Longrightarrow> \\<tau>reds0t extTA P t h (map Val vs, xs) s'", "qed auto"], ["", "lemma Red_Suspend_is_call:\n  \"\\<lbrakk> P,t \\<turnstile>0 \\<langle>e/exs, h\\<rangle> -ta\\<rightarrow> \\<langle>e'/exs', h'\\<rangle>; Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk> \\<Longrightarrow> is_call e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile>0 \\<langle>e/exs,h\\<rangle> -ta\\<rightarrow>\n                               \\<langle>e'/exs',h'\\<rangle>;\n     Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> is_call e'", "by(auto elim!: red0.cases dest: red_Suspend_is_call simp add: is_call_def)"], ["", "lemma red0_mthr: \"multithreaded final_expr0 (mred0 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded final_expr0 (mred0 P)", "by(unfold_locales)(auto elim!: red0.cases dest: red_new_thread_heap)"], ["", "lemma red0_\\<tau>mthr_wf: \"\\<tau>multithreaded_wf final_expr0 (mred0 P) (\\<tau>MOVE0 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr0 (mred0 P)\n     (\\<lambda>(es, h) ta s.\n         \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr0 (mred0 P)\n     (\\<lambda>(es, h) ta s.\n         \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)", "interpret multithreaded final_expr0 \"mred0 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded final_expr0 (mred0 P)", "by(rule red0_mthr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr0 (mred0 P)\n     (\\<lambda>(es, h) ta s.\n         \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr0 (mred0 P)\n     (\\<lambda>(es, h) ta s.\n         \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>r_syntax t x m ta x' m';\n        (case (x, m) of\n         (es, h) \\<Rightarrow>\n           \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (es, h) \\<Rightarrow>\n          \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "fix x1 m1 t ta1 x1' m1'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>r_syntax t x m ta x' m';\n        (case (x, m) of\n         (es, h) \\<Rightarrow>\n           \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (es, h) \\<Rightarrow>\n          \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "assume \"mred0 P t (x1, m1) ta1 (x1', m1')\" \"\\<tau>MOVE0 P (x1, m1) ta1 (x1', m1')\""], ["proof (state)\nthis:\n  r_syntax t x1 m1 ta1 x1' m1'\n  (case (x1, m1) of\n   (es, h) \\<Rightarrow>\n     \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n   ta1 (x1', m1')\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>r_syntax t x m ta x' m';\n        (case (x, m) of\n         (es, h) \\<Rightarrow>\n           \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (es, h) \\<Rightarrow>\n          \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "thus \"m1 = m1'\""], ["proof (prove)\nusing this:\n  r_syntax t x1 m1 ta1 x1' m1'\n  (case (x1, m1) of\n   (es, h) \\<Rightarrow>\n     \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n   ta1 (x1', m1')\n\ngoal (1 subgoal):\n 1. m1 = m1'", "by(cases x1)(fastforce elim!: red0.cases dest: \\<tau>move0_heap_unchanged)"], ["proof (state)\nthis:\n  m1 = m1'\n\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (es, h) \\<Rightarrow>\n          \\<lambda>ta s. \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "qed(simp add: split_beta)"], ["proof (state)\nthis:\n  \\<tau>multithreaded_wf final_expr0 (mred0 P)\n   (\\<lambda>(es, h) ta s.\n       \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_\\<tau>mthr_wf: \"\\<tau>multithreaded_wf final_expr (mred P) (\\<tau>MOVE P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (\\<lambda>((e, x), h) ta s'.\n         \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        (case (x, m) of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, x) \\<Rightarrow>\n              \\<lambda>h ta s'.\n                 \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n            xa)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (e, x) \\<Rightarrow>\n             \\<lambda>h ta s'.\n                \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "fix x1 m1 t ta1 x1' m1'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        (case (x, m) of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, x) \\<Rightarrow>\n              \\<lambda>h ta s'.\n                 \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n            xa)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (e, x) \\<Rightarrow>\n             \\<lambda>h ta s'.\n                \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "assume \"mred P t (x1, m1) ta1 (x1', m1')\" \"\\<tau>MOVE P (x1, m1) ta1 (x1', m1')\""], ["proof (state)\nthis:\n  red_mthr.r_syntax P t x1 m1 ta1 x1' m1'\n  (case (x1, m1) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (e, x) \\<Rightarrow>\n        \\<lambda>h ta s'. \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n      xa)\n   ta1 (x1', m1')\n\ngoal (2 subgoals):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>red_mthr.r_syntax P t x m ta x' m';\n        (case (x, m) of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (e, x) \\<Rightarrow>\n              \\<lambda>h ta s'.\n                 \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n            xa)\n         ta (x', m')\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (e, x) \\<Rightarrow>\n             \\<lambda>h ta s'.\n                \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "thus \"m1 = m1'\""], ["proof (prove)\nusing this:\n  red_mthr.r_syntax P t x1 m1 ta1 x1' m1'\n  (case (x1, m1) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (e, x) \\<Rightarrow>\n        \\<lambda>h ta s'. \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n      xa)\n   ta1 (x1', m1')\n\ngoal (1 subgoal):\n 1. m1 = m1'", "by(auto dest: \\<tau>move0_heap_unchanged simp add: split_def)"], ["proof (state)\nthis:\n  m1 = m1'\n\ngoal (1 subgoal):\n 1. \\<And>s ta s'.\n       (case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (e, x) \\<Rightarrow>\n             \\<lambda>h ta s'.\n                \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)\n           xa)\n        ta s' \\<Longrightarrow>\n       ta = \\<lbrace>\\<rbrace>", "qed(simp add: split_beta)"], ["", "end"], ["", "sublocale J_heap_base < red_mthr: \n  \\<tau>multithreaded_wf \n    final_expr\n    \"mred P\"\n    convert_RA\n    \"\\<tau>MOVE P\"\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr\n     (\\<lambda>t ((e, l), h) ta ((e', l'), h').\n         extTA2J\n          P,P,t \\<turnstile> \\<langle>e,(h, l)\\<rangle> -ta\\<rightarrow>\n                             \\<langle>e',(h', l')\\<rangle>)\n     (\\<lambda>((e, x), h) ta s'.\n         \\<tau>move0 P h e \\<and> ta = \\<lbrace>\\<rbrace>)", "by(rule red_\\<tau>mthr_wf)"], ["", "sublocale J_heap_base < red0_mthr:\n  \\<tau>multithreaded_wf \n    final_expr0\n    \"mred0 P\"\n    convert_RA\n    \"\\<tau>MOVE0 P\"\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>multithreaded_wf final_expr0 (mred0 P)\n     (\\<lambda>(es, h) ta s.\n         \\<tau>Move0 P h es \\<and> ta = \\<lbrace>\\<rbrace>)", "by(rule red0_\\<tau>mthr_wf)"], ["", "context J_heap_base begin"], ["", "lemma \\<tau>Red0r_into_red0_\\<tau>mthr_silent_moves:\n  \"\\<tau>Red0r P t h (e, es) (e'', es'') \\<Longrightarrow> red0_mthr.silent_moves P t ((e, es), h) ((e'', es''), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red0r P t h (e, es) (e'', es'') \\<Longrightarrow>\n    red0_mthr.silent_moves P t ((e, es), h) ((e'', es''), h)", "apply(induct rule: rtranclp_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. red0_mthr.silent_moves P t ((e, es), h) ((e, es), h)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red0r P t h (e, es) (a, b);\n        \\<tau>Red0 P t h (a, b) (aa, ba);\n        red0_mthr.silent_moves P t ((e, es), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> red0_mthr.silent_moves P t ((e, es), h)\n                          ((aa, ba), h)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red0r P t h (e, es) (a, b);\n        \\<tau>Red0 P t h (a, b) (aa, ba);\n        red0_mthr.silent_moves P t ((e, es), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> red0_mthr.silent_moves P t ((e, es), h)\n                          ((aa, ba), h)", "apply(erule rtranclp.rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red0r P t h (e, es) (a, b);\n        \\<tau>Red0 P t h (a, b) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> red0_mthr.silent_move P t ((a, b), h) ((aa, ba), h)", "apply(simp add: red0_mthr.silent_move_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<tau>Red0t_into_red0_\\<tau>mthr_silent_movet:\n  \"\\<tau>Red0t P t h (e, es) (e'', es'') \\<Longrightarrow> red0_mthr.silent_movet P t ((e, es), h) ((e'', es''), h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>Red0t P t h (e, es) (e'', es'') \\<Longrightarrow>\n    red0_mthr.silent_movet P t ((e, es), h) ((e'', es''), h)", "apply(induct rule: tranclp_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<tau>Red0 P t h (e, es) (a, b) \\<Longrightarrow>\n       red0_mthr.silent_movet P t ((e, es), h) ((a, b), h)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<tau>Red0t P t h (e, es) (a, b);\n        \\<tau>Red0 P t h (a, b) (aa, ba);\n        red0_mthr.silent_movet P t ((e, es), h) ((a, b), h)\\<rbrakk>\n       \\<Longrightarrow> red0_mthr.silent_movet P t ((e, es), h)\n                          ((aa, ba), h)", "apply(fastforce simp add: red0_mthr.silent_move_iff elim: tranclp.trancl_into_trancl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}