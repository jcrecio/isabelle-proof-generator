{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWCondAction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma cond_action_oks_append [simp]:\n  \"cond_action_oks s t (cts @ cts') \\<longleftrightarrow> cond_action_oks s t cts \\<and> cond_action_oks s t cts'\"", "lemma cond_action_oks_conv_set:\n  \"cond_action_oks s t cts \\<longleftrightarrow> (\\<forall>ct \\<in> set cts. cond_action_ok s t ct)\"", "lemma cond_action_ok_Join:\n  \"\\<And>ln. \\<lbrakk> cond_action_ok s t (Join T); thr s T = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> final x \\<and> ln = no_wait_locks \\<and> wset s T = None\"", "lemma cond_action_oks_Join:\n  \"\\<And>ln. \\<lbrakk> cond_action_oks s t cas; Join T \\<in> set cas; thr s T = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \n  \\<Longrightarrow> final x \\<and> ln = no_wait_locks \\<and> wset s T = None \\<and> t \\<noteq> T\"", "lemma cond_action_oks_upd:\n  assumes tst: \"thr s t = \\<lfloor>xln\\<rfloor>\"\n  shows \"cond_action_oks (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t cas = cond_action_oks s t cas\"", "lemma cond_action_ok_shr_change:\n  \"cond_action_ok (ls, (ts, m), ws, is) t ct \\<Longrightarrow> cond_action_ok (ls, (ts, m'), ws, is) t ct\"", "lemma cond_action_oks_shr_change:\n  \"cond_action_oks (ls, (ts, m), ws, is) t cts \\<Longrightarrow> cond_action_oks (ls, (ts, m'), ws, is) t cts\"", "lemma cond_action_oks'_append [simp]:\n  \"cond_action_oks' s t (cts @ cts') \\<longleftrightarrow> cond_action_oks' s t cts \\<and> cond_action_oks' s t cts'\"", "lemma cond_action_oks'_subset_Join:\n  \"set cts \\<subseteq> insert Yield (range Join) \\<Longrightarrow> cond_action_oks' s t cts\"", "lemma cond_action_ok_final_change:\n  \"\\<lbrakk> final_thread.cond_action_ok final1 s1 t ca;\n     \\<And>t. thr s1 t = None \\<longleftrightarrow> thr s2 t = None; \n     \\<And>t x1. \\<lbrakk> thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>; final1 x1; wset s1 t = None \\<rbrakk> \n     \\<Longrightarrow> \\<exists>x2. thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor> \\<and> final2 x2 \\<and> ln2 = no_wait_locks \\<and> wset s2 t = None \\<rbrakk>\n  \\<Longrightarrow> final_thread.cond_action_ok final2 s2 t ca\"", "lemma cond_action_oks_final_change:\n  assumes major: \"final_thread.cond_action_oks final1 s1 t cas\"\n  and minor: \"\\<And>t. thr s1 t = None \\<longleftrightarrow> thr s2 t = None\"\n    \"\\<And>t x1. \\<lbrakk> thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>; final1 x1; wset s1 t = None \\<rbrakk> \n     \\<Longrightarrow> \\<exists>x2. thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor> \\<and> final2 x2 \\<and> ln2 = no_wait_locks \\<and> wset s2 t = None\"\n  shows \"final_thread.cond_action_oks final2 s2 t cas\""], "translations": [["", "lemma cond_action_oks_append [simp]:\n  \"cond_action_oks s t (cts @ cts') \\<longleftrightarrow> cond_action_oks s t cts \\<and> cond_action_oks s t cts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_action_oks s t (cts @ cts') =\n    (cond_action_oks s t cts \\<and> cond_action_oks s t cts')", "by(induct cts, auto)"], ["", "lemma cond_action_oks_conv_set:\n  \"cond_action_oks s t cts \\<longleftrightarrow> (\\<forall>ct \\<in> set cts. cond_action_ok s t ct)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_action_oks s t cts =\n    (\\<forall>ct\\<in>set cts. cond_action_ok s t ct)", "by(induct cts) simp_all"], ["", "lemma cond_action_ok_Join:\n  \"\\<And>ln. \\<lbrakk> cond_action_ok s t (Join T); thr s T = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> final x \\<and> ln = no_wait_locks \\<and> wset s T = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>cond_action_ok s t (Join T);\n        thr s T = \\<lfloor>(x, ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> final x \\<and>\n                         ln = no_wait_locks \\<and> wset s T = None", "by(auto)"], ["", "lemma cond_action_oks_Join:\n  \"\\<And>ln. \\<lbrakk> cond_action_oks s t cas; Join T \\<in> set cas; thr s T = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \n  \\<Longrightarrow> final x \\<and> ln = no_wait_locks \\<and> wset s T = None \\<and> t \\<noteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>cond_action_oks s t cas; Join T \\<in> set cas;\n        thr s T = \\<lfloor>(x, ln)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> final x \\<and>\n                         ln = no_wait_locks \\<and>\n                         wset s T = None \\<and> t \\<noteq> T", "by(induct cas)(auto)"], ["", "lemma cond_action_oks_upd:\n  assumes tst: \"thr s t = \\<lfloor>xln\\<rfloor>\"\n  shows \"cond_action_oks (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t cas = cond_action_oks s t cas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_action_oks\n     (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n     cas =\n    cond_action_oks s t cas", "proof(induct cas)"], ["proof (state)\ngoal (2 subgoals):\n 1. cond_action_oks\n     (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n     [] =\n    cond_action_oks s t []\n 2. \\<And>a cas.\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        cas =\n       cond_action_oks s t cas \\<Longrightarrow>\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        (a # cas) =\n       cond_action_oks s t (a # cas)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. cond_action_oks\n     (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n     [] =\n    cond_action_oks s t []\n 2. \\<And>a cas.\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        cas =\n       cond_action_oks s t cas \\<Longrightarrow>\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        (a # cas) =\n       cond_action_oks s t (a # cas)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_action_oks\n     (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n     [] =\n    cond_action_oks s t []", "by simp"], ["proof (state)\nthis:\n  cond_action_oks\n   (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t [] =\n  cond_action_oks s t []\n\ngoal (1 subgoal):\n 1. \\<And>a cas.\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        cas =\n       cond_action_oks s t cas \\<Longrightarrow>\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        (a # cas) =\n       cond_action_oks s t (a # cas)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cas.\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        cas =\n       cond_action_oks s t cas \\<Longrightarrow>\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        (a # cas) =\n       cond_action_oks s t (a # cas)", "case (Cons ca cas)"], ["proof (state)\nthis:\n  cond_action_oks\n   (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t cas =\n  cond_action_oks s t cas\n\ngoal (1 subgoal):\n 1. \\<And>a cas.\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        cas =\n       cond_action_oks s t cas \\<Longrightarrow>\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        (a # cas) =\n       cond_action_oks s t (a # cas)", "from tst"], ["proof (chain)\npicking this:\n  thr s t = \\<lfloor>xln\\<rfloor>", "have eq: \"cond_action_ok (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t ca = cond_action_ok s t ca\""], ["proof (prove)\nusing this:\n  thr s t = \\<lfloor>xln\\<rfloor>\n\ngoal (1 subgoal):\n 1. cond_action_ok\n     (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n     ca =\n    cond_action_ok s t ca", "by(cases ca) auto"], ["proof (state)\nthis:\n  cond_action_ok\n   (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t ca =\n  cond_action_ok s t ca\n\ngoal (1 subgoal):\n 1. \\<And>a cas.\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        cas =\n       cond_action_oks s t cas \\<Longrightarrow>\n       cond_action_oks\n        (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n        (a # cas) =\n       cond_action_oks s t (a # cas)", "with Cons"], ["proof (chain)\npicking this:\n  cond_action_oks\n   (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t cas =\n  cond_action_oks s t cas\n  cond_action_ok\n   (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t ca =\n  cond_action_ok s t ca", "show ?case"], ["proof (prove)\nusing this:\n  cond_action_oks\n   (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t cas =\n  cond_action_oks s t cas\n  cond_action_ok\n   (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t ca =\n  cond_action_ok s t ca\n\ngoal (1 subgoal):\n 1. cond_action_oks\n     (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n     (ca # cas) =\n    cond_action_oks s t (ca # cas)", "by(auto simp del: fun_upd_apply)"], ["proof (state)\nthis:\n  cond_action_oks\n   (locks s, (thr s(t \\<mapsto> xln'), shr s), wset s, interrupts s) t\n   (ca # cas) =\n  cond_action_oks s t (ca # cas)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cond_action_ok_shr_change:\n  \"cond_action_ok (ls, (ts, m), ws, is) t ct \\<Longrightarrow> cond_action_ok (ls, (ts, m'), ws, is) t ct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_action_ok (ls, (ts, m), ws, is) t ct \\<Longrightarrow>\n    cond_action_ok (ls, (ts, m'), ws, is) t ct", "by(cases ct) auto"], ["", "lemma cond_action_oks_shr_change:\n  \"cond_action_oks (ls, (ts, m), ws, is) t cts \\<Longrightarrow> cond_action_oks (ls, (ts, m'), ws, is) t cts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_action_oks (ls, (ts, m), ws, is) t cts \\<Longrightarrow>\n    cond_action_oks (ls, (ts, m'), ws, is) t cts", "by(auto simp add: cond_action_oks_conv_set intro: cond_action_ok_shr_change)"], ["", "primrec cond_action_ok' :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't \\<Rightarrow> 't conditional_action \\<Rightarrow> bool\" \nwhere\n  \"cond_action_ok' _ _ (Join t) = True\"\n| \"cond_action_ok' _ _ Yield = True\""], ["", "primrec cond_action_oks' :: \"('l,'t,'x,'m,'w) state \\<Rightarrow> 't \\<Rightarrow> 't conditional_action list \\<Rightarrow> bool\" where\n  \"cond_action_oks' s t [] = True\"\n| \"cond_action_oks' s t (ct#cts) = (cond_action_ok' s t ct \\<and> cond_action_oks' s t cts)\""], ["", "lemma cond_action_oks'_append [simp]:\n  \"cond_action_oks' s t (cts @ cts') \\<longleftrightarrow> cond_action_oks' s t cts \\<and> cond_action_oks' s t cts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_action_oks' s t (cts @ cts') =\n    (cond_action_oks' s t cts \\<and> cond_action_oks' s t cts')", "by(induct cts, auto)"], ["", "lemma cond_action_oks'_subset_Join:\n  \"set cts \\<subseteq> insert Yield (range Join) \\<Longrightarrow> cond_action_oks' s t cts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set cts \\<subseteq> insert Yield (range Join) \\<Longrightarrow>\n    cond_action_oks' s t cts", "apply(induct cts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> insert Yield (range Join) \\<Longrightarrow>\n    cond_action_oks' s t []\n 2. \\<And>a cts.\n       \\<lbrakk>set cts\n                \\<subseteq> insert Yield (range Join) \\<Longrightarrow>\n                cond_action_oks' s t cts;\n        set (a # cts) \\<subseteq> insert Yield (range Join)\\<rbrakk>\n       \\<Longrightarrow> cond_action_oks' s t (a # cts)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition collect_cond_actions :: \"'t conditional_action list \\<Rightarrow> 't set\" where\n  \"collect_cond_actions cts = {t. Join t \\<in> set cts}\""], ["", "declare collect_cond_actions_def [simp]"], ["", "lemma cond_action_ok_final_change:\n  \"\\<lbrakk> final_thread.cond_action_ok final1 s1 t ca;\n     \\<And>t. thr s1 t = None \\<longleftrightarrow> thr s2 t = None; \n     \\<And>t x1. \\<lbrakk> thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>; final1 x1; wset s1 t = None \\<rbrakk> \n     \\<Longrightarrow> \\<exists>x2. thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor> \\<and> final2 x2 \\<and> ln2 = no_wait_locks \\<and> wset s2 t = None \\<rbrakk>\n  \\<Longrightarrow> final_thread.cond_action_ok final2 s2 t ca\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>final_thread.cond_action_ok final1 s1 t ca;\n     \\<And>t. (thr s1 t = None) = (thr s2 t = None);\n     \\<And>t x1.\n        \\<lbrakk>thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>;\n         final1 x1; wset s1 t = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x2.\n                             thr s2 t =\n                             \\<lfloor>(x2, no_wait_locks)\\<rfloor> \\<and>\n                             final2 x2 \\<and>\n                             ln2 = no_wait_locks \\<and>\n                             wset s2 t = None\\<rbrakk>\n    \\<Longrightarrow> final_thread.cond_action_ok final2 s2 t ca", "apply(cases ca)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>final_thread.cond_action_ok final1 s1 t ca;\n        \\<And>t. (thr s1 t = None) = (thr s2 t = None);\n        \\<And>t x1.\n           \\<lbrakk>thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>;\n            final1 x1; wset s1 t = None\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x2.\n                                thr s2 t =\n                                \\<lfloor>(x2, no_wait_locks)\\<rfloor> \\<and>\n                                final2 x2 \\<and>\n                                ln2 = no_wait_locks \\<and> wset s2 t = None;\n        ca = Join x1\\<rbrakk>\n       \\<Longrightarrow> final_thread.cond_action_ok final2 s2 t ca\n 2. \\<lbrakk>final_thread.cond_action_ok final1 s1 t ca;\n     \\<And>t. (thr s1 t = None) = (thr s2 t = None);\n     \\<And>t x1.\n        \\<lbrakk>thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>;\n         final1 x1; wset s1 t = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x2.\n                             thr s2 t =\n                             \\<lfloor>(x2, no_wait_locks)\\<rfloor> \\<and>\n                             final2 x2 \\<and>\n                             ln2 = no_wait_locks \\<and> wset s2 t = None;\n     ca = Yield\\<rbrakk>\n    \\<Longrightarrow> final_thread.cond_action_ok final2 s2 t ca", "apply(fastforce simp add: final_thread.cond_action_ok.simps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cond_action_oks_final_change:\n  assumes major: \"final_thread.cond_action_oks final1 s1 t cas\"\n  and minor: \"\\<And>t. thr s1 t = None \\<longleftrightarrow> thr s2 t = None\"\n    \"\\<And>t x1. \\<lbrakk> thr s1 t = \\<lfloor>(x1, no_wait_locks)\\<rfloor>; final1 x1; wset s1 t = None \\<rbrakk> \n     \\<Longrightarrow> \\<exists>x2. thr s2 t = \\<lfloor>(x2, no_wait_locks)\\<rfloor> \\<and> final2 x2 \\<and> ln2 = no_wait_locks \\<and> wset s2 t = None\"\n  shows \"final_thread.cond_action_oks final2 s2 t cas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final_thread.cond_action_oks final2 s2 t cas", "using major"], ["proof (prove)\nusing this:\n  final_thread.cond_action_oks final1 s1 t cas\n\ngoal (1 subgoal):\n 1. final_thread.cond_action_oks final2 s2 t cas", "by(induct cas)(auto simp add: final_thread.cond_action_oks.simps intro: cond_action_ok_final_change[OF _ minor])"], ["", "end"]]}