{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Execute/Scheduler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma unfold_tllist' [code]:\n  \"unfold_tllist' f a =\n  (case f a of Inr c \\<Rightarrow> TNil c | Inl (b, a') \\<Rightarrow> TCons b (unfold_tllist' f a'))\"", "lemma pick_wakeup_spec_via_sel:\n  assumes sel: \"map_sel' ws_\\<alpha> ws_invar ws_sel\"\n  shows \"pick_wakeup_spec (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))) \\<sigma>_invar ws_\\<alpha> ws_invar\"", "lemma free_thread_id_correct [simp]:\n  \"thr_invar ts \\<Longrightarrow> free_thread_id ts = FWThread.free_thread_id (thr_\\<alpha> ts)\"", "lemma redT_updT_correct [simp]:\n  assumes \"thr_invar ts\"\n  shows \"thr_\\<alpha> (redT_updT ts nta) = FWThread.redT_updT (thr_\\<alpha> ts) nta\"\n  and \"thr_invar (redT_updT ts nta)\"", "lemma redT_updTs_correct [simp]:\n  assumes  \"thr_invar ts\"\n  shows \"thr_\\<alpha> (redT_updTs ts ntas) = FWThread.redT_updTs (thr_\\<alpha> ts) ntas\"\n  and \"thr_invar (redT_updTs ts ntas)\"", "lemma thread_ok_correct [simp]:\n  \"thr_invar ts \\<Longrightarrow> thread_ok ts nta \\<longleftrightarrow> FWThread.thread_ok (thr_\\<alpha> ts) nta\"", "lemma thread_oks_correct [simp]:\n  \"thr_invar ts \\<Longrightarrow> thread_oks ts ntas \\<longleftrightarrow> FWThread.thread_oks (thr_\\<alpha> ts) ntas\"", "lemma wset_actions_ok_correct [simp]:\n  \"ws_invar ws \\<Longrightarrow> wset_actions_ok ws t was \\<longleftrightarrow> FWWait.wset_actions_ok (ws_\\<alpha> ws) t was\"", "lemma cond_action_ok_correct [simp]:\n  \"state_invar s \\<Longrightarrow> cond_action_ok s t cta \\<longleftrightarrow> \\<alpha>.cond_action_ok (state_\\<alpha> s) t cta\"", "lemma cond_action_oks_correct [simp]:\n  assumes \"state_invar s\"\n  shows \"cond_action_oks s t ctas \\<longleftrightarrow> \\<alpha>.cond_action_oks (state_\\<alpha> s) t ctas\"", "lemma redT_updI_correct [simp]:\n  assumes \"is_invar is\"\n  shows \"is_\\<alpha> (redT_updI is ia) = FWInterrupt.redT_updI (is_\\<alpha> is) ia\"\n  and \"is_invar (redT_updI is ia)\"", "lemma redT_updIs_correct [simp]:\n  assumes \"is_invar is\"\n  shows \"is_\\<alpha> (redT_updIs is ias) = FWInterrupt.redT_updIs (is_\\<alpha> is) ias\"\n  and \"is_invar (redT_updIs is ias)\"", "lemma interrupt_action_ok_correct [simp]:\n  \"is_invar is \\<Longrightarrow> interrupt_action_ok is ia \\<longleftrightarrow> FWInterrupt.interrupt_action_ok (is_\\<alpha> is) ia\"", "lemma interrupt_actions_ok_correct [simp]:\n  \"is_invar is \\<Longrightarrow> interrupt_actions_ok is ias \\<longleftrightarrow> FWInterrupt.interrupt_actions_ok (is_\\<alpha> is) ias\"", "lemma actions_ok_correct [simp]:\n  \"state_invar s \\<Longrightarrow> actions_ok s t ta \\<longleftrightarrow> \\<alpha>.actions_ok (state_\\<alpha> s) t ta\"", "lemma exec_updW_correct:\n  assumes invar: \"ws_invar ws\" \"\\<sigma>_invar \\<sigma> T\" \"dom (ws_\\<alpha> ws) \\<subseteq> T\" \"t \\<in> T\"\n  shows \"redT_updW t (ws_\\<alpha> ws) wa (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\" (is \"?thesis1\")\n  and \"ws_invar (exec_updW \\<sigma> t ws wa)\" (is \"?thesis2\")", "lemma exec_updWs_correct:\n  assumes \"ws_invar ws\" \"\\<sigma>_invar \\<sigma> T\" \"dom (ws_\\<alpha> ws) \\<subseteq> T\" \"t \\<in> T\"\n  shows \"redT_updWs t (ws_\\<alpha> ws) was (ws_\\<alpha> (exec_updWs \\<sigma> t ws was))\" (is \"?thesis1\")\n  and \"ws_invar (exec_updWs \\<sigma> t ws was)\" (is \"?thesis2\")", "lemma exec_upd_correct:\n  assumes \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"t \\<in> (dom (thr_\\<alpha> (thr s)))\"\n  and \"wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\"\n  shows \"redT_upd (state_\\<alpha> s) t ta x' m' (state_\\<alpha> (exec_upd \\<sigma> s t ta x' m'))\"\n  and \"state_invar (exec_upd \\<sigma> s t ta x' m')\"", "lemma execT_None:\n  assumes invar: \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and exec: \"execT \\<sigma> s = None\"\n  shows \"\\<alpha>.active_threads (state_\\<alpha> s) = {}\"", "lemma execT_Some:\n  assumes invar: \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and wstok: \"wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\"\n  and exec: \"execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\"\n  shows \"\\<alpha>.redT (state_\\<alpha> s) (t, ta) (state_\\<alpha> s')\" (is \"?thesis1\")\n  and \"state_invar s'\" (is \"?thesis2\")\n  and \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\" (is \"?thesis3\")", "lemma exec_step_into_redT:\n  assumes invar: \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and wstok: \"wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\"\n  and exec: \"exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\"\n  shows \"\\<alpha>.redT (state_\\<alpha> s) (t, ta) (state_\\<alpha> s')\" \"\\<sigma>'' = \\<sigma>\"\n  and \"state_invar s'\" \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\" \"state_\\<alpha> s' \\<in> invariant\"", "lemma exec_step_InrD:\n  assumes \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and \"exec_step (\\<sigma>, s) = Inr s'\"\n  shows \"\\<alpha>.active_threads (state_\\<alpha> s) = {}\"\n  and \"s' = s\"", "lemma (in multithreaded_base) red_in_active_threads:\n  assumes \"s -t\\<triangleright>ta\\<rightarrow> s'\"\n  shows \"t \\<in> active_threads s\"", "lemma exec_aux_into_Runs:\n  assumes \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and \"wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\"\n  shows \"\\<alpha>.mthr.Runs (state_\\<alpha> s) (lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))))\" (is ?thesis1)\n  and \"tfinite (exec_aux (\\<sigma>, s)) \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))\" (is \"_ \\<Longrightarrow> ?thesis2\")", "lemma active_threads_correct [simp]:\n  assumes \"state_invar s\"\n  shows \"thr'_\\<alpha> (active_threads s) = \\<alpha>.active_threads (state_\\<alpha> s)\" (is \"?thesis1\")\n  and \"thr'_invar (active_threads s)\" (is \"?thesis2\")", "lemma step_thread_NoneD:\n  \"step_thread update_state s t = None \\<Longrightarrow> t \\<notin> active_threads s\"", "lemma inactive_step_thread_eq_NoneI:\n  \"t \\<notin> active_threads s \\<Longrightarrow> step_thread update_state s t = None\"", "lemma step_thread_eq_None_conv:\n  \"step_thread update_state s t = None \\<longleftrightarrow> t \\<notin> active_threads s\"", "lemma step_thread_eq_Some_activeD:\n  \"step_thread update_state s t = \\<lfloor>(t', taxm\\<sigma>')\\<rfloor> \n  \\<Longrightarrow> t' = t \\<and> t \\<in> active_threads s\"", "lemma step_thread_Some_NoneD:\n  \"step_thread update_state s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  \\<Longrightarrow> \\<exists>x ln n. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln \\<and> \\<sigma>' = update_state (K$ [], [], [], [], [], convert_RA ln)\"", "lemma step_thread_Some_SomeD:\n  \"\\<lbrakk> deterministic I; step_thread update_state s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>; s \\<in> I \\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and> actions_ok s t ta \\<and> \\<sigma>' = update_state ta\"", "lemma deterministic_THE2:\n  assumes \"\\<alpha>.deterministic I\"\n  and tst: \"thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n  and red: \"Predicate.eval (r t (x, shr s)) (ta, x', m')\"\n  and aok: \"\\<alpha>.actions_ok (state_\\<alpha> s) t ta\"\n  and I: \"state_\\<alpha> s \\<in> I\"\n  shows \"Predicate.the (r t (x, shr s) \\<bind> (\\<lambda>(ta, x', m'). if \\<alpha>.actions_ok (state_\\<alpha> s) t ta then Predicate.single (ta, x', m') else bot)) = (ta, x', m')\"", "lemma step_thread_correct:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows\n  \"map_option (apsnd (apsnd \\<sigma>_\\<alpha>)) (step_thread update_state s t) = \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state) (state_\\<alpha> s) t\" (is ?thesis1)\n  and \"(\\<And>ta. FWThread.thread_oks (thr_\\<alpha> (thr s)) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow> \\<sigma>_invar (update_state ta) (dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<Longrightarrow> case_option True (\\<lambda>(t, taxm, \\<sigma>). \\<sigma>_invar \\<sigma> (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s)) | Some (ta, x', m') \\<Rightarrow> dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) (step_thread update_state s t)\"\n  (is \"(\\<And>ta. ?tso ta \\<Longrightarrow> ?inv ta) \\<Longrightarrow> ?thesis2\")", "lemma step_thread_eq_None_conv:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows \"step_thread update_state s t = None \\<longleftrightarrow> t \\<notin> \\<alpha>.active_threads (state_\\<alpha> s)\"", "lemma step_thread_Some_NoneD:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and step: \"step_thread update_state s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  and invar: \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows \"\\<exists>x ln n. thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and> may_acquire_all (locks s) t ln \\<and> \\<sigma>' = update_state (K$ [], [], [], [], [], convert_RA ln)\"", "lemma step_thread_Some_SomeD:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and step: \"step_thread update_state s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and invar: \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows \"\\<exists>x. thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> Predicate.eval (r t (x, shr s)) (ta, x', m') \\<and> actions_ok s t ta \\<and> \\<sigma>' = update_state ta\"", "lemmas [code] =\n  scheduler_base_aux.free_thread_id_def\n  scheduler_base_aux.redT_updT.simps\n  scheduler_base_aux.redT_updTs_def\n  scheduler_base_aux.thread_ok.simps\n  scheduler_base_aux.thread_oks.simps\n  scheduler_base_aux.wset_actions_ok_def\n  scheduler_base_aux.cond_action_ok.simps\n  scheduler_base_aux.cond_action_oks_def\n  scheduler_base_aux.redT_updI.simps\n  scheduler_base_aux.redT_updIs.simps\n  scheduler_base_aux.interrupt_action_ok.simps\n  scheduler_base_aux.interrupt_actions_ok.simps\n  scheduler_base_aux.actions_ok_def\n  scheduler_base_aux.step_thread_def", "lemmas [code] =\n  scheduler_base.exec_updW.simps\n  scheduler_base.exec_updWs_def\n  scheduler_base.exec_upd_def\n  scheduler_base.execT_def\n  scheduler_base.exec_step.simps\n  scheduler_base.exec_aux_def\n  scheduler_base.exec_def", "lemmas [code] =\n  scheduler_ext_base.active_threads.simps", "lemma singleton2_code [code]:\n  \"singleton2 dfault (Predicate.Seq f) =\n  (case f () of\n    Predicate.Empty \\<Rightarrow> dfault ()\n  | Predicate.Insert x P \\<Rightarrow> \n    if Predicate.is_empty P then x else Code.abort (STR ''singleton2 not unique'') (\\<lambda>_. singleton2 dfault (Predicate.Seq f))\n  | Predicate.Join P xq \\<Rightarrow>\n    if Predicate.is_empty P then \n      the_only2 dfault xq\n    else if Predicate.null xq then singleton2 dfault P else Code.abort (STR ''singleton2 not unique'') (\\<lambda>_. singleton2 dfault (Predicate.Seq f)))\"", "lemma the_only2_code [code]:\n  \"the_only2 dfault Predicate.Empty = Code.abort (STR ''the_only2 empty'') dfault\"\n  \"the_only2 dfault (Predicate.Insert x P) = \n  (if Predicate.is_empty P then x else Code.abort (STR ''the_only2 not unique'') (\\<lambda>_. the_only2 dfault (Predicate.Insert x P)))\"\n  \"the_only2 dfault (Predicate.Join P xq) = \n  (if Predicate.is_empty P then \n     the_only2 dfault xq\n   else if Predicate.null xq then \n     singleton2 dfault P \n   else\n     Code.abort (STR ''the_only2 not unique'') (\\<lambda>_. the_only2 dfault (Predicate.Join P xq)))\"", "lemma the2_eq [code]:\n  \"the2 A = singleton2 (\\<lambda>x. Code.abort (STR ''not_unique'') (\\<lambda>_. the2 A)) A\""], "translations": [["", "lemma unfold_tllist' [code]:\n  \"unfold_tllist' f a =\n  (case f a of Inr c \\<Rightarrow> TNil c | Inl (b, a') \\<Rightarrow> TCons b (unfold_tllist' f a'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_tllist' f a =\n    (case f a of Inl (b, a') \\<Rightarrow> TCons b (unfold_tllist' f a')\n     | Inr c \\<Rightarrow> TNil c)", "by(rule tllist.expand)(auto simp add: unfold_tllist'_def split: sum.split_asm)"], ["", "type_synonym\n  ('l,'t,'x,'m,'w,'o,'m_t,'m_w,'s_i,'s) scheduler = \n    \"'s \\<Rightarrow> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> ('t \\<times> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) option \\<times> 's) option\""], ["", "locale scheduler_spec_base =\n  state_refine_base\n    final r convert_RA\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar \n    is_\\<alpha> is_invar\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and schedule :: \"('l,'t,'x,'m,'w,'o,'m_t,'m_w,'s_i,'s) scheduler\"\n  and \\<sigma>_invar :: \"'s \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\""], ["", "locale scheduler_spec = \n  scheduler_spec_base\n    final r convert_RA\n    schedule \\<sigma>_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar \n    is_\\<alpha> is_invar\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and schedule :: \"('l,'t,'x,'m,'w,'o,'m_t,'m_w,'s_i,'s) scheduler\"\n  and \\<sigma>_invar :: \"'s \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  +\n  fixes invariant :: \"('l,'t,'x,'m,'w) state set\"\n  assumes schedule_NoneD:\n  \"\\<lbrakk> schedule \\<sigma> s = None; state_invar s; \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))); state_\\<alpha> s \\<in> invariant \\<rbrakk>\n  \\<Longrightarrow> \\<alpha>.active_threads (state_\\<alpha> s) = {}\"\n  and schedule_Some_NoneD:\n  \"\\<lbrakk> schedule \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>; state_invar s; \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))); state_\\<alpha> s \\<in> invariant \\<rbrakk> \n  \\<Longrightarrow> \\<exists>x ln n. thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and> may_acquire_all (locks s) t ln\"\n  and schedule_Some_SomeD:\n  \"\\<lbrakk> schedule \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>; state_invar s; \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))); state_\\<alpha> s \\<in> invariant \\<rbrakk> \n  \\<Longrightarrow> \\<exists>x. thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> Predicate.eval (r t (x, shr s)) (ta, x', m') \\<and> \n         \\<alpha>.actions_ok (state_\\<alpha> s) t ta\"\n  and schedule_invar_None:\n  \"\\<lbrakk> schedule \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>; state_invar s; \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))); state_\\<alpha> s \\<in> invariant \\<rbrakk>\n  \\<Longrightarrow> \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s)))\"\n  and schedule_invar_Some:\n  \"\\<lbrakk> schedule \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>; state_invar s; \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))); state_\\<alpha> s \\<in> invariant \\<rbrakk>\n  \\<Longrightarrow> \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\""], ["", "locale pick_wakeup_spec_base =\n  state_refine_base\n    final r convert_RA\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar \n    is_\\<alpha> is_invar\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and pick_wakeup :: \"'s \\<Rightarrow> 't \\<Rightarrow> 'w \\<Rightarrow> 'm_w \\<Rightarrow> 't option\"\n  and \\<sigma>_invar :: \"'s \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\""], ["", "locale pick_wakeup_spec =\n  pick_wakeup_spec_base \n    final r convert_RA\n    pick_wakeup \\<sigma>_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar\n    is_\\<alpha> is_invar\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and pick_wakeup :: \"'s \\<Rightarrow> 't \\<Rightarrow> 'w \\<Rightarrow> 'm_w \\<Rightarrow> 't option\"\n  and \\<sigma>_invar :: \"'s \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  +\n  assumes pick_wakeup_NoneD:\n  \"\\<lbrakk> pick_wakeup \\<sigma> t w ws = None; ws_invar ws; \\<sigma>_invar \\<sigma> T; dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T \\<rbrakk> \n  \\<Longrightarrow> InWS w \\<notin> ran (ws_\\<alpha> ws)\"\n  and pick_wakeup_SomeD:\n  \"\\<lbrakk> pick_wakeup \\<sigma> t w ws = \\<lfloor>t'\\<rfloor>; ws_invar ws; \\<sigma>_invar \\<sigma> T; dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T \\<rbrakk>\n  \\<Longrightarrow> ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>\""], ["", "locale scheduler_base_aux =\n  state_refine_base\n    final r convert_RA\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar\n    is_\\<alpha> is_invar\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\nbegin"], ["", "definition free_thread_id :: \"'m_t \\<Rightarrow> 't \\<Rightarrow> bool\"\nwhere \"free_thread_id ts t \\<longleftrightarrow> thr_lookup t ts = None\""], ["", "fun redT_updT :: \"'m_t \\<Rightarrow> ('t,'x,'m) new_thread_action \\<Rightarrow> 'm_t\"\nwhere\n  \"redT_updT ts (NewThread t' x m) = thr_update t' (x, no_wait_locks) ts\"\n| \"redT_updT ts _ = ts\""], ["", "definition redT_updTs :: \"'m_t \\<Rightarrow> ('t,'x,'m) new_thread_action list \\<Rightarrow> 'm_t\"\nwhere \"redT_updTs = foldl redT_updT\""], ["", "primrec thread_ok :: \"'m_t \\<Rightarrow> ('t,'x,'m) new_thread_action \\<Rightarrow> bool\"\nwhere\n  \"thread_ok ts (NewThread t x m) = free_thread_id ts t\"\n| \"thread_ok ts (ThreadExists t b) = (b \\<noteq> free_thread_id ts t)\""], ["", "text \\<open>\n  We use @{term \"redT_updT\"} in \\<open>thread_ok\\<close> instead of @{term \"redT_updT'\"} like in theory @{theory JinjaThreads.FWThread}.\n  This fixes @{typ \"'x\"} in the @{typ \"('t,'x,'m) new_thread_action list\"} type, but avoids @{term \"undefined\"},\n  which raises an exception during execution in the generated code.\n\\<close>"], ["", "primrec thread_oks :: \"'m_t \\<Rightarrow> ('t,'x,'m) new_thread_action list \\<Rightarrow> bool\"\nwhere\n  \"thread_oks ts [] = True\"\n| \"thread_oks ts (ta#tas) = (thread_ok ts ta \\<and> thread_oks (redT_updT ts ta) tas)\""], ["", "definition wset_actions_ok :: \"'m_w \\<Rightarrow> 't \\<Rightarrow> ('t,'w) wait_set_action list \\<Rightarrow> bool\"\nwhere\n  \"wset_actions_ok ws t was \\<longleftrightarrow>\n   ws_lookup t ws = \n   (if Notified \\<in> set was then \\<lfloor>PostWS WSNotified\\<rfloor>\n    else if WokenUp \\<in> set was then \\<lfloor>PostWS WSWokenUp\\<rfloor>\n    else None)\""], ["", "primrec cond_action_ok :: \"('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> 't \\<Rightarrow> 't conditional_action \\<Rightarrow> bool\" \nwhere\n  \"\\<And>ln. cond_action_ok s t (Join T) = \n   (case thr_lookup T (thr s)\n      of None \\<Rightarrow> True \n    | \\<lfloor>(x, ln)\\<rfloor> \\<Rightarrow> t \\<noteq> T \\<and> final x \\<and> ln = no_wait_locks \\<and> ws_lookup T (wset s) = None)\"\n| \"cond_action_ok s t Yield = True\""], ["", "definition cond_action_oks :: \"('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> 't \\<Rightarrow> 't conditional_action list \\<Rightarrow> bool\" \nwhere\n  \"cond_action_oks s t cts = list_all (cond_action_ok s t) cts\""], ["", "primrec redT_updI :: \"'s_i \\<Rightarrow> 't interrupt_action \\<Rightarrow> 's_i\"\nwhere\n  \"redT_updI is (Interrupt t) = is_ins t is\"\n| \"redT_updI is (ClearInterrupt t) = is_delete t is\"\n| \"redT_updI is (IsInterrupted t b) = is\""], ["", "primrec redT_updIs :: \"'s_i \\<Rightarrow> 't interrupt_action list \\<Rightarrow> 's_i\"\nwhere\n  \"redT_updIs is [] = is\"\n| \"redT_updIs is (ia # ias) = redT_updIs (redT_updI is ia) ias\""], ["", "primrec interrupt_action_ok :: \"'s_i \\<Rightarrow> 't interrupt_action \\<Rightarrow> bool\"\nwhere\n  \"interrupt_action_ok is (Interrupt t) = True\"\n| \"interrupt_action_ok is (ClearInterrupt t) = True\"\n| \"interrupt_action_ok is (IsInterrupted t b) = (b = (is_memb t is))\""], ["", "primrec interrupt_actions_ok :: \"'s_i \\<Rightarrow> 't interrupt_action list \\<Rightarrow> bool\"\nwhere\n  \"interrupt_actions_ok is [] = True\"\n| \"interrupt_actions_ok is (ia # ias) \\<longleftrightarrow> interrupt_action_ok is ia \\<and> interrupt_actions_ok (redT_updI is ia) ias\""], ["", "definition actions_ok :: \"('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o') thread_action \\<Rightarrow> bool\"\nwhere\n  \"actions_ok s t ta \\<longleftrightarrow>\n   lock_ok_las (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> \\<and> \n   thread_oks (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<and>\n   cond_action_oks s t \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> \\<and>\n   wset_actions_ok (wset s) t \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<and>\n   interrupt_actions_ok (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>\""], ["", "end"], ["", "locale scheduler_base =\n  scheduler_base_aux\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  +\n  scheduler_spec_base\n    final r convert_RA\n    schedule \\<sigma>_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar \n    is_\\<alpha> is_invar\n  +\n  pick_wakeup_spec_base\n    final r convert_RA\n    pick_wakeup \\<sigma>_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar\n    is_\\<alpha> is_invar\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and schedule :: \"('l,'t,'x,'m,'w,'o,'m_t,'m_w,'s_i,'s) scheduler\"\n  and \"output\" :: \"'s \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\"\n  and pick_wakeup :: \"'s \\<Rightarrow> 't \\<Rightarrow> 'w \\<Rightarrow> 'm_w \\<Rightarrow> 't option\"\n  and \\<sigma>_invar :: \"'s \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and ws_update :: \"'t \\<Rightarrow> 'w wait_set_status \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_delete :: \"'t \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_iterate :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status, 'm_w) set_iterator\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\nbegin"], ["", "primrec exec_updW :: \"'s \\<Rightarrow> 't \\<Rightarrow> 'm_w \\<Rightarrow> ('t,'w) wait_set_action \\<Rightarrow> 'm_w\"\nwhere\n  \"exec_updW \\<sigma> t ws (Notify w) = \n   (case pick_wakeup \\<sigma> t w ws\n    of None  \\<Rightarrow> ws\n    | Some t \\<Rightarrow> ws_update t (PostWS WSNotified) ws)\"\n| \"exec_updW \\<sigma> t ws (NotifyAll w) =\n   ws_iterate ws (\\<lambda>_. True) (\\<lambda>(t, w') ws'. if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws') \n              ws\"\n| \"exec_updW \\<sigma> t ws (Suspend w) = ws_update t (InWS w) ws\"\n| \"exec_updW \\<sigma> t ws (WakeUp t') =\n   (case ws_lookup t' ws of \\<lfloor>InWS w\\<rfloor> \\<Rightarrow> ws_update t' (PostWS WSWokenUp) ws | _ \\<Rightarrow> ws)\"\n| \"exec_updW \\<sigma> t ws Notified = ws_delete t ws\"\n| \"exec_updW \\<sigma> t ws WokenUp = ws_delete t ws\""], ["", "definition exec_updWs :: \"'s \\<Rightarrow> 't \\<Rightarrow> 'm_w \\<Rightarrow> ('t,'w) wait_set_action list \\<Rightarrow> 'm_w\"\nwhere \"exec_updWs \\<sigma> t = foldl (exec_updW \\<sigma> t)\""], ["", "definition exec_upd ::\n  \"'s \\<Rightarrow> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'x \\<Rightarrow> 'm\n  \\<Rightarrow> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine\"\nwhere [simp]:\n  \"exec_upd \\<sigma> s t ta x' m' =\n   (redT_updLs (locks s) t \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>,\n    (thr_update t (x', redT_updLns (locks s) t (snd (the (thr_lookup t (thr s)))) \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub>) (redT_updTs (thr s) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>), m'),\n    exec_updWs \\<sigma> t (wset s) \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>, redT_updIs (interrupts s) \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub>)\""], ["", "definition execT :: \n  \"'s \\<Rightarrow> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine\n  \\<Rightarrow> ('s \\<times> 't \\<times> ('l,'t,'x,'m,'w,'o) thread_action \\<times> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine) option\"\nwhere \n  \"execT \\<sigma> s =\n  (do {\n     (t, tax'm', \\<sigma>') \\<leftarrow> schedule \\<sigma> s;\n     case tax'm' of\n       None \\<Rightarrow> \n       (let (x, ln) = the (thr_lookup t (thr s));\n            ta = (K$ [], [], [], [], [], convert_RA ln);\n            s' = (acquire_all (locks s) t ln, (thr_update t (x, no_wait_locks) (thr s), shr s), wset s, interrupts s)\n        in \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>)\n     | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow> \\<lfloor>(\\<sigma>', t, ta, exec_upd \\<sigma> s t ta x' m')\\<rfloor>\n   })\""], ["", "primrec exec_step :: \n  \"'s \\<times> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> \n   ('s \\<times> 't \\<times> ('l,'t,'x,'m,'w,'o) thread_action) \\<times> 's \\<times> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine + ('l,'t,'m,'m_t,'m_w,'s_i) state_refine\"\nwhere\n  \"exec_step (\\<sigma>, s) =\n   (case execT \\<sigma> s of \n      None \\<Rightarrow> Inr s\n    | Some (\\<sigma>', t, ta, s') \\<Rightarrow> Inl ((\\<sigma>, t, ta), \\<sigma>', s'))\""], ["", "declare exec_step.simps [simp del]"], ["", "definition exec_aux ::\n  \"'s \\<times> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine\n  \\<Rightarrow> ('s \\<times> 't \\<times> ('l,'t,'x,'m,'w,'o) thread_action, ('l,'t,'m,'m_t,'m_w,'s_i) state_refine) tllist\"\nwhere\n  \"exec_aux \\<sigma>s = unfold_tllist' exec_step \\<sigma>s\""], ["", "definition exec :: \"'s \\<Rightarrow> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> ('q, ('l,'t,'m,'m_t,'m_w,'s_i) state_refine) tllist\"\nwhere \n  \"exec \\<sigma> s = tmap the id (tfilter undefined (\\<lambda>q. q \\<noteq> None) (tmap (\\<lambda>(\\<sigma>, t, ta). output \\<sigma> t ta) id (exec_aux (\\<sigma>, s))))\""], ["", "end"], ["", "text \\<open>\n  Implement \\<open>pick_wakeup\\<close> by \\<open>map_sel'\\<close>\n\\<close>"], ["", "definition pick_wakeup_via_sel :: \n  \"('m_w \\<Rightarrow> ('t \\<Rightarrow> 'w wait_set_status \\<Rightarrow> bool) \\<rightharpoonup> 't \\<times> 'w wait_set_status) \n  \\<Rightarrow> 's \\<Rightarrow> 't \\<Rightarrow> 'w \\<Rightarrow> 'm_w \\<Rightarrow> 't option\"\nwhere \"pick_wakeup_via_sel ws_sel \\<sigma> t w ws = map_option fst (ws_sel ws (\\<lambda>t w'. w' = InWS w))\""], ["", "lemma pick_wakeup_spec_via_sel:\n  assumes sel: \"map_sel' ws_\\<alpha> ws_invar ws_sel\"\n  shows \"pick_wakeup_spec (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))) \\<sigma>_invar ws_\\<alpha> ws_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_wakeup_spec\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     \\<sigma>_invar ws_\\<alpha> ws_invar", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pick_wakeup_spec\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     \\<sigma>_invar ws_\\<alpha> ws_invar", "interpret ws: map_sel' ws_\\<alpha> ws_invar ws_sel"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sel' ws_\\<alpha> ws_invar ws_sel", "by(rule sel)"], ["proof (state)\ngoal (1 subgoal):\n 1. pick_wakeup_spec\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     \\<sigma>_invar ws_\\<alpha> ws_invar", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_wakeup_spec\n     (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n     \\<sigma>_invar ws_\\<alpha> ws_invar", "by(unfold_locales)(auto simp add: pick_wakeup_via_sel_def ran_def dest: ws.sel'_noneD ws.sel'_SomeD)"], ["proof (state)\nthis:\n  pick_wakeup_spec\n   (pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k, v). P k v)))\n   \\<sigma>_invar ws_\\<alpha> ws_invar\n\ngoal:\nNo subgoals!", "qed"], ["", "locale scheduler_ext_base =\n  scheduler_base_aux\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and thr_iterate :: \"'m_t \\<Rightarrow> ('t \\<times> ('x \\<times> 'l released_locks), 's_t) set_iterator\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and ws_update :: \"'t \\<Rightarrow> 'w wait_set_status \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_sel :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status \\<Rightarrow> bool) \\<rightharpoonup> ('t \\<times> 'w wait_set_status)\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  +\n  fixes thr'_\\<alpha> :: \"'s_t \\<Rightarrow> 't set\"\n  and thr'_invar :: \"'s_t \\<Rightarrow> bool\"\n  and thr'_empty :: \"unit \\<Rightarrow> 's_t\"\n  and thr'_ins_dj :: \"'t \\<Rightarrow> 's_t \\<Rightarrow> 's_t\"\nbegin"], ["", "abbreviation pick_wakeup :: \"'s \\<Rightarrow> 't \\<Rightarrow> 'w \\<Rightarrow> 'm_w \\<Rightarrow> 't option\"\nwhere \"pick_wakeup \\<equiv> pick_wakeup_via_sel (\\<lambda>s P. ws_sel s (\\<lambda>(k,v). P k v))\""], ["", "fun active_threads :: \"('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> 's_t\"\nwhere\n  \"active_threads (ls, (ts, m), ws, is) =\n   thr_iterate ts (\\<lambda>_. True)\n      (\\<lambda>(t, (x, ln)) ts'. if ln = no_wait_locks\n                       then if Predicate.holds \n                               (do {\n                                  (ta, _) \\<leftarrow> r t (x, m);\n                                  Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)\n                                })\n                            then thr'_ins_dj t ts'\n                            else ts'\n                       else if \\<not> waiting (ws_lookup t ws) \\<and> may_acquire_all ls t ln then thr'_ins_dj t ts' else ts')\n      (thr'_empty ())\""], ["", "end"], ["", "locale scheduler_aux =\n  scheduler_base_aux\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  +\n  thr: finite_map thr_\\<alpha> thr_invar +\n  thr: map_lookup thr_\\<alpha> thr_invar thr_lookup +\n  thr: map_update thr_\\<alpha> thr_invar thr_update +\n  ws: map ws_\\<alpha> ws_invar +\n  ws: map_lookup ws_\\<alpha> ws_invar ws_lookup +\n  \"is\": set is_\\<alpha> is_invar +\n  \"is\": set_memb is_\\<alpha> is_invar is_memb +\n  \"is\": set_ins is_\\<alpha> is_invar is_ins +\n  \"is\": set_delete is_\\<alpha> is_invar is_delete\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\nbegin"], ["", "lemma free_thread_id_correct [simp]:\n  \"thr_invar ts \\<Longrightarrow> free_thread_id ts = FWThread.free_thread_id (thr_\\<alpha> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr_invar ts \\<Longrightarrow>\n    local.free_thread_id ts = FWThread.free_thread_id (thr_\\<alpha> ts)", "by(auto simp add: free_thread_id_def fun_eq_iff thr.lookup_correct intro: free_thread_id.intros)"], ["", "lemma redT_updT_correct [simp]:\n  assumes \"thr_invar ts\"\n  shows \"thr_\\<alpha> (redT_updT ts nta) = FWThread.redT_updT (thr_\\<alpha> ts) nta\"\n  and \"thr_invar (redT_updT ts nta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr_\\<alpha> (local.redT_updT ts nta) =\n    FWThread.redT_updT (thr_\\<alpha> ts) nta &&&\n    thr_invar (local.redT_updT ts nta)", "by(case_tac [!] nta)(simp_all add: thr.update_correct assms)"], ["", "lemma redT_updTs_correct [simp]:\n  assumes  \"thr_invar ts\"\n  shows \"thr_\\<alpha> (redT_updTs ts ntas) = FWThread.redT_updTs (thr_\\<alpha> ts) ntas\"\n  and \"thr_invar (redT_updTs ts ntas)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr_\\<alpha> (local.redT_updTs ts ntas) =\n    FWThread.redT_updTs (thr_\\<alpha> ts) ntas &&&\n    thr_invar (local.redT_updTs ts ntas)", "using assms"], ["proof (prove)\nusing this:\n  thr_invar ts\n\ngoal (1 subgoal):\n 1. thr_\\<alpha> (local.redT_updTs ts ntas) =\n    FWThread.redT_updTs (thr_\\<alpha> ts) ntas &&&\n    thr_invar (local.redT_updTs ts ntas)", "by(induct ntas arbitrary: ts)(simp_all add: redT_updTs_def)"], ["", "lemma thread_ok_correct [simp]:\n  \"thr_invar ts \\<Longrightarrow> thread_ok ts nta \\<longleftrightarrow> FWThread.thread_ok (thr_\\<alpha> ts) nta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr_invar ts \\<Longrightarrow>\n    local.thread_ok ts nta = FWThread.thread_ok (thr_\\<alpha> ts) nta", "by(cases nta) simp_all"], ["", "lemma thread_oks_correct [simp]:\n  \"thr_invar ts \\<Longrightarrow> thread_oks ts ntas \\<longleftrightarrow> FWThread.thread_oks (thr_\\<alpha> ts) ntas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr_invar ts \\<Longrightarrow>\n    local.thread_oks ts ntas = FWThread.thread_oks (thr_\\<alpha> ts) ntas", "by(induct ntas arbitrary: ts) simp_all"], ["", "lemma wset_actions_ok_correct [simp]:\n  \"ws_invar ws \\<Longrightarrow> wset_actions_ok ws t was \\<longleftrightarrow> FWWait.wset_actions_ok (ws_\\<alpha> ws) t was\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws_invar ws \\<Longrightarrow>\n    local.wset_actions_ok ws t was =\n    FWWait.wset_actions_ok (ws_\\<alpha> ws) t was", "by(simp add: wset_actions_ok_def FWWait.wset_actions_ok_def ws.lookup_correct)"], ["", "lemma cond_action_ok_correct [simp]:\n  \"state_invar s \\<Longrightarrow> cond_action_ok s t cta \\<longleftrightarrow> \\<alpha>.cond_action_ok (state_\\<alpha> s) t cta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_invar s \\<Longrightarrow>\n    cond_action_ok s t cta =\n    \\<alpha>.cond_action_ok (state_\\<alpha> s) t cta", "by(cases s,cases cta)(auto simp add: thr.lookup_correct ws.lookup_correct)"], ["", "lemma cond_action_oks_correct [simp]:\n  assumes \"state_invar s\"\n  shows \"cond_action_oks s t ctas \\<longleftrightarrow> \\<alpha>.cond_action_oks (state_\\<alpha> s) t ctas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_action_oks s t ctas =\n    \\<alpha>.cond_action_oks (state_\\<alpha> s) t ctas", "by(induct ctas)(simp_all add: cond_action_oks_def assms)"], ["", "lemma redT_updI_correct [simp]:\n  assumes \"is_invar is\"\n  shows \"is_\\<alpha> (redT_updI is ia) = FWInterrupt.redT_updI (is_\\<alpha> is) ia\"\n  and \"is_invar (redT_updI is ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_\\<alpha> (local.redT_updI is ia) =\n    FWInterrupt.redT_updI (is_\\<alpha> is) ia &&&\n    is_invar (local.redT_updI is ia)", "using assms"], ["proof (prove)\nusing this:\n  is_invar is\n\ngoal (1 subgoal):\n 1. is_\\<alpha> (local.redT_updI is ia) =\n    FWInterrupt.redT_updI (is_\\<alpha> is) ia &&&\n    is_invar (local.redT_updI is ia)", "by(case_tac [!] ia)(auto simp add: is.ins_correct is.delete_correct)"], ["", "lemma redT_updIs_correct [simp]:\n  assumes \"is_invar is\"\n  shows \"is_\\<alpha> (redT_updIs is ias) = FWInterrupt.redT_updIs (is_\\<alpha> is) ias\"\n  and \"is_invar (redT_updIs is ias)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_\\<alpha> (local.redT_updIs is ias) =\n    FWInterrupt.redT_updIs (is_\\<alpha> is) ias &&&\n    is_invar (local.redT_updIs is ias)", "using assms"], ["proof (prove)\nusing this:\n  is_invar is\n\ngoal (1 subgoal):\n 1. is_\\<alpha> (local.redT_updIs is ias) =\n    FWInterrupt.redT_updIs (is_\\<alpha> is) ias &&&\n    is_invar (local.redT_updIs is ias)", "by(induct ias arbitrary: \"is\")(auto)"], ["", "lemma interrupt_action_ok_correct [simp]:\n  \"is_invar is \\<Longrightarrow> interrupt_action_ok is ia \\<longleftrightarrow> FWInterrupt.interrupt_action_ok (is_\\<alpha> is) ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar is \\<Longrightarrow>\n    local.interrupt_action_ok is ia =\n    FWInterrupt.interrupt_action_ok (is_\\<alpha> is) ia", "by(cases ia)(auto simp add: is.memb_correct)"], ["", "lemma interrupt_actions_ok_correct [simp]:\n  \"is_invar is \\<Longrightarrow> interrupt_actions_ok is ias \\<longleftrightarrow> FWInterrupt.interrupt_actions_ok (is_\\<alpha> is) ias\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar is \\<Longrightarrow>\n    local.interrupt_actions_ok is ias =\n    FWInterrupt.interrupt_actions_ok (is_\\<alpha> is) ias", "by(induct ias arbitrary:\"is\") simp_all"], ["", "lemma actions_ok_correct [simp]:\n  \"state_invar s \\<Longrightarrow> actions_ok s t ta \\<longleftrightarrow> \\<alpha>.actions_ok (state_\\<alpha> s) t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_invar s \\<Longrightarrow>\n    actions_ok s t ta = \\<alpha>.actions_ok (state_\\<alpha> s) t ta", "by(auto simp add: actions_ok_def)"], ["", "end"], ["", "locale scheduler =\n  scheduler_base \n    final r convert_RA\n    schedule \"output\" pick_wakeup \\<sigma>_invar\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  +\n  scheduler_aux\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  +\n  scheduler_spec\n    final r convert_RA\n    schedule \\<sigma>_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar\n    is_\\<alpha> is_invar\n    invariant\n  +\n  pick_wakeup_spec\n    final r convert_RA\n    pick_wakeup \\<sigma>_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar\n    is_\\<alpha> is_invar\n  +\n  ws: map_update ws_\\<alpha> ws_invar ws_update +\n  ws: map_delete ws_\\<alpha> ws_invar ws_delete +\n  ws: map_iteratei ws_\\<alpha> ws_invar ws_iterate \n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and schedule :: \"('l,'t,'x,'m,'w,'o,'m_t,'m_w,'s_i,'s) scheduler\"\n  and \"output\" :: \"'s \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\"\n  and pick_wakeup :: \"'s \\<Rightarrow> 't \\<Rightarrow> 'w \\<Rightarrow> 'm_w \\<Rightarrow> 't option\"\n  and \\<sigma>_invar :: \"'s \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and ws_update :: \"'t \\<Rightarrow> 'w wait_set_status \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_delete :: \"'t \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_iterate :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status, 'm_w) set_iterator\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and invariant :: \"('l,'t,'x,'m,'w) state set\"\n  +\n  assumes invariant: \"invariant3p \\<alpha>.redT invariant\"\nbegin"], ["", "lemma exec_updW_correct:\n  assumes invar: \"ws_invar ws\" \"\\<sigma>_invar \\<sigma> T\" \"dom (ws_\\<alpha> ws) \\<subseteq> T\" \"t \\<in> T\"\n  shows \"redT_updW t (ws_\\<alpha> ws) wa (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\" (is \"?thesis1\")\n  and \"ws_invar (exec_updW \\<sigma> t ws wa)\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) &&&\n    ws_invar (exec_updW \\<sigma> t ws wa)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n 2. ws_invar (exec_updW \\<sigma> t ws wa)", "from invar"], ["proof (chain)\npicking this:\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T", "have \"?thesis1 \\<and> ?thesis2\""], ["proof (prove)\nusing this:\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "proof(cases wa)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x2.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Notify x2\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 6. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "case [simp]: (Notify w)"], ["proof (state)\nthis:\n  wa = Notify w\n\ngoal (6 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x2.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Notify x2\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 6. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "proof(cases \"pick_wakeup \\<sigma> t w ws\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pick_wakeup \\<sigma> t w ws = None \\<Longrightarrow>\n    redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>a.\n       pick_wakeup \\<sigma> t w ws = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       redT_updW t (ws_\\<alpha> ws) wa\n        (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n       ws_invar (exec_updW \\<sigma> t ws wa)", "case (Some t')"], ["proof (state)\nthis:\n  pick_wakeup \\<sigma> t w ws = \\<lfloor>t'\\<rfloor>\n\ngoal (2 subgoals):\n 1. pick_wakeup \\<sigma> t w ws = None \\<Longrightarrow>\n    redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>a.\n       pick_wakeup \\<sigma> t w ws = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       redT_updW t (ws_\\<alpha> ws) wa\n        (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n       ws_invar (exec_updW \\<sigma> t ws wa)", "hence \"ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>\""], ["proof (prove)\nusing this:\n  pick_wakeup \\<sigma> t w ws = \\<lfloor>t'\\<rfloor>\n\ngoal (1 subgoal):\n 1. ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>", "using invar"], ["proof (prove)\nusing this:\n  pick_wakeup \\<sigma> t w ws = \\<lfloor>t'\\<rfloor>\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>", "by(rule pick_wakeup_SomeD)"], ["proof (state)\nthis:\n  ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>\n\ngoal (2 subgoals):\n 1. pick_wakeup \\<sigma> t w ws = None \\<Longrightarrow>\n    redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>a.\n       pick_wakeup \\<sigma> t w ws = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       redT_updW t (ws_\\<alpha> ws) wa\n        (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n       ws_invar (exec_updW \\<sigma> t ws wa)", "with Some"], ["proof (chain)\npicking this:\n  pick_wakeup \\<sigma> t w ws = \\<lfloor>t'\\<rfloor>\n  ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  pick_wakeup \\<sigma> t w ws = \\<lfloor>t'\\<rfloor>\n  ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "using invar"], ["proof (prove)\nusing this:\n  pick_wakeup \\<sigma> t w ws = \\<lfloor>t'\\<rfloor>\n  ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "by(auto simp add: ws.update_correct)"], ["proof (state)\nthis:\n  redT_updW t (ws_\\<alpha> ws) wa\n   (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n  ws_invar (exec_updW \\<sigma> t ws wa)\n\ngoal (1 subgoal):\n 1. pick_wakeup \\<sigma> t w ws = None \\<Longrightarrow>\n    redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pick_wakeup \\<sigma> t w ws = None \\<Longrightarrow>\n    redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "case None"], ["proof (state)\nthis:\n  pick_wakeup \\<sigma> t w ws = None\n\ngoal (1 subgoal):\n 1. pick_wakeup \\<sigma> t w ws = None \\<Longrightarrow>\n    redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "hence \"InWS w \\<notin> ran (ws_\\<alpha> ws)\""], ["proof (prove)\nusing this:\n  pick_wakeup \\<sigma> t w ws = None\n\ngoal (1 subgoal):\n 1. InWS w \\<notin> ran (ws_\\<alpha> ws)", "using invar"], ["proof (prove)\nusing this:\n  pick_wakeup \\<sigma> t w ws = None\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. InWS w \\<notin> ran (ws_\\<alpha> ws)", "by(rule pick_wakeup_NoneD)"], ["proof (state)\nthis:\n  InWS w \\<notin> ran (ws_\\<alpha> ws)\n\ngoal (1 subgoal):\n 1. pick_wakeup \\<sigma> t w ws = None \\<Longrightarrow>\n    redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "with None"], ["proof (chain)\npicking this:\n  pick_wakeup \\<sigma> t w ws = None\n  InWS w \\<notin> ran (ws_\\<alpha> ws)", "show ?thesis"], ["proof (prove)\nusing this:\n  pick_wakeup \\<sigma> t w ws = None\n  InWS w \\<notin> ran (ws_\\<alpha> ws)\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "using invar"], ["proof (prove)\nusing this:\n  pick_wakeup \\<sigma> t w ws = None\n  InWS w \\<notin> ran (ws_\\<alpha> ws)\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "by(auto simp add: ran_def)"], ["proof (state)\nthis:\n  redT_updW t (ws_\\<alpha> ws) wa\n   (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n  ws_invar (exec_updW \\<sigma> t ws wa)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  redT_updW t (ws_\\<alpha> ws) wa\n   (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n  ws_invar (exec_updW \\<sigma> t ws wa)\n\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "case [simp]: (NotifyAll w)"], ["proof (state)\nthis:\n  wa = NotifyAll w\n\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "let ?f = \"\\<lambda>(t, w') ws'. if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws'\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "let ?I = \"\\<lambda>T ws'. (\\<forall>k. if k\\<notin>T \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor> then ws_\\<alpha> ws' k = \\<lfloor>PostWS WSNotified\\<rfloor> else ws_\\<alpha> ws' k = ws_\\<alpha> ws k) \\<and> ws_invar ws'\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "from invar"], ["proof (chain)\npicking this:\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T", "have \"?I (dom (ws_\\<alpha> ws)) ws\""], ["proof (prove)\nusing this:\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<forall>k.\n        if k \\<notin> dom (ws_\\<alpha> ws) \\<and>\n           ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n        then ws_\\<alpha> ws k = \\<lfloor>PostWS WSNotified\\<rfloor>\n        else ws_\\<alpha> ws k = ws_\\<alpha> ws k) \\<and>\n    ws_invar ws", "by(auto simp add: ws.lookup_correct)"], ["proof (state)\nthis:\n  (\\<forall>k.\n      if k \\<notin> dom (ws_\\<alpha> ws) \\<and>\n         ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws\n\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "with \\<open>ws_invar ws\\<close>"], ["proof (chain)\npicking this:\n  ws_invar ws\n  (\\<forall>k.\n      if k \\<notin> dom (ws_\\<alpha> ws) \\<and>\n         ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws", "have \"?I {} (ws_iterate ws (\\<lambda>_. True) ?f ws)\""], ["proof (prove)\nusing this:\n  ws_invar ws\n  (\\<forall>k.\n      if k \\<notin> dom (ws_\\<alpha> ws) \\<and>\n         ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws\n\ngoal (1 subgoal):\n 1. (\\<forall>k.\n        if k \\<notin> {} \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n        then ws_\\<alpha>\n              (ws_iterate ws (\\<lambda>_. True)\n                (\\<lambda>(t, w') ws'.\n                    if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                    else ws')\n                ws)\n              k =\n             \\<lfloor>PostWS WSNotified\\<rfloor>\n        else ws_\\<alpha>\n              (ws_iterate ws (\\<lambda>_. True)\n                (\\<lambda>(t, w') ws'.\n                    if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                    else ws')\n                ws)\n              k =\n             ws_\\<alpha> ws k) \\<and>\n    ws_invar\n     (ws_iterate ws (\\<lambda>_. True)\n       (\\<lambda>(t, w') ws'.\n           if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n       ws)", "proof(rule ws.iterate_rule_P[where I=\"?I\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "fix t w' T ws'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "assume t: \"t \\<in> T\" and w': \"ws_\\<alpha> ws t = \\<lfloor>w'\\<rfloor>\"\n        and T: \"T \\<subseteq> dom (ws_\\<alpha> ws)\" and I: \"?I T ws'\""], ["proof (state)\nthis:\n  t \\<in> T\n  ws_\\<alpha> ws t = \\<lfloor>w'\\<rfloor>\n  T \\<subseteq> dom (ws_\\<alpha> ws)\n  (\\<forall>k.\n      if k \\<notin> T \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws' k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws' k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws'\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "{"], ["proof (state)\nthis:\n  t \\<in> T\n  ws_\\<alpha> ws t = \\<lfloor>w'\\<rfloor>\n  T \\<subseteq> dom (ws_\\<alpha> ws)\n  (\\<forall>k.\n      if k \\<notin> T \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws' k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws' k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws'\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "fix t'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "assume \"t' \\<notin> T - {t}\" \"ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>\""], ["proof (state)\nthis:\n  t' \\<notin> T - {t}\n  ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "with t I w' invar"], ["proof (chain)\npicking this:\n  t \\<in> T\n  (\\<forall>k.\n      if k \\<notin> T \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws' k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws' k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws'\n  ws_\\<alpha> ws t = \\<lfloor>w'\\<rfloor>\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n  t' \\<notin> T - {t}\n  ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>", "have \"ws_\\<alpha> (?f (t, w') ws') t' = \\<lfloor>PostWS WSNotified\\<rfloor>\""], ["proof (prove)\nusing this:\n  t \\<in> T\n  (\\<forall>k.\n      if k \\<notin> T \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws' k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws' k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws'\n  ws_\\<alpha> ws t = \\<lfloor>w'\\<rfloor>\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n  t' \\<notin> T - {t}\n  ws_\\<alpha> ws t' = \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. ws_\\<alpha>\n     ((case (t, w') of\n       (t, w') \\<Rightarrow>\n         \\<lambda>ws'.\n            if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n            else ws')\n       ws')\n     t' =\n    \\<lfloor>PostWS WSNotified\\<rfloor>", "by(auto)(simp_all add: ws.update_correct)"], ["proof (state)\nthis:\n  ws_\\<alpha>\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n   t' =\n  \\<lfloor>PostWS WSNotified\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?t'4 \\<notin> T - {t};\n   ws_\\<alpha> ws ?t'4 = \\<lfloor>InWS w\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> ws_\\<alpha>\n                     ((case (t, w') of\n                       (t, w') \\<Rightarrow>\n                         \\<lambda>ws'.\n                            if w' = InWS w\n                            then ws_update t (PostWS WSNotified) ws'\n                            else ws')\n                       ws')\n                     ?t'4 =\n                    \\<lfloor>PostWS WSNotified\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?t'4 \\<notin> T - {t};\n   ws_\\<alpha> ws ?t'4 = \\<lfloor>InWS w\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> ws_\\<alpha>\n                     ((case (t, w') of\n                       (t, w') \\<Rightarrow>\n                         \\<lambda>ws'.\n                            if w' = InWS w\n                            then ws_update t (PostWS WSNotified) ws'\n                            else ws')\n                       ws')\n                     ?t'4 =\n                    \\<lfloor>PostWS WSNotified\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?t'4 \\<notin> T - {t};\n   ws_\\<alpha> ws ?t'4 = \\<lfloor>InWS w\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> ws_\\<alpha>\n                     ((case (t, w') of\n                       (t, w') \\<Rightarrow>\n                         \\<lambda>ws'.\n                            if w' = InWS w\n                            then ws_update t (PostWS WSNotified) ws'\n                            else ws')\n                       ws')\n                     ?t'4 =\n                    \\<lfloor>PostWS WSNotified\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "fix t'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "assume \"t' \\<in> T - {t} \\<or> ws_\\<alpha> ws t' \\<noteq> \\<lfloor>InWS w\\<rfloor>\""], ["proof (state)\nthis:\n  t' \\<in> T - {t} \\<or> ws_\\<alpha> ws t' \\<noteq> \\<lfloor>InWS w\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "with t I w' invar"], ["proof (chain)\npicking this:\n  t \\<in> T\n  (\\<forall>k.\n      if k \\<notin> T \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws' k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws' k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws'\n  ws_\\<alpha> ws t = \\<lfloor>w'\\<rfloor>\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n  t' \\<in> T - {t} \\<or> ws_\\<alpha> ws t' \\<noteq> \\<lfloor>InWS w\\<rfloor>", "have \"ws_\\<alpha> (?f (t,w') ws') t' = ws_\\<alpha> ws t'\""], ["proof (prove)\nusing this:\n  t \\<in> T\n  (\\<forall>k.\n      if k \\<notin> T \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws' k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws' k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws'\n  ws_\\<alpha> ws t = \\<lfloor>w'\\<rfloor>\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n  t' \\<in> T - {t} \\<or> ws_\\<alpha> ws t' \\<noteq> \\<lfloor>InWS w\\<rfloor>\n\ngoal (1 subgoal):\n 1. ws_\\<alpha>\n     ((case (t, w') of\n       (t, w') \\<Rightarrow>\n         \\<lambda>ws'.\n            if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n            else ws')\n       ws')\n     t' =\n    ws_\\<alpha> ws t'", "by(auto simp add: ws.update_correct)"], ["proof (state)\nthis:\n  ws_\\<alpha>\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n   t' =\n  ws_\\<alpha> ws t'\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "}"], ["proof (state)\nthis:\n  ?t'4 \\<in> T - {t} \\<or>\n  ws_\\<alpha> ws ?t'4 \\<noteq> \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow>\n  ws_\\<alpha>\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n   ?t'4 =\n  ws_\\<alpha> ws ?t'4\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "moreover"], ["proof (state)\nthis:\n  ?t'4 \\<in> T - {t} \\<or>\n  ws_\\<alpha> ws ?t'4 \\<noteq> \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow>\n  ws_\\<alpha>\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n   ?t'4 =\n  ws_\\<alpha> ws ?t'4\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "have \"ws_invar (?f (t, w') ws')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws_invar\n     ((case (t, w') of\n       (t, w') \\<Rightarrow>\n         \\<lambda>ws'.\n            if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n            else ws')\n       ws')", "using I"], ["proof (prove)\nusing this:\n  (\\<forall>k.\n      if k \\<notin> T \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha> ws' k = \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha> ws' k = ws_\\<alpha> ws k) \\<and>\n  ws_invar ws'\n\ngoal (1 subgoal):\n 1. ws_invar\n     ((case (t, w') of\n       (t, w') \\<Rightarrow>\n         \\<lambda>ws'.\n            if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n            else ws')\n       ws')", "by(simp add: ws.update_correct)"], ["proof (state)\nthis:\n  ws_invar\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; ws_\\<alpha> ws k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (ws_\\<alpha> ws);\n        (\\<forall>k.\n            if k \\<notin> it \\<and>\n               ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n            then ws_\\<alpha> \\<sigma> k =\n                 \\<lfloor>PostWS WSNotified\\<rfloor>\n            else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n        ws_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ka.\n                             if ka \\<notin> it - {k} \\<and>\n                                ws_\\<alpha> ws ka = \\<lfloor>InWS w\\<rfloor>\n                             then ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  \\<lfloor>PostWS WSNotified\\<rfloor>\n                             else ws_\\<alpha>\n                                   ((case (k, v) of\n                                     (t, w') \\<Rightarrow>\n \\<lambda>ws'.\n    if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n                                     \\<sigma>)\n                                   ka =\n                                  ws_\\<alpha> ws ka) \\<and>\n                         ws_invar\n                          ((case (k, v) of\n                            (t, w') \\<Rightarrow>\n                              \\<lambda>ws'.\n                                 if w' = InWS w\n                                 then ws_update t (PostWS WSNotified) ws'\n                                 else ws')\n                            \\<sigma>)\n 2. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?t'4 \\<notin> T - {t};\n   ws_\\<alpha> ws ?t'4 = \\<lfloor>InWS w\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> ws_\\<alpha>\n                     ((case (t, w') of\n                       (t, w') \\<Rightarrow>\n                         \\<lambda>ws'.\n                            if w' = InWS w\n                            then ws_update t (PostWS WSNotified) ws'\n                            else ws')\n                       ws')\n                     ?t'4 =\n                    \\<lfloor>PostWS WSNotified\\<rfloor>\n  ?t'4 \\<in> T - {t} \\<or>\n  ws_\\<alpha> ws ?t'4 \\<noteq> \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow>\n  ws_\\<alpha>\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n   ?t'4 =\n  ws_\\<alpha> ws ?t'4\n  ws_invar\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')", "show \"?I (T - {t}) (?f (t, w') ws')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?t'4 \\<notin> T - {t};\n   ws_\\<alpha> ws ?t'4 = \\<lfloor>InWS w\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> ws_\\<alpha>\n                     ((case (t, w') of\n                       (t, w') \\<Rightarrow>\n                         \\<lambda>ws'.\n                            if w' = InWS w\n                            then ws_update t (PostWS WSNotified) ws'\n                            else ws')\n                       ws')\n                     ?t'4 =\n                    \\<lfloor>PostWS WSNotified\\<rfloor>\n  ?t'4 \\<in> T - {t} \\<or>\n  ws_\\<alpha> ws ?t'4 \\<noteq> \\<lfloor>InWS w\\<rfloor> \\<Longrightarrow>\n  ws_\\<alpha>\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n   ?t'4 =\n  ws_\\<alpha> ws ?t'4\n  ws_invar\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n\ngoal (1 subgoal):\n 1. (\\<forall>k.\n        if k \\<notin> T - {t} \\<and>\n           ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n        then ws_\\<alpha>\n              ((case (t, w') of\n                (t, w') \\<Rightarrow>\n                  \\<lambda>ws'.\n                     if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                     else ws')\n                ws')\n              k =\n             \\<lfloor>PostWS WSNotified\\<rfloor>\n        else ws_\\<alpha>\n              ((case (t, w') of\n                (t, w') \\<Rightarrow>\n                  \\<lambda>ws'.\n                     if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                     else ws')\n                ws')\n              k =\n             ws_\\<alpha> ws k) \\<and>\n    ws_invar\n     ((case (t, w') of\n       (t, w') \\<Rightarrow>\n         \\<lambda>ws'.\n            if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n            else ws')\n       ws')", "by safe simp"], ["proof (state)\nthis:\n  (\\<forall>k.\n      if k \\<notin> T - {t} \\<and>\n         ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha>\n            ((case (t, w') of\n              (t, w') \\<Rightarrow>\n                \\<lambda>ws'.\n                   if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                   else ws')\n              ws')\n            k =\n           \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha>\n            ((case (t, w') of\n              (t, w') \\<Rightarrow>\n                \\<lambda>ws'.\n                   if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                   else ws')\n              ws')\n            k =\n           ws_\\<alpha> ws k) \\<and>\n  ws_invar\n   ((case (t, w') of\n     (t, w') \\<Rightarrow>\n       \\<lambda>ws'.\n          if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws')\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma> \\<Longrightarrow>\n       (\\<forall>k.\n           if k \\<notin> {} \\<and>\n              ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n           then ws_\\<alpha> \\<sigma> k = \\<lfloor>PostWS WSNotified\\<rfloor>\n           else ws_\\<alpha> \\<sigma> k = ws_\\<alpha> ws k) \\<and>\n       ws_invar \\<sigma>", "qed"], ["proof (state)\nthis:\n  (\\<forall>k.\n      if k \\<notin> {} \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha>\n            (ws_iterate ws (\\<lambda>_. True)\n              (\\<lambda>(t, w') ws'.\n                  if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                  else ws')\n              ws)\n            k =\n           \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha>\n            (ws_iterate ws (\\<lambda>_. True)\n              (\\<lambda>(t, w') ws'.\n                  if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                  else ws')\n              ws)\n            k =\n           ws_\\<alpha> ws k) \\<and>\n  ws_invar\n   (ws_iterate ws (\\<lambda>_. True)\n     (\\<lambda>(t, w') ws'.\n         if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws)\n\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "hence \"ws_\\<alpha> (ws_iterate ws (\\<lambda>_. True) ?f ws) = (\\<lambda>t. if ws_\\<alpha> ws t = \\<lfloor>InWS w\\<rfloor> then \\<lfloor>PostWS WSNotified\\<rfloor> else ws_\\<alpha> ws t)\"\n      and \"ws_invar (ws_iterate ws (\\<lambda>_. True) ?f ws)\""], ["proof (prove)\nusing this:\n  (\\<forall>k.\n      if k \\<notin> {} \\<and> ws_\\<alpha> ws k = \\<lfloor>InWS w\\<rfloor>\n      then ws_\\<alpha>\n            (ws_iterate ws (\\<lambda>_. True)\n              (\\<lambda>(t, w') ws'.\n                  if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                  else ws')\n              ws)\n            k =\n           \\<lfloor>PostWS WSNotified\\<rfloor>\n      else ws_\\<alpha>\n            (ws_iterate ws (\\<lambda>_. True)\n              (\\<lambda>(t, w') ws'.\n                  if w' = InWS w then ws_update t (PostWS WSNotified) ws'\n                  else ws')\n              ws)\n            k =\n           ws_\\<alpha> ws k) \\<and>\n  ws_invar\n   (ws_iterate ws (\\<lambda>_. True)\n     (\\<lambda>(t, w') ws'.\n         if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws)\n\ngoal (1 subgoal):\n 1. ws_\\<alpha>\n     (ws_iterate ws (\\<lambda>_. True)\n       (\\<lambda>(t, w') ws'.\n           if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n       ws) =\n    (\\<lambda>t.\n        if ws_\\<alpha> ws t = \\<lfloor>InWS w\\<rfloor>\n        then \\<lfloor>PostWS WSNotified\\<rfloor> else ws_\\<alpha> ws t) &&&\n    ws_invar\n     (ws_iterate ws (\\<lambda>_. True)\n       (\\<lambda>(t, w') ws'.\n           if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n       ws)", "by(simp_all add: fun_eq_iff)"], ["proof (state)\nthis:\n  ws_\\<alpha>\n   (ws_iterate ws (\\<lambda>_. True)\n     (\\<lambda>(t, w') ws'.\n         if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws) =\n  (\\<lambda>t.\n      if ws_\\<alpha> ws t = \\<lfloor>InWS w\\<rfloor>\n      then \\<lfloor>PostWS WSNotified\\<rfloor> else ws_\\<alpha> ws t)\n  ws_invar\n   (ws_iterate ws (\\<lambda>_. True)\n     (\\<lambda>(t, w') ws'.\n         if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws)\n\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x3.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = NotifyAll x3\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 5. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ws_\\<alpha>\n   (ws_iterate ws (\\<lambda>_. True)\n     (\\<lambda>(t, w') ws'.\n         if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws) =\n  (\\<lambda>t.\n      if ws_\\<alpha> ws t = \\<lfloor>InWS w\\<rfloor>\n      then \\<lfloor>PostWS WSNotified\\<rfloor> else ws_\\<alpha> ws t)\n  ws_invar\n   (ws_iterate ws (\\<lambda>_. True)\n     (\\<lambda>(t, w') ws'.\n         if w' = InWS w then ws_update t (PostWS WSNotified) ws' else ws')\n     ws)\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "by simp"], ["proof (state)\nthis:\n  redT_updW t (ws_\\<alpha> ws) wa\n   (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n  ws_invar (exec_updW \\<sigma> t ws wa)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "case WakeUp"], ["proof (state)\nthis:\n  wa = WakeUp x4_\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<And>x4.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = WakeUp x4\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 4. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wa = WakeUp x4_\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "using assms"], ["proof (prove)\nusing this:\n  wa = WakeUp x4_\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n    ws_invar (exec_updW \\<sigma> t ws wa)", "by(auto simp add: ws.lookup_correct ws.update_correct split: wait_set_status.split)"], ["proof (state)\nthis:\n  redT_updW t (ws_\\<alpha> ws) wa\n   (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n  ws_invar (exec_updW \\<sigma> t ws wa)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n        dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T;\n        wa = Suspend x1\\<rbrakk>\n       \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                          (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                         ws_invar (exec_updW \\<sigma> t ws wa)\n 2. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = Notified\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)\n 3. \\<lbrakk>ws_invar ws; \\<sigma>_invar \\<sigma> T;\n     dom (ws_\\<alpha> ws) \\<subseteq> T; t \\<in> T; wa = WokenUp\\<rbrakk>\n    \\<Longrightarrow> redT_updW t (ws_\\<alpha> ws) wa\n                       (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n                      ws_invar (exec_updW \\<sigma> t ws wa)", "qed(simp_all add: ws.update_correct ws.delete_correct map_upd_eq_restrict)"], ["proof (state)\nthis:\n  redT_updW t (ws_\\<alpha> ws) wa\n   (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n  ws_invar (exec_updW \\<sigma> t ws wa)\n\ngoal (2 subgoals):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n 2. ws_invar (exec_updW \\<sigma> t ws wa)", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  redT_updW t (ws_\\<alpha> ws) wa\n   (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<and>\n  ws_invar (exec_updW \\<sigma> t ws wa)\n\ngoal (1 subgoal):\n 1. redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) &&&\n    ws_invar (exec_updW \\<sigma> t ws wa)", "by simp_all"], ["proof (state)\nthis:\n  redT_updW t (ws_\\<alpha> ws) wa (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n  ws_invar (exec_updW \\<sigma> t ws wa)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_updWs_correct:\n  assumes \"ws_invar ws\" \"\\<sigma>_invar \\<sigma> T\" \"dom (ws_\\<alpha> ws) \\<subseteq> T\" \"t \\<in> T\"\n  shows \"redT_updWs t (ws_\\<alpha> ws) was (ws_\\<alpha> (exec_updWs \\<sigma> t ws was))\" (is \"?thesis1\")\n  and \"ws_invar (exec_updWs \\<sigma> t ws was)\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updWs t (ws_\\<alpha> ws) was\n     (ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) &&&\n    ws_invar (exec_updWs \\<sigma> t ws was)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. redT_updWs t (ws_\\<alpha> ws) was\n     (ws_\\<alpha> (exec_updWs \\<sigma> t ws was))\n 2. ws_invar (exec_updWs \\<sigma> t ws was)", "from \\<open>ws_invar ws\\<close> \\<open>dom (ws_\\<alpha> ws) \\<subseteq> T\\<close>"], ["proof (chain)\npicking this:\n  ws_invar ws\n  dom (ws_\\<alpha> ws) \\<subseteq> T", "have \"?thesis1 \\<and> ?thesis2\""], ["proof (prove)\nusing this:\n  ws_invar ws\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n\ngoal (1 subgoal):\n 1. redT_updWs t (ws_\\<alpha> ws) was\n     (ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n    ws_invar (exec_updWs \\<sigma> t ws was)", "proof(induct was arbitrary: ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ws.\n       \\<lbrakk>ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) []\n                          (ws_\\<alpha> (exec_updWs \\<sigma> t ws [])) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws [])\n 2. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "case Nil"], ["proof (state)\nthis:\n  ws_invar ws\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n\ngoal (2 subgoals):\n 1. \\<And>ws.\n       \\<lbrakk>ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) []\n                          (ws_\\<alpha> (exec_updWs \\<sigma> t ws [])) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws [])\n 2. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "thus ?case"], ["proof (prove)\nusing this:\n  ws_invar ws\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n\ngoal (1 subgoal):\n 1. redT_updWs t (ws_\\<alpha> ws) []\n     (ws_\\<alpha> (exec_updWs \\<sigma> t ws [])) \\<and>\n    ws_invar (exec_updWs \\<sigma> t ws [])", "by(auto simp add: exec_updWs_def redT_updWs_def)"], ["proof (state)\nthis:\n  redT_updWs t (ws_\\<alpha> ws) []\n   (ws_\\<alpha> (exec_updWs \\<sigma> t ws [])) \\<and>\n  ws_invar (exec_updWs \\<sigma> t ws [])\n\ngoal (1 subgoal):\n 1. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "case (Cons wa was)"], ["proof (state)\nthis:\n  \\<lbrakk>ws_invar ?ws2; dom (ws_\\<alpha> ?ws2) \\<subseteq> T\\<rbrakk>\n  \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ?ws2) was\n                     (ws_\\<alpha> (exec_updWs \\<sigma> t ?ws2 was)) \\<and>\n                    ws_invar (exec_updWs \\<sigma> t ?ws2 was)\n  ws_invar ws\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n\ngoal (1 subgoal):\n 1. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "let ?ws' = \"exec_updW \\<sigma> t ws wa\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "from \\<open>ws_invar ws\\<close> \\<open>\\<sigma>_invar \\<sigma> T\\<close> \\<open>dom (ws_\\<alpha> ws) \\<subseteq> T\\<close> \\<open>t \\<in> T\\<close>"], ["proof (chain)\npicking this:\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T", "have invar': \"ws_invar ?ws'\" and red: \"redT_updW t (ws_\\<alpha> ws) wa (ws_\\<alpha> ?ws')\""], ["proof (prove)\nusing this:\n  ws_invar ws\n  \\<sigma>_invar \\<sigma> T\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. ws_invar (exec_updW \\<sigma> t ws wa) &&&\n    redT_updW t (ws_\\<alpha> ws) wa\n     (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))", "by(rule exec_updW_correct)+"], ["proof (state)\nthis:\n  ws_invar (exec_updW \\<sigma> t ws wa)\n  redT_updW t (ws_\\<alpha> ws) wa (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n\ngoal (1 subgoal):\n 1. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "have \"dom (ws_\\<alpha> ?ws') \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<subseteq> T", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom (ws_\\<alpha>\n                     (exec_updW \\<sigma> t ws wa)) \\<Longrightarrow>\n       x \\<in> T", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom (ws_\\<alpha>\n                     (exec_updW \\<sigma> t ws wa)) \\<Longrightarrow>\n       x \\<in> T", "assume \"t' \\<in> dom (ws_\\<alpha> ?ws')\""], ["proof (state)\nthis:\n  t' \\<in> dom (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom (ws_\\<alpha>\n                     (exec_updW \\<sigma> t ws wa)) \\<Longrightarrow>\n       x \\<in> T", "with red"], ["proof (chain)\npicking this:\n  redT_updW t (ws_\\<alpha> ws) wa (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n  t' \\<in> dom (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))", "have \"t' \\<in> dom (ws_\\<alpha> ws) \\<or> t = t'\""], ["proof (prove)\nusing this:\n  redT_updW t (ws_\\<alpha> ws) wa (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n  t' \\<in> dom (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n\ngoal (1 subgoal):\n 1. t' \\<in> dom (ws_\\<alpha> ws) \\<or> t = t'", "by(auto dest!: redT_updW_Some_otherD split: wait_set_status.split_asm)"], ["proof (state)\nthis:\n  t' \\<in> dom (ws_\\<alpha> ws) \\<or> t = t'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom (ws_\\<alpha>\n                     (exec_updW \\<sigma> t ws wa)) \\<Longrightarrow>\n       x \\<in> T", "with \\<open>dom (ws_\\<alpha> ws) \\<subseteq> T\\<close> \\<open>t \\<in> T\\<close>"], ["proof (chain)\npicking this:\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n  t' \\<in> dom (ws_\\<alpha> ws) \\<or> t = t'", "show \"t' \\<in> T\""], ["proof (prove)\nusing this:\n  dom (ws_\\<alpha> ws) \\<subseteq> T\n  t \\<in> T\n  t' \\<in> dom (ws_\\<alpha> ws) \\<or> t = t'\n\ngoal (1 subgoal):\n 1. t' \\<in> T", "by auto"], ["proof (state)\nthis:\n  t' \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<subseteq> T\n\ngoal (1 subgoal):\n 1. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "with invar'"], ["proof (chain)\npicking this:\n  ws_invar (exec_updW \\<sigma> t ws wa)\n  dom (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<subseteq> T", "have \"redT_updWs t (ws_\\<alpha> ?ws') was (ws_\\<alpha> (exec_updWs \\<sigma> t ?ws' was)) \\<and> ws_invar (exec_updWs \\<sigma> t ?ws' was)\""], ["proof (prove)\nusing this:\n  ws_invar (exec_updW \\<sigma> t ws wa)\n  dom (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) \\<subseteq> T\n\ngoal (1 subgoal):\n 1. redT_updWs t (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) was\n     (ws_\\<alpha>\n       (exec_updWs \\<sigma> t (exec_updW \\<sigma> t ws wa) was)) \\<and>\n    ws_invar (exec_updWs \\<sigma> t (exec_updW \\<sigma> t ws wa) was)", "by(rule Cons.hyps)"], ["proof (state)\nthis:\n  redT_updWs t (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) was\n   (ws_\\<alpha>\n     (exec_updWs \\<sigma> t (exec_updW \\<sigma> t ws wa) was)) \\<and>\n  ws_invar (exec_updWs \\<sigma> t (exec_updW \\<sigma> t ws wa) was)\n\ngoal (1 subgoal):\n 1. \\<And>a was ws.\n       \\<lbrakk>\\<And>ws.\n                   \\<lbrakk>ws_invar ws;\n                    dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n                   \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) was\n(ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n                                     ws_invar\n(exec_updWs \\<sigma> t ws was);\n        ws_invar ws; dom (ws_\\<alpha> ws) \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> redT_updWs t (ws_\\<alpha> ws) (a # was)\n                          (ws_\\<alpha>\n                            (exec_updWs \\<sigma> t ws (a # was))) \\<and>\n                         ws_invar (exec_updWs \\<sigma> t ws (a # was))", "thus ?case"], ["proof (prove)\nusing this:\n  redT_updWs t (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) was\n   (ws_\\<alpha>\n     (exec_updWs \\<sigma> t (exec_updW \\<sigma> t ws wa) was)) \\<and>\n  ws_invar (exec_updWs \\<sigma> t (exec_updW \\<sigma> t ws wa) was)\n\ngoal (1 subgoal):\n 1. redT_updWs t (ws_\\<alpha> ws) (wa # was)\n     (ws_\\<alpha> (exec_updWs \\<sigma> t ws (wa # was))) \\<and>\n    ws_invar (exec_updWs \\<sigma> t ws (wa # was))", "using red"], ["proof (prove)\nusing this:\n  redT_updWs t (ws_\\<alpha> (exec_updW \\<sigma> t ws wa)) was\n   (ws_\\<alpha>\n     (exec_updWs \\<sigma> t (exec_updW \\<sigma> t ws wa) was)) \\<and>\n  ws_invar (exec_updWs \\<sigma> t (exec_updW \\<sigma> t ws wa) was)\n  redT_updW t (ws_\\<alpha> ws) wa (ws_\\<alpha> (exec_updW \\<sigma> t ws wa))\n\ngoal (1 subgoal):\n 1. redT_updWs t (ws_\\<alpha> ws) (wa # was)\n     (ws_\\<alpha> (exec_updWs \\<sigma> t ws (wa # was))) \\<and>\n    ws_invar (exec_updWs \\<sigma> t ws (wa # was))", "by(auto simp add: exec_updWs_def redT_updWs_def intro: rtrancl3p_step_converse)"], ["proof (state)\nthis:\n  redT_updWs t (ws_\\<alpha> ws) (wa # was)\n   (ws_\\<alpha> (exec_updWs \\<sigma> t ws (wa # was))) \\<and>\n  ws_invar (exec_updWs \\<sigma> t ws (wa # was))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  redT_updWs t (ws_\\<alpha> ws) was\n   (ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n  ws_invar (exec_updWs \\<sigma> t ws was)\n\ngoal (2 subgoals):\n 1. redT_updWs t (ws_\\<alpha> ws) was\n     (ws_\\<alpha> (exec_updWs \\<sigma> t ws was))\n 2. ws_invar (exec_updWs \\<sigma> t ws was)", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  redT_updWs t (ws_\\<alpha> ws) was\n   (ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) \\<and>\n  ws_invar (exec_updWs \\<sigma> t ws was)\n\ngoal (1 subgoal):\n 1. redT_updWs t (ws_\\<alpha> ws) was\n     (ws_\\<alpha> (exec_updWs \\<sigma> t ws was)) &&&\n    ws_invar (exec_updWs \\<sigma> t ws was)", "by simp_all"], ["proof (state)\nthis:\n  redT_updWs t (ws_\\<alpha> ws) was\n   (ws_\\<alpha> (exec_updWs \\<sigma> t ws was))\n  ws_invar (exec_updWs \\<sigma> t ws was)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_upd_correct:\n  assumes \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"t \\<in> (dom (thr_\\<alpha> (thr s)))\"\n  and \"wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\"\n  shows \"redT_upd (state_\\<alpha> s) t ta x' m' (state_\\<alpha> (exec_upd \\<sigma> s t ta x' m'))\"\n  and \"state_invar (exec_upd \\<sigma> s t ta x' m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_upd (state_\\<alpha> s) t ta x' m'\n     (state_\\<alpha> (exec_upd \\<sigma> s t ta x' m')) &&&\n    state_invar (exec_upd \\<sigma> s t ta x' m')", "using assms"], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  t \\<in> dom (thr_\\<alpha> (thr s))\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. redT_upd (state_\\<alpha> s) t ta x' m'\n     (state_\\<alpha> (exec_upd \\<sigma> s t ta x' m')) &&&\n    state_invar (exec_upd \\<sigma> s t ta x' m')", "unfolding wset_thread_ok_conv_dom"], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  t \\<in> dom (thr_\\<alpha> (thr s))\n  dom (ws_\\<alpha> (wset s)) \\<subseteq> dom (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. redT_upd (state_\\<alpha> s) t ta x' m'\n     (state_\\<alpha> (exec_upd \\<sigma> s t ta x' m')) &&&\n    state_invar (exec_upd \\<sigma> s t ta x' m')", "by(auto simp add: thr.update_correct thr.lookup_correct intro: exec_updWs_correct)"], ["", "lemma execT_None:\n  assumes invar: \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and exec: \"execT \\<sigma> s = None\"\n  shows \"\\<alpha>.active_threads (state_\\<alpha> s) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>.active_threads (state_\\<alpha> s) = {}", "using assms"], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  execT \\<sigma> s = None\n\ngoal (1 subgoal):\n 1. \\<alpha>.active_threads (state_\\<alpha> s) = {}", "by(cases \"schedule \\<sigma> s\")(fastforce simp add: execT_def thr.lookup_correct dest: schedule_Some_NoneD schedule_NoneD)+"], ["", "lemma execT_Some:\n  assumes invar: \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and wstok: \"wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\"\n  and exec: \"execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\"\n  shows \"\\<alpha>.redT (state_\\<alpha> s) (t, ta) (state_\\<alpha> s')\" (is \"?thesis1\")\n  and \"state_invar s'\" (is \"?thesis2\")\n  and \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\" (is \"?thesis3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') &&&\n    state_invar s' &&&\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n 2. state_invar s'\n 3. \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "note [simp del] = redT_upd_simps exec_upd_def"], ["proof (state)\nthis:\n  redT_upd ?s ?t ?ta ?x' ?m' ?s' =\n  (\\<exists>ws'.\n      ?s' =\n      (redT_updLs (locks ?s) ?t \\<lbrace>?ta\\<rbrace>\\<^bsub>l\\<^esub>,\n       (FWThread.redT_updTs (thr ?s) \\<lbrace>?ta\\<rbrace>\\<^bsub>t\\<^esub>\n        (?t \\<mapsto>\n        (?x',\n         redT_updLns (locks ?s) ?t (snd (the (thr ?s ?t)))\n          \\<lbrace>?ta\\<rbrace>\\<^bsub>l\\<^esub>)),\n        ?m'),\n       ws',\n       FWInterrupt.redT_updIs (interrupts ?s)\n        \\<lbrace>?ta\\<rbrace>\\<^bsub>i\\<^esub>) \\<and>\n      redT_updWs ?t (wset ?s) \\<lbrace>?ta\\<rbrace>\\<^bsub>w\\<^esub> ws')\n  exec_upd ?\\<sigma> ?s ?t ?ta ?x' ?m' =\n  (redT_updLs (locks ?s) ?t \\<lbrace>?ta\\<rbrace>\\<^bsub>l\\<^esub>,\n   (thr_update ?t\n     (?x',\n      redT_updLns (locks ?s) ?t (snd (the (thr_lookup ?t (thr ?s))))\n       \\<lbrace>?ta\\<rbrace>\\<^bsub>l\\<^esub>)\n     (local.redT_updTs (thr ?s) \\<lbrace>?ta\\<rbrace>\\<^bsub>t\\<^esub>),\n    ?m'),\n   exec_updWs ?\\<sigma> ?t (wset ?s) \\<lbrace>?ta\\<rbrace>\\<^bsub>w\\<^esub>,\n   local.redT_updIs (interrupts ?s) \\<lbrace>?ta\\<rbrace>\\<^bsub>i\\<^esub>)\n\ngoal (3 subgoals):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n 2. state_invar s'\n 3. \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "have \"?thesis1 \\<and> ?thesis2 \\<and> ?thesis3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "proof(cases \"fst (snd (the (schedule \\<sigma> s)))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "case None"], ["proof (state)\nthis:\n  fst (snd (the (schedule \\<sigma> s))) = None\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "with exec invar"], ["proof (chain)\npicking this:\n  execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  fst (snd (the (schedule \\<sigma> s))) = None", "have schedule: \"schedule \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n      and ta: \"ta = (K$ [], [], [], [], [], convert_RA (snd (the (thr_\\<alpha> (thr s) t))))\"\n      and s': \"s' = (acquire_all (locks s) t (snd (the (thr_\\<alpha> (thr s) t))), (thr_update t (fst (the (thr_\\<alpha> (thr s) t)), no_wait_locks) (thr s), shr s), wset s, interrupts s)\""], ["proof (prove)\nusing this:\n  execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  fst (snd (the (schedule \\<sigma> s))) = None\n\ngoal (1 subgoal):\n 1. schedule \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor> &&&\n    ta =\n    (K$ [], [], [], [], [],\n     convert_RA (snd (the (thr_\\<alpha> (thr s) t)))) &&&\n    s' =\n    (acquire_all (locks s) t (snd (the (thr_\\<alpha> (thr s) t))),\n     (thr_update t (fst (the (thr_\\<alpha> (thr s) t)), no_wait_locks)\n       (thr s),\n      shr s),\n     wset s, interrupts s)", "by(auto simp add: execT_def Option_bind_eq_Some_conv thr.lookup_correct split_beta split del: option.split_asm)"], ["proof (state)\nthis:\n  schedule \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  ta =\n  (K$ [], [], [], [], [], convert_RA (snd (the (thr_\\<alpha> (thr s) t))))\n  s' =\n  (acquire_all (locks s) t (snd (the (thr_\\<alpha> (thr s) t))),\n   (thr_update t (fst (the (thr_\\<alpha> (thr s) t)), no_wait_locks)\n     (thr s),\n    shr s),\n   wset s, interrupts s)\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "from schedule_Some_NoneD[OF schedule invar]"], ["proof (chain)\npicking this:\n  \\<exists>x ln n.\n     thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n     may_acquire_all (locks s) t ln", "obtain x ln n where t: \"thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor>\"\n      and \"0 < ln $ n\" \"\\<not> waiting (ws_\\<alpha> (wset s) t)\" \"may_acquire_all (locks s) t ln\""], ["proof (prove)\nusing this:\n  \\<exists>x ln n.\n     thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n     0 < ln $ n \\<and>\n     \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n     may_acquire_all (locks s) t ln\n\ngoal (1 subgoal):\n 1. (\\<And>x ln n.\n        \\<lbrakk>thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor>;\n         0 < ln $ n; \\<not> waiting (ws_\\<alpha> (wset s) t);\n         may_acquire_all (locks s) t ln\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ n\n  \\<not> waiting (ws_\\<alpha> (wset s) t)\n  may_acquire_all (locks s) t ln\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "hence ?thesis1"], ["proof (prove)\nusing this:\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ n\n  \\<not> waiting (ws_\\<alpha> (wset s) t)\n  may_acquire_all (locks s) t ln\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')", "using ta s' invar"], ["proof (prove)\nusing this:\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor>\n  0 < ln $ n\n  \\<not> waiting (ws_\\<alpha> (wset s) t)\n  may_acquire_all (locks s) t ln\n  ta =\n  (K$ [], [], [], [], [], convert_RA (snd (the (thr_\\<alpha> (thr s) t))))\n  s' =\n  (acquire_all (locks s) t (snd (the (thr_\\<alpha> (thr s) t))),\n   (thr_update t (fst (the (thr_\\<alpha> (thr s) t)), no_wait_locks)\n     (thr s),\n    shr s),\n   wset s, interrupts s)\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')", "by(auto intro: \\<alpha>.redT.redT_acquire simp add: thr.update_correct)"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "moreover"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "from invar s'"], ["proof (chain)\npicking this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  s' =\n  (acquire_all (locks s) t (snd (the (thr_\\<alpha> (thr s) t))),\n   (thr_update t (fst (the (thr_\\<alpha> (thr s) t)), no_wait_locks)\n     (thr s),\n    shr s),\n   wset s, interrupts s)", "have \"?thesis2\""], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  s' =\n  (acquire_all (locks s) t (snd (the (thr_\\<alpha> (thr s) t))),\n   (thr_update t (fst (the (thr_\\<alpha> (thr s) t)), no_wait_locks)\n     (thr s),\n    shr s),\n   wset s, interrupts s)\n\ngoal (1 subgoal):\n 1. state_invar s'", "by(simp add: thr.update_correct)"], ["proof (state)\nthis:\n  state_invar s'\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "moreover"], ["proof (state)\nthis:\n  state_invar s'\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "from t s' invar"], ["proof (chain)\npicking this:\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor>\n  s' =\n  (acquire_all (locks s) t (snd (the (thr_\\<alpha> (thr s) t))),\n   (thr_update t (fst (the (thr_\\<alpha> (thr s) t)), no_wait_locks)\n     (thr s),\n    shr s),\n   wset s, interrupts s)\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant", "have \"dom (thr_\\<alpha> (thr s')) = dom (thr_\\<alpha> (thr s))\""], ["proof (prove)\nusing this:\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor>\n  s' =\n  (acquire_all (locks s) t (snd (the (thr_\\<alpha> (thr s) t))),\n   (thr_update t (fst (the (thr_\\<alpha> (thr s) t)), no_wait_locks)\n     (thr s),\n    shr s),\n   wset s, interrupts s)\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s')) = dom (thr_\\<alpha> (thr s))", "by(auto simp add: thr.update_correct)"], ["proof (state)\nthis:\n  dom (thr_\\<alpha> (thr s')) = dom (thr_\\<alpha> (thr s))\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "hence \"?thesis3\""], ["proof (prove)\nusing this:\n  dom (thr_\\<alpha> (thr s')) = dom (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "using invar schedule"], ["proof (prove)\nusing this:\n  dom (thr_\\<alpha> (thr s')) = dom (thr_\\<alpha> (thr s))\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  schedule \\<sigma> s = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "by(auto intro: schedule_invar_None)"], ["proof (state)\nthis:\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (2 subgoals):\n 1. fst (snd (the (schedule \\<sigma> s))) = None \\<Longrightarrow>\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 2. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "by simp"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n  state_invar s' \\<and>\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "case (Some taxm)"], ["proof (state)\nthis:\n  fst (snd (the (schedule \\<sigma> s))) = \\<lfloor>taxm\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "with exec invar"], ["proof (chain)\npicking this:\n  execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  fst (snd (the (schedule \\<sigma> s))) = \\<lfloor>taxm\\<rfloor>", "obtain x' m' \n      where schedule: \"schedule \\<sigma> s = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n      and s': \"s' = exec_upd \\<sigma> s t ta x' m'\""], ["proof (prove)\nusing this:\n  execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  fst (snd (the (schedule \\<sigma> s))) = \\<lfloor>taxm\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>x' m'.\n        \\<lbrakk>schedule \\<sigma> s =\n                 \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                           \\<sigma>')\\<rfloor>;\n         s' = exec_upd \\<sigma> s t ta x' m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases taxm)(fastforce simp add: execT_def Option_bind_eq_Some_conv split del: option.split_asm)"], ["proof (state)\nthis:\n  schedule \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  s' = exec_upd \\<sigma> s t ta x' m'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "from schedule_Some_SomeD[OF schedule invar]"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n     \\<alpha>.actions_ok (state_\\<alpha> s) t ta", "obtain x where t: \"thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\" \n      and \"Predicate.eval (r t (x, shr s)) (ta, x', m')\" \n      and aok: \"\\<alpha>.actions_ok (state_\\<alpha> s) t ta\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n     \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n     \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>thr_\\<alpha> (thr s) t =\n                 \\<lfloor>(x, no_wait_locks)\\<rfloor>;\n         \\<alpha>.r_syntax t x (shr s) ta x' m';\n         \\<alpha>.actions_ok (state_\\<alpha> s) t ta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<alpha>.r_syntax t x (shr s) ta x' m'\n  \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "with s'"], ["proof (chain)\npicking this:\n  s' = exec_upd \\<sigma> s t ta x' m'\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<alpha>.r_syntax t x (shr s) ta x' m'\n  \\<alpha>.actions_ok (state_\\<alpha> s) t ta", "have ?thesis1"], ["proof (prove)\nusing this:\n  s' = exec_upd \\<sigma> s t ta x' m'\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<alpha>.r_syntax t x (shr s) ta x' m'\n  \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')", "using invar wstok"], ["proof (prove)\nusing this:\n  s' = exec_upd \\<sigma> s t ta x' m'\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  \\<alpha>.r_syntax t x (shr s) ta x' m'\n  \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')", "by(fastforce intro: \\<alpha>.redT.intros exec_upd_correct)"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "moreover"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "from invar s' t wstok"], ["proof (chain)\npicking this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  s' = exec_upd \\<sigma> s t ta x' m'\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))", "have ?thesis2"], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  s' = exec_upd \\<sigma> s t ta x' m'\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. state_invar s'", "by(auto intro: exec_upd_correct)"], ["proof (state)\nthis:\n  state_invar s'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "moreover"], ["proof (state)\nthis:\n  state_invar s'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "{"], ["proof (state)\nthis:\n  state_invar s'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "from schedule invar"], ["proof (chain)\npicking this:\n  schedule \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant", "have \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\""], ["proof (prove)\nusing this:\n  schedule \\<sigma> s =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n\ngoal (1 subgoal):\n 1. \\<sigma>_invar \\<sigma>'\n     (dom (thr_\\<alpha> (thr s)) \\<union>\n      {t. \\<exists>x m.\n             NewThread t x m\n             \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(rule schedule_invar_Some)"], ["proof (state)\nthis:\n  \\<sigma>_invar \\<sigma>'\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "also"], ["proof (state)\nthis:\n  \\<sigma>_invar \\<sigma>'\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "have \"dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>} = dom (thr_\\<alpha> (thr s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m\n           \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>} =\n    dom (thr_\\<alpha> (thr s'))", "using invar s' aok t"], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  s' = exec_upd \\<sigma> s t ta x' m'\n  \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n  thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\n\ngoal (1 subgoal):\n 1. dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m\n           \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>} =\n    dom (thr_\\<alpha> (thr s'))", "by(auto simp add: exec_upd_def thr.lookup_correct thr.update_correct simp del: split_paired_Ex)(fastforce dest: redT_updTs_new_thread intro: redT_updTs_Some1 redT_updTs_new_thread_ts simp del: split_paired_Ex)+"], ["proof (state)\nthis:\n  dom (thr_\\<alpha> (thr s)) \\<union>\n  {t. \\<exists>x m.\n         NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>} =\n  dom (thr_\\<alpha> (thr s'))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "finally"], ["proof (chain)\npicking this:\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "have \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\""], ["proof (prove)\nusing this:\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (1 subgoal):\n 1. \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "."], ["proof (state)\nthis:\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "}"], ["proof (state)\nthis:\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fst (snd (the (schedule \\<sigma> s))) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta\n        (state_\\<alpha> s') \\<and>\n       state_invar s' \\<and>\n       \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n    state_invar s' \\<and>\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "by simp"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n  state_invar s' \\<and>\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n  state_invar s' \\<and>\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (3 subgoals):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n 2. state_invar s'\n 3. \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "thus ?thesis1 ?thesis2 ?thesis3"], ["proof (prove)\nusing this:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') \\<and>\n  state_invar s' \\<and>\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') &&&\n    state_invar s' &&&\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))", "by simp_all"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_step_into_redT:\n  assumes invar: \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and wstok: \"wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\"\n  and exec: \"exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\"\n  shows \"\\<alpha>.redT (state_\\<alpha> s) (t, ta) (state_\\<alpha> s')\" \"\\<sigma>'' = \\<sigma>\"\n  and \"state_invar s'\" \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\" \"state_\\<alpha> s' \\<in> invariant\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') &&&\n     \\<sigma>'' = \\<sigma>) &&&\n    state_invar s' &&&\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s'))) &&&\n    state_\\<alpha> s' \\<in> invariant", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n 2. \\<sigma>'' = \\<sigma>\n 3. state_invar s'\n 4. \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 5. state_\\<alpha> s' \\<in> invariant", "from exec"], ["proof (chain)\npicking this:\n  exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')", "have execT: \"execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\" \n    and q: \"\\<sigma>'' = \\<sigma>\""], ["proof (prove)\nusing this:\n  exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\n\ngoal (1 subgoal):\n 1. execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor> &&&\n    \\<sigma>'' = \\<sigma>", "by(auto simp add: exec_step.simps split_beta)"], ["proof (state)\nthis:\n  execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\n  \\<sigma>'' = \\<sigma>\n\ngoal (5 subgoals):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n 2. \\<sigma>'' = \\<sigma>\n 3. state_invar s'\n 4. \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n 5. state_\\<alpha> s' \\<in> invariant", "from invar wstok execT"], ["proof (chain)\npicking this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n  execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>", "show red: \"\\<alpha>.redT (state_\\<alpha> s) (t, ta) (state_\\<alpha> s')\" \n    and invar': \"state_invar s'\" \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\" \"\\<sigma>'' = \\<sigma>\""], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n  execT \\<sigma> s = \\<lfloor>(\\<sigma>', t, ta, s')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') &&&\n    state_invar s' &&&\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s'))) &&&\n    \\<sigma>'' = \\<sigma>", "by(rule execT_Some)+(rule q)"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  \\<sigma>'' = \\<sigma>\n\ngoal (1 subgoal):\n 1. state_\\<alpha> s' \\<in> invariant", "from invariant red \\<open>state_\\<alpha> s \\<in> invariant\\<close>"], ["proof (chain)\npicking this:\n  invariant3p \\<alpha>.redT invariant\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  state_\\<alpha> s \\<in> invariant", "show \"state_\\<alpha> s' \\<in> invariant\""], ["proof (prove)\nusing this:\n  invariant3p \\<alpha>.redT invariant\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  state_\\<alpha> s \\<in> invariant\n\ngoal (1 subgoal):\n 1. state_\\<alpha> s' \\<in> invariant", "by(rule invariant3pD)"], ["proof (state)\nthis:\n  state_\\<alpha> s' \\<in> invariant\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_step_InrD:\n  assumes \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and \"exec_step (\\<sigma>, s) = Inr s'\"\n  shows \"\\<alpha>.active_threads (state_\\<alpha> s) = {}\"\n  and \"s' = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>.active_threads (state_\\<alpha> s) = {} &&& s' = s", "using assms"], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  exec_step (\\<sigma>, s) = Inr s'\n\ngoal (1 subgoal):\n 1. \\<alpha>.active_threads (state_\\<alpha> s) = {} &&& s' = s", "by(auto simp add: exec_step_def dest: execT_None)"], ["", "lemma (in multithreaded_base) red_in_active_threads:\n  assumes \"s -t\\<triangleright>ta\\<rightarrow> s'\"\n  shows \"t \\<in> active_threads s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> active_threads s", "using assms"], ["proof (prove)\nusing this:\n  s -t\\<triangleright>ta\\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. t \\<in> active_threads s", "by cases(auto intro: active_threads.intros)"], ["", "lemma exec_aux_into_Runs:\n  assumes \"state_invar s\" \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_\\<alpha> s \\<in> invariant\"\n  and \"wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\"\n  shows \"\\<alpha>.mthr.Runs (state_\\<alpha> s) (lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))))\" (is ?thesis1)\n  and \"tfinite (exec_aux (\\<sigma>, s)) \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))\" (is \"_ \\<Longrightarrow> ?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>.mthr.Runs (state_\\<alpha> s)\n     (lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s)))) &&&\n    (tfinite (exec_aux (\\<sigma>, s)) \\<Longrightarrow>\n     state_invar (terminal (exec_aux (\\<sigma>, s))))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha>.mthr.Runs (state_\\<alpha> s)\n     (lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))))\n 2. tfinite (exec_aux (\\<sigma>, s)) \\<Longrightarrow>\n    state_invar (terminal (exec_aux (\\<sigma>, s)))", "from assms"], ["proof (chain)\npicking this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))", "show ?thesis1"], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. \\<alpha>.mthr.Runs (state_\\<alpha> s)\n     (lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))))", "proof(coinduction arbitrary: \\<sigma> s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa.\n                             state_\\<alpha> s = sa \\<and>\n                             lmap snd\n                              (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n                             LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> \\<alpha>.redT sa x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             state_\\<alpha> s = sa \\<and>\n                             lmap snd\n                              (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n                             LCons tl tls \\<and>\n                             \\<alpha>.redT sa tl s' \\<and>\n                             ((\\<exists>\\<sigma> s.\n                                  s' = state_\\<alpha> s \\<and>\n                                  tls =\n                                  lmap snd\n                                   (llist_of_tllist\n                                     (exec_aux (\\<sigma>, s))) \\<and>\n                                  state_invar s \\<and>\n                                  \\<sigma>_invar \\<sigma>\n                                   (dom (thr_\\<alpha> (thr s))) \\<and>\n                                  state_\\<alpha> s \\<in> invariant \\<and>\n                                  wset_thread_ok (ws_\\<alpha> (wset s))\n                                   (thr_\\<alpha> (thr s))) \\<or>\n                              \\<alpha>.mthr.Runs s' tls))", "case (Runs \\<sigma> s)"], ["proof (state)\nthis:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa.\n                             state_\\<alpha> s = sa \\<and>\n                             lmap snd\n                              (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n                             LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> \\<alpha>.redT sa x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             state_\\<alpha> s = sa \\<and>\n                             lmap snd\n                              (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n                             LCons tl tls \\<and>\n                             \\<alpha>.redT sa tl s' \\<and>\n                             ((\\<exists>\\<sigma> s.\n                                  s' = state_\\<alpha> s \\<and>\n                                  tls =\n                                  lmap snd\n                                   (llist_of_tllist\n                                     (exec_aux (\\<sigma>, s))) \\<and>\n                                  state_invar s \\<and>\n                                  \\<sigma>_invar \\<sigma>\n                                   (dom (thr_\\<alpha> (thr s))) \\<and>\n                                  state_\\<alpha> s \\<in> invariant \\<and>\n                                  wset_thread_ok (ws_\\<alpha> (wset s))\n                                   (thr_\\<alpha> (thr s))) \\<or>\n                              \\<alpha>.mthr.Runs s' tls))", "note invar = \\<open>state_invar s\\<close> \\<open>\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\\<close> \\<open>state_\\<alpha> s \\<in> invariant\\<close>\n      and wstok = \\<open>wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\\<close>"], ["proof (state)\nthis:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> s.\n       \\<lbrakk>state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>sa.\n                             state_\\<alpha> s = sa \\<and>\n                             lmap snd\n                              (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n                             LNil \\<and>\n                             (\\<forall>x xa.\n                                 \\<not> \\<alpha>.redT sa x xa)) \\<or>\n                         (\\<exists>sa s' tls tl.\n                             state_\\<alpha> s = sa \\<and>\n                             lmap snd\n                              (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n                             LCons tl tls \\<and>\n                             \\<alpha>.redT sa tl s' \\<and>\n                             ((\\<exists>\\<sigma> s.\n                                  s' = state_\\<alpha> s \\<and>\n                                  tls =\n                                  lmap snd\n                                   (llist_of_tllist\n                                     (exec_aux (\\<sigma>, s))) \\<and>\n                                  state_invar s \\<and>\n                                  \\<sigma>_invar \\<sigma>\n                                   (dom (thr_\\<alpha> (thr s))) \\<and>\n                                  state_\\<alpha> s \\<in> invariant \\<and>\n                                  wset_thread_ok (ws_\\<alpha> (wset s))\n                                   (thr_\\<alpha> (thr s))) \\<or>\n                              \\<alpha>.mthr.Runs s' tls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        state_\\<alpha> s = s \\<and>\n        lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n        (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        state_\\<alpha> s = s \\<and>\n        lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n        LCons tl tls \\<and>\n        \\<alpha>.redT s tl s' \\<and>\n        ((\\<exists>\\<sigma> s.\n             s' = state_\\<alpha> s \\<and>\n             tls =\n             lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n             state_invar s \\<and>\n             \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n             state_\\<alpha> s \\<in> invariant \\<and>\n             wset_thread_ok (ws_\\<alpha> (wset s))\n              (thr_\\<alpha> (thr s))) \\<or>\n         \\<alpha>.mthr.Runs s' tls))", "proof(cases \"exec_aux (\\<sigma>, s)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       exec_aux (\\<sigma>, s) = TNil x1 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))\n 2. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "case (TNil s')"], ["proof (state)\nthis:\n  exec_aux (\\<sigma>, s) = TNil s'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       exec_aux (\\<sigma>, s) = TNil x1 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))\n 2. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "hence \"\\<alpha>.active_threads (state_\\<alpha> s) = {}\" \"s' = s\""], ["proof (prove)\nusing this:\n  exec_aux (\\<sigma>, s) = TNil s'\n\ngoal (1 subgoal):\n 1. \\<alpha>.active_threads (state_\\<alpha> s) = {} &&& s' = s", "by(auto simp add: exec_aux_def unfold_tllist' split: sum.split_asm dest: exec_step_InrD[OF invar])"], ["proof (state)\nthis:\n  \\<alpha>.active_threads (state_\\<alpha> s) = {}\n  s' = s\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       exec_aux (\\<sigma>, s) = TNil x1 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))\n 2. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "hence ?Stuck"], ["proof (prove)\nusing this:\n  \\<alpha>.active_threads (state_\\<alpha> s) = {}\n  s' = s\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       state_\\<alpha> s = s \\<and>\n       lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n       (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)", "using TNil"], ["proof (prove)\nusing this:\n  \\<alpha>.active_threads (state_\\<alpha> s) = {}\n  s' = s\n  exec_aux (\\<sigma>, s) = TNil s'\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       state_\\<alpha> s = s \\<and>\n       lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n       (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)", "by(auto dest: \\<alpha>.red_in_active_threads)"], ["proof (state)\nthis:\n  \\<exists>s.\n     state_\\<alpha> s = s \\<and>\n     lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n     (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       exec_aux (\\<sigma>, s) = TNil x1 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))\n 2. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s.\n     state_\\<alpha> s = s \\<and>\n     lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n     (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        state_\\<alpha> s = s \\<and>\n        lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n        (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        state_\\<alpha> s = s \\<and>\n        lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n        LCons tl tls \\<and>\n        \\<alpha>.redT s tl s' \\<and>\n        ((\\<exists>\\<sigma> s.\n             s' = state_\\<alpha> s \\<and>\n             tls =\n             lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n             state_invar s \\<and>\n             \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n             state_\\<alpha> s \\<in> invariant \\<and>\n             wset_thread_ok (ws_\\<alpha> (wset s))\n              (thr_\\<alpha> (thr s))) \\<or>\n         \\<alpha>.mthr.Runs s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      state_\\<alpha> s = s \\<and>\n      lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n      (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      state_\\<alpha> s = s \\<and>\n      lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n      LCons tl tls \\<and>\n      \\<alpha>.redT s tl s' \\<and>\n      ((\\<exists>\\<sigma> s.\n           s' = state_\\<alpha> s \\<and>\n           tls = lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n           state_invar s \\<and>\n           \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n           state_\\<alpha> s \\<in> invariant \\<and>\n           wset_thread_ok (ws_\\<alpha> (wset s))\n            (thr_\\<alpha> (thr s))) \\<or>\n       \\<alpha>.mthr.Runs s' tls))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "case (TCons \\<sigma>tta ttls')"], ["proof (state)\nthis:\n  exec_aux (\\<sigma>, s) = TCons \\<sigma>tta ttls'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "then"], ["proof (chain)\npicking this:\n  exec_aux (\\<sigma>, s) = TCons \\<sigma>tta ttls'", "obtain t ta \\<sigma>' s' \\<sigma>''\n        where [simp]: \"\\<sigma>tta = (\\<sigma>'', t, ta)\"\n        and [simp]: \"ttls' = exec_aux (\\<sigma>', s')\"\n        and step: \"exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\""], ["proof (prove)\nusing this:\n  exec_aux (\\<sigma>, s) = TCons \\<sigma>tta ttls'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'' t ta \\<sigma>''' s'.\n        \\<lbrakk>\\<sigma>tta = (\\<sigma>'', t, ta);\n         ttls' = exec_aux (\\<sigma>''', s');\n         exec_step (\\<sigma>, s) =\n         Inl ((\\<sigma>'', t, ta), \\<sigma>''', s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding exec_aux_def"], ["proof (prove)\nusing this:\n  unfold_tllist' exec_step (\\<sigma>, s) = TCons \\<sigma>tta ttls'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'' t ta \\<sigma>''' s'.\n        \\<lbrakk>\\<sigma>tta = (\\<sigma>'', t, ta);\n         ttls' = unfold_tllist' exec_step (\\<sigma>''', s');\n         exec_step (\\<sigma>, s) =\n         Inl ((\\<sigma>'', t, ta), \\<sigma>''', s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(subst (asm) (2) unfold_tllist')(fastforce split: sum.split_asm)"], ["proof (state)\nthis:\n  \\<sigma>tta = (\\<sigma>'', t, ta)\n  ttls' = exec_aux (\\<sigma>', s')\n  exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "from invar wstok step"], ["proof (chain)\npicking this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n  exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')", "have redT: \"\\<alpha>.redT (state_\\<alpha> s) (t, ta) (state_\\<alpha> s')\"\n        and [simp]: \"\\<sigma>'' = \\<sigma>\"\n        and invar': \"state_invar s'\" \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\" \"state_\\<alpha> s' \\<in> invariant\""], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n  exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\n\ngoal (1 subgoal):\n 1. \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s') &&&\n    \\<sigma>'' = \\<sigma> &&&\n    state_invar s' &&&\n    \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s'))) &&&\n    state_\\<alpha> s' \\<in> invariant", "by(rule exec_step_into_redT)+"], ["proof (state)\nthis:\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  \\<sigma>'' = \\<sigma>\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  state_\\<alpha> s' \\<in> invariant\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "from wstok \\<alpha>.redT_preserves_wset_thread_ok[OF redT]"], ["proof (chain)\npicking this:\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n  wset_thread_ok (wset (state_\\<alpha> s))\n   (thr (state_\\<alpha> s)) \\<Longrightarrow>\n  wset_thread_ok (wset (state_\\<alpha> s')) (thr (state_\\<alpha> s'))", "have \"wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))\""], ["proof (prove)\nusing this:\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n  wset_thread_ok (wset (state_\\<alpha> s))\n   (thr (state_\\<alpha> s)) \\<Longrightarrow>\n  wset_thread_ok (wset (state_\\<alpha> s')) (thr (state_\\<alpha> s'))\n\ngoal (1 subgoal):\n 1. wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))", "by simp"], ["proof (state)\nthis:\n  wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "with invar' redT TCons"], ["proof (chain)\npicking this:\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  state_\\<alpha> s' \\<in> invariant\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  exec_aux (\\<sigma>, s) = TCons \\<sigma>tta ttls'\n  wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))", "have ?Step"], ["proof (prove)\nusing this:\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  state_\\<alpha> s' \\<in> invariant\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n  exec_aux (\\<sigma>, s) = TCons \\<sigma>tta ttls'\n  wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))\n\ngoal (1 subgoal):\n 1. \\<exists>s s' tls tl.\n       state_\\<alpha> s = s \\<and>\n       lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n       LCons tl tls \\<and>\n       \\<alpha>.redT s tl s' \\<and>\n       ((\\<exists>\\<sigma> s.\n            s' = state_\\<alpha> s \\<and>\n            tls = lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n            state_invar s \\<and>\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n            state_\\<alpha> s \\<in> invariant \\<and>\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))) \\<or>\n        \\<alpha>.mthr.Runs s' tls)", "by(auto simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>s s' tls tl.\n     state_\\<alpha> s = s \\<and>\n     lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n     LCons tl tls \\<and>\n     \\<alpha>.redT s tl s' \\<and>\n     ((\\<exists>\\<sigma> s.\n          s' = state_\\<alpha> s \\<and>\n          tls = lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n          state_invar s \\<and>\n          \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n          state_\\<alpha> s \\<in> invariant \\<and>\n          wset_thread_ok (ws_\\<alpha> (wset s))\n           (thr_\\<alpha> (thr s))) \\<or>\n      \\<alpha>.mthr.Runs s' tls)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       exec_aux (\\<sigma>, s) = TCons x21 x22 \\<Longrightarrow>\n       (\\<exists>s.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n           (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n       (\\<exists>s s' tls tl.\n           state_\\<alpha> s = s \\<and>\n           lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n           LCons tl tls \\<and>\n           \\<alpha>.redT s tl s' \\<and>\n           ((\\<exists>\\<sigma> s.\n                s' = state_\\<alpha> s \\<and>\n                tls =\n                lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n                state_invar s \\<and>\n                \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n                state_\\<alpha> s \\<in> invariant \\<and>\n                wset_thread_ok (ws_\\<alpha> (wset s))\n                 (thr_\\<alpha> (thr s))) \\<or>\n            \\<alpha>.mthr.Runs s' tls))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s s' tls tl.\n     state_\\<alpha> s = s \\<and>\n     lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n     LCons tl tls \\<and>\n     \\<alpha>.redT s tl s' \\<and>\n     ((\\<exists>\\<sigma> s.\n          s' = state_\\<alpha> s \\<and>\n          tls = lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n          state_invar s \\<and>\n          \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n          state_\\<alpha> s \\<in> invariant \\<and>\n          wset_thread_ok (ws_\\<alpha> (wset s))\n           (thr_\\<alpha> (thr s))) \\<or>\n      \\<alpha>.mthr.Runs s' tls)\n\ngoal (1 subgoal):\n 1. (\\<exists>s.\n        state_\\<alpha> s = s \\<and>\n        lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n        (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n    (\\<exists>s s' tls tl.\n        state_\\<alpha> s = s \\<and>\n        lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n        LCons tl tls \\<and>\n        \\<alpha>.redT s tl s' \\<and>\n        ((\\<exists>\\<sigma> s.\n             s' = state_\\<alpha> s \\<and>\n             tls =\n             lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n             state_invar s \\<and>\n             \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n             state_\\<alpha> s \\<in> invariant \\<and>\n             wset_thread_ok (ws_\\<alpha> (wset s))\n              (thr_\\<alpha> (thr s))) \\<or>\n         \\<alpha>.mthr.Runs s' tls))", ".."], ["proof (state)\nthis:\n  (\\<exists>s.\n      state_\\<alpha> s = s \\<and>\n      lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n      (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      state_\\<alpha> s = s \\<and>\n      lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n      LCons tl tls \\<and>\n      \\<alpha>.redT s tl s' \\<and>\n      ((\\<exists>\\<sigma> s.\n           s' = state_\\<alpha> s \\<and>\n           tls = lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n           state_invar s \\<and>\n           \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n           state_\\<alpha> s \\<in> invariant \\<and>\n           wset_thread_ok (ws_\\<alpha> (wset s))\n            (thr_\\<alpha> (thr s))) \\<or>\n       \\<alpha>.mthr.Runs s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>s.\n      state_\\<alpha> s = s \\<and>\n      lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) = LNil \\<and>\n      (\\<forall>x xa. \\<not> \\<alpha>.redT s x xa)) \\<or>\n  (\\<exists>s s' tls tl.\n      state_\\<alpha> s = s \\<and>\n      lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) =\n      LCons tl tls \\<and>\n      \\<alpha>.redT s tl s' \\<and>\n      ((\\<exists>\\<sigma> s.\n           s' = state_\\<alpha> s \\<and>\n           tls = lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))) \\<and>\n           state_invar s \\<and>\n           \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))) \\<and>\n           state_\\<alpha> s \\<in> invariant \\<and>\n           wset_thread_ok (ws_\\<alpha> (wset s))\n            (thr_\\<alpha> (thr s))) \\<or>\n       \\<alpha>.mthr.Runs s' tls))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>.mthr.Runs (state_\\<alpha> s)\n   (lmap snd (llist_of_tllist (exec_aux (\\<sigma>, s))))\n\ngoal (1 subgoal):\n 1. tfinite (exec_aux (\\<sigma>, s)) \\<Longrightarrow>\n    state_invar (terminal (exec_aux (\\<sigma>, s)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tfinite (exec_aux (\\<sigma>, s)) \\<Longrightarrow>\n    state_invar (terminal (exec_aux (\\<sigma>, s)))", "assume \"tfinite (exec_aux (\\<sigma>, s))\""], ["proof (state)\nthis:\n  tfinite (exec_aux (\\<sigma>, s))\n\ngoal (1 subgoal):\n 1. tfinite (exec_aux (\\<sigma>, s)) \\<Longrightarrow>\n    state_invar (terminal (exec_aux (\\<sigma>, s)))", "thus \"?thesis2\""], ["proof (prove)\nusing this:\n  tfinite (exec_aux (\\<sigma>, s))\n\ngoal (1 subgoal):\n 1. state_invar (terminal (exec_aux (\\<sigma>, s)))", "using assms"], ["proof (prove)\nusing this:\n  tfinite (exec_aux (\\<sigma>, s))\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. state_invar (terminal (exec_aux (\\<sigma>, s)))", "proof(induct \"exec_aux (\\<sigma>, s)\" arbitrary: \\<sigma> s rule: tfinite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y \\<sigma> s.\n       \\<lbrakk>TNil y = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))\n 2. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "case TNil"], ["proof (state)\nthis:\n  TNil y_ = exec_aux (\\<sigma>, s)\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (2 subgoals):\n 1. \\<And>y \\<sigma> s.\n       \\<lbrakk>TNil y = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))\n 2. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "thus ?case"], ["proof (prove)\nusing this:\n  TNil y_ = exec_aux (\\<sigma>, s)\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. state_invar (terminal (exec_aux (\\<sigma>, s)))", "by(auto simp add: exec_aux_def unfold_tllist' split_beta split: sum.split_asm dest: exec_step_InrD)"], ["proof (state)\nthis:\n  state_invar (terminal (exec_aux (\\<sigma>, s)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "case (TCons \\<sigma>tta ttls)"], ["proof (state)\nthis:\n  tfinite ttls\n  \\<lbrakk>ttls = exec_aux (?\\<sigma>2, ?s2); state_invar ?s2;\n   \\<sigma>_invar ?\\<sigma>2 (dom (thr_\\<alpha> (thr ?s2)));\n   state_\\<alpha> ?s2 \\<in> invariant;\n   wset_thread_ok (ws_\\<alpha> (wset ?s2)) (thr_\\<alpha> (thr ?s2))\\<rbrakk>\n  \\<Longrightarrow> state_invar (terminal (exec_aux (?\\<sigma>2, ?s2)))\n  TCons \\<sigma>tta ttls = exec_aux (\\<sigma>, s)\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "from \\<open>TCons \\<sigma>tta ttls = exec_aux (\\<sigma>, s)\\<close>"], ["proof (chain)\npicking this:\n  TCons \\<sigma>tta ttls = exec_aux (\\<sigma>, s)", "obtain \\<sigma>'' t ta \\<sigma>' s' \n      where [simp]: \"\\<sigma>tta = (\\<sigma>'', t, ta)\"\n      and ttls: \"ttls = exec_aux (\\<sigma>', s')\"\n      and step: \"exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\""], ["proof (prove)\nusing this:\n  TCons \\<sigma>tta ttls = exec_aux (\\<sigma>, s)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'' t ta \\<sigma>''' s'.\n        \\<lbrakk>\\<sigma>tta = (\\<sigma>'', t, ta);\n         ttls = exec_aux (\\<sigma>''', s');\n         exec_step (\\<sigma>, s) =\n         Inl ((\\<sigma>'', t, ta), \\<sigma>''', s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding exec_aux_def"], ["proof (prove)\nusing this:\n  TCons \\<sigma>tta ttls = unfold_tllist' exec_step (\\<sigma>, s)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'' t ta \\<sigma>''' s'.\n        \\<lbrakk>\\<sigma>tta = (\\<sigma>'', t, ta);\n         ttls = unfold_tllist' exec_step (\\<sigma>''', s');\n         exec_step (\\<sigma>, s) =\n         Inl ((\\<sigma>'', t, ta), \\<sigma>''', s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(subst (asm) (2) unfold_tllist')(fastforce split: sum.split_asm)"], ["proof (state)\nthis:\n  \\<sigma>tta = (\\<sigma>'', t, ta)\n  ttls = exec_aux (\\<sigma>', s')\n  exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "note ttls"], ["proof (state)\nthis:\n  ttls = exec_aux (\\<sigma>', s')\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "moreover"], ["proof (state)\nthis:\n  ttls = exec_aux (\\<sigma>', s')\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "from \\<open>state_invar s\\<close> \\<open>\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\\<close> \\<open>state_\\<alpha> s \\<in> invariant\\<close> \\<open>wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\\<close> step"], ["proof (chain)\npicking this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n  exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')", "have [simp]: \"\\<sigma>'' = \\<sigma>\"\n      and invar': \"state_invar s'\" \"\\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\" \"state_\\<alpha> s' \\<in> invariant\"\n      and redT: \"\\<alpha>.redT (state_\\<alpha> s) (t, ta) (state_\\<alpha> s')\""], ["proof (prove)\nusing this:\n  state_invar s\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_\\<alpha> s \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n  exec_step (\\<sigma>, s) = Inl ((\\<sigma>'', t, ta), \\<sigma>', s')\n\ngoal (1 subgoal):\n 1. \\<sigma>'' = \\<sigma> &&&\n    (state_invar s' &&&\n     \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s'))) &&&\n     state_\\<alpha> s' \\<in> invariant) &&&\n    \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')", "by(rule exec_step_into_redT)+"], ["proof (state)\nthis:\n  \\<sigma>'' = \\<sigma>\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  state_\\<alpha> s' \\<in> invariant\n  \\<alpha>.redT_syntax1 (state_\\<alpha> s) t ta (state_\\<alpha> s')\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "note invar'"], ["proof (state)\nthis:\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  state_\\<alpha> s' \\<in> invariant\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "moreover"], ["proof (state)\nthis:\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  state_\\<alpha> s' \\<in> invariant\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "from \\<alpha>.redT_preserves_wset_thread_ok[OF redT] \\<open>wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\\<close>"], ["proof (chain)\npicking this:\n  wset_thread_ok (wset (state_\\<alpha> s))\n   (thr (state_\\<alpha> s)) \\<Longrightarrow>\n  wset_thread_ok (wset (state_\\<alpha> s')) (thr (state_\\<alpha> s'))\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))", "have \"wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))\""], ["proof (prove)\nusing this:\n  wset_thread_ok (wset (state_\\<alpha> s))\n   (thr (state_\\<alpha> s)) \\<Longrightarrow>\n  wset_thread_ok (wset (state_\\<alpha> s')) (thr (state_\\<alpha> s'))\n  wset_thread_ok (ws_\\<alpha> (wset s)) (thr_\\<alpha> (thr s))\n\ngoal (1 subgoal):\n 1. wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))", "by simp"], ["proof (state)\nthis:\n  wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "ultimately"], ["proof (chain)\npicking this:\n  ttls = exec_aux (\\<sigma>', s')\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  state_\\<alpha> s' \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))", "have \"state_invar (terminal (exec_aux (\\<sigma>', s')))\""], ["proof (prove)\nusing this:\n  ttls = exec_aux (\\<sigma>', s')\n  state_invar s'\n  \\<sigma>_invar \\<sigma>' (dom (thr_\\<alpha> (thr s')))\n  state_\\<alpha> s' \\<in> invariant\n  wset_thread_ok (ws_\\<alpha> (wset s')) (thr_\\<alpha> (thr s'))\n\ngoal (1 subgoal):\n 1. state_invar (terminal (exec_aux (\\<sigma>', s')))", "by(rule TCons)"], ["proof (state)\nthis:\n  state_invar (terminal (exec_aux (\\<sigma>', s')))\n\ngoal (1 subgoal):\n 1. \\<And>x xs \\<sigma> s.\n       \\<lbrakk>tfinite xs;\n        \\<And>\\<sigma> s.\n           \\<lbrakk>xs = exec_aux (\\<sigma>, s); state_invar s;\n            \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n            state_\\<alpha> s \\<in> invariant;\n            wset_thread_ok (ws_\\<alpha> (wset s))\n             (thr_\\<alpha> (thr s))\\<rbrakk>\n           \\<Longrightarrow> state_invar\n                              (terminal (exec_aux (\\<sigma>, s)));\n        TCons x xs = exec_aux (\\<sigma>, s); state_invar s;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)));\n        state_\\<alpha> s \\<in> invariant;\n        wset_thread_ok (ws_\\<alpha> (wset s))\n         (thr_\\<alpha> (thr s))\\<rbrakk>\n       \\<Longrightarrow> state_invar (terminal (exec_aux (\\<sigma>, s)))", "with \\<open>TCons \\<sigma>tta ttls = exec_aux (\\<sigma>, s)\\<close>[symmetric]"], ["proof (chain)\npicking this:\n  exec_aux (\\<sigma>, s) = TCons \\<sigma>tta ttls\n  state_invar (terminal (exec_aux (\\<sigma>', s')))", "show ?case"], ["proof (prove)\nusing this:\n  exec_aux (\\<sigma>, s) = TCons \\<sigma>tta ttls\n  state_invar (terminal (exec_aux (\\<sigma>', s')))\n\ngoal (1 subgoal):\n 1. state_invar (terminal (exec_aux (\\<sigma>, s)))", "unfolding ttls"], ["proof (prove)\nusing this:\n  exec_aux (\\<sigma>, s) = TCons \\<sigma>tta (exec_aux (\\<sigma>', s'))\n  state_invar (terminal (exec_aux (\\<sigma>', s')))\n\ngoal (1 subgoal):\n 1. state_invar (terminal (exec_aux (\\<sigma>, s)))", "by simp"], ["proof (state)\nthis:\n  state_invar (terminal (exec_aux (\\<sigma>, s)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_invar (terminal (exec_aux (\\<sigma>, s)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale scheduler_ext_aux =\n  scheduler_ext_base\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update thr_iterate\n    ws_\\<alpha> ws_invar ws_lookup ws_update ws_sel\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n    thr'_\\<alpha> thr'_invar thr'_empty thr'_ins_dj\n  +\n  scheduler_aux\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n  +\n  thr: map_iteratei thr_\\<alpha> thr_invar thr_iterate +\n  ws: map_update ws_\\<alpha> ws_invar ws_update +\n  ws: map_sel' ws_\\<alpha> ws_invar ws_sel +\n  thr': finite_set thr'_\\<alpha> thr'_invar +\n  thr': set_empty thr'_\\<alpha> thr'_invar thr'_empty +\n  thr': set_ins_dj thr'_\\<alpha> thr'_invar thr'_ins_dj  \n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and thr_iterate :: \"'m_t \\<Rightarrow> ('t \\<times> ('x \\<times> 'l released_locks), 's_t) set_iterator\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and ws_update :: \"'t \\<Rightarrow> 'w wait_set_status \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_sel :: \"'m_w \\<Rightarrow> (('t \\<times> 'w wait_set_status) \\<Rightarrow> bool) \\<rightharpoonup> ('t \\<times> 'w wait_set_status)\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and thr'_\\<alpha> :: \"'s_t \\<Rightarrow> 't set\"\n  and thr'_invar :: \"'s_t \\<Rightarrow> bool\"\n  and thr'_empty :: \"unit \\<Rightarrow> 's_t\"\n  and thr'_ins_dj :: \"'t \\<Rightarrow> 's_t \\<Rightarrow> 's_t\"\nbegin"], ["", "lemma active_threads_correct [simp]:\n  assumes \"state_invar s\"\n  shows \"thr'_\\<alpha> (active_threads s) = \\<alpha>.active_threads (state_\\<alpha> s)\" (is \"?thesis1\")\n  and \"thr'_invar (active_threads s)\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s) &&&\n    thr'_invar (active_threads s)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s)\n 2. thr'_invar (active_threads s)", "obtain ls ts m ws \"is\" where s: \"s = (ls, (ts, m), ws, is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls ts m ws is.\n        s = (ls, (ts, m), ws, is) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s) fastforce"], ["proof (state)\nthis:\n  s = (ls, (ts, m), ws, is)\n\ngoal (2 subgoals):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s)\n 2. thr'_invar (active_threads s)", "let ?f = \"\\<lambda>(t, (x, ln)) TS. if ln = no_wait_locks\n           then if Predicate.holds (do { (ta, _) \\<leftarrow> r t (x, m); Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta) })\n                then thr'_ins_dj t TS else TS\n           else if \\<not> waiting (ws_lookup t ws) \\<and> may_acquire_all ls t ln then thr'_ins_dj t TS else TS\""], ["proof (state)\ngoal (2 subgoals):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s)\n 2. thr'_invar (active_threads s)", "let ?I = \"\\<lambda>T TS. thr'_invar TS \\<and> thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and> (\\<forall>t. t \\<notin> T \\<longrightarrow> t \\<in> thr'_\\<alpha> TS \\<longleftrightarrow> t \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\""], ["proof (state)\ngoal (2 subgoals):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s)\n 2. thr'_invar (active_threads s)", "from assms s"], ["proof (chain)\npicking this:\n  state_invar s\n  s = (ls, (ts, m), ws, is)", "have \"thr_invar ts\""], ["proof (prove)\nusing this:\n  state_invar s\n  s = (ls, (ts, m), ws, is)\n\ngoal (1 subgoal):\n 1. thr_invar ts", "by simp"], ["proof (state)\nthis:\n  thr_invar ts\n\ngoal (2 subgoals):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s)\n 2. thr'_invar (active_threads s)", "moreover"], ["proof (state)\nthis:\n  thr_invar ts\n\ngoal (2 subgoals):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s)\n 2. thr'_invar (active_threads s)", "have \"?I (dom (thr_\\<alpha> ts)) (thr'_empty ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thr'_invar (thr'_empty ()) \\<and>\n    thr'_\\<alpha> (thr'_empty ())\n    \\<subseteq> dom (thr_\\<alpha> ts) - dom (thr_\\<alpha> ts) \\<and>\n    (\\<forall>t.\n        t \\<notin> dom (thr_\\<alpha> ts) \\<longrightarrow>\n        (t \\<in> thr'_\\<alpha> (thr'_empty ())) =\n        (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "by(auto simp add: thr'.empty_correct s elim: \\<alpha>.active_threads.cases)"], ["proof (state)\nthis:\n  thr'_invar (thr'_empty ()) \\<and>\n  thr'_\\<alpha> (thr'_empty ())\n  \\<subseteq> dom (thr_\\<alpha> ts) - dom (thr_\\<alpha> ts) \\<and>\n  (\\<forall>t.\n      t \\<notin> dom (thr_\\<alpha> ts) \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> (thr'_empty ())) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (2 subgoals):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s)\n 2. thr'_invar (active_threads s)", "ultimately"], ["proof (chain)\npicking this:\n  thr_invar ts\n  thr'_invar (thr'_empty ()) \\<and>\n  thr'_\\<alpha> (thr'_empty ())\n  \\<subseteq> dom (thr_\\<alpha> ts) - dom (thr_\\<alpha> ts) \\<and>\n  (\\<forall>t.\n      t \\<notin> dom (thr_\\<alpha> ts) \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> (thr'_empty ())) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "have \"?I {} (thr_iterate ts (\\<lambda>_. True) ?f (thr'_empty ()))\""], ["proof (prove)\nusing this:\n  thr_invar ts\n  thr'_invar (thr'_empty ()) \\<and>\n  thr'_\\<alpha> (thr'_empty ())\n  \\<subseteq> dom (thr_\\<alpha> ts) - dom (thr_\\<alpha> ts) \\<and>\n  (\\<forall>t.\n      t \\<notin> dom (thr_\\<alpha> ts) \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> (thr'_empty ())) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. thr'_invar\n     (thr_iterate ts (\\<lambda>_. True)\n       (\\<lambda>(t, x, ln) TS.\n           if ln = no_wait_locks\n           then if Predicate.holds\n                    (r t (x, m) \\<bind>\n                     (\\<lambda>(ta, uu_).\n                         Predicate.if_pred\n                          (actions_ok (ls, (ts, m), ws, is) t ta)))\n                then thr'_ins_dj t TS else TS\n           else if \\<not> waiting (ws_lookup t ws) \\<and>\n                   may_acquire_all ls t ln\n                then thr'_ins_dj t TS else TS)\n       (thr'_empty ())) \\<and>\n    thr'_\\<alpha>\n     (thr_iterate ts (\\<lambda>_. True)\n       (\\<lambda>(t, x, ln) TS.\n           if ln = no_wait_locks\n           then if Predicate.holds\n                    (r t (x, m) \\<bind>\n                     (\\<lambda>(ta, uu_).\n                         Predicate.if_pred\n                          (actions_ok (ls, (ts, m), ws, is) t ta)))\n                then thr'_ins_dj t TS else TS\n           else if \\<not> waiting (ws_lookup t ws) \\<and>\n                   may_acquire_all ls t ln\n                then thr'_ins_dj t TS else TS)\n       (thr'_empty ()))\n    \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n    (\\<forall>t.\n        t \\<notin> {} \\<longrightarrow>\n        (t \\<in> thr'_\\<alpha>\n                  (thr_iterate ts (\\<lambda>_. True)\n                    (\\<lambda>(t, x, ln) TS.\n                        if ln = no_wait_locks\n                        then if Predicate.holds\n                                 (r t (x, m) \\<bind>\n                                  (\\<lambda>(ta, uu_).\nPredicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\n                             then thr'_ins_dj t TS else TS\n                        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                                may_acquire_all ls t ln\n                             then thr'_ins_dj t TS else TS)\n                    (thr'_empty ()))) =\n        (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "proof(rule thr.iterate_rule_P[where I=\"?I\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "fix t xln T TS"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "assume tT: \"t \\<in> T\" \n      and tst: \"thr_\\<alpha> ts t = \\<lfloor>xln\\<rfloor>\"\n      and Tdom: \"T \\<subseteq> dom (thr_\\<alpha> ts)\"\n      and I: \"?I T TS\""], ["proof (state)\nthis:\n  t \\<in> T\n  thr_\\<alpha> ts t = \\<lfloor>xln\\<rfloor>\n  T \\<subseteq> dom (thr_\\<alpha> ts)\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "obtain x ln where xln: \"xln = (x, ln)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x ln. xln = (x, ln) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xln)"], ["proof (state)\nthis:\n  xln = (x, ln)\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "from tT I"], ["proof (chain)\npicking this:\n  t \\<in> T\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "have t: \"t \\<notin> thr'_\\<alpha> TS\""], ["proof (prove)\nusing this:\n  t \\<in> T\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. t \\<notin> thr'_\\<alpha> TS", "by blast"], ["proof (state)\nthis:\n  t \\<notin> thr'_\\<alpha> TS\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "from I"], ["proof (chain)\npicking this:\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "have invar: \"thr'_invar TS\""], ["proof (prove)\nusing this:\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. thr'_invar TS", ".."], ["proof (state)\nthis:\n  thr'_invar TS\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "hence \"thr'_invar (?f (t, xln) TS)\""], ["proof (prove)\nusing this:\n  thr'_invar TS\n\ngoal (1 subgoal):\n 1. thr'_invar\n     ((case (t, xln) of\n       (t, xa, ln) \\<Rightarrow>\n         \\<lambda>TS.\n            if ln = no_wait_locks\n            then if Predicate.holds\n                     (r t (xa, m) \\<bind>\n                      (\\<lambda>(ta, uu_).\n                          Predicate.if_pred\n                           (actions_ok (ls, (ts, m), ws, is) t ta)))\n                 then thr'_ins_dj t TS else TS\n            else if \\<not> waiting (ws_lookup t ws) \\<and>\n                    may_acquire_all ls t ln\n                 then thr'_ins_dj t TS else TS)\n       TS)", "using t"], ["proof (prove)\nusing this:\n  thr'_invar TS\n  t \\<notin> thr'_\\<alpha> TS\n\ngoal (1 subgoal):\n 1. thr'_invar\n     ((case (t, xln) of\n       (t, xa, ln) \\<Rightarrow>\n         \\<lambda>TS.\n            if ln = no_wait_locks\n            then if Predicate.holds\n                     (r t (xa, m) \\<bind>\n                      (\\<lambda>(ta, uu_).\n                          Predicate.if_pred\n                           (actions_ok (ls, (ts, m), ws, is) t ta)))\n                 then thr'_ins_dj t TS else TS\n            else if \\<not> waiting (ws_lookup t ws) \\<and>\n                    may_acquire_all ls t ln\n                 then thr'_ins_dj t TS else TS)\n       TS)", "unfolding xln"], ["proof (prove)\nusing this:\n  thr'_invar TS\n  t \\<notin> thr'_\\<alpha> TS\n\ngoal (1 subgoal):\n 1. thr'_invar\n     ((case (t, x, ln) of\n       (t, xa, ln) \\<Rightarrow>\n         \\<lambda>TS.\n            if ln = no_wait_locks\n            then if Predicate.holds\n                     (r t (xa, m) \\<bind>\n                      (\\<lambda>(ta, uu_).\n                          Predicate.if_pred\n                           (actions_ok (ls, (ts, m), ws, is) t ta)))\n                 then thr'_ins_dj t TS else TS\n            else if \\<not> waiting (ws_lookup t ws) \\<and>\n                    may_acquire_all ls t ln\n                 then thr'_ins_dj t TS else TS)\n       TS)", "by(auto simp add: thr'.ins_dj_correct)"], ["proof (state)\nthis:\n  thr'_invar\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "moreover"], ["proof (state)\nthis:\n  thr'_invar\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "from I"], ["proof (chain)\npicking this:\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "have \"thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T\""], ["proof (prove)\nusing this:\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T", "by blast"], ["proof (state)\nthis:\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "hence \"thr'_\\<alpha> (?f (t, xln) TS) \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t})\""], ["proof (prove)\nusing this:\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T\n\ngoal (1 subgoal):\n 1. thr'_\\<alpha>\n     ((case (t, xln) of\n       (t, xa, ln) \\<Rightarrow>\n         \\<lambda>TS.\n            if ln = no_wait_locks\n            then if Predicate.holds\n                     (r t (xa, m) \\<bind>\n                      (\\<lambda>(ta, uu_).\n                          Predicate.if_pred\n                           (actions_ok (ls, (ts, m), ws, is) t ta)))\n                 then thr'_ins_dj t TS else TS\n            else if \\<not> waiting (ws_lookup t ws) \\<and>\n                    may_acquire_all ls t ln\n                 then thr'_ins_dj t TS else TS)\n       TS)\n    \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t})", "using invar tst t"], ["proof (prove)\nusing this:\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T\n  thr'_invar TS\n  thr_\\<alpha> ts t = \\<lfloor>xln\\<rfloor>\n  t \\<notin> thr'_\\<alpha> TS\n\ngoal (1 subgoal):\n 1. thr'_\\<alpha>\n     ((case (t, xln) of\n       (t, xa, ln) \\<Rightarrow>\n         \\<lambda>TS.\n            if ln = no_wait_locks\n            then if Predicate.holds\n                     (r t (xa, m) \\<bind>\n                      (\\<lambda>(ta, uu_).\n                          Predicate.if_pred\n                           (actions_ok (ls, (ts, m), ws, is) t ta)))\n                 then thr'_ins_dj t TS else TS\n            else if \\<not> waiting (ws_lookup t ws) \\<and>\n                    may_acquire_all ls t ln\n                 then thr'_ins_dj t TS else TS)\n       TS)\n    \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t})", "by(auto simp add: xln thr'.ins_dj_correct)"], ["proof (state)\nthis:\n  thr'_\\<alpha>\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n  \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t})\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "moreover"], ["proof (state)\nthis:\n  thr'_\\<alpha>\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n  \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t})\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "{"], ["proof (state)\nthis:\n  thr'_\\<alpha>\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n  \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t})\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "fix t'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "assume t': \"t' \\<notin> T - {t}\""], ["proof (state)\nthis:\n  t' \\<notin> T - {t}\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "have \"t' \\<in> thr'_\\<alpha> (?f (t, xln) TS) \\<longleftrightarrow> t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "proof(cases \"t' = t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n 2. t' \\<noteq> t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "case True"], ["proof (state)\nthis:\n  t' = t\n\ngoal (2 subgoals):\n 1. t' = t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n 2. t' \\<noteq> t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t' \\<in> thr'_\\<alpha>\n              ((case (t, xln) of\n                (t, xa, ln) \\<Rightarrow>\n                  \\<lambda>TS.\n                     if ln = no_wait_locks\n                     then if Predicate.holds\n                              (r t (xa, m) \\<bind>\n                               (\\<lambda>(ta, uu_).\n                                   Predicate.if_pred\n                                    (actions_ok (ls, (ts, m), ws, is) t\nta)))\n                          then thr'_ins_dj t TS else TS\n                     else if \\<not> waiting (ws_lookup t ws) \\<and>\n                             may_acquire_all ls t ln\n                          then thr'_ins_dj t TS else TS)\n                TS) \\<Longrightarrow>\n    t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)\n 2. t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s) \\<Longrightarrow>\n    t' \\<in> thr'_\\<alpha>\n              ((case (t, xln) of\n                (t, xa, ln) \\<Rightarrow>\n                  \\<lambda>TS.\n                     if ln = no_wait_locks\n                     then if Predicate.holds\n                              (r t (xa, m) \\<bind>\n                               (\\<lambda>(ta, uu_).\n                                   Predicate.if_pred\n                                    (actions_ok (ls, (ts, m), ws, is) t\nta)))\n                          then thr'_ins_dj t TS else TS\n                     else if \\<not> waiting (ws_lookup t ws) \\<and>\n                             may_acquire_all ls t ln\n                          then thr'_ins_dj t TS else TS)\n                TS)", "assume ?lhs"], ["proof (state)\nthis:\n  t' \\<in> thr'_\\<alpha>\n            ((case (t, xln) of\n              (t, xa, ln) \\<Rightarrow>\n                \\<lambda>TS.\n                   if ln = no_wait_locks\n                   then if Predicate.holds\n                            (r t (xa, m) \\<bind>\n                             (\\<lambda>(ta, uu_).\n                                 Predicate.if_pred\n                                  (actions_ok (ls, (ts, m), ws, is) t ta)))\n                        then thr'_ins_dj t TS else TS\n                   else if \\<not> waiting (ws_lookup t ws) \\<and>\n                           may_acquire_all ls t ln\n                        then thr'_ins_dj t TS else TS)\n              TS)\n\ngoal (2 subgoals):\n 1. t' \\<in> thr'_\\<alpha>\n              ((case (t, xln) of\n                (t, xa, ln) \\<Rightarrow>\n                  \\<lambda>TS.\n                     if ln = no_wait_locks\n                     then if Predicate.holds\n                              (r t (xa, m) \\<bind>\n                               (\\<lambda>(ta, uu_).\n                                   Predicate.if_pred\n                                    (actions_ok (ls, (ts, m), ws, is) t\nta)))\n                          then thr'_ins_dj t TS else TS\n                     else if \\<not> waiting (ws_lookup t ws) \\<and>\n                             may_acquire_all ls t ln\n                          then thr'_ins_dj t TS else TS)\n                TS) \\<Longrightarrow>\n    t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)\n 2. t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s) \\<Longrightarrow>\n    t' \\<in> thr'_\\<alpha>\n              ((case (t, xln) of\n                (t, xa, ln) \\<Rightarrow>\n                  \\<lambda>TS.\n                     if ln = no_wait_locks\n                     then if Predicate.holds\n                              (r t (xa, m) \\<bind>\n                               (\\<lambda>(ta, uu_).\n                                   Predicate.if_pred\n                                    (actions_ok (ls, (ts, m), ws, is) t\nta)))\n                          then thr'_ins_dj t TS else TS\n                     else if \\<not> waiting (ws_lookup t ws) \\<and>\n                             may_acquire_all ls t ln\n                          then thr'_ins_dj t TS else TS)\n                TS)", "with True xln invar tst \\<open>state_invar s\\<close> t"], ["proof (chain)\npicking this:\n  t' = t\n  xln = (x, ln)\n  thr'_invar TS\n  thr_\\<alpha> ts t = \\<lfloor>xln\\<rfloor>\n  state_invar s\n  t \\<notin> thr'_\\<alpha> TS\n  t' \\<in> thr'_\\<alpha>\n            ((case (t, xln) of\n              (t, xa, ln) \\<Rightarrow>\n                \\<lambda>TS.\n                   if ln = no_wait_locks\n                   then if Predicate.holds\n                            (r t (xa, m) \\<bind>\n                             (\\<lambda>(ta, uu_).\n                                 Predicate.if_pred\n                                  (actions_ok (ls, (ts, m), ws, is) t ta)))\n                        then thr'_ins_dj t TS else TS\n                   else if \\<not> waiting (ws_lookup t ws) \\<and>\n                           may_acquire_all ls t ln\n                        then thr'_ins_dj t TS else TS)\n              TS)", "show ?rhs"], ["proof (prove)\nusing this:\n  t' = t\n  xln = (x, ln)\n  thr'_invar TS\n  thr_\\<alpha> ts t = \\<lfloor>xln\\<rfloor>\n  state_invar s\n  t \\<notin> thr'_\\<alpha> TS\n  t' \\<in> thr'_\\<alpha>\n            ((case (t, xln) of\n              (t, xa, ln) \\<Rightarrow>\n                \\<lambda>TS.\n                   if ln = no_wait_locks\n                   then if Predicate.holds\n                            (r t (xa, m) \\<bind>\n                             (\\<lambda>(ta, uu_).\n                                 Predicate.if_pred\n                                  (actions_ok (ls, (ts, m), ws, is) t ta)))\n                        then thr'_ins_dj t TS else TS\n                   else if \\<not> waiting (ws_lookup t ws) \\<and>\n                           may_acquire_all ls t ln\n                        then thr'_ins_dj t TS else TS)\n              TS)\n\ngoal (1 subgoal):\n 1. t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)", "by(fastforce simp add: holds_eq thr'.ins_dj_correct s split_beta ws.lookup_correct split: if_split_asm elim!: bindE if_predE intro: \\<alpha>.active_threads.intros)"], ["proof (state)\nthis:\n  t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s) \\<Longrightarrow>\n    t' \\<in> thr'_\\<alpha>\n              ((case (t, xln) of\n                (t, xa, ln) \\<Rightarrow>\n                  \\<lambda>TS.\n                     if ln = no_wait_locks\n                     then if Predicate.holds\n                              (r t (xa, m) \\<bind>\n                               (\\<lambda>(ta, uu_).\n                                   Predicate.if_pred\n                                    (actions_ok (ls, (ts, m), ws, is) t\nta)))\n                          then thr'_ins_dj t TS else TS\n                     else if \\<not> waiting (ws_lookup t ws) \\<and>\n                             may_acquire_all ls t ln\n                          then thr'_ins_dj t TS else TS)\n                TS)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s) \\<Longrightarrow>\n    t' \\<in> thr'_\\<alpha>\n              ((case (t, xln) of\n                (t, xa, ln) \\<Rightarrow>\n                  \\<lambda>TS.\n                     if ln = no_wait_locks\n                     then if Predicate.holds\n                              (r t (xa, m) \\<bind>\n                               (\\<lambda>(ta, uu_).\n                                   Predicate.if_pred\n                                    (actions_ok (ls, (ts, m), ws, is) t\nta)))\n                          then thr'_ins_dj t TS else TS\n                     else if \\<not> waiting (ws_lookup t ws) \\<and>\n                             may_acquire_all ls t ln\n                          then thr'_ins_dj t TS else TS)\n                TS)", "assume ?rhs"], ["proof (state)\nthis:\n  t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s) \\<Longrightarrow>\n    t' \\<in> thr'_\\<alpha>\n              ((case (t, xln) of\n                (t, xa, ln) \\<Rightarrow>\n                  \\<lambda>TS.\n                     if ln = no_wait_locks\n                     then if Predicate.holds\n                              (r t (xa, m) \\<bind>\n                               (\\<lambda>(ta, uu_).\n                                   Predicate.if_pred\n                                    (actions_ok (ls, (ts, m), ws, is) t\nta)))\n                          then thr'_ins_dj t TS else TS\n                     else if \\<not> waiting (ws_lookup t ws) \\<and>\n                             may_acquire_all ls t ln\n                          then thr'_ins_dj t TS else TS)\n                TS)", "with True xln invar tst \\<open>state_invar s\\<close> t"], ["proof (chain)\npicking this:\n  t' = t\n  xln = (x, ln)\n  thr'_invar TS\n  thr_\\<alpha> ts t = \\<lfloor>xln\\<rfloor>\n  state_invar s\n  t \\<notin> thr'_\\<alpha> TS\n  t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)", "show ?lhs"], ["proof (prove)\nusing this:\n  t' = t\n  xln = (x, ln)\n  thr'_invar TS\n  thr_\\<alpha> ts t = \\<lfloor>xln\\<rfloor>\n  state_invar s\n  t \\<notin> thr'_\\<alpha> TS\n  t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. t' \\<in> thr'_\\<alpha>\n              ((case (t, xln) of\n                (t, xa, ln) \\<Rightarrow>\n                  \\<lambda>TS.\n                     if ln = no_wait_locks\n                     then if Predicate.holds\n                              (r t (xa, m) \\<bind>\n                               (\\<lambda>(ta, uu_).\n                                   Predicate.if_pred\n                                    (actions_ok (ls, (ts, m), ws, is) t\nta)))\n                          then thr'_ins_dj t TS else TS\n                     else if \\<not> waiting (ws_lookup t ws) \\<and>\n                             may_acquire_all ls t ln\n                          then thr'_ins_dj t TS else TS)\n                TS)", "by(fastforce elim!: \\<alpha>.active_threads.cases simp add: holds_eq s thr'.ins_dj_correct ws.lookup_correct elim!: bindE if_predE intro: bindI if_predI)"], ["proof (state)\nthis:\n  t' \\<in> thr'_\\<alpha>\n            ((case (t, xln) of\n              (t, xa, ln) \\<Rightarrow>\n                \\<lambda>TS.\n                   if ln = no_wait_locks\n                   then if Predicate.holds\n                            (r t (xa, m) \\<bind>\n                             (\\<lambda>(ta, uu_).\n                                 Predicate.if_pred\n                                  (actions_ok (ls, (ts, m), ws, is) t ta)))\n                        then thr'_ins_dj t TS else TS\n                   else if \\<not> waiting (ws_lookup t ws) \\<and>\n                           may_acquire_all ls t ln\n                        then thr'_ins_dj t TS else TS)\n              TS)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t' \\<in> thr'_\\<alpha>\n             ((case (t, xln) of\n               (t, xa, ln) \\<Rightarrow>\n                 \\<lambda>TS.\n                    if ln = no_wait_locks\n                    then if Predicate.holds\n                             (r t (xa, m) \\<bind>\n                              (\\<lambda>(ta, uu_).\n                                  Predicate.if_pred\n                                   (actions_ok (ls, (ts, m), ws, is) t ta)))\n                         then thr'_ins_dj t TS else TS\n                    else if \\<not> waiting (ws_lookup t ws) \\<and>\n                            may_acquire_all ls t ln\n                         then thr'_ins_dj t TS else TS)\n               TS)) =\n  (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "case False"], ["proof (state)\nthis:\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "with t'"], ["proof (chain)\npicking this:\n  t' \\<notin> T - {t}\n  t' \\<noteq> t", "have \"t' \\<notin> T\""], ["proof (prove)\nusing this:\n  t' \\<notin> T - {t}\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. t' \\<notin> T", "by simp"], ["proof (state)\nthis:\n  t' \\<notin> T\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "with I"], ["proof (chain)\npicking this:\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n  t' \\<notin> T", "have \"t' \\<in> thr'_\\<alpha> TS \\<longleftrightarrow> t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s)\""], ["proof (prove)\nusing this:\n  thr'_invar TS \\<and>\n  thr'_\\<alpha> TS \\<subseteq> dom (thr_\\<alpha> ts) - T \\<and>\n  (\\<forall>t.\n      t \\<notin> T \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha> TS) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n  t' \\<notin> T\n\ngoal (1 subgoal):\n 1. (t' \\<in> thr'_\\<alpha> TS) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "by blast"], ["proof (state)\nthis:\n  (t' \\<in> thr'_\\<alpha> TS) =\n  (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n\ngoal (1 subgoal):\n 1. t' \\<noteq> t \\<Longrightarrow>\n    (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t' \\<in> thr'_\\<alpha> TS) =\n  (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n\ngoal (1 subgoal):\n 1. (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "using xln False invar t"], ["proof (prove)\nusing this:\n  (t' \\<in> thr'_\\<alpha> TS) =\n  (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n  xln = (x, ln)\n  t' \\<noteq> t\n  thr'_invar TS\n  t \\<notin> thr'_\\<alpha> TS\n\ngoal (1 subgoal):\n 1. (t' \\<in> thr'_\\<alpha>\n               ((case (t, xln) of\n                 (t, xa, ln) \\<Rightarrow>\n                   \\<lambda>TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (xa, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                 TS)) =\n    (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "by(auto simp add: thr'.ins_dj_correct)"], ["proof (state)\nthis:\n  (t' \\<in> thr'_\\<alpha>\n             ((case (t, xln) of\n               (t, xa, ln) \\<Rightarrow>\n                 \\<lambda>TS.\n                    if ln = no_wait_locks\n                    then if Predicate.holds\n                             (r t (xa, m) \\<bind>\n                              (\\<lambda>(ta, uu_).\n                                  Predicate.if_pred\n                                   (actions_ok (ls, (ts, m), ws, is) t ta)))\n                         then thr'_ins_dj t TS else TS\n                    else if \\<not> waiting (ws_lookup t ws) \\<and>\n                            may_acquire_all ls t ln\n                         then thr'_ins_dj t TS else TS)\n               TS)) =\n  (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t' \\<in> thr'_\\<alpha>\n             ((case (t, xln) of\n               (t, xa, ln) \\<Rightarrow>\n                 \\<lambda>TS.\n                    if ln = no_wait_locks\n                    then if Predicate.holds\n                             (r t (xa, m) \\<bind>\n                              (\\<lambda>(ta, uu_).\n                                  Predicate.if_pred\n                                   (actions_ok (ls, (ts, m), ws, is) t ta)))\n                         then thr'_ins_dj t TS else TS\n                    else if \\<not> waiting (ws_lookup t ws) \\<and>\n                            may_acquire_all ls t ln\n                         then thr'_ins_dj t TS else TS)\n               TS)) =\n  (t' \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "}"], ["proof (state)\nthis:\n  ?t'5 \\<notin> T - {t} \\<Longrightarrow>\n  (?t'5\n   \\<in> thr'_\\<alpha>\n          ((case (t, xln) of\n            (t, xa, ln) \\<Rightarrow>\n              \\<lambda>TS.\n                 if ln = no_wait_locks\n                 then if Predicate.holds\n                          (r t (xa, m) \\<bind>\n                           (\\<lambda>(ta, uu_).\n                               Predicate.if_pred\n                                (actions_ok (ls, (ts, m), ws, is) t ta)))\n                      then thr'_ins_dj t TS else TS\n                 else if \\<not> waiting (ws_lookup t ws) \\<and>\n                         may_acquire_all ls t ln\n                      then thr'_ins_dj t TS else TS)\n            TS)) =\n  (?t'5 \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>k \\<in> it; thr_\\<alpha> ts k = \\<lfloor>v\\<rfloor>;\n        it \\<subseteq> dom (thr_\\<alpha> ts);\n        thr'_invar \\<sigma> \\<and>\n        thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - it \\<and>\n        (\\<forall>t.\n            t \\<notin> it \\<longrightarrow>\n            (t \\<in> thr'_\\<alpha> \\<sigma>) =\n            (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\\<rbrakk>\n       \\<Longrightarrow> thr'_invar\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>) \\<and>\n                         thr'_\\<alpha>\n                          ((case (k, v) of\n                            (t, xa, ln) \\<Rightarrow>\n                              \\<lambda>TS.\n                                 if ln = no_wait_locks\n                                 then if Predicate.holds\n    (r t (xa, m) \\<bind>\n     (\\<lambda>(ta, uu_).\n         Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\nthen thr'_ins_dj t TS else TS\n                                 else if \\<not> waiting\n           (ws_lookup t ws) \\<and>\n   may_acquire_all ls t ln\nthen thr'_ins_dj t TS else TS)\n                            \\<sigma>)\n                         \\<subseteq> dom (thr_\\<alpha> ts) -\n                                     (it - {k}) \\<and>\n                         (\\<forall>t.\n                             t \\<notin> it - {k} \\<longrightarrow>\n                             (t \\<in> thr'_\\<alpha>\n ((case (k, v) of\n   (t, xa, ln) \\<Rightarrow>\n     \\<lambda>TS.\n        if ln = no_wait_locks\n        then if Predicate.holds\n                 (r t (xa, m) \\<bind>\n                  (\\<lambda>(ta, uu_).\n                      Predicate.if_pred\n                       (actions_ok (ls, (ts, m), ws, is) t ta)))\n             then thr'_ins_dj t TS else TS\n        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                may_acquire_all ls t ln\n             then thr'_ins_dj t TS else TS)\n   \\<sigma>)) =\n                             (t \\<in> \\<alpha>.active_threads\n (state_\\<alpha> s)))\n 2. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "ultimately"], ["proof (chain)\npicking this:\n  thr'_invar\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n  thr'_\\<alpha>\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n  \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t})\n  ?t'5 \\<notin> T - {t} \\<Longrightarrow>\n  (?t'5\n   \\<in> thr'_\\<alpha>\n          ((case (t, xln) of\n            (t, xa, ln) \\<Rightarrow>\n              \\<lambda>TS.\n                 if ln = no_wait_locks\n                 then if Predicate.holds\n                          (r t (xa, m) \\<bind>\n                           (\\<lambda>(ta, uu_).\n                               Predicate.if_pred\n                                (actions_ok (ls, (ts, m), ws, is) t ta)))\n                      then thr'_ins_dj t TS else TS\n                 else if \\<not> waiting (ws_lookup t ws) \\<and>\n                         may_acquire_all ls t ln\n                      then thr'_ins_dj t TS else TS)\n            TS)) =\n  (?t'5 \\<in> \\<alpha>.active_threads (state_\\<alpha> s))", "show \"?I (T - {t}) (?f (t, xln) TS)\""], ["proof (prove)\nusing this:\n  thr'_invar\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n  thr'_\\<alpha>\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n  \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t})\n  ?t'5 \\<notin> T - {t} \\<Longrightarrow>\n  (?t'5\n   \\<in> thr'_\\<alpha>\n          ((case (t, xln) of\n            (t, xa, ln) \\<Rightarrow>\n              \\<lambda>TS.\n                 if ln = no_wait_locks\n                 then if Predicate.holds\n                          (r t (xa, m) \\<bind>\n                           (\\<lambda>(ta, uu_).\n                               Predicate.if_pred\n                                (actions_ok (ls, (ts, m), ws, is) t ta)))\n                      then thr'_ins_dj t TS else TS\n                 else if \\<not> waiting (ws_lookup t ws) \\<and>\n                         may_acquire_all ls t ln\n                      then thr'_ins_dj t TS else TS)\n            TS)) =\n  (?t'5 \\<in> \\<alpha>.active_threads (state_\\<alpha> s))\n\ngoal (1 subgoal):\n 1. thr'_invar\n     ((case (t, xln) of\n       (t, xa, ln) \\<Rightarrow>\n         \\<lambda>TS.\n            if ln = no_wait_locks\n            then if Predicate.holds\n                     (r t (xa, m) \\<bind>\n                      (\\<lambda>(ta, uu_).\n                          Predicate.if_pred\n                           (actions_ok (ls, (ts, m), ws, is) t ta)))\n                 then thr'_ins_dj t TS else TS\n            else if \\<not> waiting (ws_lookup t ws) \\<and>\n                    may_acquire_all ls t ln\n                 then thr'_ins_dj t TS else TS)\n       TS) \\<and>\n    thr'_\\<alpha>\n     ((case (t, xln) of\n       (t, xa, ln) \\<Rightarrow>\n         \\<lambda>TS.\n            if ln = no_wait_locks\n            then if Predicate.holds\n                     (r t (xa, m) \\<bind>\n                      (\\<lambda>(ta, uu_).\n                          Predicate.if_pred\n                           (actions_ok (ls, (ts, m), ws, is) t ta)))\n                 then thr'_ins_dj t TS else TS\n            else if \\<not> waiting (ws_lookup t ws) \\<and>\n                    may_acquire_all ls t ln\n                 then thr'_ins_dj t TS else TS)\n       TS)\n    \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t}) \\<and>\n    (\\<forall>ta.\n        ta \\<notin> T - {t} \\<longrightarrow>\n        (ta \\<in> thr'_\\<alpha>\n                   ((case (t, xln) of\n                     (t, xa, ln) \\<Rightarrow>\n                       \\<lambda>TS.\n                          if ln = no_wait_locks\n                          then if Predicate.holds\n                                   (r t (xa, m) \\<bind>\n                                    (\\<lambda>(ta, uu_).\n  Predicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\n                               then thr'_ins_dj t TS else TS\n                          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                                  may_acquire_all ls t ln\n                               then thr'_ins_dj t TS else TS)\n                     TS)) =\n        (ta \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "by blast"], ["proof (state)\nthis:\n  thr'_invar\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS) \\<and>\n  thr'_\\<alpha>\n   ((case (t, xln) of\n     (t, xa, ln) \\<Rightarrow>\n       \\<lambda>TS.\n          if ln = no_wait_locks\n          then if Predicate.holds\n                   (r t (xa, m) \\<bind>\n                    (\\<lambda>(ta, uu_).\n                        Predicate.if_pred\n                         (actions_ok (ls, (ts, m), ws, is) t ta)))\n               then thr'_ins_dj t TS else TS\n          else if \\<not> waiting (ws_lookup t ws) \\<and>\n                  may_acquire_all ls t ln\n               then thr'_ins_dj t TS else TS)\n     TS)\n  \\<subseteq> dom (thr_\\<alpha> ts) - (T - {t}) \\<and>\n  (\\<forall>ta.\n      ta \\<notin> T - {t} \\<longrightarrow>\n      (ta \\<in> thr'_\\<alpha>\n                 ((case (t, xln) of\n                   (t, xa, ln) \\<Rightarrow>\n                     \\<lambda>TS.\n                        if ln = no_wait_locks\n                        then if Predicate.holds\n                                 (r t (xa, m) \\<bind>\n                                  (\\<lambda>(ta, uu_).\nPredicate.if_pred (actions_ok (ls, (ts, m), ws, is) t ta)))\n                             then thr'_ins_dj t TS else TS\n                        else if \\<not> waiting (ws_lookup t ws) \\<and>\n                                may_acquire_all ls t ln\n                             then thr'_ins_dj t TS else TS)\n                   TS)) =\n      (ta \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads\n                     (state_\\<alpha> s))) \\<Longrightarrow>\n       thr'_invar \\<sigma> \\<and>\n       thr'_\\<alpha> \\<sigma> \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n       (\\<forall>t.\n           t \\<notin> {} \\<longrightarrow>\n           (t \\<in> thr'_\\<alpha> \\<sigma>) =\n           (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))", "qed"], ["proof (state)\nthis:\n  thr'_invar\n   (thr_iterate ts (\\<lambda>_. True)\n     (\\<lambda>(t, x, ln) TS.\n         if ln = no_wait_locks\n         then if Predicate.holds\n                  (r t (x, m) \\<bind>\n                   (\\<lambda>(ta, uu_).\n                       Predicate.if_pred\n                        (actions_ok (ls, (ts, m), ws, is) t ta)))\n              then thr'_ins_dj t TS else TS\n         else if \\<not> waiting (ws_lookup t ws) \\<and>\n                 may_acquire_all ls t ln\n              then thr'_ins_dj t TS else TS)\n     (thr'_empty ())) \\<and>\n  thr'_\\<alpha>\n   (thr_iterate ts (\\<lambda>_. True)\n     (\\<lambda>(t, x, ln) TS.\n         if ln = no_wait_locks\n         then if Predicate.holds\n                  (r t (x, m) \\<bind>\n                   (\\<lambda>(ta, uu_).\n                       Predicate.if_pred\n                        (actions_ok (ls, (ts, m), ws, is) t ta)))\n              then thr'_ins_dj t TS else TS\n         else if \\<not> waiting (ws_lookup t ws) \\<and>\n                 may_acquire_all ls t ln\n              then thr'_ins_dj t TS else TS)\n     (thr'_empty ()))\n  \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n  (\\<forall>t.\n      t \\<notin> {} \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha>\n                (thr_iterate ts (\\<lambda>_. True)\n                  (\\<lambda>(t, x, ln) TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (x, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                  (thr'_empty ()))) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (2 subgoals):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s)\n 2. thr'_invar (active_threads s)", "thus \"?thesis1\" \"?thesis2\""], ["proof (prove)\nusing this:\n  thr'_invar\n   (thr_iterate ts (\\<lambda>_. True)\n     (\\<lambda>(t, x, ln) TS.\n         if ln = no_wait_locks\n         then if Predicate.holds\n                  (r t (x, m) \\<bind>\n                   (\\<lambda>(ta, uu_).\n                       Predicate.if_pred\n                        (actions_ok (ls, (ts, m), ws, is) t ta)))\n              then thr'_ins_dj t TS else TS\n         else if \\<not> waiting (ws_lookup t ws) \\<and>\n                 may_acquire_all ls t ln\n              then thr'_ins_dj t TS else TS)\n     (thr'_empty ())) \\<and>\n  thr'_\\<alpha>\n   (thr_iterate ts (\\<lambda>_. True)\n     (\\<lambda>(t, x, ln) TS.\n         if ln = no_wait_locks\n         then if Predicate.holds\n                  (r t (x, m) \\<bind>\n                   (\\<lambda>(ta, uu_).\n                       Predicate.if_pred\n                        (actions_ok (ls, (ts, m), ws, is) t ta)))\n              then thr'_ins_dj t TS else TS\n         else if \\<not> waiting (ws_lookup t ws) \\<and>\n                 may_acquire_all ls t ln\n              then thr'_ins_dj t TS else TS)\n     (thr'_empty ()))\n  \\<subseteq> dom (thr_\\<alpha> ts) - {} \\<and>\n  (\\<forall>t.\n      t \\<notin> {} \\<longrightarrow>\n      (t \\<in> thr'_\\<alpha>\n                (thr_iterate ts (\\<lambda>_. True)\n                  (\\<lambda>(t, x, ln) TS.\n                      if ln = no_wait_locks\n                      then if Predicate.holds\n                               (r t (x, m) \\<bind>\n                                (\\<lambda>(ta, uu_).\n                                    Predicate.if_pred\n                                     (actions_ok (ls, (ts, m), ws, is) t\n ta)))\n                           then thr'_ins_dj t TS else TS\n                      else if \\<not> waiting (ws_lookup t ws) \\<and>\n                              may_acquire_all ls t ln\n                           then thr'_ins_dj t TS else TS)\n                  (thr'_empty ()))) =\n      (t \\<in> \\<alpha>.active_threads (state_\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. thr'_\\<alpha> (active_threads s) =\n    \\<alpha>.active_threads (state_\\<alpha> s) &&&\n    thr'_invar (active_threads s)", "by(auto simp add: s)"], ["proof (state)\nthis:\n  thr'_\\<alpha> (active_threads s) =\n  \\<alpha>.active_threads (state_\\<alpha> s)\n  thr'_invar (active_threads s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale scheduler_ext =\n  scheduler_ext_aux\n    final r convert_RA\n    thr_\\<alpha> thr_invar thr_lookup thr_update thr_iterate\n    ws_\\<alpha> ws_invar ws_lookup ws_update ws_sel\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n    thr'_\\<alpha> thr'_invar thr'_empty thr'_ins_dj\n  +\n  scheduler_spec\n    final r convert_RA\n    schedule \\<sigma>_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar\n    is_\\<alpha> is_invar\n    invariant\n  +\n  ws: map_delete ws_\\<alpha> ws_invar ws_delete +\n  ws: map_iteratei ws_\\<alpha> ws_invar ws_iterate\n  for final :: \"'x \\<Rightarrow> bool\"\n  and r :: \"'t \\<Rightarrow> ('x \\<times> 'm) \\<Rightarrow> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) Predicate.pred\"\n  and convert_RA :: \"'l released_locks \\<Rightarrow> 'o list\"\n  and schedule :: \"('l,'t,'x,'m,'w,'o,'m_t,'m_w,'s_i,'s) scheduler\"\n  and \"output\" :: \"'s \\<Rightarrow> 't \\<Rightarrow> ('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 'q option\"\n  and \\<sigma>_invar :: \"'s \\<Rightarrow> 't set \\<Rightarrow> bool\"\n  and thr_\\<alpha> :: \"'m_t \\<Rightarrow> ('l,'t,'x) thread_info\"\n  and thr_invar :: \"'m_t \\<Rightarrow> bool\"\n  and thr_lookup :: \"'t \\<Rightarrow> 'm_t \\<rightharpoonup> ('x \\<times> 'l released_locks)\"\n  and thr_update :: \"'t \\<Rightarrow> 'x \\<times> 'l released_locks \\<Rightarrow> 'm_t \\<Rightarrow> 'm_t\"\n  and thr_iterate :: \"'m_t \\<Rightarrow> ('t \\<times> ('x \\<times> 'l released_locks), 's_t) set_iterator\"\n  and ws_\\<alpha> :: \"'m_w \\<Rightarrow> ('w,'t) wait_sets\"\n  and ws_invar :: \"'m_w \\<Rightarrow> bool\"\n  and ws_empty :: \"unit \\<Rightarrow> 'm_w\"\n  and ws_lookup :: \"'t \\<Rightarrow> 'm_w \\<rightharpoonup> 'w wait_set_status\"\n  and ws_update :: \"'t \\<Rightarrow> 'w wait_set_status \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_delete :: \"'t \\<Rightarrow> 'm_w \\<Rightarrow> 'm_w\"\n  and ws_iterate :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status, 'm_w) set_iterator\"\n  and ws_sel :: \"'m_w \\<Rightarrow> ('t \\<times> 'w wait_set_status \\<Rightarrow> bool) \\<rightharpoonup> ('t \\<times> 'w wait_set_status)\"\n  and is_\\<alpha> :: \"'s_i \\<Rightarrow> 't interrupts\"\n  and is_invar :: \"'s_i \\<Rightarrow> bool\"\n  and is_memb :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> bool\"\n  and is_ins :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and is_delete :: \"'t \\<Rightarrow> 's_i \\<Rightarrow> 's_i\"\n  and thr'_\\<alpha> :: \"'s_t \\<Rightarrow> 't set\"\n  and thr'_invar :: \"'s_t \\<Rightarrow> bool\"\n  and thr'_empty :: \"unit \\<Rightarrow> 's_t\"\n  and thr'_ins_dj :: \"'t \\<Rightarrow> 's_t \\<Rightarrow> 's_t\"\n  and invariant :: \"('l,'t,'x,'m,'w) state set\"\n  +\n  assumes invariant: \"invariant3p \\<alpha>.redT invariant\""], ["", "sublocale scheduler_ext < \n  pick_wakeup_spec\n    final r convert_RA\n    pick_wakeup \\<sigma>_invar\n    thr_\\<alpha> thr_invar\n    ws_\\<alpha> ws_invar"], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_wakeup_spec pick_wakeup \\<sigma>_invar ws_\\<alpha> ws_invar", "by(rule pick_wakeup_spec_via_sel)(unfold_locales)"], ["", "sublocale scheduler_ext < \n  scheduler\n    final r convert_RA\n    schedule \"output\" \"pick_wakeup\" \\<sigma>_invar\n    thr_\\<alpha> thr_invar thr_lookup thr_update\n    ws_\\<alpha> ws_invar ws_lookup ws_update ws_delete ws_iterate\n    is_\\<alpha> is_invar is_memb is_ins is_delete\n    invariant"], ["proof (prove)\ngoal (1 subgoal):\n 1. scheduler final r convert_RA schedule pick_wakeup \\<sigma>_invar\n     thr_\\<alpha> thr_invar thr_lookup thr_update ws_\\<alpha> ws_invar\n     ws_lookup ws_update ws_delete ws_iterate is_\\<alpha> is_invar is_memb\n     is_ins is_delete invariant", "by(unfold_locales)(rule invariant)"], ["", "subsection \\<open>Schedulers for deterministic small-step semantics\\<close>"], ["", "text \\<open>\n  The default code equations for @{term Predicate.the} impose the type class constraint \\<open>eq\\<close>\n  on the predicate elements. For the semantics, which contains the heap, there might be no such\n  instance, so we use new constants for which other code equations can be used.\n  These do not add the type class constraint, but may fail more often with non-uniqueness exception.\n\\<close>"], ["", "definition singleton2 where [simp]: \"singleton2 = Predicate.singleton\""], ["", "definition the_only2 where [simp]: \"the_only2 = Predicate.the_only\""], ["", "definition the2 where [simp]: \"the2 = Predicate.the\""], ["", "context multithreaded_base begin"], ["", "definition step_thread ::\n  \"(('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 's) \\<Rightarrow> ('l,'t,'x,'m,'w) state \\<Rightarrow> 't\n  \\<Rightarrow> ('t \\<times> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) option \\<times> 's) option\"\nwhere\n  \"\\<And>ln. step_thread update_state s t =\n   (case thr s t of\n      \\<lfloor>(x, ln)\\<rfloor> \\<Rightarrow>\n      if ln = no_wait_locks then\n        if \\<exists>ta x' m'. t \\<turnstile> (x, shr s) -ta\\<rightarrow> (x', m') \\<and> actions_ok s t ta then\n          let\n            (ta, x', m') = THE (ta, x', m'). t \\<turnstile> (x, shr s) -ta\\<rightarrow> (x', m') \\<and> actions_ok s t ta\n          in\n            \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, update_state ta)\\<rfloor>\n        else\n          None\n      else if may_acquire_all (locks s) t ln \\<and> \\<not> waiting (wset s t) then \n        \\<lfloor>(t, None, update_state (K$ [], [], [], [], [], convert_RA ln))\\<rfloor>\n      else\n        None\n    | None \\<Rightarrow> None)\""], ["", "lemma step_thread_NoneD:\n  \"step_thread update_state s t = None \\<Longrightarrow> t \\<notin> active_threads s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step_thread update_state s t = None \\<Longrightarrow>\n    t \\<notin> active_threads s", "unfolding step_thread_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case thr s t of None \\<Rightarrow> None\n     | \\<lfloor>(xa, ln)\\<rfloor> \\<Rightarrow>\n         if ln = no_wait_locks\n         then if \\<exists>ta x' m'.\n                    t \\<turnstile> \\<langle>xa, shr\n           s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                    actions_ok s t ta\n              then let (ta, x', m') =\n                         THE (ta, x', m').\n                            t \\<turnstile> \\<langle>xa, shr\n                   s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t ta\n                   in \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                                update_state ta)\\<rfloor>\n              else None\n         else if may_acquire_all (locks s) t ln \\<and>\n                 \\<not> waiting (wset s t)\n              then \\<lfloor>(t, None,\n                             update_state\n                              (K$ [], [], [], [], [],\n                               convert_RA ln))\\<rfloor>\n              else None) =\n    None \\<Longrightarrow>\n    t \\<notin> active_threads s", "by(fastforce simp add: split_beta elim!: active_threads.cases split: if_split_asm)"], ["", "lemma inactive_step_thread_eq_NoneI:\n  \"t \\<notin> active_threads s \\<Longrightarrow> step_thread update_state s t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> active_threads s \\<Longrightarrow>\n    step_thread update_state s t = None", "unfolding step_thread_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> active_threads s \\<Longrightarrow>\n    (case thr s t of None \\<Rightarrow> None\n     | \\<lfloor>(xa, ln)\\<rfloor> \\<Rightarrow>\n         if ln = no_wait_locks\n         then if \\<exists>ta x' m'.\n                    t \\<turnstile> \\<langle>xa, shr\n           s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                    actions_ok s t ta\n              then let (ta, x', m') =\n                         THE (ta, x', m').\n                            t \\<turnstile> \\<langle>xa, shr\n                   s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t ta\n                   in \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                                update_state ta)\\<rfloor>\n              else None\n         else if may_acquire_all (locks s) t ln \\<and>\n                 \\<not> waiting (wset s t)\n              then \\<lfloor>(t, None,\n                             update_state\n                              (K$ [], [], [], [], [],\n                               convert_RA ln))\\<rfloor>\n              else None) =\n    None", "by(fastforce simp add: split_beta split: if_split_asm intro: active_threads.intros)"], ["", "lemma step_thread_eq_None_conv:\n  \"step_thread update_state s t = None \\<longleftrightarrow> t \\<notin> active_threads s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (step_thread update_state s t = None) = (t \\<notin> active_threads s)", "by(blast dest: step_thread_NoneD intro: inactive_step_thread_eq_NoneI)"], ["", "lemma step_thread_eq_Some_activeD:\n  \"step_thread update_state s t = \\<lfloor>(t', taxm\\<sigma>')\\<rfloor> \n  \\<Longrightarrow> t' = t \\<and> t \\<in> active_threads s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step_thread update_state s t =\n    \\<lfloor>(t', taxm\\<sigma>')\\<rfloor> \\<Longrightarrow>\n    t' = t \\<and> t \\<in> active_threads s", "unfolding step_thread_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case thr s t of None \\<Rightarrow> None\n     | \\<lfloor>(xa, ln)\\<rfloor> \\<Rightarrow>\n         if ln = no_wait_locks\n         then if \\<exists>ta x' m'.\n                    t \\<turnstile> \\<langle>xa, shr\n           s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                    actions_ok s t ta\n              then let (ta, x', m') =\n                         THE (ta, x', m').\n                            t \\<turnstile> \\<langle>xa, shr\n                   s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t ta\n                   in \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>,\n                                update_state ta)\\<rfloor>\n              else None\n         else if may_acquire_all (locks s) t ln \\<and>\n                 \\<not> waiting (wset s t)\n              then \\<lfloor>(t, None,\n                             update_state\n                              (K$ [], [], [], [], [],\n                               convert_RA ln))\\<rfloor>\n              else None) =\n    \\<lfloor>(t', taxm\\<sigma>')\\<rfloor> \\<Longrightarrow>\n    t' = t \\<and> t \\<in> active_threads s", "by(fastforce split: if_split_asm simp add: split_beta intro: active_threads.intros)"], ["", "declare actions_ok_iff [simp del]"], ["", "declare actions_ok.cases [rule del]"], ["", "lemma step_thread_Some_NoneD:\n  \"step_thread update_state s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  \\<Longrightarrow> \\<exists>x ln n. thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (wset s t) \\<and> may_acquire_all (locks s) t ln \\<and> \\<sigma>' = update_state (K$ [], [], [], [], [], convert_RA ln)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step_thread update_state s t' =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and>\n       may_acquire_all (locks s) t ln \\<and>\n       \\<sigma>' = update_state (K$ [], [], [], [], [], convert_RA ln)", "unfolding step_thread_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case thr s t' of None \\<Rightarrow> None\n     | \\<lfloor>(xa, ln)\\<rfloor> \\<Rightarrow>\n         if ln = no_wait_locks\n         then if \\<exists>ta x' m'.\n                    t' \\<turnstile> \\<langle>xa, shr\n            s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                    actions_ok s t' ta\n              then let (ta, x', m') =\n                         THE (ta, x', m').\n                            t' \\<turnstile> \\<langle>xa, shr\n                    s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                            actions_ok s t' ta\n                   in \\<lfloor>(t', \\<lfloor>(ta, x', m')\\<rfloor>,\n                                update_state ta)\\<rfloor>\n              else None\n         else if may_acquire_all (locks s) t' ln \\<and>\n                 \\<not> waiting (wset s t')\n              then \\<lfloor>(t', None,\n                             update_state\n                              (K$ [], [], [], [], [],\n                               convert_RA ln))\\<rfloor>\n              else None) =\n    \\<lfloor>(t, None, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n    \\<exists>x ln n.\n       thr s t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (wset s t) \\<and>\n       may_acquire_all (locks s) t ln \\<and>\n       \\<sigma>' = update_state (K$ [], [], [], [], [], convert_RA ln)", "by(auto split: if_split_asm simp add: split_beta elim!: neq_no_wait_locksE)"], ["", "lemma step_thread_Some_SomeD:\n  \"\\<lbrakk> deterministic I; step_thread update_state s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>; s \\<in> I \\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. thr s t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> t \\<turnstile> \\<langle>x, shr s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and> actions_ok s t ta \\<and> \\<sigma>' = update_state ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic I;\n     step_thread update_state s t' =\n     \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n     s \\<in> I\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         thr s t =\n                         \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                         t \\<turnstile> \\<langle>x, shr\n               s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                         actions_ok s t ta \\<and>\n                         \\<sigma>' = update_state ta", "unfolding step_thread_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic I;\n     (case thr s t' of None \\<Rightarrow> None\n      | \\<lfloor>(xa, ln)\\<rfloor> \\<Rightarrow>\n          if ln = no_wait_locks\n          then if \\<exists>ta x' m'.\n                     t' \\<turnstile> \\<langle>xa, shr\n             s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                     actions_ok s t' ta\n               then let (ta, x', m') =\n                          THE (ta, x', m').\n                             t' \\<turnstile> \\<langle>xa, shr\n                     s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                             actions_ok s t' ta\n                    in \\<lfloor>(t', \\<lfloor>(ta, x', m')\\<rfloor>,\n                                 update_state ta)\\<rfloor>\n               else None\n          else if may_acquire_all (locks s) t' ln \\<and>\n                  \\<not> waiting (wset s t')\n               then \\<lfloor>(t', None,\n                              update_state\n                               (K$ [], [], [], [], [],\n                                convert_RA ln))\\<rfloor>\n               else None) =\n     \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>;\n     s \\<in> I\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         thr s t =\n                         \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n                         t \\<turnstile> \\<langle>x, shr\n               s\\<rangle> -ta\\<rightarrow> \\<langle>x', m'\\<rangle> \\<and>\n                         actions_ok s t ta \\<and>\n                         \\<sigma>' = update_state ta", "by(auto simp add: split_beta deterministic_THE split: if_split_asm)"], ["", "end"], ["", "context scheduler_base_aux begin"], ["", "definition step_thread ::\n  \"(('l,'t,'x,'m,'w,'o) thread_action \\<Rightarrow> 's) \\<Rightarrow> ('l,'t,'m,'m_t,'m_w,'s_i) state_refine \\<Rightarrow> 't \\<Rightarrow>\n   ('t \\<times> (('l,'t,'x,'m,'w,'o) thread_action \\<times> 'x \\<times> 'm) option \\<times> 's) option\"\nwhere \n  \"\\<And>ln. step_thread update_state s t =\n  (case thr_lookup t (thr s) of\n      \\<lfloor>(x, ln)\\<rfloor> \\<Rightarrow>\n      if ln = no_wait_locks then\n        let\n          reds = do {\n            (ta, x', m') \\<leftarrow> r t (x, shr s);\n            if actions_ok s t ta then Predicate.single (ta, x', m') else bot\n          }\n        in\n          if Predicate.holds (reds \\<bind> (\\<lambda>_. Predicate.single ())) then\n            let\n              (ta, x', m') = the2 reds\n            in \n              \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, update_state ta)\\<rfloor>\n          else\n            None\n      else if may_acquire_all (locks s) t ln \\<and> \\<not> waiting (ws_lookup t (wset s)) then \n        \\<lfloor>(t, None, update_state (K$ [], [], [], [], [],convert_RA ln))\\<rfloor>\n      else\n        None\n    | None \\<Rightarrow> None)\""], ["", "end"], ["", "context scheduler_aux begin"], ["", "lemma deterministic_THE2:\n  assumes \"\\<alpha>.deterministic I\"\n  and tst: \"thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor>\"\n  and red: \"Predicate.eval (r t (x, shr s)) (ta, x', m')\"\n  and aok: \"\\<alpha>.actions_ok (state_\\<alpha> s) t ta\"\n  and I: \"state_\\<alpha> s \\<in> I\"\n  shows \"Predicate.the (r t (x, shr s) \\<bind> (\\<lambda>(ta, x', m'). if \\<alpha>.actions_ok (state_\\<alpha> s) t ta then Predicate.single (ta, x', m') else bot)) = (ta, x', m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Predicate.the\n     (r t (x, shr s) \\<bind>\n      (\\<lambda>(ta, x', m').\n          if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n          then Predicate.single (ta, x', m') else \\<bottom>)) =\n    (ta, x', m')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Predicate.the\n     (r t (x, shr s) \\<bind>\n      (\\<lambda>(ta, x', m').\n          if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n          then Predicate.single (ta, x', m') else \\<bottom>)) =\n    (ta, x', m')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Predicate.the\n     (r t (x, shr s) \\<bind>\n      (\\<lambda>(ta, x', m').\n          if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n          then Predicate.single (ta, x', m') else \\<bottom>)) =\n    (ta, x', m')", "unfolding the_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. The (pred.eval\n          (r t (x, shr s) \\<bind>\n           (\\<lambda>(ta, x', m').\n               if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n               then Predicate.single (ta, x', m') else \\<bottom>))) =\n    (ta, x', m')", "apply(rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pred.eval\n     (r t (x, shr s) \\<bind>\n      (\\<lambda>(ta, x', m').\n          if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n          then Predicate.single (ta, x', m') else \\<bottom>))\n     (ta, x', m')\n 2. \\<And>xa.\n       pred.eval\n        (r t (x, shr s) \\<bind>\n         (\\<lambda>(ta, x', m').\n             if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n             then Predicate.single (ta, x', m') else \\<bottom>))\n        xa \\<Longrightarrow>\n       xa = (ta, x', m')", "apply(rule bindI[OF red])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pred.eval\n     (case (ta, x', m') of\n      (ta, x', m') \\<Rightarrow>\n        if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n        then Predicate.single (ta, x', m') else \\<bottom>)\n     (ta, x', m')\n 2. \\<And>xa.\n       pred.eval\n        (r t (x, shr s) \\<bind>\n         (\\<lambda>(ta, x', m').\n             if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n             then Predicate.single (ta, x', m') else \\<bottom>))\n        xa \\<Longrightarrow>\n       xa = (ta, x', m')", "apply(simp add: singleI aok)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       pred.eval\n        (r t (x, shr s) \\<bind>\n         (\\<lambda>(ta, x', m').\n             if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n             then Predicate.single (ta, x', m') else \\<bottom>))\n        xa \\<Longrightarrow>\n       xa = (ta, x', m')", "apply(erule bindE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>pred.eval (r t (x, shr s)) xaa;\n        pred.eval\n         (case xaa of\n          (ta, x', m') \\<Rightarrow>\n            if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n            then Predicate.single (ta, x', m') else \\<bottom>)\n         xa\\<rbrakk>\n       \\<Longrightarrow> xa = (ta, x', m')", "apply(clarsimp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae ba.\n       \\<lbrakk>\\<alpha>.r_syntax t x (shr s) (a, aa, ab, ac, ad, b) ae ba;\n        \\<alpha>.actions_ok (state_\\<alpha> s) t\n         (a, aa, ab, ac, ad, b)\\<rbrakk>\n       \\<Longrightarrow> (a, aa, ab, ac, ad, b) = ta \\<and>\n                         ae = x' \\<and> ba = m'", "apply(drule (1) \\<alpha>.deterministicD[OF \\<open>\\<alpha>.deterministic I\\<close>, where s=\"state_\\<alpha> s\", simplified, OF red _ tst aok])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b ae ba.\n       \\<alpha>.actions_ok (state_\\<alpha> s) t\n        (a, aa, ab, ac, ad, b) \\<Longrightarrow>\n       state_\\<alpha> s \\<in> I\n 2. \\<And>a aa ab ac ad b ae ba.\n       \\<lbrakk>\\<alpha>.actions_ok (state_\\<alpha> s) t\n                 (a, aa, ab, ac, ad, b);\n        ta = (a, aa, ab, ac, ad, b) \\<and> x' = ae \\<and> m' = ba\\<rbrakk>\n       \\<Longrightarrow> (a, aa, ab, ac, ad, b) = ta \\<and>\n                         ae = x' \\<and> ba = m'", "apply(rule I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae ba.\n       \\<lbrakk>\\<alpha>.actions_ok (state_\\<alpha> s) t\n                 (a, aa, ab, ac, ad, b);\n        ta = (a, aa, ab, ac, ad, b) \\<and> x' = ae \\<and> m' = ba\\<rbrakk>\n       \\<Longrightarrow> (a, aa, ab, ac, ad, b) = ta \\<and>\n                         ae = x' \\<and> ba = m'", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Predicate.the\n   (r t (x, shr s) \\<bind>\n    (\\<lambda>(ta, x', m').\n        if \\<alpha>.actions_ok (state_\\<alpha> s) t ta\n        then Predicate.single (ta, x', m') else \\<bottom>)) =\n  (ta, x', m')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_thread_correct:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"\\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\" \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows\n  \"map_option (apsnd (apsnd \\<sigma>_\\<alpha>)) (step_thread update_state s t) = \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state) (state_\\<alpha> s) t\" (is ?thesis1)\n  and \"(\\<And>ta. FWThread.thread_oks (thr_\\<alpha> (thr s)) \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow> \\<sigma>_invar (update_state ta) (dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<Longrightarrow> case_option True (\\<lambda>(t, taxm, \\<sigma>). \\<sigma>_invar \\<sigma> (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s)) | Some (ta, x', m') \\<Rightarrow> dom (thr_\\<alpha> (thr s)) \\<union> {t. \\<exists>x m. NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) (step_thread update_state s t)\"\n  (is \"(\\<And>ta. ?tso ta \\<Longrightarrow> ?inv ta) \\<Longrightarrow> ?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t &&&\n    ((\\<And>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<Longrightarrow>\n     case step_thread update_state s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         \\<sigma>_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t\n 2. (\\<And>ta.\n        FWThread.thread_oks (thr_\\<alpha> (thr s))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<sigma>_invar (update_state ta)\n         (dom (thr_\\<alpha> (thr s)) \\<union>\n          {t. \\<exists>x m.\n                 NewThread t x m\n                 \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<Longrightarrow>\n    case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "have \"?thesis1 \\<and> ((\\<forall>ta. ?tso ta \\<longrightarrow> ?inv ta) \\<longrightarrow> ?thesis2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "proof(cases \"step_thread update_state s t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. step_thread update_state s t = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       step_thread update_state s t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "case None"], ["proof (state)\nthis:\n  step_thread update_state s t = None\n\ngoal (2 subgoals):\n 1. step_thread update_state s t = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       step_thread update_state s t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "with invar"], ["proof (chain)\npicking this:\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  step_thread update_state s t = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  step_thread update_state s t = None\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "apply (auto simp add: thr.lookup_correct \\<alpha>.step_thread_def step_thread_def ws.lookup_correct\n        split_beta holds_eq split: if_split_asm cong del: image_cong_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ab ac ad ae af bb x' m'.\n       \\<lbrakk>\\<forall>a ab ac ad ae b af ba bb.\n                   \\<alpha>.r_syntax t aa (shr s) (a, ab, ac, ad, ae, b) af\n                    bb \\<longrightarrow>\n                   \\<alpha>.actions_ok (state_\\<alpha> s) t\n                    (a, ab, ac, ad, ae, b) \\<longrightarrow>\n                   bb \\<noteq> ba;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))); state_invar s;\n        state_\\<alpha> s \\<in> I;\n        thr_\\<alpha> (thr s) t = \\<lfloor>(aa, no_wait_locks)\\<rfloor>;\n        \\<alpha>.actions_ok (state_\\<alpha> s) t (ab, ac, ad, ae, af, bb);\n        \\<alpha>.r_syntax t aa (shr s) (ab, ac, ad, ae, af, bb) x' m';\n        may_acquire_all (locks s) t no_wait_locks;\n        \\<not> waiting (ws_\\<alpha> (wset s) t)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ab ac ad ae af bb x' m'.\n       \\<lbrakk>\\<forall>a ab ac ad ae b af ba bb.\n                   \\<alpha>.r_syntax t aa (shr s) (a, ab, ac, ad, ae, b) af\n                    bb \\<longrightarrow>\n                   \\<alpha>.actions_ok (state_\\<alpha> s) t\n                    (a, ab, ac, ad, ae, b) \\<longrightarrow>\n                   bb \\<noteq> ba;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))); state_invar s;\n        state_\\<alpha> s \\<in> I;\n        thr_\\<alpha> (thr s) t = \\<lfloor>(aa, no_wait_locks)\\<rfloor>;\n        \\<alpha>.actions_ok (state_\\<alpha> s) t (ab, ac, ad, ae, af, bb);\n        \\<alpha>.r_syntax t aa (shr s) (ab, ac, ad, ae, af, bb) x' m';\n        waiting (ws_\\<alpha> (wset s) t)\\<rbrakk>\n       \\<Longrightarrow> False", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ab ac ad ae af bb x' m'.\n       \\<lbrakk>\\<forall>a ab ac ad ae b af ba bb.\n                   \\<alpha>.r_syntax t aa (shr s) (a, ab, ac, ad, ae, b) af\n                    bb \\<longrightarrow>\n                   \\<alpha>.actions_ok (state_\\<alpha> s) t\n                    (a, ab, ac, ad, ae, b) \\<longrightarrow>\n                   bb \\<noteq> ba;\n        \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s))); state_invar s;\n        state_\\<alpha> s \\<in> I;\n        thr_\\<alpha> (thr s) t = \\<lfloor>(aa, no_wait_locks)\\<rfloor>;\n        \\<alpha>.actions_ok (state_\\<alpha> s) t (ab, ac, ad, ae, af, bb);\n        \\<alpha>.r_syntax t aa (shr s) (ab, ac, ad, ae, af, bb) x' m';\n        waiting (ws_\\<alpha> (wset s) t)\\<rbrakk>\n       \\<Longrightarrow> False", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t \\<and>\n  ((\\<forall>ta.\n       FWThread.thread_oks (thr_\\<alpha> (thr s))\n        \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n       \\<sigma>_invar (update_state ta)\n        (dom (thr_\\<alpha> (thr s)) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n   (case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       step_thread update_state s t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       step_thread update_state s t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "case (Some a)"], ["proof (state)\nthis:\n  step_thread update_state s t = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       step_thread update_state s t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "then"], ["proof (chain)\npicking this:\n  step_thread update_state s t = \\<lfloor>a\\<rfloor>", "obtain t' taxm \\<sigma>' \n      where rrs: \"step_thread update_state s t = \\<lfloor>(t', taxm, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  step_thread update_state s t = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>t' taxm \\<sigma>'.\n        step_thread update_state s t =\n        \\<lfloor>(t', taxm, \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases a) auto"], ["proof (state)\nthis:\n  step_thread update_state s t = \\<lfloor>(t', taxm, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       step_thread update_state s t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "proof(cases \"taxm\")"], ["proof (state)\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "case None"], ["proof (state)\nthis:\n  taxm = None\n\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "with rrs invar"], ["proof (chain)\npicking this:\n  step_thread update_state s t = \\<lfloor>(t', taxm, \\<sigma>')\\<rfloor>\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  taxm = None", "have ?thesis1"], ["proof (prove)\nusing this:\n  step_thread update_state s t = \\<lfloor>(t', taxm, \\<sigma>')\\<rfloor>\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  taxm = None\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t", "by(auto simp add: thr.lookup_correct ws.lookup_correct \\<alpha>.step_thread_def step_thread_def split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "moreover"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "{"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "let ?ta = \"(K$ [], [], [], [], [], convert_RA (snd (the (thr_lookup t (thr s)))))\""], ["proof (state)\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "assume \"?tso ?ta \\<longrightarrow> ?inv ?ta\""], ["proof (state)\nthis:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>(K$ [], [], [], [], [],\n             convert_RA\n              (snd (the (thr_lookup t\n                          (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar\n   (update_state\n     (K$ [], [], [], [], [], convert_RA (snd (the (thr_lookup t (thr s))))))\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {ta.\n     \\<exists>x m.\n        NewThread ta x m\n        \\<in> set \\<lbrace>(K$ [], [], [], [], [],\n                            convert_RA\n                             (snd (the (thr_lookup t\n   (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "hence ?thesis2"], ["proof (prove)\nusing this:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>(K$ [], [], [], [], [],\n             convert_RA\n              (snd (the (thr_lookup t\n                          (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar\n   (update_state\n     (K$ [], [], [], [], [], convert_RA (snd (the (thr_lookup t (thr s))))))\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {ta.\n     \\<exists>x m.\n        NewThread ta x m\n        \\<in> set \\<lbrace>(K$ [], [], [], [], [],\n                            convert_RA\n                             (snd (the (thr_lookup t\n   (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using None rrs"], ["proof (prove)\nusing this:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>(K$ [], [], [], [], [],\n             convert_RA\n              (snd (the (thr_lookup t\n                          (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar\n   (update_state\n     (K$ [], [], [], [], [], convert_RA (snd (the (thr_lookup t (thr s))))))\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {ta.\n     \\<exists>x m.\n        NewThread ta x m\n        \\<in> set \\<lbrace>(K$ [], [], [], [], [],\n                            convert_RA\n                             (snd (the (thr_lookup t\n   (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub>})\n  taxm = None\n  step_thread update_state s t = \\<lfloor>(t', taxm, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(auto simp add: thr.lookup_correct ws.lookup_correct \\<alpha>.step_thread_def step_thread_def split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "}"], ["proof (state)\nthis:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>(K$ [], [], [], [], [],\n             convert_RA\n              (snd (the (thr_lookup t\n                          (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar\n   (update_state\n     (K$ [], [], [], [], [], convert_RA (snd (the (thr_lookup t (thr s))))))\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {ta.\n     \\<exists>x m.\n        NewThread ta x m\n        \\<in> set \\<lbrace>(K$ [], [], [], [], [],\n                            convert_RA\n                             (snd (the (thr_lookup t\n   (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub>}) \\<Longrightarrow>\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (2 subgoals):\n 1. taxm = None \\<Longrightarrow>\n    map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n 2. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "ultimately"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>(K$ [], [], [], [], [],\n             convert_RA\n              (snd (the (thr_lookup t\n                          (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar\n   (update_state\n     (K$ [], [], [], [], [], convert_RA (snd (the (thr_lookup t (thr s))))))\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {ta.\n     \\<exists>x m.\n        NewThread ta x m\n        \\<in> set \\<lbrace>(K$ [], [], [], [], [],\n                            convert_RA\n                             (snd (the (thr_lookup t\n   (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub>}) \\<Longrightarrow>\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "show ?thesis"], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>(K$ [], [], [], [], [],\n             convert_RA\n              (snd (the (thr_lookup t\n                          (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar\n   (update_state\n     (K$ [], [], [], [], [], convert_RA (snd (the (thr_lookup t (thr s))))))\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {ta.\n     \\<exists>x m.\n        NewThread ta x m\n        \\<in> set \\<lbrace>(K$ [], [], [], [], [],\n                            convert_RA\n                             (snd (the (thr_lookup t\n   (thr s)))))\\<rbrace>\\<^bsub>t\\<^esub>}) \\<Longrightarrow>\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "by blast"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t \\<and>\n  ((\\<forall>ta.\n       FWThread.thread_oks (thr_\\<alpha> (thr s))\n        \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n       \\<sigma>_invar (update_state ta)\n        (dom (thr_\\<alpha> (thr s)) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n   (case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "case (Some a)"], ["proof (state)\nthis:\n  taxm = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "with rrs"], ["proof (chain)\npicking this:\n  step_thread update_state s t = \\<lfloor>(t', taxm, \\<sigma>')\\<rfloor>\n  taxm = \\<lfloor>a\\<rfloor>", "obtain ta x' m'\n        where rrs: \"step_thread update_state s t =  \\<lfloor>(t', \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\""], ["proof (prove)\nusing this:\n  step_thread update_state s t = \\<lfloor>(t', taxm, \\<sigma>')\\<rfloor>\n  taxm = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>ta x' m'.\n        step_thread update_state s t =\n        \\<lfloor>(t', \\<lfloor>(ta, x', m')\\<rfloor>,\n                  \\<sigma>')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases a) fastforce"], ["proof (state)\nthis:\n  step_thread update_state s t =\n  \\<lfloor>(t', \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "with invar"], ["proof (chain)\npicking this:\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  step_thread update_state s t =\n  \\<lfloor>(t', \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>", "have ?thesis1"], ["proof (prove)\nusing this:\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  step_thread update_state s t =\n  \\<lfloor>(t', \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t", "by (auto simp add: thr.lookup_correct ws.lookup_correct \\<alpha>.step_thread_def step_thread_def\n          split_beta \\<alpha>.deterministic_THE [OF det, where s=\"state_\\<alpha> s\", simplified]\n          deterministic_THE2[OF det] holds_eq split: if_split_asm\n          cong del: image_cong_simp) blast+"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "moreover"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "{"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "assume \"?tso ta \\<longrightarrow> ?inv ta\""], ["proof (state)\nthis:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar (update_state ta)\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "hence ?thesis2"], ["proof (prove)\nusing this:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar (update_state ta)\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "using rrs invar"], ["proof (prove)\nusing this:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar (update_state ta)\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n  step_thread update_state s t =\n  \\<lfloor>(t', \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  \\<sigma>_invar \\<sigma> (dom (thr_\\<alpha> (thr s)))\n  state_invar s\n  state_\\<alpha> s \\<in> I\n\ngoal (1 subgoal):\n 1. case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "by(auto simp add: thr.lookup_correct ws.lookup_correct \\<alpha>.step_thread_def step_thread_def split_beta \\<alpha>.deterministic_THE[OF det, where s=\"state_\\<alpha> s\", simplified] deterministic_THE2[OF det] holds_eq split: if_split_asm)(auto simp add: \\<alpha>.actions_ok_iff)"], ["proof (state)\nthis:\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "}"], ["proof (state)\nthis:\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar (update_state ta)\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m\n           \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}) \\<Longrightarrow>\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       taxm = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n        (step_thread update_state s t) =\n       \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n        (state_\\<alpha> s) t \\<and>\n       ((\\<forall>ta.\n            FWThread.thread_oks (thr_\\<alpha> (thr s))\n             \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n            \\<sigma>_invar (update_state ta)\n             (dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n        (case step_thread update_state s t of None \\<Rightarrow> True\n         | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n             \\<sigma>_invar \\<sigma>\n              (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n               | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                   dom (thr_\\<alpha> (thr s)) \\<union>\n                   {t. \\<exists>x m.\n                          NewThread t x m\n                          \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "ultimately"], ["proof (chain)\npicking this:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar (update_state ta)\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m\n           \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}) \\<Longrightarrow>\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "show ?thesis"], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n  FWThread.thread_oks (thr_\\<alpha> (thr s))\n   \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n  \\<sigma>_invar (update_state ta)\n   (dom (thr_\\<alpha> (thr s)) \\<union>\n    {t. \\<exists>x m.\n           NewThread t x m\n           \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}) \\<Longrightarrow>\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t \\<and>\n    ((\\<forall>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n     (case step_thread update_state s t of None \\<Rightarrow> True\n      | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n          \\<sigma>_invar \\<sigma>\n           (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n            | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n                dom (thr_\\<alpha> (thr s)) \\<union>\n                {t. \\<exists>x m.\n                       NewThread t x m\n                       \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))", "by blast"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t \\<and>\n  ((\\<forall>ta.\n       FWThread.thread_oks (thr_\\<alpha> (thr s))\n        \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n       \\<sigma>_invar (update_state ta)\n        (dom (thr_\\<alpha> (thr s)) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n   (case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t \\<and>\n  ((\\<forall>ta.\n       FWThread.thread_oks (thr_\\<alpha> (thr s))\n        \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n       \\<sigma>_invar (update_state ta)\n        (dom (thr_\\<alpha> (thr s)) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n   (case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t \\<and>\n  ((\\<forall>ta.\n       FWThread.thread_oks (thr_\\<alpha> (thr s))\n        \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n       \\<sigma>_invar (update_state ta)\n        (dom (thr_\\<alpha> (thr s)) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n   (case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n\ngoal (2 subgoals):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t\n 2. (\\<And>ta.\n        FWThread.thread_oks (thr_\\<alpha> (thr s))\n         \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n        \\<sigma>_invar (update_state ta)\n         (dom (thr_\\<alpha> (thr s)) \\<union>\n          {t. \\<exists>x m.\n                 NewThread t x m\n                 \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<Longrightarrow>\n    case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})", "thus ?thesis1 \"(\\<And>ta. ?tso ta \\<Longrightarrow> ?inv ta) \\<Longrightarrow> ?thesis2\""], ["proof (prove)\nusing this:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t \\<and>\n  ((\\<forall>ta.\n       FWThread.thread_oks (thr_\\<alpha> (thr s))\n        \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<longrightarrow>\n       \\<sigma>_invar (update_state ta)\n        (dom (thr_\\<alpha> (thr s)) \\<union>\n         {t. \\<exists>x m.\n                NewThread t x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<longrightarrow>\n   (case step_thread update_state s t of None \\<Rightarrow> True\n    | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n        \\<sigma>_invar \\<sigma>\n         (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n          | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n              dom (thr_\\<alpha> (thr s)) \\<union>\n              {t. \\<exists>x m.\n                     NewThread t x m\n                     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})))\n\ngoal (1 subgoal):\n 1. map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n     (step_thread update_state s t) =\n    \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n     (state_\\<alpha> s) t &&&\n    ((\\<And>ta.\n         FWThread.thread_oks (thr_\\<alpha> (thr s))\n          \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n         \\<sigma>_invar (update_state ta)\n          (dom (thr_\\<alpha> (thr s)) \\<union>\n           {t. \\<exists>x m.\n                  NewThread t x m\n                  \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<Longrightarrow>\n     case step_thread update_state s t of None \\<Rightarrow> True\n     | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n         \\<sigma>_invar \\<sigma>\n          (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n           | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n               dom (thr_\\<alpha> (thr s)) \\<union>\n               {t. \\<exists>x m.\n                      NewThread t x m\n                      \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>}))", "by blast+"], ["proof (state)\nthis:\n  map_option (apsnd (apsnd \\<sigma>_\\<alpha>))\n   (step_thread update_state s t) =\n  \\<alpha>.step_thread (\\<sigma>_\\<alpha> \\<circ> update_state)\n   (state_\\<alpha> s) t\n  (\\<And>ta.\n      FWThread.thread_oks (thr_\\<alpha> (thr s))\n       \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<Longrightarrow>\n      \\<sigma>_invar (update_state ta)\n       (dom (thr_\\<alpha> (thr s)) \\<union>\n        {t. \\<exists>x m.\n               NewThread t x m\n               \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})) \\<Longrightarrow>\n  case step_thread update_state s t of None \\<Rightarrow> True\n  | \\<lfloor>(t, taxm, \\<sigma>)\\<rfloor> \\<Rightarrow>\n      \\<sigma>_invar \\<sigma>\n       (case taxm of None \\<Rightarrow> dom (thr_\\<alpha> (thr s))\n        | \\<lfloor>(ta, x', m')\\<rfloor> \\<Rightarrow>\n            dom (thr_\\<alpha> (thr s)) \\<union>\n            {t. \\<exists>x m.\n                   NewThread t x m\n                   \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_thread_eq_None_conv:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and invar: \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows \"step_thread update_state s t = None \\<longleftrightarrow> t \\<notin> \\<alpha>.active_threads (state_\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (step_thread update_state s t = None) =\n    (t \\<notin> \\<alpha>.active_threads (state_\\<alpha> s))", "using assms step_thread_correct(1)[OF det _ invar(1), of \"\\<lambda>_ _. True\", of id update_state t]"], ["proof (prove)\nusing this:\n  \\<alpha>.deterministic I\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<lbrakk>True; state_\\<alpha> s \\<in> I\\<rbrakk>\n  \\<Longrightarrow> map_option (apsnd (apsnd id))\n                     (step_thread update_state s t) =\n                    \\<alpha>.step_thread (id \\<circ> update_state)\n                     (state_\\<alpha> s) t\n\ngoal (1 subgoal):\n 1. (step_thread update_state s t = None) =\n    (t \\<notin> \\<alpha>.active_threads (state_\\<alpha> s))", "by(simp add: map_option.id \\<alpha>.step_thread_eq_None_conv)"], ["", "lemma step_thread_Some_NoneD:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and step: \"step_thread update_state s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\"\n  and invar: \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows \"\\<exists>x ln n. thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and> ln $ n > 0 \\<and> \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and> may_acquire_all (locks s) t ln \\<and> \\<sigma>' = update_state (K$ [], [], [], [], [], convert_RA ln)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n       may_acquire_all (locks s) t ln \\<and>\n       \\<sigma>' = update_state (K$ [], [], [], [], [], convert_RA ln)", "using assms step_thread_correct(1)[OF det _ invar(1), of \"\\<lambda>_ _. True\", of id update_state t']"], ["proof (prove)\nusing this:\n  \\<alpha>.deterministic I\n  step_thread update_state s t' = \\<lfloor>(t, None, \\<sigma>')\\<rfloor>\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<lbrakk>True; state_\\<alpha> s \\<in> I\\<rbrakk>\n  \\<Longrightarrow> map_option (apsnd (apsnd id))\n                     (step_thread update_state s t') =\n                    \\<alpha>.step_thread (id \\<circ> update_state)\n                     (state_\\<alpha> s) t'\n\ngoal (1 subgoal):\n 1. \\<exists>x ln n.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n       0 < ln $ n \\<and>\n       \\<not> waiting (ws_\\<alpha> (wset s) t) \\<and>\n       may_acquire_all (locks s) t ln \\<and>\n       \\<sigma>' = update_state (K$ [], [], [], [], [], convert_RA ln)", "by(fastforce simp add: map_option.id dest: \\<alpha>.step_thread_Some_NoneD[OF sym])"], ["", "lemma step_thread_Some_SomeD:\n  assumes det: \"\\<alpha>.deterministic I\"\n  and step: \"step_thread update_state s t' = \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\"\n  and invar: \"state_invar s\" \"state_\\<alpha> s \\<in> I\"\n  shows \"\\<exists>x. thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and> Predicate.eval (r t (x, shr s)) (ta, x', m') \\<and> actions_ok s t ta \\<and> \\<sigma>' = update_state ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n       actions_ok s t ta \\<and> \\<sigma>' = update_state ta", "using assms step_thread_correct(1)[OF det _ invar(1), of \"\\<lambda>_ _. True\", of id update_state t']"], ["proof (prove)\nusing this:\n  \\<alpha>.deterministic I\n  step_thread update_state s t' =\n  \\<lfloor>(t, \\<lfloor>(ta, x', m')\\<rfloor>, \\<sigma>')\\<rfloor>\n  state_invar s\n  state_\\<alpha> s \\<in> I\n  \\<lbrakk>True; state_\\<alpha> s \\<in> I\\<rbrakk>\n  \\<Longrightarrow> map_option (apsnd (apsnd id))\n                     (step_thread update_state s t') =\n                    \\<alpha>.step_thread (id \\<circ> update_state)\n                     (state_\\<alpha> s) t'\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       thr_\\<alpha> (thr s) t = \\<lfloor>(x, no_wait_locks)\\<rfloor> \\<and>\n       \\<alpha>.r_syntax t x (shr s) ta x' m' \\<and>\n       actions_ok s t ta \\<and> \\<sigma>' = update_state ta", "by(auto simp add: map_option.id dest: \\<alpha>.step_thread_Some_SomeD[OF det sym])"], ["", "end"], ["", "subsection \\<open>Code Generator setup\\<close>"], ["", "lemmas [code] =\n  scheduler_base_aux.free_thread_id_def\n  scheduler_base_aux.redT_updT.simps\n  scheduler_base_aux.redT_updTs_def\n  scheduler_base_aux.thread_ok.simps\n  scheduler_base_aux.thread_oks.simps\n  scheduler_base_aux.wset_actions_ok_def\n  scheduler_base_aux.cond_action_ok.simps\n  scheduler_base_aux.cond_action_oks_def\n  scheduler_base_aux.redT_updI.simps\n  scheduler_base_aux.redT_updIs.simps\n  scheduler_base_aux.interrupt_action_ok.simps\n  scheduler_base_aux.interrupt_actions_ok.simps\n  scheduler_base_aux.actions_ok_def\n  scheduler_base_aux.step_thread_def"], ["", "lemmas [code] =\n  scheduler_base.exec_updW.simps\n  scheduler_base.exec_updWs_def\n  scheduler_base.exec_upd_def\n  scheduler_base.execT_def\n  scheduler_base.exec_step.simps\n  scheduler_base.exec_aux_def\n  scheduler_base.exec_def"], ["", "lemmas [code] =\n  scheduler_ext_base.active_threads.simps"], ["", "lemma singleton2_code [code]:\n  \"singleton2 dfault (Predicate.Seq f) =\n  (case f () of\n    Predicate.Empty \\<Rightarrow> dfault ()\n  | Predicate.Insert x P \\<Rightarrow> \n    if Predicate.is_empty P then x else Code.abort (STR ''singleton2 not unique'') (\\<lambda>_. singleton2 dfault (Predicate.Seq f))\n  | Predicate.Join P xq \\<Rightarrow>\n    if Predicate.is_empty P then \n      the_only2 dfault xq\n    else if Predicate.null xq then singleton2 dfault P else Code.abort (STR ''singleton2 not unique'') (\\<lambda>_. singleton2 dfault (Predicate.Seq f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton2 dfault (Predicate.Seq f) =\n    (case f () of seq.Empty \\<Rightarrow> dfault ()\n     | seq.Insert x P \\<Rightarrow>\n         if Predicate.is_empty P then x\n         else Code.abort STR ''singleton2 not unique''\n               (\\<lambda>_. singleton2 dfault (Predicate.Seq f))\n     | seq.Join P xq \\<Rightarrow>\n         if Predicate.is_empty P then the_only2 dfault xq\n         else if Predicate.null xq then singleton2 dfault P\n              else Code.abort STR ''singleton2 not unique''\n                    (\\<lambda>_. singleton2 dfault (Predicate.Seq f)))", "unfolding singleton2_def the_only2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Predicate.singleton dfault (Predicate.Seq f) =\n    (case f () of seq.Empty \\<Rightarrow> dfault ()\n     | seq.Insert x P \\<Rightarrow>\n         if Predicate.is_empty P then x\n         else Code.abort STR ''singleton2 not unique''\n               (\\<lambda>_. Predicate.singleton dfault (Predicate.Seq f))\n     | seq.Join P xq \\<Rightarrow>\n         if Predicate.is_empty P then Predicate.the_only dfault xq\n         else if Predicate.null xq then Predicate.singleton dfault P\n              else Code.abort STR ''singleton2 not unique''\n                    (\\<lambda>_.\n                        Predicate.singleton dfault (Predicate.Seq f)))", "by(auto simp only: singleton_code Code.abort_def split: seq.split if_split)"], ["", "lemma the_only2_code [code]:\n  \"the_only2 dfault Predicate.Empty = Code.abort (STR ''the_only2 empty'') dfault\"\n  \"the_only2 dfault (Predicate.Insert x P) = \n  (if Predicate.is_empty P then x else Code.abort (STR ''the_only2 not unique'') (\\<lambda>_. the_only2 dfault (Predicate.Insert x P)))\"\n  \"the_only2 dfault (Predicate.Join P xq) = \n  (if Predicate.is_empty P then \n     the_only2 dfault xq\n   else if Predicate.null xq then \n     singleton2 dfault P \n   else\n     Code.abort (STR ''the_only2 not unique'') (\\<lambda>_. the_only2 dfault (Predicate.Join P xq)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_only2 dfault seq.Empty =\n    Code.abort STR ''the_only2 empty'' dfault &&&\n    the_only2 dfault (seq.Insert x P) =\n    (if Predicate.is_empty P then x\n     else Code.abort STR ''the_only2 not unique''\n           (\\<lambda>_. the_only2 dfault (seq.Insert x P))) &&&\n    the_only2 dfault (seq.Join P xq) =\n    (if Predicate.is_empty P then the_only2 dfault xq\n     else if Predicate.null xq then singleton2 dfault P\n          else Code.abort STR ''the_only2 not unique''\n                (\\<lambda>_. the_only2 dfault (seq.Join P xq)))", "unfolding singleton2_def the_only2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Predicate.the_only dfault seq.Empty =\n    Code.abort STR ''the_only2 empty'' dfault &&&\n    Predicate.the_only dfault (seq.Insert x P) =\n    (if Predicate.is_empty P then x\n     else Code.abort STR ''the_only2 not unique''\n           (\\<lambda>_. Predicate.the_only dfault (seq.Insert x P))) &&&\n    Predicate.the_only dfault (seq.Join P xq) =\n    (if Predicate.is_empty P then Predicate.the_only dfault xq\n     else if Predicate.null xq then Predicate.singleton dfault P\n          else Code.abort STR ''the_only2 not unique''\n                (\\<lambda>_. Predicate.the_only dfault (seq.Join P xq)))", "by simp_all"], ["", "lemma the2_eq [code]:\n  \"the2 A = singleton2 (\\<lambda>x. Code.abort (STR ''not_unique'') (\\<lambda>_. the2 A)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the2 A =\n    singleton2\n     (\\<lambda>x. Code.abort STR ''not_unique'' (\\<lambda>_. the2 A)) A", "unfolding the2_def singleton2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Predicate.the A =\n    Predicate.singleton\n     (\\<lambda>x.\n         Code.abort STR ''not_unique'' (\\<lambda>_. Predicate.the A))\n     A", "by(rule the_eq)"], ["", "end"]]}