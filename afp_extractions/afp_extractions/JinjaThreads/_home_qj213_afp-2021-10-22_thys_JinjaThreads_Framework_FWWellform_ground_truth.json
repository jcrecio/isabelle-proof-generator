{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWWellform.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma lock_thread_ok_code [code]: \n  \"lock_thread_ok ls ts = finfun_All ((\\<lambda>l. case l of None \\<Rightarrow> True | \\<lfloor>(t, n)\\<rfloor> \\<Rightarrow> (ts t \\<noteq> None)) \\<circ>$ ls)\"", "lemma lock_thread_okI:\n  \"(\\<And>l t. has_lock (ls $ l) t \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>) \\<Longrightarrow> lock_thread_ok ls ts\"", "lemma lock_thread_okD:\n  \"\\<lbrakk> lock_thread_ok ls ts; has_lock (ls $ l) t \\<rbrakk> \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\"", "lemma lock_thread_okD':\n  \"\\<lbrakk> lock_thread_ok ls ts; has_locks (ls $ l) t = Suc n \\<rbrakk> \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\"", "lemma lock_thread_okE:\n  \"\\<lbrakk> lock_thread_ok ls ts; \\<forall>l t. has_lock (ls $ l) t \\<longrightarrow> (\\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma lock_thread_ok_upd:\n  \"lock_thread_ok ls ts \\<Longrightarrow> lock_thread_ok ls (ts(t \\<mapsto> xw))\"", "lemma lock_thread_ok_has_lockE:\n  assumes \"lock_thread_ok ls ts\"\n  and \"has_lock (ls $ l) t\"\n  obtains x ln' where \"ts t = \\<lfloor>(x, ln')\\<rfloor>\"", "lemma redT_updLs_preserves_lock_thread_ok:\n  assumes lto: \"lock_thread_ok ls ts\"\n  and tst: \"ts t = \\<lfloor>xw\\<rfloor>\"\n  shows \"lock_thread_ok (redT_updLs ls t las) ts\"", "lemma redT_updTs_preserves_lock_thread_ok:\n  assumes lto: \"lock_thread_ok ls ts\"\n  shows \"lock_thread_ok ls (redT_updTs ts nts)\"", "lemma lock_thread_ok_has_lock:\n  assumes \"lock_thread_ok ls ts\"\n  and \"has_lock (ls $ l) t\"\n  obtains xw where \"ts t = \\<lfloor>xw\\<rfloor>\"", "lemma lock_thread_ok_None_has_locks_0:\n  \"\\<lbrakk> lock_thread_ok ls ts; ts t = None \\<rbrakk> \\<Longrightarrow> has_locks (ls $ l) t = 0\"", "lemma redT_upds_preserves_lock_thread_ok:\n  \"\\<lbrakk>lock_thread_ok ls ts; ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas\\<rbrakk>\n  \\<Longrightarrow> lock_thread_ok (redT_updLs ls t las) (redT_updTs ts tas(t \\<mapsto> xw'))\"", "lemma acquire_all_preserves_lock_thread_ok:\n  fixes ln\n  shows \"\\<lbrakk> lock_thread_ok ls ts; ts t = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> lock_thread_ok (acquire_all ls t ln) (ts(t \\<mapsto> xw))\"", "lemma wset_thread_okI:\n  \"(\\<And>t. ts t = None \\<Longrightarrow> ws t = None) \\<Longrightarrow> wset_thread_ok ws ts\"", "lemma wset_thread_okD:\n  \"\\<lbrakk> wset_thread_ok ws ts; ts t = None \\<rbrakk> \\<Longrightarrow> ws t = None\"", "lemma wset_thread_ok_conv_dom:\n  \"wset_thread_ok ws ts \\<longleftrightarrow> dom ws \\<subseteq> dom ts\"", "lemma wset_thread_ok_upd:\n  \"wset_thread_ok ls ts \\<Longrightarrow> wset_thread_ok ls (ts(t \\<mapsto> xw))\"", "lemma wset_thread_ok_upd_None:\n  \"wset_thread_ok ws ts \\<Longrightarrow> wset_thread_ok (ws(t := None)) (ts(t := None))\"", "lemma wset_thread_ok_upd_Some:\n  \"wset_thread_ok ws ts \\<Longrightarrow> wset_thread_ok (ws(t := wo)) (ts(t \\<mapsto> xln))\"", "lemma wset_thread_ok_upd_ws:\n  \"\\<lbrakk> wset_thread_ok ws ts; ts t = \\<lfloor>xln\\<rfloor> \\<rbrakk> \\<Longrightarrow> wset_thread_ok (ws(t := w)) ts\"", "lemma wset_thread_ok_NotifyAllI: \n  \"wset_thread_ok ws ts \\<Longrightarrow> wset_thread_ok (\\<lambda>t. if ws t = \\<lfloor>w t\\<rfloor> then \\<lfloor>w' t\\<rfloor> else ws t) ts\"", "lemma redT_updTs_preserves_wset_thread_ok:\n  assumes wto: \"wset_thread_ok ws ts\"\n  shows \"wset_thread_ok ws (redT_updTs ts nts)\"", "lemma redT_updW_preserve_wset_thread_ok: \n  \"\\<lbrakk> wset_thread_ok ws ts; redT_updW t ws wa ws'; ts t = \\<lfloor>xln\\<rfloor> \\<rbrakk> \\<Longrightarrow> wset_thread_ok ws' ts\"", "lemma redT_updWs_preserve_wset_thread_ok:\n  \"\\<lbrakk> wset_thread_ok ws ts; redT_updWs t ws was ws'; ts t = \\<lfloor>xln\\<rfloor> \\<rbrakk> \\<Longrightarrow> wset_thread_ok ws' ts\"", "lemma wset_final_okI:\n  \"(\\<And>t w. ws t = \\<lfloor>w\\<rfloor> \\<Longrightarrow> \\<exists>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final x) \\<Longrightarrow> wset_final_ok ws ts\"", "lemma wset_final_okD:\n  \"\\<lbrakk> wset_final_ok ws ts; ws t = \\<lfloor>w\\<rfloor> \\<rbrakk> \\<Longrightarrow> \\<exists>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final x\"", "lemma wset_final_okE:\n  assumes \"wset_final_ok ws ts\" \"ws t = \\<lfloor>w\\<rfloor>\"\n  and \"\\<And>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> \\<not> final x \\<Longrightarrow> thesis\"\n  shows thesis", "lemma wset_final_ok_imp_wset_thread_ok:\n  \"wset_final_ok ws ts \\<Longrightarrow> wset_thread_ok ws ts\""], "translations": [["", "lemma lock_thread_ok_code [code]: \n  \"lock_thread_ok ls ts = finfun_All ((\\<lambda>l. case l of None \\<Rightarrow> True | \\<lfloor>(t, n)\\<rfloor> \\<Rightarrow> (ts t \\<noteq> None)) \\<circ>$ ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_thread_ok ls ts =\n    finfun_All\n     ((\\<lambda>l.\n          case l of None \\<Rightarrow> True\n          | \\<lfloor>(t, n)\\<rfloor> \\<Rightarrow>\n              ts t \\<noteq> None) \\<circ>$\n      ls)", "by(simp add: lock_thread_ok_def finfun_All_All has_lock_has_locks_conv has_locks_iff o_def)"], ["", "lemma lock_thread_okI:\n  \"(\\<And>l t. has_lock (ls $ l) t \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>) \\<Longrightarrow> lock_thread_ok ls ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l t.\n        has_lock (ls $ l) t \\<Longrightarrow>\n        \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>) \\<Longrightarrow>\n    lock_thread_ok ls ts", "by(auto simp add: lock_thread_ok_def)"], ["", "lemma lock_thread_okD:\n  \"\\<lbrakk> lock_thread_ok ls ts; has_lock (ls $ l) t \\<rbrakk> \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_thread_ok ls ts; has_lock (ls $ l) t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "by(fastforce simp add: lock_thread_ok_def)"], ["", "lemma lock_thread_okD':\n  \"\\<lbrakk> lock_thread_ok ls ts; has_locks (ls $ l) t = Suc n \\<rbrakk> \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_thread_ok ls ts; has_locks (ls $ l) t = Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "by(auto elim: lock_thread_okD[where l=l] simp del: split_paired_Ex)"], ["", "lemma lock_thread_okE:\n  \"\\<lbrakk> lock_thread_ok ls ts; \\<forall>l t. has_lock (ls $ l) t \\<longrightarrow> (\\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_thread_ok ls ts;\n     \\<forall>l t.\n        has_lock (ls $ l) t \\<longrightarrow>\n        (\\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>) \\<Longrightarrow>\n     P\\<rbrakk>\n    \\<Longrightarrow> P", "by(auto simp add: lock_thread_ok_def simp del: split_paired_Ex)"], ["", "lemma lock_thread_ok_upd:\n  \"lock_thread_ok ls ts \\<Longrightarrow> lock_thread_ok ls (ts(t \\<mapsto> xw))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_thread_ok ls ts \\<Longrightarrow>\n    lock_thread_ok ls (ts(t \\<mapsto> xw))", "by(auto intro!: lock_thread_okI dest: lock_thread_okD)"], ["", "lemma lock_thread_ok_has_lockE:\n  assumes \"lock_thread_ok ls ts\"\n  and \"has_lock (ls $ l) t\"\n  obtains x ln' where \"ts t = \\<lfloor>(x, ln')\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x ln'.\n        ts t = \\<lfloor>(x, ln')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  lock_thread_ok ls ts\n  has_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. (\\<And>x ln'.\n        ts t = \\<lfloor>(x, ln')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest!: lock_thread_okD)"], ["", "lemma redT_updLs_preserves_lock_thread_ok:\n  assumes lto: \"lock_thread_ok ls ts\"\n  and tst: \"ts t = \\<lfloor>xw\\<rfloor>\"\n  shows \"lock_thread_ok (redT_updLs ls t las) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_thread_ok (redT_updLs ls t las) ts", "proof(rule lock_thread_okI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l ta.\n       has_lock (redT_updLs ls t las $ l) ta \\<Longrightarrow>\n       \\<exists>xw. ts ta = \\<lfloor>xw\\<rfloor>", "fix L T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l ta.\n       has_lock (redT_updLs ls t las $ l) ta \\<Longrightarrow>\n       \\<exists>xw. ts ta = \\<lfloor>xw\\<rfloor>", "assume ru: \"has_lock (redT_updLs ls t las $ L) T\""], ["proof (state)\nthis:\n  has_lock (redT_updLs ls t las $ L) T\n\ngoal (1 subgoal):\n 1. \\<And>l ta.\n       has_lock (redT_updLs ls t las $ l) ta \\<Longrightarrow>\n       \\<exists>xw. ts ta = \\<lfloor>xw\\<rfloor>", "show \"\\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "proof(cases \"t = T\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = T \\<Longrightarrow> \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>\n 2. t \\<noteq> T \\<Longrightarrow> \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "case True"], ["proof (state)\nthis:\n  t = T\n\ngoal (2 subgoals):\n 1. t = T \\<Longrightarrow> \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>\n 2. t \\<noteq> T \\<Longrightarrow> \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = T\n\ngoal (1 subgoal):\n 1. \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "using tst lto"], ["proof (prove)\nusing this:\n  t = T\n  ts t = \\<lfloor>xw\\<rfloor>\n  lock_thread_ok ls ts\n\ngoal (1 subgoal):\n 1. \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "by(auto elim: lock_thread_okE)"], ["proof (state)\nthis:\n  \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>\n\ngoal (1 subgoal):\n 1. t \\<noteq> T \\<Longrightarrow> \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> T \\<Longrightarrow> \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "case False"], ["proof (state)\nthis:\n  t \\<noteq> T\n\ngoal (1 subgoal):\n 1. t \\<noteq> T \\<Longrightarrow> \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "with ru"], ["proof (chain)\npicking this:\n  has_lock (redT_updLs ls t las $ L) T\n  t \\<noteq> T", "have \"has_lock (ls $ L) T\""], ["proof (prove)\nusing this:\n  has_lock (redT_updLs ls t las $ L) T\n  t \\<noteq> T\n\ngoal (1 subgoal):\n 1. has_lock (ls $ L) T", "by(rule redT_updLs_Some_thread_idD)"], ["proof (state)\nthis:\n  has_lock (ls $ L) T\n\ngoal (1 subgoal):\n 1. t \\<noteq> T \\<Longrightarrow> \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  has_lock (ls $ L) T\n\ngoal (1 subgoal):\n 1. \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "using lto"], ["proof (prove)\nusing this:\n  has_lock (ls $ L) T\n  lock_thread_ok ls ts\n\ngoal (1 subgoal):\n 1. \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>", "by(auto elim!: lock_thread_okE simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xw. ts T = \\<lfloor>xw\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redT_updTs_preserves_lock_thread_ok:\n  assumes lto: \"lock_thread_ok ls ts\"\n  shows \"lock_thread_ok ls (redT_updTs ts nts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_thread_ok ls (redT_updTs ts nts)", "proof(rule lock_thread_okI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l t.\n       has_lock (ls $ l) t \\<Longrightarrow>\n       \\<exists>xw. redT_updTs ts nts t = \\<lfloor>xw\\<rfloor>", "fix l t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l t.\n       has_lock (ls $ l) t \\<Longrightarrow>\n       \\<exists>xw. redT_updTs ts nts t = \\<lfloor>xw\\<rfloor>", "assume \"has_lock (ls $ l) t\""], ["proof (state)\nthis:\n  has_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. \\<And>l t.\n       has_lock (ls $ l) t \\<Longrightarrow>\n       \\<exists>xw. redT_updTs ts nts t = \\<lfloor>xw\\<rfloor>", "with lto"], ["proof (chain)\npicking this:\n  lock_thread_ok ls ts\n  has_lock (ls $ l) t", "have \"\\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\nusing this:\n  lock_thread_ok ls ts\n  has_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>", "by(auto elim!: lock_thread_okE simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>l t.\n       has_lock (ls $ l) t \\<Longrightarrow>\n       \\<exists>xw. redT_updTs ts nts t = \\<lfloor>xw\\<rfloor>", "thus \"\\<exists>xw. redT_updTs ts nts t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<exists>xw. ts t = \\<lfloor>xw\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>xw. redT_updTs ts nts t = \\<lfloor>xw\\<rfloor>", "by(auto intro: redT_updTs_Some1 simp del: split_paired_Ex)"], ["proof (state)\nthis:\n  \\<exists>xw. redT_updTs ts nts t = \\<lfloor>xw\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lock_thread_ok_has_lock:\n  assumes \"lock_thread_ok ls ts\"\n  and \"has_lock (ls $ l) t\"\n  obtains xw where \"ts t = \\<lfloor>xw\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xw.\n        ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  lock_thread_ok ls ts\n  has_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. (\\<And>xw.\n        ts t = \\<lfloor>xw\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest!: lock_thread_okD)"], ["", "lemma lock_thread_ok_None_has_locks_0:\n  \"\\<lbrakk> lock_thread_ok ls ts; ts t = None \\<rbrakk> \\<Longrightarrow> has_locks (ls $ l) t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_thread_ok ls ts; ts t = None\\<rbrakk>\n    \\<Longrightarrow> has_locks (ls $ l) t = 0", "by(rule ccontr)(auto dest: lock_thread_okD)"], ["", "lemma redT_upds_preserves_lock_thread_ok:\n  \"\\<lbrakk>lock_thread_ok ls ts; ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas\\<rbrakk>\n  \\<Longrightarrow> lock_thread_ok (redT_updLs ls t las) (redT_updTs ts tas(t \\<mapsto> xw'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_thread_ok ls ts; ts t = \\<lfloor>xw\\<rfloor>;\n     thread_oks ts tas\\<rbrakk>\n    \\<Longrightarrow> lock_thread_ok (redT_updLs ls t las)\n                       (redT_updTs ts tas(t \\<mapsto> xw'))", "apply(rule lock_thread_okI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ta.\n       \\<lbrakk>lock_thread_ok ls ts; ts t = \\<lfloor>xw\\<rfloor>;\n        thread_oks ts tas; has_lock (redT_updLs ls t las $ l) ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xw.\n                            (redT_updTs ts tas(t \\<mapsto> xw')) ta =\n                            \\<lfloor>xw\\<rfloor>", "apply(clarsimp simp del: split_paired_Ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ta.\n       \\<lbrakk>lock_thread_ok ls ts; ts t = \\<lfloor>xw\\<rfloor>;\n        thread_oks ts tas; has_lock (upd_locks (ls $ l) t (las $ l)) ta;\n        ta \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xw.\n                            redT_updTs ts tas ta = \\<lfloor>xw\\<rfloor>", "apply(drule has_lock_upd_locks_implies_has_lock, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ta.\n       \\<lbrakk>lock_thread_ok ls ts; ts t = \\<lfloor>xw\\<rfloor>;\n        thread_oks ts tas; ta \\<noteq> t; has_lock (ls $ l) ta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xw.\n                            redT_updTs ts tas ta = \\<lfloor>xw\\<rfloor>", "apply(drule lock_thread_okD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ta.\n       \\<lbrakk>ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas;\n        ta \\<noteq> t; has_lock (ls $ l) ta;\n        \\<exists>xw. ts ta = \\<lfloor>xw\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xw.\n                            redT_updTs ts tas ta = \\<lfloor>xw\\<rfloor>", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ta xwa.\n       \\<lbrakk>ts t = \\<lfloor>xw\\<rfloor>; thread_oks ts tas;\n        ta \\<noteq> t; has_lock (ls $ l) ta;\n        ts ta = \\<lfloor>xwa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xw.\n                            redT_updTs ts tas ta = \\<lfloor>xw\\<rfloor>", "by(rule redT_updTs_Some1)"], ["", "lemma acquire_all_preserves_lock_thread_ok:\n  fixes ln\n  shows \"\\<lbrakk> lock_thread_ok ls ts; ts t = \\<lfloor>(x, ln)\\<rfloor> \\<rbrakk> \\<Longrightarrow> lock_thread_ok (acquire_all ls t ln) (ts(t \\<mapsto> xw))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_thread_ok ls ts; ts t = \\<lfloor>(x, ln)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> lock_thread_ok (acquire_all ls t ln)\n                       (ts(t \\<mapsto> xw))", "by(rule lock_thread_okI)(auto dest!: has_lock_acquire_locks_implies_has_lock dest: lock_thread_okD)"], ["", "text \\<open>Well-formedness condition: Wait sets contain only real threads\\<close>"], ["", "definition wset_thread_ok :: \"('w, 't) wait_sets \\<Rightarrow> ('l, 't, 'x) thread_info \\<Rightarrow> bool\"\nwhere \"wset_thread_ok ws ts \\<equiv> \\<forall>t. ts t = None \\<longrightarrow> ws t = None\""], ["", "lemma wset_thread_okI:\n  \"(\\<And>t. ts t = None \\<Longrightarrow> ws t = None) \\<Longrightarrow> wset_thread_ok ws ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. ts t = None \\<Longrightarrow> ws t = None) \\<Longrightarrow>\n    wset_thread_ok ws ts", "by(simp add: wset_thread_ok_def)"], ["", "lemma wset_thread_okD:\n  \"\\<lbrakk> wset_thread_ok ws ts; ts t = None \\<rbrakk> \\<Longrightarrow> ws t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wset_thread_ok ws ts; ts t = None\\<rbrakk>\n    \\<Longrightarrow> ws t = None", "by(simp add: wset_thread_ok_def)"], ["", "lemma wset_thread_ok_conv_dom:\n  \"wset_thread_ok ws ts \\<longleftrightarrow> dom ws \\<subseteq> dom ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_thread_ok ws ts = (dom ws \\<subseteq> dom ts)", "by(auto simp add: wset_thread_ok_def)"], ["", "lemma wset_thread_ok_upd:\n  \"wset_thread_ok ls ts \\<Longrightarrow> wset_thread_ok ls (ts(t \\<mapsto> xw))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_thread_ok ls ts \\<Longrightarrow>\n    wset_thread_ok ls (ts(t \\<mapsto> xw))", "by(auto intro!: wset_thread_okI dest: wset_thread_okD split: if_split_asm)"], ["", "lemma wset_thread_ok_upd_None:\n  \"wset_thread_ok ws ts \\<Longrightarrow> wset_thread_ok (ws(t := None)) (ts(t := None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_thread_ok ws ts \\<Longrightarrow>\n    wset_thread_ok (ws(t := None)) (ts(t := None))", "by(auto intro!: wset_thread_okI dest: wset_thread_okD split: if_split_asm)"], ["", "lemma wset_thread_ok_upd_Some:\n  \"wset_thread_ok ws ts \\<Longrightarrow> wset_thread_ok (ws(t := wo)) (ts(t \\<mapsto> xln))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_thread_ok ws ts \\<Longrightarrow>\n    wset_thread_ok (ws(t := wo)) (ts(t \\<mapsto> xln))", "by(auto intro!: wset_thread_okI dest: wset_thread_okD split: if_split_asm)"], ["", "lemma wset_thread_ok_upd_ws:\n  \"\\<lbrakk> wset_thread_ok ws ts; ts t = \\<lfloor>xln\\<rfloor> \\<rbrakk> \\<Longrightarrow> wset_thread_ok (ws(t := w)) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wset_thread_ok ws ts; ts t = \\<lfloor>xln\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> wset_thread_ok (ws(t := w)) ts", "by(auto intro!: wset_thread_okI dest: wset_thread_okD)"], ["", "lemma wset_thread_ok_NotifyAllI: \n  \"wset_thread_ok ws ts \\<Longrightarrow> wset_thread_ok (\\<lambda>t. if ws t = \\<lfloor>w t\\<rfloor> then \\<lfloor>w' t\\<rfloor> else ws t) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_thread_ok ws ts \\<Longrightarrow>\n    wset_thread_ok\n     (\\<lambda>t.\n         if ws t = \\<lfloor>w t\\<rfloor> then \\<lfloor>w' t\\<rfloor>\n         else ws t)\n     ts", "by(simp add: wset_thread_ok_def)"], ["", "lemma redT_updTs_preserves_wset_thread_ok:\n  assumes wto: \"wset_thread_ok ws ts\"\n  shows \"wset_thread_ok ws (redT_updTs ts nts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_thread_ok ws (redT_updTs ts nts)", "proof(rule wset_thread_okI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. redT_updTs ts nts t = None \\<Longrightarrow> ws t = None", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. redT_updTs ts nts t = None \\<Longrightarrow> ws t = None", "assume \"redT_updTs ts nts t = None\""], ["proof (state)\nthis:\n  redT_updTs ts nts t = None\n\ngoal (1 subgoal):\n 1. \\<And>t. redT_updTs ts nts t = None \\<Longrightarrow> ws t = None", "hence \"ts t = None\""], ["proof (prove)\nusing this:\n  redT_updTs ts nts t = None\n\ngoal (1 subgoal):\n 1. ts t = None", "by(rule redT_updTs_None)"], ["proof (state)\nthis:\n  ts t = None\n\ngoal (1 subgoal):\n 1. \\<And>t. redT_updTs ts nts t = None \\<Longrightarrow> ws t = None", "with wto"], ["proof (chain)\npicking this:\n  wset_thread_ok ws ts\n  ts t = None", "show \"ws t = None\""], ["proof (prove)\nusing this:\n  wset_thread_ok ws ts\n  ts t = None\n\ngoal (1 subgoal):\n 1. ws t = None", "by(rule wset_thread_okD)"], ["proof (state)\nthis:\n  ws t = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redT_updW_preserve_wset_thread_ok: \n  \"\\<lbrakk> wset_thread_ok ws ts; redT_updW t ws wa ws'; ts t = \\<lfloor>xln\\<rfloor> \\<rbrakk> \\<Longrightarrow> wset_thread_ok ws' ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wset_thread_ok ws ts; redT_updW t ws wa ws';\n     ts t = \\<lfloor>xln\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> wset_thread_ok ws' ts", "by(fastforce simp add: redT_updW.simps intro: wset_thread_okI wset_thread_ok_NotifyAllI wset_thread_ok_upd_ws dest: wset_thread_okD)"], ["", "lemma redT_updWs_preserve_wset_thread_ok:\n  \"\\<lbrakk> wset_thread_ok ws ts; redT_updWs t ws was ws'; ts t = \\<lfloor>xln\\<rfloor> \\<rbrakk> \\<Longrightarrow> wset_thread_ok ws' ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wset_thread_ok ws ts; redT_updWs t ws was ws';\n     ts t = \\<lfloor>xln\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> wset_thread_ok ws' ts", "unfolding redT_updWs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wset_thread_ok ws ts; rtrancl3p (redT_updW t) ws was ws';\n     ts t = \\<lfloor>xln\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> wset_thread_ok ws' ts", "apply(rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtrancl3p (redT_updW t) ws was ws';\n     ts t = \\<lfloor>xln\\<rfloor>; wset_thread_ok ws ts\\<rbrakk>\n    \\<Longrightarrow> wset_thread_ok ws' ts", "by(induct rule: rtrancl3p_converse_induct)(auto intro: redT_updW_preserve_wset_thread_ok)"], ["", "text \\<open>Well-formedness condition: Wait sets contain only non-final threads\\<close>"], ["", "context final_thread begin"], ["", "definition wset_final_ok :: \"('w, 't) wait_sets \\<Rightarrow> ('l, 't, 'x) thread_info \\<Rightarrow> bool\"\nwhere \"wset_final_ok ws ts \\<longleftrightarrow> (\\<forall>t \\<in> dom ws. \\<exists>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final x)\""], ["", "lemma wset_final_okI:\n  \"(\\<And>t w. ws t = \\<lfloor>w\\<rfloor> \\<Longrightarrow> \\<exists>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final x) \\<Longrightarrow> wset_final_ok ws ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t w.\n        ws t = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n        \\<exists>x ln.\n           ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> final x) \\<Longrightarrow>\n    wset_final_ok ws ts", "unfolding wset_final_ok_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t w.\n        ws t = \\<lfloor>w\\<rfloor> \\<Longrightarrow>\n        \\<exists>x ln.\n           ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n           \\<not> final x) \\<Longrightarrow>\n    \\<forall>t\\<in>dom ws.\n       \\<exists>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final x", "by(blast)"], ["", "lemma wset_final_okD:\n  \"\\<lbrakk> wset_final_ok ws ts; ws t = \\<lfloor>w\\<rfloor> \\<rbrakk> \\<Longrightarrow> \\<exists>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wset_final_ok ws ts; ws t = \\<lfloor>w\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x ln.\n                         ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                         \\<not> final x", "unfolding wset_final_ok_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t\\<in>dom ws.\n                \\<exists>x ln.\n                   ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and> \\<not> final x;\n     ws t = \\<lfloor>w\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x ln.\n                         ts t = \\<lfloor>(x, ln)\\<rfloor> \\<and>\n                         \\<not> final x", "by(blast)"], ["", "lemma wset_final_okE:\n  assumes \"wset_final_ok ws ts\" \"ws t = \\<lfloor>w\\<rfloor>\"\n  and \"\\<And>x ln. ts t = \\<lfloor>(x, ln)\\<rfloor> \\<Longrightarrow> \\<not> final x \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  wset_final_ok ws ts\n  ws t = \\<lfloor>w\\<rfloor>\n  \\<lbrakk>ts t = \\<lfloor>(?x5, ?ln5)\\<rfloor>; \\<not> final ?x5\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by(blast dest: wset_final_okD)"], ["", "lemma wset_final_ok_imp_wset_thread_ok:\n  \"wset_final_ok ws ts \\<Longrightarrow> wset_thread_ok ws ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_final_ok ws ts \\<Longrightarrow> wset_thread_ok ws ts", "apply(rule wset_thread_okI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>wset_final_ok ws ts; ts t = None\\<rbrakk>\n       \\<Longrightarrow> ws t = None", "apply(rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>wset_final_ok ws ts; ts t = None;\n        ws t \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto elim: wset_final_okE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}