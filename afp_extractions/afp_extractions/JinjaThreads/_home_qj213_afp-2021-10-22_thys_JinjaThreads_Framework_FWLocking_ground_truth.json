{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/Framework/FWLocking.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma redT_updLs_iff [simp]: \"redT_updLs ls t las $ l = upd_locks (ls $ l) t (las $ l)\"", "lemma upd_locks_empty_conv [simp]: \"(\\<lambda>(l, las). upd_locks l t las) \\<circ>$ ($ls, K$ []$) = ls\"", "lemma redT_updLs_Some_thread_idD:\n  \"\\<lbrakk> has_lock (redT_updLs ls t las $ l) t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_lock (ls $ l) t'\"", "lemma acquire_all_iff [simp]: \n  \"\\<And>ln. acquire_all ls t ln $ l = acquire_locks (ls $ l) t (ln $ l)\"", "lemma lock_ok_lasI [intro]:\n  \"(\\<And>l. lock_actions_ok (ls $ l) t (las $ l)) \\<Longrightarrow> lock_ok_las ls t las\"", "lemma lock_ok_lasE:\n  \"\\<lbrakk> lock_ok_las ls t las; (\\<And>l. lock_actions_ok (ls $ l) t (las $ l)) \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"", "lemma lock_ok_lasD:\n  \"lock_ok_las ls t las \\<Longrightarrow> lock_actions_ok (ls $ l) t (las $ l)\"", "lemma lock_ok_las_code [code]:\n  \"lock_ok_las ls t las = finfun_All ((\\<lambda>(l, la). lock_actions_ok l t la) \\<circ>$ ($ls, las$))\"", "lemma lock_ok_las_may_lock:\n  \"\\<lbrakk> lock_ok_las ls t las; Lock \\<in> set (las $ l) \\<rbrakk> \\<Longrightarrow> may_lock (ls $ l) t\"", "lemma redT_updLs_may_lock [simp]:\n  \"lock_ok_las ls t las \\<Longrightarrow> may_lock (redT_updLs ls t las $ l) t = may_lock (ls $ l) t\"", "lemma redT_updLs_has_locks [simp]:\n  \"\\<lbrakk> lock_ok_las ls t' las; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (redT_updLs ls t' las $ l) t = has_locks (ls $ l) t\"", "lemma may_acquire_allI [intro]:\n  \"\\<And>ln. (\\<And>l. ln $ l > 0 \\<Longrightarrow> may_lock (ls $ l) t) \\<Longrightarrow> may_acquire_all ls t ln\"", "lemma may_acquire_allE:\n  \"\\<And>ln. \\<lbrakk> may_acquire_all ls t ln; \\<forall>l. ln $ l > 0 \\<longrightarrow> may_lock (ls $ l) t \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma may_acquire_allD [dest]:\n  \"\\<And>ln. \\<lbrakk> may_acquire_all ls t ln; ln $ l > 0 \\<rbrakk> \\<Longrightarrow> may_lock (ls $ l) t\"", "lemma may_acquire_all_has_locks_acquire_locks [simp]:\n  fixes ln\n  shows \"\\<lbrakk> may_acquire_all ls t ln; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (acquire_locks (ls $ l) t (ln $ l)) t' = has_locks (ls $ l) t'\"", "lemma may_acquire_all_code [code]:\n  \"\\<And>ln. may_acquire_all ls t ln \\<longleftrightarrow> finfun_All ((\\<lambda>(lock, n). n > 0 \\<longrightarrow> may_lock lock t) \\<circ>$ ($ls, ln$))\"", "lemma collect_locksI:\n  \"Lock \\<in> set (las $ l) \\<Longrightarrow> l \\<in> collect_locks las\"", "lemma collect_locksE:\n  \"\\<lbrakk> l \\<in> collect_locks las; Lock \\<in> set (las $ l) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma collect_locksD:\n  \"l \\<in> collect_locks las \\<Longrightarrow> Lock \\<in> set (las $ l)\"", "lemma must_acquire_lock_append:\n  \"must_acquire_lock (xs @ ys) \\<longleftrightarrow> (if Lock \\<in> set xs \\<or> Unlock \\<in> set xs then must_acquire_lock xs else must_acquire_lock ys)\"", "lemma must_acquire_lock_contains_lock:\n  \"must_acquire_lock las \\<Longrightarrow> Lock \\<in> set las\"", "lemma must_acquire_lock_conv:\n  \"must_acquire_lock las = (case (filter (\\<lambda>L. L = Lock \\<or> L = Unlock) las) of [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)\"", "lemma collect_locks'I:\n  \"must_acquire_lock (las $ l) \\<Longrightarrow> l \\<in> collect_locks' las\"", "lemma collect_locks'E:\n  \"\\<lbrakk> l \\<in> collect_locks' las; must_acquire_lock (las $ l) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma collect_locks'_subset_collect_locks:\n  \"collect_locks' las \\<subseteq> collect_locks las\"", "lemma lock_ok_las'I: \"(\\<And>l. lock_actions_ok' (ls $ l) t (las $ l)) \\<Longrightarrow> lock_ok_las' ls t las\"", "lemma lock_ok_las'D: \"lock_ok_las' ls t las \\<Longrightarrow> lock_actions_ok' (ls $ l) t (las $ l)\"", "lemma not_lock_ok_las'_conv:\n  \"\\<not> lock_ok_las' ls t las \\<longleftrightarrow> (\\<exists>l. \\<not> lock_actions_ok' (ls $ l) t (las $ l))\"", "lemma lock_ok_las'_code:\n    \"lock_ok_las' ls t las = finfun_All ((\\<lambda>(l, la). lock_actions_ok' l t la) \\<circ>$ ($ls, las$))\"", "lemma lock_ok_las'_collect_locks'_may_lock:\n  assumes lot': \"lock_ok_las' ls t las\"\n  and mayl: \"\\<forall>l \\<in> collect_locks' las. may_lock (ls $ l) t\"\n  and l: \"l \\<in> collect_locks las\"\n  shows \"may_lock (ls $ l) t\"", "lemma lock_actions_ok'_must_acquire_lock_lock_actions_ok:\n  \"\\<lbrakk> lock_actions_ok' l t Ls; must_acquire_lock Ls \\<longrightarrow> may_lock l t\\<rbrakk> \\<Longrightarrow> lock_actions_ok l t Ls\"", "lemma lock_ok_las'_collect_locks_lock_ok_las:\n  assumes lol': \"lock_ok_las' ls t las\"\n  and clml: \"\\<And>l. l \\<in> collect_locks las \\<Longrightarrow> may_lock (ls $ l) t\"\n  shows \"lock_ok_las ls t las\"", "lemma lock_ok_las'_into_lock_on_las:\n  \"\\<lbrakk>lock_ok_las' ls t las; \\<And>l. l \\<in> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t\\<rbrakk> \\<Longrightarrow> lock_ok_las ls t las\""], "translations": [["", "lemma redT_updLs_iff [simp]: \"redT_updLs ls t las $ l = upd_locks (ls $ l) t (las $ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redT_updLs ls t las $ l = upd_locks (ls $ l) t (las $ l)", "by(simp add: redT_updLs_def)"], ["", "lemma upd_locks_empty_conv [simp]: \"(\\<lambda>(l, las). upd_locks l t las) \\<circ>$ ($ls, K$ []$) = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(l, las). upd_locks l t las) \\<circ>$ ($ls, K$ []$) = ls", "by(auto intro: finfun_ext)"], ["", "lemma redT_updLs_Some_thread_idD:\n  \"\\<lbrakk> has_lock (redT_updLs ls t las $ l) t'; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_lock (ls $ l) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_lock (redT_updLs ls t las $ l) t'; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_lock (ls $ l) t'", "by(auto simp add: redT_updLs_def intro: has_lock_upd_locks_implies_has_lock)"], ["", "definition acquire_all :: \"('l, 't) locks \\<Rightarrow> 't \\<Rightarrow> ('l \\<Rightarrow>f nat) \\<Rightarrow> ('l, 't) locks\"\nwhere \"\\<And>ln. acquire_all ls t ln \\<equiv> (\\<lambda>(l, la). acquire_locks l t la) \\<circ>$ (($ls, ln$))\""], ["", "lemma acquire_all_iff [simp]: \n  \"\\<And>ln. acquire_all ls t ln $ l = acquire_locks (ls $ l) t (ln $ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln. acquire_all ls t ln $ l = acquire_locks (ls $ l) t (ln $ l)", "by(simp add: acquire_all_def)"], ["", "definition lock_ok_las :: \"('l,'t) locks \\<Rightarrow> 't \\<Rightarrow> 'l lock_actions \\<Rightarrow> bool\" where\n  \"lock_ok_las ls t las \\<equiv> \\<forall>l. lock_actions_ok (ls $ l) t (las $ l)\""], ["", "lemma lock_ok_lasI [intro]:\n  \"(\\<And>l. lock_actions_ok (ls $ l) t (las $ l)) \\<Longrightarrow> lock_ok_las ls t las\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. lock_actions_ok (ls $ l) t (las $ l)) \\<Longrightarrow>\n    lock_ok_las ls t las", "by(simp add: lock_ok_las_def)"], ["", "lemma lock_ok_lasE:\n  \"\\<lbrakk> lock_ok_las ls t las; (\\<And>l. lock_actions_ok (ls $ l) t (las $ l)) \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_ok_las ls t las;\n     (\\<And>l. lock_actions_ok (ls $ l) t (las $ l)) \\<Longrightarrow>\n     Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by(simp add: lock_ok_las_def)"], ["", "lemma lock_ok_lasD:\n  \"lock_ok_las ls t las \\<Longrightarrow> lock_actions_ok (ls $ l) t (las $ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok_las ls t las \\<Longrightarrow>\n    lock_actions_ok (ls $ l) t (las $ l)", "by(simp add: lock_ok_las_def)"], ["", "lemma lock_ok_las_code [code]:\n  \"lock_ok_las ls t las = finfun_All ((\\<lambda>(l, la). lock_actions_ok l t la) \\<circ>$ ($ls, las$))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok_las ls t las =\n    finfun_All\n     ((\\<lambda>(l, la). lock_actions_ok l t la) \\<circ>$ ($ls, las$))", "by(simp add: lock_ok_las_def finfun_All_All o_def)"], ["", "lemma lock_ok_las_may_lock:\n  \"\\<lbrakk> lock_ok_las ls t las; Lock \\<in> set (las $ l) \\<rbrakk> \\<Longrightarrow> may_lock (ls $ l) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_ok_las ls t las; Lock \\<in> set (las $ l)\\<rbrakk>\n    \\<Longrightarrow> may_lock (ls $ l) t", "by(erule lock_ok_lasE)(rule lock_actions_ok_Lock_may_lock)"], ["", "lemma redT_updLs_may_lock [simp]:\n  \"lock_ok_las ls t las \\<Longrightarrow> may_lock (redT_updLs ls t las $ l) t = may_lock (ls $ l) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok_las ls t las \\<Longrightarrow>\n    may_lock (redT_updLs ls t las $ l) t = may_lock (ls $ l) t", "by(auto dest!: lock_ok_lasD[where l=l])"], ["", "lemma redT_updLs_has_locks [simp]:\n  \"\\<lbrakk> lock_ok_las ls t' las; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (redT_updLs ls t' las $ l) t = has_locks (ls $ l) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_ok_las ls t' las; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (redT_updLs ls t' las $ l) t =\n                      has_locks (ls $ l) t", "by(auto dest!: lock_ok_lasD[where l=l])"], ["", "definition may_acquire_all :: \"('l, 't) locks \\<Rightarrow> 't \\<Rightarrow> ('l \\<Rightarrow>f nat) \\<Rightarrow> bool\"\nwhere \"\\<And>ln. may_acquire_all ls t ln \\<equiv> \\<forall>l. ln $ l > 0 \\<longrightarrow> may_lock (ls $ l) t\""], ["", "lemma may_acquire_allI [intro]:\n  \"\\<And>ln. (\\<And>l. ln $ l > 0 \\<Longrightarrow> may_lock (ls $ l) t) \\<Longrightarrow> may_acquire_all ls t ln\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       (\\<And>l.\n           0 < ln $ l \\<Longrightarrow>\n           may_lock (ls $ l) t) \\<Longrightarrow>\n       may_acquire_all ls t ln", "by(simp add: may_acquire_all_def)"], ["", "lemma may_acquire_allE:\n  \"\\<And>ln. \\<lbrakk> may_acquire_all ls t ln; \\<forall>l. ln $ l > 0 \\<longrightarrow> may_lock (ls $ l) t \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>may_acquire_all ls t ln;\n        \\<forall>l.\n           0 < ln $ l \\<longrightarrow>\n           may_lock (ls $ l) t \\<Longrightarrow>\n        P\\<rbrakk>\n       \\<Longrightarrow> P", "by(auto simp add: may_acquire_all_def)"], ["", "lemma may_acquire_allD [dest]:\n  \"\\<And>ln. \\<lbrakk> may_acquire_all ls t ln; ln $ l > 0 \\<rbrakk> \\<Longrightarrow> may_lock (ls $ l) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>may_acquire_all ls t ln; 0 < ln $ l\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "by(auto simp add: may_acquire_all_def)"], ["", "lemma may_acquire_all_has_locks_acquire_locks [simp]:\n  fixes ln\n  shows \"\\<lbrakk> may_acquire_all ls t ln; t \\<noteq> t' \\<rbrakk> \\<Longrightarrow> has_locks (acquire_locks (ls $ l) t (ln $ l)) t' = has_locks (ls $ l) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>may_acquire_all ls t ln; t \\<noteq> t'\\<rbrakk>\n    \\<Longrightarrow> has_locks (acquire_locks (ls $ l) t (ln $ l)) t' =\n                      has_locks (ls $ l) t'", "by(cases \"ln $ l > 0\")(auto dest: may_acquire_allD)"], ["", "lemma may_acquire_all_code [code]:\n  \"\\<And>ln. may_acquire_all ls t ln \\<longleftrightarrow> finfun_All ((\\<lambda>(lock, n). n > 0 \\<longrightarrow> may_lock lock t) \\<circ>$ ($ls, ln$))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       may_acquire_all ls t ln =\n       finfun_All\n        ((\\<lambda>(lock, n).\n             0 < n \\<longrightarrow> may_lock lock t) \\<circ>$\n         ($ls, ln$))", "by(auto simp add: may_acquire_all_def finfun_All_All o_def)"], ["", "definition collect_locks :: \"'l lock_actions \\<Rightarrow> 'l set\" where\n  \"collect_locks las = {l. Lock \\<in> set (las $ l)}\""], ["", "lemma collect_locksI:\n  \"Lock \\<in> set (las $ l) \\<Longrightarrow> l \\<in> collect_locks las\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lock \\<in> set (las $ l) \\<Longrightarrow> l \\<in> collect_locks las", "by(simp add: collect_locks_def)"], ["", "lemma collect_locksE:\n  \"\\<lbrakk> l \\<in> collect_locks las; Lock \\<in> set (las $ l) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<in> collect_locks las;\n     Lock \\<in> set (las $ l) \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by(simp add: collect_locks_def)"], ["", "lemma collect_locksD:\n  \"l \\<in> collect_locks las \\<Longrightarrow> Lock \\<in> set (las $ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> collect_locks las \\<Longrightarrow> Lock \\<in> set (las $ l)", "by(simp add: collect_locks_def)"], ["", "fun must_acquire_lock :: \"lock_action list \\<Rightarrow> bool\" where\n  \"must_acquire_lock [] = False\"\n| \"must_acquire_lock (Lock # las) = True\"\n| \"must_acquire_lock (Unlock # las) = False\"\n| \"must_acquire_lock (_ # las) = must_acquire_lock las\""], ["", "lemma must_acquire_lock_append:\n  \"must_acquire_lock (xs @ ys) \\<longleftrightarrow> (if Lock \\<in> set xs \\<or> Unlock \\<in> set xs then must_acquire_lock xs else must_acquire_lock ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. must_acquire_lock (xs @ ys) =\n    (if Lock \\<in> set xs \\<or> Unlock \\<in> set xs\n     then must_acquire_lock xs else must_acquire_lock ys)", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. must_acquire_lock ([] @ ys) =\n    (if Lock \\<in> set [] \\<or> Unlock \\<in> set []\n     then must_acquire_lock [] else must_acquire_lock ys)\n 2. \\<And>a xs.\n       must_acquire_lock (xs @ ys) =\n       (if Lock \\<in> set xs \\<or> Unlock \\<in> set xs\n        then must_acquire_lock xs\n        else must_acquire_lock ys) \\<Longrightarrow>\n       must_acquire_lock ((a # xs) @ ys) =\n       (if Lock \\<in> set (a # xs) \\<or> Unlock \\<in> set (a # xs)\n        then must_acquire_lock (a # xs) else must_acquire_lock ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. must_acquire_lock ([] @ ys) =\n    (if Lock \\<in> set [] \\<or> Unlock \\<in> set []\n     then must_acquire_lock [] else must_acquire_lock ys)\n 2. \\<And>a xs.\n       must_acquire_lock (xs @ ys) =\n       (if Lock \\<in> set xs \\<or> Unlock \\<in> set xs\n        then must_acquire_lock xs\n        else must_acquire_lock ys) \\<Longrightarrow>\n       must_acquire_lock ((a # xs) @ ys) =\n       (if Lock \\<in> set (a # xs) \\<or> Unlock \\<in> set (a # xs)\n        then must_acquire_lock (a # xs) else must_acquire_lock ys)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. must_acquire_lock ([] @ ys) =\n    (if Lock \\<in> set [] \\<or> Unlock \\<in> set []\n     then must_acquire_lock [] else must_acquire_lock ys)", "by simp"], ["proof (state)\nthis:\n  must_acquire_lock ([] @ ys) =\n  (if Lock \\<in> set [] \\<or> Unlock \\<in> set [] then must_acquire_lock []\n   else must_acquire_lock ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       must_acquire_lock (xs @ ys) =\n       (if Lock \\<in> set xs \\<or> Unlock \\<in> set xs\n        then must_acquire_lock xs\n        else must_acquire_lock ys) \\<Longrightarrow>\n       must_acquire_lock ((a # xs) @ ys) =\n       (if Lock \\<in> set (a # xs) \\<or> Unlock \\<in> set (a # xs)\n        then must_acquire_lock (a # xs) else must_acquire_lock ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       must_acquire_lock (xs @ ys) =\n       (if Lock \\<in> set xs \\<or> Unlock \\<in> set xs\n        then must_acquire_lock xs\n        else must_acquire_lock ys) \\<Longrightarrow>\n       must_acquire_lock ((a # xs) @ ys) =\n       (if Lock \\<in> set (a # xs) \\<or> Unlock \\<in> set (a # xs)\n        then must_acquire_lock (a # xs) else must_acquire_lock ys)", "case (Cons L Ls)"], ["proof (state)\nthis:\n  must_acquire_lock (Ls @ ys) =\n  (if Lock \\<in> set Ls \\<or> Unlock \\<in> set Ls then must_acquire_lock Ls\n   else must_acquire_lock ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       must_acquire_lock (xs @ ys) =\n       (if Lock \\<in> set xs \\<or> Unlock \\<in> set xs\n        then must_acquire_lock xs\n        else must_acquire_lock ys) \\<Longrightarrow>\n       must_acquire_lock ((a # xs) @ ys) =\n       (if Lock \\<in> set (a # xs) \\<or> Unlock \\<in> set (a # xs)\n        then must_acquire_lock (a # xs) else must_acquire_lock ys)", "thus ?case"], ["proof (prove)\nusing this:\n  must_acquire_lock (Ls @ ys) =\n  (if Lock \\<in> set Ls \\<or> Unlock \\<in> set Ls then must_acquire_lock Ls\n   else must_acquire_lock ys)\n\ngoal (1 subgoal):\n 1. must_acquire_lock ((L # Ls) @ ys) =\n    (if Lock \\<in> set (L # Ls) \\<or> Unlock \\<in> set (L # Ls)\n     then must_acquire_lock (L # Ls) else must_acquire_lock ys)", "by (cases L, simp_all)"], ["proof (state)\nthis:\n  must_acquire_lock ((L # Ls) @ ys) =\n  (if Lock \\<in> set (L # Ls) \\<or> Unlock \\<in> set (L # Ls)\n   then must_acquire_lock (L # Ls) else must_acquire_lock ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma must_acquire_lock_contains_lock:\n  \"must_acquire_lock las \\<Longrightarrow> Lock \\<in> set las\""], ["proof (prove)\ngoal (1 subgoal):\n 1. must_acquire_lock las \\<Longrightarrow> Lock \\<in> set las", "proof(induct las)"], ["proof (state)\ngoal (2 subgoals):\n 1. must_acquire_lock [] \\<Longrightarrow> Lock \\<in> set []\n 2. \\<And>a las.\n       \\<lbrakk>must_acquire_lock las \\<Longrightarrow> Lock \\<in> set las;\n        must_acquire_lock (a # las)\\<rbrakk>\n       \\<Longrightarrow> Lock \\<in> set (a # las)", "case (Cons l las)"], ["proof (state)\nthis:\n  must_acquire_lock las \\<Longrightarrow> Lock \\<in> set las\n  must_acquire_lock (l # las)\n\ngoal (2 subgoals):\n 1. must_acquire_lock [] \\<Longrightarrow> Lock \\<in> set []\n 2. \\<And>a las.\n       \\<lbrakk>must_acquire_lock las \\<Longrightarrow> Lock \\<in> set las;\n        must_acquire_lock (a # las)\\<rbrakk>\n       \\<Longrightarrow> Lock \\<in> set (a # las)", "thus ?case"], ["proof (prove)\nusing this:\n  must_acquire_lock las \\<Longrightarrow> Lock \\<in> set las\n  must_acquire_lock (l # las)\n\ngoal (1 subgoal):\n 1. Lock \\<in> set (l # las)", "by(cases l) auto"], ["proof (state)\nthis:\n  Lock \\<in> set (l # las)\n\ngoal (1 subgoal):\n 1. must_acquire_lock [] \\<Longrightarrow> Lock \\<in> set []", "qed simp"], ["", "lemma must_acquire_lock_conv:\n  \"must_acquire_lock las = (case (filter (\\<lambda>L. L = Lock \\<or> L = Unlock) las) of [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. must_acquire_lock las =\n    (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) las of\n     [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)", "proof(induct las)"], ["proof (state)\ngoal (2 subgoals):\n 1. must_acquire_lock [] =\n    (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) [] of\n     [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)\n 2. \\<And>a las.\n       must_acquire_lock las =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) las of\n        [] \\<Rightarrow> False\n        | L # Ls \\<Rightarrow> L = Lock) \\<Longrightarrow>\n       must_acquire_lock (a # las) =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) (a # las) of\n        [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. must_acquire_lock [] =\n    (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) [] of\n     [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)\n 2. \\<And>a las.\n       must_acquire_lock las =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) las of\n        [] \\<Rightarrow> False\n        | L # Ls \\<Rightarrow> L = Lock) \\<Longrightarrow>\n       must_acquire_lock (a # las) =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) (a # las) of\n        [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. must_acquire_lock [] =\n    (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) [] of\n     [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)", "by simp"], ["proof (state)\nthis:\n  must_acquire_lock [] =\n  (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) [] of\n   [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)\n\ngoal (1 subgoal):\n 1. \\<And>a las.\n       must_acquire_lock las =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) las of\n        [] \\<Rightarrow> False\n        | L # Ls \\<Rightarrow> L = Lock) \\<Longrightarrow>\n       must_acquire_lock (a # las) =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) (a # las) of\n        [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a las.\n       must_acquire_lock las =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) las of\n        [] \\<Rightarrow> False\n        | L # Ls \\<Rightarrow> L = Lock) \\<Longrightarrow>\n       must_acquire_lock (a # las) =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) (a # las) of\n        [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)", "case (Cons LA LAS)"], ["proof (state)\nthis:\n  must_acquire_lock LAS =\n  (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) LAS of\n   [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)\n\ngoal (1 subgoal):\n 1. \\<And>a las.\n       must_acquire_lock las =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) las of\n        [] \\<Rightarrow> False\n        | L # Ls \\<Rightarrow> L = Lock) \\<Longrightarrow>\n       must_acquire_lock (a # las) =\n       (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) (a # las) of\n        [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)", "thus ?case"], ["proof (prove)\nusing this:\n  must_acquire_lock LAS =\n  (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) LAS of\n   [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)\n\ngoal (1 subgoal):\n 1. must_acquire_lock (LA # LAS) =\n    (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) (LA # LAS) of\n     [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)", "by(cases LA, auto split: list.split_asm)"], ["proof (state)\nthis:\n  must_acquire_lock (LA # LAS) =\n  (case filter (\\<lambda>L. L = Lock \\<or> L = Unlock) (LA # LAS) of\n   [] \\<Rightarrow> False | L # Ls \\<Rightarrow> L = Lock)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition collect_locks' :: \"'l lock_actions \\<Rightarrow> 'l set\" where\n  \"collect_locks' las \\<equiv> {l. must_acquire_lock (las $ l)}\""], ["", "lemma collect_locks'I:\n  \"must_acquire_lock (las $ l) \\<Longrightarrow> l \\<in> collect_locks' las\""], ["proof (prove)\ngoal (1 subgoal):\n 1. must_acquire_lock (las $ l) \\<Longrightarrow> l \\<in> collect_locks' las", "by(simp add: collect_locks'_def)"], ["", "lemma collect_locks'E:\n  \"\\<lbrakk> l \\<in> collect_locks' las; must_acquire_lock (las $ l) \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<in> collect_locks' las;\n     must_acquire_lock (las $ l) \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by(simp add: collect_locks'_def)"], ["", "lemma collect_locks'_subset_collect_locks:\n  \"collect_locks' las \\<subseteq> collect_locks las\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collect_locks' las \\<subseteq> collect_locks las", "by(auto simp add: collect_locks'_def collect_locks_def intro: must_acquire_lock_contains_lock)"], ["", "definition lock_ok_las' :: \"('l,'t) locks \\<Rightarrow> 't \\<Rightarrow> 'l lock_actions \\<Rightarrow> bool\" where\n  \"lock_ok_las' ls t las \\<equiv> \\<forall>l. lock_actions_ok' (ls $ l) t (las $ l)\""], ["", "lemma lock_ok_las'I: \"(\\<And>l. lock_actions_ok' (ls $ l) t (las $ l)) \\<Longrightarrow> lock_ok_las' ls t las\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. lock_actions_ok' (ls $ l) t (las $ l)) \\<Longrightarrow>\n    lock_ok_las' ls t las", "by(simp add: lock_ok_las'_def)"], ["", "lemma lock_ok_las'D: \"lock_ok_las' ls t las \\<Longrightarrow> lock_actions_ok' (ls $ l) t (las $ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok_las' ls t las \\<Longrightarrow>\n    lock_actions_ok' (ls $ l) t (las $ l)", "by(simp add: lock_ok_las'_def)"], ["", "lemma not_lock_ok_las'_conv:\n  \"\\<not> lock_ok_las' ls t las \\<longleftrightarrow> (\\<exists>l. \\<not> lock_actions_ok' (ls $ l) t (las $ l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> lock_ok_las' ls t las) =\n    (\\<exists>l. \\<not> lock_actions_ok' (ls $ l) t (las $ l))", "by(simp add: lock_ok_las'_def)"], ["", "lemma lock_ok_las'_code:\n    \"lock_ok_las' ls t las = finfun_All ((\\<lambda>(l, la). lock_actions_ok' l t la) \\<circ>$ ($ls, las$))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok_las' ls t las =\n    finfun_All\n     ((\\<lambda>(l, la). lock_actions_ok' l t la) \\<circ>$ ($ls, las$))", "by(simp add: lock_ok_las'_def finfun_All_All o_def)"], ["", "lemma lock_ok_las'_collect_locks'_may_lock:\n  assumes lot': \"lock_ok_las' ls t las\"\n  and mayl: \"\\<forall>l \\<in> collect_locks' las. may_lock (ls $ l) t\"\n  and l: \"l \\<in> collect_locks las\"\n  shows \"may_lock (ls $ l) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "proof(cases \"l \\<in> collect_locks' las\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l \\<in> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t\n 2. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "case True"], ["proof (state)\nthis:\n  l \\<in> collect_locks' las\n\ngoal (2 subgoals):\n 1. l \\<in> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t\n 2. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "thus ?thesis"], ["proof (prove)\nusing this:\n  l \\<in> collect_locks' las\n\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "using mayl"], ["proof (prove)\nusing this:\n  l \\<in> collect_locks' las\n  \\<forall>l\\<in>collect_locks' las. may_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "by auto"], ["proof (state)\nthis:\n  may_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "case False"], ["proof (state)\nthis:\n  l \\<notin> collect_locks' las\n\ngoal (1 subgoal):\n 1. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "hence nmal: \"\\<not> must_acquire_lock (las $ l)\""], ["proof (prove)\nusing this:\n  l \\<notin> collect_locks' las\n\ngoal (1 subgoal):\n 1. \\<not> must_acquire_lock (las $ l)", "by(auto intro: collect_locks'I)"], ["proof (state)\nthis:\n  \\<not> must_acquire_lock (las $ l)\n\ngoal (1 subgoal):\n 1. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "from l"], ["proof (chain)\npicking this:\n  l \\<in> collect_locks las", "have locklasl: \"Lock \\<in> set (las $ l)\""], ["proof (prove)\nusing this:\n  l \\<in> collect_locks las\n\ngoal (1 subgoal):\n 1. Lock \\<in> set (las $ l)", "by(rule collect_locksD)"], ["proof (state)\nthis:\n  Lock \\<in> set (las $ l)\n\ngoal (1 subgoal):\n 1. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "then"], ["proof (chain)\npicking this:\n  Lock \\<in> set (las $ l)", "obtain ys zs\n    where las: \"las $ l = ys @ Lock # zs\"\n    and notin: \"Lock \\<notin> set ys\""], ["proof (prove)\nusing this:\n  Lock \\<in> set (las $ l)\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>las $ l = ys @ Lock # zs; Lock \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: split_list_first)"], ["proof (state)\nthis:\n  las $ l = ys @ Lock # zs\n  Lock \\<notin> set ys\n\ngoal (1 subgoal):\n 1. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "from lot'"], ["proof (chain)\npicking this:\n  lock_ok_las' ls t las", "have \"lock_actions_ok' (ls $ l) t (las $ l)\""], ["proof (prove)\nusing this:\n  lock_ok_las' ls t las\n\ngoal (1 subgoal):\n 1. lock_actions_ok' (ls $ l) t (las $ l)", "by(auto simp add: lock_ok_las'_def)"], ["proof (state)\nthis:\n  lock_actions_ok' (ls $ l) t (las $ l)\n\ngoal (1 subgoal):\n 1. l \\<notin> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t", "thus ?thesis"], ["proof (prove)\nusing this:\n  lock_actions_ok' (ls $ l) t (las $ l)\n\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "proof(induct rule: lock_actions_ok'E)"], ["proof (state)\ngoal (2 subgoals):\n 1. lock_actions_ok (ls $ l) t (las $ l) \\<Longrightarrow>\n    may_lock (ls $ l) t\n 2. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "case ok"], ["proof (state)\nthis:\n  lock_actions_ok (ls $ l) t (las $ l)\n\ngoal (2 subgoals):\n 1. lock_actions_ok (ls $ l) t (las $ l) \\<Longrightarrow>\n    may_lock (ls $ l) t\n 2. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "with locklasl"], ["proof (chain)\npicking this:\n  Lock \\<in> set (las $ l)\n  lock_actions_ok (ls $ l) t (las $ l)", "show ?thesis"], ["proof (prove)\nusing this:\n  Lock \\<in> set (las $ l)\n  lock_actions_ok (ls $ l) t (las $ l)\n\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "by -(rule lock_actions_ok_Lock_may_lock)"], ["proof (state)\nthis:\n  may_lock (ls $ l) t\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "case (Lock YS ZS)"], ["proof (state)\nthis:\n  las $ l = YS @ Lock # ZS\n  lock_actions_ok (ls $ l) t YS\n  \\<not> may_lock (upd_locks (ls $ l) t YS) t\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "note LAS = \\<open>las $ l = YS @ Lock # ZS\\<close>"], ["proof (state)\nthis:\n  las $ l = YS @ Lock # ZS\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "note lao = \\<open>lock_actions_ok (ls $ l) t YS\\<close>"], ["proof (state)\nthis:\n  lock_actions_ok (ls $ l) t YS\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "note nml = \\<open>\\<not> may_lock (upd_locks (ls $ l) t YS) t\\<close>"], ["proof (state)\nthis:\n  \\<not> may_lock (upd_locks (ls $ l) t YS) t\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "from LAS las nmal notin"], ["proof (chain)\npicking this:\n  las $ l = YS @ Lock # ZS\n  las $ l = ys @ Lock # zs\n  \\<not> must_acquire_lock (las $ l)\n  Lock \\<notin> set ys", "have \"Unlock \\<in> set YS\""], ["proof (prove)\nusing this:\n  las $ l = YS @ Lock # ZS\n  las $ l = ys @ Lock # zs\n  \\<not> must_acquire_lock (las $ l)\n  Lock \\<notin> set ys\n\ngoal (1 subgoal):\n 1. Unlock \\<in> set YS", "by -(erule contrapos_np, auto simp add: must_acquire_lock_append append_eq_append_conv2 append_eq_Cons_conv)"], ["proof (state)\nthis:\n  Unlock \\<in> set YS\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "then"], ["proof (chain)\npicking this:\n  Unlock \\<in> set YS", "obtain ys' zs'\n      where YS: \"YS = ys' @ Unlock # zs'\"\n      and unlock: \"Unlock \\<notin> set ys'\""], ["proof (prove)\nusing this:\n  Unlock \\<in> set YS\n\ngoal (1 subgoal):\n 1. (\\<And>ys' zs'.\n        \\<lbrakk>YS = ys' @ Unlock # zs'; Unlock \\<notin> set ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: split_list_first)"], ["proof (state)\nthis:\n  YS = ys' @ Unlock # zs'\n  Unlock \\<notin> set ys'\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "from YS las LAS lao"], ["proof (chain)\npicking this:\n  YS = ys' @ Unlock # zs'\n  las $ l = ys @ Lock # zs\n  las $ l = YS @ Lock # ZS\n  lock_actions_ok (ls $ l) t YS", "have lao': \"lock_actions_ok (ls $ l) t (ys' @ [Unlock])\""], ["proof (prove)\nusing this:\n  YS = ys' @ Unlock # zs'\n  las $ l = ys @ Lock # zs\n  las $ l = YS @ Lock # ZS\n  lock_actions_ok (ls $ l) t YS\n\ngoal (1 subgoal):\n 1. lock_actions_ok (ls $ l) t (ys' @ [Unlock])", "by(auto)"], ["proof (state)\nthis:\n  lock_actions_ok (ls $ l) t (ys' @ [Unlock])\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "hence \"has_lock (upd_locks (ls $ l) t ys') t\""], ["proof (prove)\nusing this:\n  lock_actions_ok (ls $ l) t (ys' @ [Unlock])\n\ngoal (1 subgoal):\n 1. has_lock (upd_locks (ls $ l) t ys') t", "by simp"], ["proof (state)\nthis:\n  has_lock (upd_locks (ls $ l) t ys') t\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "hence \"may_lock (upd_locks (ls $ l) t ys') t\""], ["proof (prove)\nusing this:\n  has_lock (upd_locks (ls $ l) t ys') t\n\ngoal (1 subgoal):\n 1. may_lock (upd_locks (ls $ l) t ys') t", "by(rule has_lock_may_lock)"], ["proof (state)\nthis:\n  may_lock (upd_locks (ls $ l) t ys') t\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "moreover"], ["proof (state)\nthis:\n  may_lock (upd_locks (ls $ l) t ys') t\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "from lao'"], ["proof (chain)\npicking this:\n  lock_actions_ok (ls $ l) t (ys' @ [Unlock])", "have \"lock_actions_ok (ls $ l) t ys'\""], ["proof (prove)\nusing this:\n  lock_actions_ok (ls $ l) t (ys' @ [Unlock])\n\ngoal (1 subgoal):\n 1. lock_actions_ok (ls $ l) t ys'", "by simp"], ["proof (state)\nthis:\n  lock_actions_ok (ls $ l) t ys'\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>las $ l = xs @ Lock # ys; lock_actions_ok (ls $ l) t xs;\n        \\<not> may_lock (upd_locks (ls $ l) t xs) t\\<rbrakk>\n       \\<Longrightarrow> may_lock (ls $ l) t", "ultimately"], ["proof (chain)\npicking this:\n  may_lock (upd_locks (ls $ l) t ys') t\n  lock_actions_ok (ls $ l) t ys'", "show ?thesis"], ["proof (prove)\nusing this:\n  may_lock (upd_locks (ls $ l) t ys') t\n  lock_actions_ok (ls $ l) t ys'\n\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "by simp"], ["proof (state)\nthis:\n  may_lock (ls $ l) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  may_lock (ls $ l) t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lock_actions_ok'_must_acquire_lock_lock_actions_ok:\n  \"\\<lbrakk> lock_actions_ok' l t Ls; must_acquire_lock Ls \\<longrightarrow> may_lock l t\\<rbrakk> \\<Longrightarrow> lock_actions_ok l t Ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_actions_ok' l t Ls;\n     must_acquire_lock Ls \\<longrightarrow> may_lock l t\\<rbrakk>\n    \\<Longrightarrow> lock_actions_ok l t Ls", "proof(induct l t Ls rule: lock_actions_ok.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l t.\n       \\<lbrakk>lock_actions_ok' l t [];\n        must_acquire_lock [] \\<longrightarrow> may_lock l t\\<rbrakk>\n       \\<Longrightarrow> lock_actions_ok l t []\n 2. \\<And>l t L Ls.\n       \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t Ls;\n                 must_acquire_lock Ls \\<longrightarrow>\n                 may_lock (upd_lock l t L) t\\<rbrakk>\n                \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t Ls;\n        lock_actions_ok' l t (L # Ls);\n        must_acquire_lock (L # Ls) \\<longrightarrow> may_lock l t\\<rbrakk>\n       \\<Longrightarrow> lock_actions_ok l t (L # Ls)", "case 1"], ["proof (state)\nthis:\n  lock_actions_ok' l_ t_ []\n  must_acquire_lock [] \\<longrightarrow> may_lock l_ t_\n\ngoal (2 subgoals):\n 1. \\<And>l t.\n       \\<lbrakk>lock_actions_ok' l t [];\n        must_acquire_lock [] \\<longrightarrow> may_lock l t\\<rbrakk>\n       \\<Longrightarrow> lock_actions_ok l t []\n 2. \\<And>l t L Ls.\n       \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t Ls;\n                 must_acquire_lock Ls \\<longrightarrow>\n                 may_lock (upd_lock l t L) t\\<rbrakk>\n                \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t Ls;\n        lock_actions_ok' l t (L # Ls);\n        must_acquire_lock (L # Ls) \\<longrightarrow> may_lock l t\\<rbrakk>\n       \\<Longrightarrow> lock_actions_ok l t (L # Ls)", "thus ?case"], ["proof (prove)\nusing this:\n  lock_actions_ok' l_ t_ []\n  must_acquire_lock [] \\<longrightarrow> may_lock l_ t_\n\ngoal (1 subgoal):\n 1. lock_actions_ok l_ t_ []", "by simp"], ["proof (state)\nthis:\n  lock_actions_ok l_ t_ []\n\ngoal (1 subgoal):\n 1. \\<And>l t L Ls.\n       \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t Ls;\n                 must_acquire_lock Ls \\<longrightarrow>\n                 may_lock (upd_lock l t L) t\\<rbrakk>\n                \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t Ls;\n        lock_actions_ok' l t (L # Ls);\n        must_acquire_lock (L # Ls) \\<longrightarrow> may_lock l t\\<rbrakk>\n       \\<Longrightarrow> lock_actions_ok l t (L # Ls)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l t L Ls.\n       \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t Ls;\n                 must_acquire_lock Ls \\<longrightarrow>\n                 may_lock (upd_lock l t L) t\\<rbrakk>\n                \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t Ls;\n        lock_actions_ok' l t (L # Ls);\n        must_acquire_lock (L # Ls) \\<longrightarrow> may_lock l t\\<rbrakk>\n       \\<Longrightarrow> lock_actions_ok l t (L # Ls)", "case (2 l t L LS)"], ["proof (state)\nthis:\n  \\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n   must_acquire_lock LS \\<longrightarrow>\n   may_lock (upd_lock l t L) t\\<rbrakk>\n  \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS\n  lock_actions_ok' l t (L # LS)\n  must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t\n\ngoal (1 subgoal):\n 1. \\<And>l t L Ls.\n       \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t Ls;\n                 must_acquire_lock Ls \\<longrightarrow>\n                 may_lock (upd_lock l t L) t\\<rbrakk>\n                \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t Ls;\n        lock_actions_ok' l t (L # Ls);\n        must_acquire_lock (L # Ls) \\<longrightarrow> may_lock l t\\<rbrakk>\n       \\<Longrightarrow> lock_actions_ok l t (L # Ls)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n   must_acquire_lock LS \\<longrightarrow>\n   may_lock (upd_lock l t L) t\\<rbrakk>\n  \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS\n  lock_actions_ok' l t (L # LS)\n  must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t\n\ngoal (1 subgoal):\n 1. lock_actions_ok l t (L # LS)", "proof(cases \"L = Lock \\<or> L = Unlock\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n              must_acquire_lock LS \\<longrightarrow>\n              may_lock (upd_lock l t L) t\\<rbrakk>\n             \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS;\n     lock_actions_ok' l t (L # LS);\n     must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t;\n     L = Lock \\<or> L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_actions_ok l t (L # LS)\n 2. \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n              must_acquire_lock LS \\<longrightarrow>\n              may_lock (upd_lock l t L) t\\<rbrakk>\n             \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS;\n     lock_actions_ok' l t (L # LS);\n     must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t;\n     \\<not> (L = Lock \\<or> L = Unlock)\\<rbrakk>\n    \\<Longrightarrow> lock_actions_ok l t (L # LS)", "case True"], ["proof (state)\nthis:\n  L = Lock \\<or> L = Unlock\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n              must_acquire_lock LS \\<longrightarrow>\n              may_lock (upd_lock l t L) t\\<rbrakk>\n             \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS;\n     lock_actions_ok' l t (L # LS);\n     must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t;\n     L = Lock \\<or> L = Unlock\\<rbrakk>\n    \\<Longrightarrow> lock_actions_ok l t (L # LS)\n 2. \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n              must_acquire_lock LS \\<longrightarrow>\n              may_lock (upd_lock l t L) t\\<rbrakk>\n             \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS;\n     lock_actions_ok' l t (L # LS);\n     must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t;\n     \\<not> (L = Lock \\<or> L = Unlock)\\<rbrakk>\n    \\<Longrightarrow> lock_actions_ok l t (L # LS)", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n   must_acquire_lock LS \\<longrightarrow>\n   may_lock (upd_lock l t L) t\\<rbrakk>\n  \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS\n  lock_actions_ok' l t (L # LS)\n  must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t\n  L = Lock \\<or> L = Unlock", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n   must_acquire_lock LS \\<longrightarrow>\n   may_lock (upd_lock l t L) t\\<rbrakk>\n  \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS\n  lock_actions_ok' l t (L # LS)\n  must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t\n  L = Lock \\<or> L = Unlock\n\ngoal (1 subgoal):\n 1. lock_actions_ok l t (L # LS)", "by(auto simp add: lock_actions_ok'_iff Cons_eq_append_conv intro: has_lock_may_lock)"], ["proof (state)\nthis:\n  lock_actions_ok l t (L # LS)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>lock_actions_ok' (upd_lock l t L) t LS;\n              must_acquire_lock LS \\<longrightarrow>\n              may_lock (upd_lock l t L) t\\<rbrakk>\n             \\<Longrightarrow> lock_actions_ok (upd_lock l t L) t LS;\n     lock_actions_ok' l t (L # LS);\n     must_acquire_lock (L # LS) \\<longrightarrow> may_lock l t;\n     \\<not> (L = Lock \\<or> L = Unlock)\\<rbrakk>\n    \\<Longrightarrow> lock_actions_ok l t (L # LS)", "qed(cases L, auto)"], ["proof (state)\nthis:\n  lock_actions_ok l t (L # LS)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lock_ok_las'_collect_locks_lock_ok_las:\n  assumes lol': \"lock_ok_las' ls t las\"\n  and clml: \"\\<And>l. l \\<in> collect_locks las \\<Longrightarrow> may_lock (ls $ l) t\"\n  shows \"lock_ok_las ls t las\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lock_ok_las ls t las", "proof(rule lock_ok_lasI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. lock_actions_ok (ls $ l) t (las $ l)", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. lock_actions_ok (ls $ l) t (las $ l)", "from lol'"], ["proof (chain)\npicking this:\n  lock_ok_las' ls t las", "have \"lock_actions_ok' (ls $ l) t (las $ l)\""], ["proof (prove)\nusing this:\n  lock_ok_las' ls t las\n\ngoal (1 subgoal):\n 1. lock_actions_ok' (ls $ l) t (las $ l)", "by(rule lock_ok_las'D)"], ["proof (state)\nthis:\n  lock_actions_ok' (ls $ l) t (las $ l)\n\ngoal (1 subgoal):\n 1. \\<And>l. lock_actions_ok (ls $ l) t (las $ l)", "thus \"lock_actions_ok (ls $ l) t (las $ l)\""], ["proof (prove)\nusing this:\n  lock_actions_ok' (ls $ l) t (las $ l)\n\ngoal (1 subgoal):\n 1. lock_actions_ok (ls $ l) t (las $ l)", "proof(rule lock_actions_ok'_must_acquire_lock_lock_actions_ok[OF _ impI])"], ["proof (state)\ngoal (1 subgoal):\n 1. must_acquire_lock (las $ l) \\<Longrightarrow> may_lock (ls $ l) t", "assume mal: \"must_acquire_lock (las $ l)\""], ["proof (state)\nthis:\n  must_acquire_lock (las $ l)\n\ngoal (1 subgoal):\n 1. must_acquire_lock (las $ l) \\<Longrightarrow> may_lock (ls $ l) t", "thus \"may_lock (ls $ l) t\""], ["proof (prove)\nusing this:\n  must_acquire_lock (las $ l)\n\ngoal (1 subgoal):\n 1. may_lock (ls $ l) t", "by(auto intro!: clml collect_locksI elim: must_acquire_lock_contains_lock )"], ["proof (state)\nthis:\n  may_lock (ls $ l) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lock_actions_ok (ls $ l) t (las $ l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lock_ok_las'_into_lock_on_las:\n  \"\\<lbrakk>lock_ok_las' ls t las; \\<And>l. l \\<in> collect_locks' las \\<Longrightarrow> may_lock (ls $ l) t\\<rbrakk> \\<Longrightarrow> lock_ok_las ls t las\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lock_ok_las' ls t las;\n     \\<And>l.\n        l \\<in> collect_locks' las \\<Longrightarrow>\n        may_lock (ls $ l) t\\<rbrakk>\n    \\<Longrightarrow> lock_ok_las ls t las", "by (metis lock_ok_las'_collect_locks'_may_lock lock_ok_las'_collect_locks_lock_ok_las)"], ["", "end"]]}