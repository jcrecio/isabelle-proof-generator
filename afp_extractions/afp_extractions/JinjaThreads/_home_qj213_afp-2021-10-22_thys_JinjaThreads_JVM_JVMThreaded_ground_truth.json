{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaThreads/JVM/JVMThreaded.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaThreads", "problem_names": ["lemma NewThread_memory_exec_instr:\n  \"\\<lbrakk> (ta, s) \\<in> exec_instr I P t h stk loc C M pc frs; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> m = fst (snd s)\"", "lemma NewThread_memory_exec:\n  \"\\<lbrakk> P,t \\<turnstile> \\<sigma> -ta-jvm\\<rightarrow> \\<sigma>'; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> m = (fst (snd \\<sigma>'))\"", "lemma exec_instr_Wakeup_no_Lock_no_Join_no_Interrupt:\n  \"\\<lbrakk> (ta, s) \\<in> exec_instr I P t h stk loc C M pc frs; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\"", "lemma mexec_instr_Wakeup_no_Join:\n  \"\\<lbrakk> P,t \\<turnstile> \\<sigma> -ta-jvm\\<rightarrow> \\<sigma>'; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\"", "lemma mexec_final: \n  \"\\<lbrakk> mexec P t (x, m) ta (x', m'); JVM_final x \\<rbrakk> \\<Longrightarrow> False\"", "lemma exec_mthr: \"multithreaded JVM_final (mexec P)\"", "lemma execd_mthr: \"multithreaded JVM_final (mexecd P)\"", "lemma mexecd_Suspend_Invoke:\n  \"\\<lbrakk> mexecd P t (x, m) ta (x', m'); Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>stk loc C M pc frs' n a T Ts Tr D. x' = (None, (stk, loc, C, M, pc) # frs') \\<and> instrs_of P C M ! pc = Invoke wait n \\<and> stk ! n = Addr a \\<and> typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees wait:Ts\\<rightarrow>Tr = Native in D \\<and> D\\<bullet>wait(Ts) :: Tr\"", "lemma exec_instr_New_Thread_exists_thread_object:\n  \"\\<lbrakk> (ta, xcp', h', frs') \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr h' (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"", "lemma exec_New_Thread_exists_thread_object:\n  \"\\<lbrakk> P,t \\<turnstile> Normal (xcp, h, frs) -ta-jvmd\\<rightarrow> Normal (xcp', h', frs'); NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr h' (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\"", "lemma exec_instr_preserve_tconf:\n  \"\\<lbrakk> (ta, xcp', h', frs') \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     P,h \\<turnstile> t' \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\"", "lemma exec_preserve_tconf:\n  \"\\<lbrakk> P,t \\<turnstile> Normal (xcp, h, frs) -ta-jvmd\\<rightarrow> Normal (xcp', h', frs'); P,h \\<turnstile> t' \\<surd>t \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\"", "lemma lifting_wf_thread_conf: \"lifting_wf JVM_final (mexecd P) (\\<lambda>t x m. P,m \\<turnstile> t \\<surd>t)\"", "lemma execd_hext:\n  \"P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow>\\<^bsub>jvmd\\<^esub> s' \\<Longrightarrow> shr s \\<unlhd> shr s'\"", "lemma Execd_hext:\n  assumes \"P \\<turnstile> s -\\<triangleright>tta\\<rightarrow>\\<^bsub>jvmd\\<^esub>* s'\"\n  shows \"shr s \\<unlhd> shr s'\""], "translations": [["", "lemma NewThread_memory_exec_instr:\n  \"\\<lbrakk> (ta, s) \\<in> exec_instr I P t h stk loc C M pc frs; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> m = fst (snd s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n     NewThread t' x m\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> m = fst (snd s)", "apply(cases I)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        I = Load x1\\<rbrakk>\n       \\<Longrightarrow> m = fst (snd s)\n 2. \\<And>x2.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        I = Store x2\\<rbrakk>\n       \\<Longrightarrow> m = fst (snd s)\n 3. \\<And>x3.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        I = Push x3\\<rbrakk>\n       \\<Longrightarrow> m = fst (snd s)\n 4. \\<And>x4.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        I = New x4\\<rbrakk>\n       \\<Longrightarrow> m = fst (snd s)\n 5. \\<And>x5.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        I = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> m = fst (snd s)\n 6. \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n     NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     I = ALoad\\<rbrakk>\n    \\<Longrightarrow> m = fst (snd s)\n 7. \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n     NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     I = AStore\\<rbrakk>\n    \\<Longrightarrow> m = fst (snd s)\n 8. \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n     NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     I = ALength\\<rbrakk>\n    \\<Longrightarrow> m = fst (snd s)\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        I = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> m = fst (snd s)\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n         NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n         I = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> m = fst (snd s)\nA total of 24 subgoals...", "apply(auto split: if_split_asm simp add: split_beta ta_upd_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x141 x142 a aa ab ac ad b va h' ae af ba.\n       \\<lbrakk>I = Invoke x141 x142; stk ! x142 \\<noteq> Null;\n        snd (snd (snd (method P\n                        (class_type_of\n                          (the (typeof_addr h (the_Addr (stk ! x142)))))\n                        x141))) =\n        None;\n        ta =\n        (a, map (convert_new_thread_action (extNTA2JVM P)) aa, ab, ac, ad,\n         b);\n        ((a, aa, ab, ac, ad, b), va, h')\n        \\<in> red_external_aggr P t (the_Addr (stk ! x142)) x141\n               (rev (take x142 stk)) h;\n        s = extRet2JVM x142 h' stk loc C M pc frs va;\n        NewThread t' (ae, af, ba) m \\<in> set aa;\n        x = extNTA2JVM P (ae, af, ba)\\<rbrakk>\n       \\<Longrightarrow> m =\n                         fst (snd (extRet2JVM x142 h' stk loc C M pc frs\n                                    va))", "apply(auto dest!: red_ext_aggr_new_thread_heap simp add: extRet2JVM_def split: extCallRet.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NewThread_memory_exec:\n  \"\\<lbrakk> P,t \\<turnstile> \\<sigma> -ta-jvm\\<rightarrow> \\<sigma>'; NewThread t' x m \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk> \\<Longrightarrow> m = (fst (snd \\<sigma>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<sigma> -ta-jvm\\<rightarrow> \\<sigma>';\n     NewThread t' x m\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> m = fst (snd \\<sigma>')", "apply(erule exec_1.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>taa \\<sigma>'' \\<sigma>'''.\n       \\<lbrakk>NewThread t' x m\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        \\<sigma> = \\<sigma>'''; ta = taa; \\<sigma>' = \\<sigma>'';\n        (taa, \\<sigma>'') \\<in> exec P t \\<sigma>'''\\<rbrakk>\n       \\<Longrightarrow> m = fst (snd \\<sigma>')", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae af ba ag ah bb.\n       \\<lbrakk>NewThread t' x m \\<in> set aa; \\<sigma> = (ag, ah, bb);\n        ta = (a, aa, ab, ac, ad, b); \\<sigma>' = (ae, af, ba);\n        ((a, aa, ab, ac, ad, b), ae, af, ba)\n        \\<in> exec P t (ag, ah, bb)\\<rbrakk>\n       \\<Longrightarrow> m = af", "apply(case_tac bb, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae af ba ag ah bb ai list.\n       \\<lbrakk>NewThread t' x m \\<in> set aa; \\<sigma> = (ag, ah, bb);\n        ta = (a, aa, ab, ac, ad, b); \\<sigma>' = (ae, af, ba);\n        ((a, aa, ab, ac, ad, b), ae, af, ba) \\<in> exec P t (ag, ah, bb);\n        bb = ai # list\\<rbrakk>\n       \\<Longrightarrow> m = af", "apply(case_tac ag, auto simp add: exception_step_def_raw split: list.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae af ba ah ai aj ak al bc list.\n       \\<lbrakk>NewThread t' x m \\<in> set aa;\n        \\<sigma> = (None, ah, (ai, aj, ak, al, bc) # list);\n        ta = (a, aa, ab, ac, ad, b); \\<sigma>' = (ae, af, ba);\n        ((a, aa, ab, ac, ad, b), ae, af, ba)\n        \\<in> exec_instr (instrs_of P ak al ! bc) P t ah ai aj ak al bc\n               list\\<rbrakk>\n       \\<Longrightarrow> m = af", "apply(drule NewThread_memory_exec_instr, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exec_instr_Wakeup_no_Lock_no_Join_no_Interrupt:\n  \"\\<lbrakk> (ta, s) \\<in> exec_instr I P t h stk loc C M pc frs; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n     WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      {} \\<and>\n                      collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                      {} \\<and>\n                      collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                      {}", "apply(cases I)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        I = Load x1\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 2. \\<And>x2.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        I = Store x2\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 3. \\<And>x3.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        I = Push x3\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 4. \\<And>x4.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        I = New x4\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 5. \\<And>x5.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        I = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 6. \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n     WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n     I = ALoad\\<rbrakk>\n    \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      {} \\<and>\n                      collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                      {} \\<and>\n                      collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                      {}\n 7. \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n     WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n     I = AStore\\<rbrakk>\n    \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      {} \\<and>\n                      collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                      {} \\<and>\n                      collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                      {}\n 8. \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n     WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n     I = ALength\\<rbrakk>\n    \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      {} \\<and>\n                      collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                      {} \\<and>\n                      collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                      {}\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n        Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n        WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        I = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, s) \\<in> exec_instr I P t h stk loc C M pc frs;\n         Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n         WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n         I = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> collect_locks\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                          {} \\<and>\n                          collect_cond_actions\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                          {} \\<and>\n                          collect_interrupts\n                           \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                          {}\nA total of 24 subgoals...", "apply(auto split: if_split_asm simp add: split_beta ta_upd_simps dest: red_external_aggr_Wakeup_no_Join)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mexec_instr_Wakeup_no_Join:\n  \"\\<lbrakk> P,t \\<turnstile> \\<sigma> -ta-jvm\\<rightarrow> \\<sigma>'; Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or> WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> = {} \\<and> collect_cond_actions \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> = {} \\<and> collect_interrupts \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> \\<sigma> -ta-jvm\\<rightarrow> \\<sigma>';\n     Notified \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n     WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> collect_locks \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                      {} \\<and>\n                      collect_cond_actions\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                      {} \\<and>\n                      collect_interrupts\n                       \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                      {}", "apply(erule exec_1.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>taa \\<sigma>'' \\<sigma>'''.\n       \\<lbrakk>Notified\n                \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n                WokenUp \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        \\<sigma> = \\<sigma>'''; ta = taa; \\<sigma>' = \\<sigma>'';\n        (taa, \\<sigma>'') \\<in> exec P t \\<sigma>'''\\<rbrakk>\n       \\<Longrightarrow> collect_locks\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>l\\<^esub> =\n                         {} \\<and>\n                         collect_cond_actions\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>c\\<^esub> =\n                         {} \\<and>\n                         collect_interrupts\n                          \\<lbrace>ta\\<rbrace>\\<^bsub>i\\<^esub> =\n                         {}", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae af ba ag ah bb.\n       \\<lbrakk>Notified \\<in> set ac \\<or> WokenUp \\<in> set ac;\n        \\<sigma> = (ag, ah, bb); ta = (a, aa, ab, ac, ad, b);\n        \\<sigma>' = (ae, af, ba);\n        ((a, aa, ab, ac, ad, b), ae, af, ba)\n        \\<in> exec P t (ag, ah, bb)\\<rbrakk>\n       \\<Longrightarrow> collect_locks a = {} \\<and>\n                         (\\<forall>x. Join x \\<notin> set ab) \\<and>\n                         collect_interrupts ad = {}", "apply(case_tac bb, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b ae af ba ag ah bb ai list.\n       \\<lbrakk>Notified \\<in> set ac \\<or> WokenUp \\<in> set ac;\n        \\<sigma> = (ag, ah, bb); ta = (a, aa, ab, ac, ad, b);\n        \\<sigma>' = (ae, af, ba);\n        ((a, aa, ab, ac, ad, b), ae, af, ba) \\<in> exec P t (ag, ah, bb);\n        bb = ai # list\\<rbrakk>\n       \\<Longrightarrow> collect_locks a = {} \\<and>\n                         (\\<forall>x. Join x \\<notin> set ab) \\<and>\n                         collect_interrupts ad = {}", "apply(case_tac ag, clarsimp simp add: exception_step_def_raw split: list.split_asm del: disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b ae af ba ah ai aj ak al bc list.\n       \\<lbrakk>Notified \\<in> set ac \\<or> WokenUp \\<in> set ac;\n        \\<sigma> = (None, ah, (ai, aj, ak, al, bc) # list);\n        ta = (a, aa, ab, ac, ad, b); \\<sigma>' = (ae, af, ba);\n        ((a, aa, ab, ac, ad, b), ae, af, ba)\n        \\<in> exec_instr (instrs_of P ak al ! bc) P t ah ai aj ak al bc\n               list\\<rbrakk>\n       \\<Longrightarrow> collect_locks a = {} \\<and>\n                         (\\<forall>x. Join x \\<notin> set ab) \\<and>\n                         collect_interrupts ad = {}\n 2. \\<And>a aa ab ac ad b ae af ba ag ah bb ai list aj.\n       \\<lbrakk>Notified \\<in> set ac \\<or> WokenUp \\<in> set ac;\n        \\<sigma> = (ag, ah, bb); ta = (a, aa, ab, ac, ad, b);\n        \\<sigma>' = (ae, af, ba);\n        ((a, aa, ab, ac, ad, b), ae, af, ba) \\<in> exec P t (ag, ah, bb);\n        bb = ai # list; ag = \\<lfloor>aj\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> collect_locks a = {} \\<and>\n                         (\\<forall>x. Join x \\<notin> set ab) \\<and>\n                         collect_interrupts ad = {}", "apply(drule exec_instr_Wakeup_no_Lock_no_Join_no_Interrupt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab ac ad b ae af ba ah ai aj ak al bc list.\n       \\<lbrakk>Notified \\<in> set ac \\<or> WokenUp \\<in> set ac;\n        \\<sigma> = (None, ah, (ai, aj, ak, al, bc) # list);\n        ta = (a, aa, ab, ac, ad, b); \\<sigma>' = (ae, af, ba)\\<rbrakk>\n       \\<Longrightarrow> Notified\n                         \\<in> set \\<lbrace>(a, aa, ab, ac, ad,\n       b)\\<rbrace>\\<^bsub>w\\<^esub> \\<or>\n                         WokenUp\n                         \\<in> set \\<lbrace>(a, aa, ab, ac, ad,\n       b)\\<rbrace>\\<^bsub>w\\<^esub>\n 2. \\<And>a aa ab ac ad b ae af ba ah ai aj ak al bc list.\n       \\<lbrakk>Notified \\<in> set ac \\<or> WokenUp \\<in> set ac;\n        \\<sigma> = (None, ah, (ai, aj, ak, al, bc) # list);\n        ta = (a, aa, ab, ac, ad, b); \\<sigma>' = (ae, af, ba);\n        collect_locks\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>l\\<^esub> =\n        {} \\<and>\n        collect_cond_actions\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>c\\<^esub> =\n        {} \\<and>\n        collect_interrupts\n         \\<lbrace>(a, aa, ab, ac, ad, b)\\<rbrace>\\<^bsub>i\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> collect_locks a = {} \\<and>\n                         (\\<forall>x. Join x \\<notin> set ab) \\<and>\n                         collect_interrupts ad = {}\n 3. \\<And>a aa ab ac ad b ae af ba ag ah bb ai list aj.\n       \\<lbrakk>Notified \\<in> set ac \\<or> WokenUp \\<in> set ac;\n        \\<sigma> = (ag, ah, bb); ta = (a, aa, ab, ac, ad, b);\n        \\<sigma>' = (ae, af, ba);\n        ((a, aa, ab, ac, ad, b), ae, af, ba) \\<in> exec P t (ag, ah, bb);\n        bb = ai # list; ag = \\<lfloor>aj\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> collect_locks a = {} \\<and>\n                         (\\<forall>x. Join x \\<notin> set ab) \\<and>\n                         collect_interrupts ad = {}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mexec_final: \n  \"\\<lbrakk> mexec P t (x, m) ta (x', m'); JVM_final x \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mexec P t (x, m) ta (x', m'); JVM_final x\\<rbrakk>\n    \\<Longrightarrow> False", "by(cases x)(auto simp add: exec_1_iff)"], ["", "lemma exec_mthr: \"multithreaded JVM_final (mexec P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded JVM_final (mexec P)", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t s ta s' t' x m.\n       \\<lbrakk>mexec P t s ta s';\n        NewThread t' x m\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> m = snd s'\n 2. \\<And>t x m ta x' m'.\n       \\<lbrakk>mexec P t (x, m) ta (x', m'); JVM_final x\\<rbrakk>\n       \\<Longrightarrow> False", "apply(clarsimp, drule NewThread_memory_exec, fastforce, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>mexec P t (x, m) ta (x', m'); JVM_final x\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule (1) mexec_final)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "sublocale JVM_heap_base < exec_mthr: \n  multithreaded\n    JVM_final\n    \"mexec P\"\n    convert_RA\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded JVM_final (mexec P)", "by(rule exec_mthr)"], ["", "context JVM_heap_base begin"], ["", "abbreviation mexecT ::\n  \"'addr jvm_prog\n  \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state\n  \\<Rightarrow> 'thread_id \\<times> ('addr, 'thread_id, 'heap) jvm_thread_action\n  \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state \\<Rightarrow> bool\"\nwhere\n  \"mexecT P \\<equiv> exec_mthr.redT P\""], ["", "abbreviation mexecT_syntax1 ::\n  \"'addr jvm_prog \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state\n  \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'thread_id, 'heap) jvm_thread_action\n  \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ -_\\<triangleright>_\\<rightarrow>\\<^bsub>jvm\\<^esub> _\" [50,0,0,0,50] 80)\nwhere\n  \"mexecT_syntax1 P s t ta s' \\<equiv> mexecT P s (t, ta) s'\""], ["", "abbreviation mExecT_syntax1 :: \n  \"'addr jvm_prog \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state\n  \\<Rightarrow> ('thread_id \\<times> ('addr, 'thread_id, 'heap) jvm_thread_action) list\n  \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ -\\<triangleright>_\\<rightarrow>\\<^bsub>jvm\\<^esub>* _\" [50,0,0,50] 80)\nwhere\n  \"P \\<turnstile> s -\\<triangleright>ttas\\<rightarrow>\\<^bsub>jvm\\<^esub>* s' \\<equiv> exec_mthr.RedT P s ttas s'\""], ["", "text\\<open>The defensive JVM\\<close>"], ["", "abbreviation mexecd :: \n  \"'addr jvm_prog \\<Rightarrow> 'thread_id \\<Rightarrow> 'addr jvm_thread_state \\<times> 'heap \n  \\<Rightarrow> ('addr, 'thread_id, 'heap) jvm_thread_action \\<Rightarrow> 'addr jvm_thread_state \\<times> 'heap \\<Rightarrow> bool\"\nwhere\n  \"mexecd P t \\<equiv> (\\<lambda>((xcp, frstls), h) ta ((xcp', frstls'), h'). P,t \\<turnstile> Normal (xcp, h, frstls) -ta-jvmd\\<rightarrow> Normal (xcp', h', frstls'))\""], ["", "lemma execd_mthr: \"multithreaded JVM_final (mexecd P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded JVM_final (mexecd P)", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t s ta s' t' x m.\n       \\<lbrakk>mexecd P t s ta s';\n        NewThread t' x m\n        \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> m = snd s'\n 2. \\<And>t x m ta x' m'.\n       \\<lbrakk>mexecd P t (x, m) ta (x', m'); JVM_final x\\<rbrakk>\n       \\<Longrightarrow> False", "apply(fastforce dest: defensive_imp_aggressive_1 NewThread_memory_exec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x m ta x' m'.\n       \\<lbrakk>mexecd P t (x, m) ta (x', m'); JVM_final x\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto elim: jvmd_NormalE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "sublocale JVM_heap_base < execd_mthr:\n  multithreaded\n    JVM_final\n    \"mexecd P\"\n    convert_RA\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. multithreaded JVM_final (mexecd P)", "by(rule execd_mthr)"], ["", "context JVM_heap_base begin"], ["", "abbreviation mexecdT ::\n  \"'addr jvm_prog \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state\n  \\<Rightarrow> 'thread_id \\<times> ('addr, 'thread_id, 'heap) jvm_thread_action\n  \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state \\<Rightarrow> bool\"\nwhere\n  \"mexecdT P \\<equiv> execd_mthr.redT P\""], ["", "abbreviation mexecdT_syntax1 ::\n  \"'addr jvm_prog \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state\n  \\<Rightarrow> 'thread_id \\<Rightarrow> ('addr, 'thread_id, 'heap) jvm_thread_action\n  \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ -_\\<triangleright>_\\<rightarrow>\\<^bsub>jvmd\\<^esub> _\" [50,0,0,0,50] 80)\nwhere\n  \"mexecdT_syntax1 P s t ta s' \\<equiv> mexecdT P s (t, ta) s'\""], ["", "abbreviation mExecdT_syntax1 ::\n  \"'addr jvm_prog \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state\n  \\<Rightarrow> ('thread_id \\<times> ('addr, 'thread_id, 'heap) jvm_thread_action) list\n  \\<Rightarrow> ('addr,'thread_id,'addr jvm_thread_state,'heap,'addr) state \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ -\\<triangleright>_\\<rightarrow>\\<^bsub>jvmd\\<^esub>* _\" [50,0,0,50] 80)\nwhere\n  \"P \\<turnstile> s -\\<triangleright>ttas\\<rightarrow>\\<^bsub>jvmd\\<^esub>* s' \\<equiv> execd_mthr.RedT P s ttas s'\""], ["", "lemma mexecd_Suspend_Invoke:\n  \"\\<lbrakk> mexecd P t (x, m) ta (x', m'); Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>stk loc C M pc frs' n a T Ts Tr D. x' = (None, (stk, loc, C, M, pc) # frs') \\<and> instrs_of P C M ! pc = Invoke wait n \\<and> stk ! n = Addr a \\<and> typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and> P \\<turnstile> class_type_of T sees wait:Ts\\<rightarrow>Tr = Native in D \\<and> D\\<bullet>wait(Ts) :: Tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>execd_mthr.r_syntax P t x m ta x' m';\n     Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stk loc C M pc frs' n a T Ts Tr D.\n                         x' = (None, (stk, loc, C, M, pc) # frs') \\<and>\n                         instrs_of P C M ! pc = Invoke wait n \\<and>\n                         stk ! n = Addr a \\<and>\n                         typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and>\n                         P \\<turnstile> class_type_of\n   T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n                         D\\<bullet>wait(Ts) :: Tr", "apply(cases x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>execd_mthr.r_syntax P t x m ta x' m';\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk loc C M pc frs' n a T Ts Tr D.\n                            x' = (None, (stk, loc, C, M, pc) # frs') \\<and>\n                            instrs_of P C M ! pc = Invoke wait n \\<and>\n                            stk ! n = Addr a \\<and>\n                            typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n                            D\\<bullet>wait(Ts) :: Tr", "apply(cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>execd_mthr.r_syntax P t x m ta x' m';\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk loc C M pc frs' n a T Ts Tr D.\n                            x' = (None, (stk, loc, C, M, pc) # frs') \\<and>\n                            instrs_of P C M ! pc = Invoke wait n \\<and>\n                            stk ! n = Addr a \\<and>\n                            typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n                            D\\<bullet>wait(Ts) :: Tr", "apply(cases \"fst x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>execd_mthr.r_syntax P t x m ta x' m';\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (aa, ba); fst x = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk loc C M pc frs' n a T Ts Tr D.\n                            x' = (None, (stk, loc, C, M, pc) # frs') \\<and>\n                            instrs_of P C M ! pc = Invoke wait n \\<and>\n                            stk ! n = Addr a \\<and>\n                            typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n                            D\\<bullet>wait(Ts) :: Tr\n 2. \\<And>a b aa ba ab.\n       \\<lbrakk>execd_mthr.r_syntax P t x m ta x' m';\n        Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (aa, ba); fst x = \\<lfloor>ab\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk loc C M pc frs' n a T Ts Tr D.\n                            x' = (None, (stk, loc, C, M, pc) # frs') \\<and>\n                            instrs_of P C M ! pc = Invoke wait n \\<and>\n                            stk ! n = Addr a \\<and>\n                            typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and>\n                            P \\<turnstile> class_type_of\n      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n                            D\\<bullet>wait(Ts) :: Tr", "apply(auto elim!: jvmd_NormalE simp add: split_beta)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ab ac ad ae bb frs.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (ab, ac, ad, ae, bb) # frs);\n        check P (None, m, (ab, ac, ad, ae, bb) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P ad ae ! bb) P t m ab ac ad ae bb\n               frs\\<rbrakk>\n       \\<Longrightarrow> a = None\n 2. \\<And>a b ab ac ad ae bb frs.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (ab, ac, ad, ae, bb) # frs);\n        check P (None, m, (ab, ac, ad, ae, bb) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P ad ae ! bb) P t m ab ac ad ae bb\n               frs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk loc C M pc.\n                            (\\<exists>frs'.\n                                b = (stk, loc, C, M, pc) # frs') \\<and>\n                            (\\<exists>n.\n                                instrs_of P C M ! pc = Invoke wait n \\<and>\n                                (\\<exists>a.\n                                    stk ! n = Addr a \\<and>\n                                    (\\<exists>T.\n  typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and>\n  (\\<exists>Ts Tr D.\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      D\\<bullet>wait(Ts) :: Tr))))", "apply(rename_tac [!] stk loc C M pc frs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b stk loc C M pc frs.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc\n               frs\\<rbrakk>\n       \\<Longrightarrow> a = None\n 2. \\<And>a b stk loc C M pc frs.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc\n               frs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk loc C M pc.\n                            (\\<exists>frs'.\n                                b = (stk, loc, C, M, pc) # frs') \\<and>\n                            (\\<exists>n.\n                                instrs_of P C M ! pc = Invoke wait n \\<and>\n                                (\\<exists>a.\n                                    stk ! n = Addr a \\<and>\n                                    (\\<exists>T.\n  typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and>\n  (\\<exists>Ts Tr D.\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      D\\<bullet>wait(Ts) :: Tr))))", "apply(case_tac [!] \"instrs_of P C M ! pc\")"], ["proof (prove)\ngoal (48 subgoals):\n 1. \\<And>a b stk loc C M pc frs x1.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> a = None\n 2. \\<And>a b stk loc C M pc frs x2.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> a = None\n 3. \\<And>a b stk loc C M pc frs x3.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> a = None\n 4. \\<And>a b stk loc C M pc frs x4.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> a = None\n 5. \\<And>a b stk loc C M pc frs x5.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> a = None\n 6. \\<And>a b stk loc C M pc frs.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = ALoad\\<rbrakk>\n       \\<Longrightarrow> a = None\n 7. \\<And>a b stk loc C M pc frs.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = AStore\\<rbrakk>\n       \\<Longrightarrow> a = None\n 8. \\<And>a b stk loc C M pc frs.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = ALength\\<rbrakk>\n       \\<Longrightarrow> a = None\n 9. \\<And>a b stk loc C M pc frs x91 x92.\n       \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n        check P (None, m, (stk, loc, C, M, pc) # frs);\n        (ta, a, m', b)\n        \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n        instrs_of P C M ! pc = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> a = None\n 10. \\<And>a b stk loc C M pc frs x101 x102.\n        \\<lbrakk>Suspend w \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>w\\<^esub>;\n         x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs);\n         check P (None, m, (stk, loc, C, M, pc) # frs);\n         (ta, a, m', b)\n         \\<in> exec_instr (instrs_of P C M ! pc) P t m stk loc C M pc frs;\n         instrs_of P C M ! pc = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> a = None\nA total of 48 subgoals...", "apply(auto split: if_split_asm simp add: split_beta check_def is_Ref_def has_method_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b stk loc C M pc frs x141 x142 Ts aa T ab ac xa ba y Tsa Ta xaa\n       ad ae af ag ah ai bb va.\n       \\<lbrakk>ac ! pc = Invoke x141 x142; Suspend w \\<in> set ah;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs); pc < length ac;\n        length stk \\<le> aa; x142 < length stk;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(aa, ab, ac,\n                        ba)\\<rfloor> in xa;\n        P,m \\<turnstile> rev (take x142 stk) [:\\<le>] Tsa;\n        xaa\\<bullet>x141(Tsa) :: Ta; typeof_addr m ad = \\<lfloor>y\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        y sees x141: Tsa\\<rightarrow>Ta = Native in xaa;\n        stk ! x142 = Addr ad;\n        ta =\n        (ae, map (convert_new_thread_action (extNTA2JVM P)) af, ag, ah, ai,\n         bb);\n        case va of\n        RetVal v \\<Rightarrow>\n          a = None \\<and>\n          b = (v # drop (Suc x142) stk, loc, C, M, pc + 1) # frs\n        | RetExc aa \\<Rightarrow>\n            a = \\<lfloor>aa\\<rfloor> \\<and> b = (stk, loc, C, M, pc) # frs\n        | RetStaySame \\<Rightarrow>\n            a = None \\<and> b = (stk, loc, C, M, pc) # frs;\n        ((ae, af, ag, ah, ai, bb), va, m')\n        \\<in> red_external_aggr P t ad x141 (rev (take x142 stk)) m\\<rbrakk>\n       \\<Longrightarrow> a = None\n 2. \\<And>a b stk loc C M pc frs x141 x142 Ts aa T ab ac xa ba y Tsa Ta xaa\n       ad ae af ag ah ai bb va.\n       \\<lbrakk>ac ! pc = Invoke x141 x142; Suspend w \\<in> set ah;\n        x' = (a, b); x = (None, (stk, loc, C, M, pc) # frs); pc < length ac;\n        length stk \\<le> aa; x142 < length stk;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = \\<lfloor>(aa, ab, ac,\n                        ba)\\<rfloor> in xa;\n        P,m \\<turnstile> rev (take x142 stk) [:\\<le>] Tsa;\n        xaa\\<bullet>x141(Tsa) :: Ta; typeof_addr m ad = \\<lfloor>y\\<rfloor>;\n        P \\<turnstile> class_type_of\n                        y sees x141: Tsa\\<rightarrow>Ta = Native in xaa;\n        stk ! x142 = Addr ad;\n        ta =\n        (ae, map (convert_new_thread_action (extNTA2JVM P)) af, ag, ah, ai,\n         bb);\n        case va of\n        RetVal v \\<Rightarrow>\n          a = None \\<and>\n          b = (v # drop (Suc x142) stk, loc, C, M, pc + 1) # frs\n        | RetExc aa \\<Rightarrow>\n            a = \\<lfloor>aa\\<rfloor> \\<and> b = (stk, loc, C, M, pc) # frs\n        | RetStaySame \\<Rightarrow>\n            a = None \\<and> b = (stk, loc, C, M, pc) # frs;\n        ((ae, af, ag, ah, ai, bb), va, m')\n        \\<in> red_external_aggr P t ad x141 (rev (take x142 stk)) m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stk loc C M pc.\n                            (\\<exists>frs'.\n                                b = (stk, loc, C, M, pc) # frs') \\<and>\n                            (\\<exists>n.\n                                instrs_of P C M ! pc = Invoke wait n \\<and>\n                                (\\<exists>a.\n                                    stk ! n = Addr a \\<and>\n                                    (\\<exists>T.\n  typeof_addr m a = \\<lfloor>T\\<rfloor> \\<and>\n  (\\<exists>Ts Tr D.\n      P \\<turnstile> class_type_of\n                      T sees wait: Ts\\<rightarrow>Tr = Native in D \\<and>\n      D\\<bullet>wait(Ts) :: Tr))))", "apply(frule red_external_aggr_Suspend_StaySame, simp, drule red_external_aggr_Suspend_waitD, simp, fastforce)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context JVM_heap begin"], ["", "lemma exec_instr_New_Thread_exists_thread_object:\n  \"\\<lbrakk> (ta, xcp', h', frs') \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr h' (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     NewThread t' x h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "apply(cases ins)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        ins = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        ins = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        ins = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        ins = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        ins = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     ins = ALoad\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 7. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     ins = AStore\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 8. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     ins = ALength\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        ins = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr ins P t h stk loc C M pc frs;\n         check_instr ins P h stk loc C M pc frs;\n         NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n         ins = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<exists>C.\n                             typeof_addr h' (thread_id2addr t') =\n                             \\<lfloor>Class_type C\\<rfloor> \\<and>\n                             P \\<turnstile> C \\<preceq>\\<^sup>* Thread\nA total of 24 subgoals...", "apply(fastforce simp add: split_beta ta_upd_simps split: if_split_asm intro: red_external_aggr_new_thread_exists_thread_object)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exec_New_Thread_exists_thread_object:\n  \"\\<lbrakk> P,t \\<turnstile> Normal (xcp, h, frs) -ta-jvmd\\<rightarrow> Normal (xcp', h', frs'); NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>C. typeof_addr h' (thread_id2addr t') = \\<lfloor>Class_type C\\<rfloor> \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* Thread\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> Normal\n                               (xcp, h,\n                                frs) -ta-jvmd\\<rightarrow> Normal\n                      (xcp', h', frs');\n     NewThread t' x h''\n     \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "apply(cases xcp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,t \\<turnstile> Normal\n                               (xcp, h,\n                                frs) -ta-jvmd\\<rightarrow> Normal\n                      (xcp', h', frs');\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     xcp = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 2. \\<And>a.\n       \\<lbrakk>P,t \\<turnstile> Normal\n                                  (xcp, h,\n                                   frs) -ta-jvmd\\<rightarrow> Normal\n                         (xcp', h', frs');\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        xcp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "apply(case_tac [!] frs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>P,t \\<turnstile> Normal\n                               (xcp, h,\n                                frs) -ta-jvmd\\<rightarrow> Normal\n                      (xcp', h', frs');\n     NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n     xcp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C.\n                         typeof_addr h' (thread_id2addr t') =\n                         \\<lfloor>Class_type C\\<rfloor> \\<and>\n                         P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 2. \\<And>a list.\n       \\<lbrakk>P,t \\<turnstile> Normal\n                                  (xcp, h,\n                                   frs) -ta-jvmd\\<rightarrow> Normal\n                         (xcp', h', frs');\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        xcp = None; frs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 3. \\<And>a.\n       \\<lbrakk>P,t \\<turnstile> Normal\n                                  (xcp, h,\n                                   frs) -ta-jvmd\\<rightarrow> Normal\n                         (xcp', h', frs');\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        xcp = \\<lfloor>a\\<rfloor>; frs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread\n 4. \\<And>a aa list.\n       \\<lbrakk>P,t \\<turnstile> Normal\n                                  (xcp, h,\n                                   frs) -ta-jvmd\\<rightarrow> Normal\n                         (xcp', h', frs');\n        NewThread t' x h'' \\<in> set \\<lbrace>ta\\<rbrace>\\<^bsub>t\\<^esub>;\n        xcp = \\<lfloor>a\\<rfloor>; frs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            typeof_addr h' (thread_id2addr t') =\n                            \\<lfloor>Class_type C\\<rfloor> \\<and>\n                            P \\<turnstile> C \\<preceq>\\<^sup>* Thread", "apply(auto simp add: check_def elim!: jvmd_NormalE dest!: exec_instr_New_Thread_exists_thread_object)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exec_instr_preserve_tconf:\n  \"\\<lbrakk> (ta, xcp', h', frs') \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     P,h \\<turnstile> t' \\<surd>t \\<rbrakk>\n  \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs;\n     P,h \\<turnstile> t' \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t", "apply(cases ins)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        P,h \\<turnstile> t' \\<surd>t; ins = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 2. \\<And>x2.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        P,h \\<turnstile> t' \\<surd>t; ins = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 3. \\<And>x3.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        P,h \\<turnstile> t' \\<surd>t; ins = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 4. \\<And>x4.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        P,h \\<turnstile> t' \\<surd>t; ins = New x4\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 5. \\<And>x5.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        P,h \\<turnstile> t' \\<surd>t; ins = NewArray x5\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 6. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs; P,h \\<turnstile> t' \\<surd>t;\n     ins = ALoad\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 7. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs; P,h \\<turnstile> t' \\<surd>t;\n     ins = AStore\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 8. \\<lbrakk>(ta, xcp', h', frs')\n             \\<in> exec_instr ins P t h stk loc C M pc frs;\n     check_instr ins P h stk loc C M pc frs; P,h \\<turnstile> t' \\<surd>t;\n     ins = ALength\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 9. \\<And>x91 x92.\n       \\<lbrakk>(ta, xcp', h', frs')\n                \\<in> exec_instr ins P t h stk loc C M pc frs;\n        check_instr ins P h stk loc C M pc frs;\n        P,h \\<turnstile> t' \\<surd>t; ins = Getfield x91 x92\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 10. \\<And>x101 x102.\n        \\<lbrakk>(ta, xcp', h', frs')\n                 \\<in> exec_instr ins P t h stk loc C M pc frs;\n         check_instr ins P h stk loc C M pc frs;\n         P,h \\<turnstile> t' \\<surd>t; ins = Putfield x101 x102\\<rbrakk>\n        \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\nA total of 24 subgoals...", "apply(auto intro: tconf_hext_mono hext_allocate hext_heap_write red_external_aggr_preserves_tconf split: if_split_asm sum.split_asm simp add: split_beta has_method_def intro!: is_native.intros cong del: image_cong_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exec_preserve_tconf:\n  \"\\<lbrakk> P,t \\<turnstile> Normal (xcp, h, frs) -ta-jvmd\\<rightarrow> Normal (xcp', h', frs'); P,h \\<turnstile> t' \\<surd>t \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,t \\<turnstile> Normal\n                               (xcp, h,\n                                frs) -ta-jvmd\\<rightarrow> Normal\n                      (xcp', h', frs');\n     P,h \\<turnstile> t' \\<surd>t\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t", "apply(cases xcp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,t \\<turnstile> Normal\n                               (xcp, h,\n                                frs) -ta-jvmd\\<rightarrow> Normal\n                      (xcp', h', frs');\n     P,h \\<turnstile> t' \\<surd>t; xcp = None\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 2. \\<And>a.\n       \\<lbrakk>P,t \\<turnstile> Normal\n                                  (xcp, h,\n                                   frs) -ta-jvmd\\<rightarrow> Normal\n                         (xcp', h', frs');\n        P,h \\<turnstile> t' \\<surd>t; xcp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t", "apply(case_tac [!] frs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>P,t \\<turnstile> Normal\n                               (xcp, h,\n                                frs) -ta-jvmd\\<rightarrow> Normal\n                      (xcp', h', frs');\n     P,h \\<turnstile> t' \\<surd>t; xcp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 2. \\<And>a list.\n       \\<lbrakk>P,t \\<turnstile> Normal\n                                  (xcp, h,\n                                   frs) -ta-jvmd\\<rightarrow> Normal\n                         (xcp', h', frs');\n        P,h \\<turnstile> t' \\<surd>t; xcp = None; frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 3. \\<And>a.\n       \\<lbrakk>P,t \\<turnstile> Normal\n                                  (xcp, h,\n                                   frs) -ta-jvmd\\<rightarrow> Normal\n                         (xcp', h', frs');\n        P,h \\<turnstile> t' \\<surd>t; xcp = \\<lfloor>a\\<rfloor>;\n        frs = []\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t\n 4. \\<And>a aa list.\n       \\<lbrakk>P,t \\<turnstile> Normal\n                                  (xcp, h,\n                                   frs) -ta-jvmd\\<rightarrow> Normal\n                         (xcp', h', frs');\n        P,h \\<turnstile> t' \\<surd>t; xcp = \\<lfloor>a\\<rfloor>;\n        frs = aa # list\\<rbrakk>\n       \\<Longrightarrow> P,h' \\<turnstile> t' \\<surd>t", "apply(auto simp add: check_def elim!: jvmd_NormalE elim!: exec_instr_preserve_tconf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lifting_wf_thread_conf: \"lifting_wf JVM_final (mexecd P) (\\<lambda>t x m. P,m \\<turnstile> t \\<surd>t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf JVM_final (mexecd P)\n     (\\<lambda>t x m. P,m \\<turnstile> t \\<surd>t)", "by(unfold_locales)(auto intro: exec_preserve_tconf dest: exec_New_Thread_exists_thread_object intro: tconfI)"], ["", "end"], ["", "sublocale JVM_heap < execd_tconf: lifting_wf JVM_final \"mexecd P\" convert_RA \"\\<lambda>t x m. P,m \\<turnstile> t \\<surd>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lifting_wf JVM_final (mexecd P)\n     (\\<lambda>t x m. P,m \\<turnstile> t \\<surd>t)", "by(rule lifting_wf_thread_conf)"], ["", "context JVM_heap begin"], ["", "lemma execd_hext:\n  \"P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow>\\<^bsub>jvmd\\<^esub> s' \\<Longrightarrow> shr s \\<unlhd> shr s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s -t\\<triangleright>ta\\<rightarrow>\\<^bsub>jvmd\\<^esub> s' \\<Longrightarrow>\n    shr s \\<unlhd> shr s'", "by(auto elim!: execd_mthr.redT.cases dest!: exec_1_d_hext intro: hext_trans)"], ["", "lemma Execd_hext:\n  assumes \"P \\<turnstile> s -\\<triangleright>tta\\<rightarrow>\\<^bsub>jvmd\\<^esub>* s'\"\n  shows \"shr s \\<unlhd> shr s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shr s \\<unlhd> shr s'", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> s -\\<triangleright>tta\\<rightarrow>\\<^bsub>jvmd\\<^esub>* s'\n\ngoal (1 subgoal):\n 1. shr s \\<unlhd> shr s'", "unfolding execd_mthr.RedT_def"], ["proof (prove)\nusing this:\n  rtrancl3p (mexecdT P) s tta s'\n\ngoal (1 subgoal):\n 1. shr s \\<unlhd> shr s'", "by(induct)(auto dest!: execd_hext intro: hext_trans simp add: execd_mthr.RedT_def)"], ["", "end"], ["", "end"]]}